diff -Nur linux-2.6.16/arch/mips/aruba/Makefile linux-2.6.16-owrt/arch/mips/aruba/Makefile
--- linux-2.6.16/arch/mips/aruba/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/Makefile	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,49 @@
+###############################################################################
+#
+#  BRIEF MODULE DESCRIPTION
+#     Makefile for IDT EB434 BSP
+#
+#  Copyright 2004 IDT Inc. (rischelp@idt.com)
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#   You should have received a copy of the  GNU General Public License along
+#   with this program; if not, write  to the Free Software Foundation, Inc.,
+#   675 Mass Ave, Cambridge, MA 02139, USA.
+# 
+# 
+###############################################################################
+#  May 2004 rkt, neb
+# 
+#  Initial Release
+# 
+#  
+# 
+###############################################################################
+
+
+# .S.s:
+# 	$(CPP) $(CFLAGS) $< -o $*.s
+# .S.o:
+# 	$(CC) $(CFLAGS) -c $< -o $*.o
+
+obj-y	 := prom.o setup.o idtIRQ.o irq.o time.o flash_lock.o
+obj-$(CONFIG_SERIAL_8250) 		+= serial.o
+
+subdir-y         += nvram
+obj-y            += nvram/built-in.o
+
diff -Nur linux-2.6.16/arch/mips/aruba/nvram/Makefile linux-2.6.16-owrt/arch/mips/aruba/nvram/Makefile
--- linux-2.6.16/arch/mips/aruba/nvram/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/nvram/Makefile	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,46 @@
+###############################################################################
+#
+#  BRIEF MODULE DESCRIPTION
+#     Makefile for IDT EB434 nvram access routines
+#
+#  Copyright 2004 IDT Inc. (rischelp@idt.com)
+#
+#  This program is free software; you can redistribute  it and/or modify it
+#  under  the terms of  the GNU General  Public License as published by the
+#  Free Software Foundation;  either version 2 of the  License, or (at your
+#  option) any later version.
+#
+#  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+#  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#   You should have received a copy of the  GNU General Public License along
+#   with this program; if not, write  to the Free Software Foundation, Inc.,
+#   675 Mass Ave, Cambridge, MA 02139, USA.
+#
+#
+###############################################################################
+#  May 2004  rkt, neb
+#
+#  Initial Release
+#
+#
+#
+###############################################################################
+
+obj-y   := nvram434.o
+obj-m   := $(O_TARGET)
+
+
+
+
+
+
+
diff -Nur linux-2.6.16/arch/mips/aruba/nvram/nvram434.c linux-2.6.16-owrt/arch/mips/aruba/nvram/nvram434.c
--- linux-2.6.16/arch/mips/aruba/nvram/nvram434.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/nvram/nvram434.c	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,392 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     nvram interface routines.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/ctype.h>
+#include <linux/string.h>
+
+//#include <asm/ds1553rtc.h>
+#include "nvram434.h"
+#define  NVRAM_BASE 0xbfff8000
+
+extern void setenv (char *e, char *v, int rewrite);
+extern void unsetenv (char *e);
+extern void mapenv (int (*func)(char *, char *));
+extern char *getenv (char *s);
+extern void purgeenv(void);
+
+static void nvram_initenv(void);
+
+static unsigned char
+nvram_getbyte(int offs)
+{
+  return(*((unsigned char*)(NVRAM_BASE + offs)));
+}
+
+static void
+nvram_setbyte(int offs, unsigned char val)
+{
+  unsigned char* nvramDataPointer = (unsigned char*)(NVRAM_BASE + offs);
+
+  *nvramDataPointer = val;
+}
+
+/*
+ * BigEndian!
+ */
+static unsigned short
+nvram_getshort(int offs)
+{
+  return((nvram_getbyte(offs) << 8) | nvram_getbyte(offs + 1));
+}
+
+static void
+nvram_setshort(int offs, unsigned short val)
+{
+  nvram_setbyte(offs, (unsigned char)((val >> 8) & 0xff));
+  nvram_setbyte(offs + 1, (unsigned char)(val & 0xff));
+}
+#if 0
+static unsigned int
+nvram_getint(int offs)
+{
+  unsigned int val;
+  val = nvram_getbyte(offs) << 24;
+  val |= nvram_getbyte(offs + 1) << 16;
+  val |= nvram_getbyte(offs + 2) << 8;
+  val |= nvram_getbyte(offs + 3);
+  return(val);
+}
+
+static void
+nvram_setint(int offs, unsigned int val)
+{
+  nvram_setbyte(offs, val >> 24);
+  nvram_setbyte(offs + 1, val >> 16);
+  nvram_setbyte(offs + 2, val >> 8);
+  nvram_setbyte(offs + 3, val);
+}
+#endif
+/*
+ * calculate NVRAM checksum
+ */
+static unsigned short
+nvram_calcsum(void)
+{
+  unsigned short sum = NV_MAGIC;
+  int     i;
+
+  for (i = ENV_BASE; i < ENV_TOP; i += 2)
+    sum += nvram_getshort(i);
+  return(sum);
+}
+
+/*
+ * update the nvram checksum
+ */
+static void
+nvram_updatesum (void)
+{
+  nvram_setshort(NVOFF_CSUM, nvram_calcsum());
+}
+
+/*
+ * test validity of nvram by checksumming it
+ */
+static int
+nvram_isvalid(void)
+{
+  static int  is_valid;
+
+  if (is_valid)
+    return(1);
+
+  if (nvram_getshort(NVOFF_MAGIC) != NV_MAGIC) {
+	printk("nvram_isvalid FAILED\n");
+    //nvram_initenv();
+  }
+  is_valid = 1;
+  return(1);
+}
+
+/* return nvram address of environment string */
+static int
+nvram_matchenv(char *s)
+{
+  int envsize, envp, n, i, varsize;
+  char *var;
+
+  envsize = nvram_getshort(NVOFF_ENVSIZE);
+
+  if (envsize > ENV_AVAIL)
+    return(0);     /* sanity */
+    
+  envp = ENV_BASE;
+
+  if ((n = strlen (s)) > 255)
+    return(0);
+    
+  while (envsize > 0) {
+    varsize = nvram_getbyte(envp);
+    if (varsize == 0 || (envp + varsize) > ENV_TOP)
+      return(0);   /* sanity */
+    for (i = envp + 1, var = s; i <= envp + n; i++, var++) {
+      char c1 = nvram_getbyte(i);
+      char c2 = *var;
+      if (islower(c1))
+        c1 = toupper(c1);
+      if (islower(c2))
+        c2 = toupper(c2);
+      if (c1 != c2)
+        break;
+    }
+    if (i > envp + n) {       /* match so far */
+      if (n == varsize - 1)   /* match on boolean */
+        return(envp);
+      if (nvram_getbyte(i) == '=')  /* exact match on variable */
+        return(envp);
+    }
+    envsize -= varsize;
+    envp += varsize;
+  }
+  return(0);
+}
+
+static void nvram_initenv(void)
+{
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);
+  nvram_setshort(NVOFF_ENVSIZE, 0);
+
+  nvram_updatesum();
+}
+
+static void
+nvram_delenv(char *s)
+{
+  int nenvp, envp, envsize, nbytes;
+
+  envp = nvram_matchenv(s);
+  if (envp == 0)
+    return;
+
+  nenvp = envp + nvram_getbyte(envp);
+  envsize = nvram_getshort(NVOFF_ENVSIZE);
+  nbytes = envsize - (nenvp - ENV_BASE);
+  nvram_setshort(NVOFF_ENVSIZE, envsize - (nenvp - envp));
+  while (nbytes--) {
+    nvram_setbyte(envp, nvram_getbyte(nenvp));
+    envp++;
+    nenvp++;
+  }
+  nvram_updatesum();
+}
+
+static int
+nvram_setenv(char *s, char *v)
+{
+  int ns, nv, total;
+  int envp;
+
+  if (!nvram_isvalid())
+    return(-1);
+
+  nvram_delenv(s);
+  ns = strlen(s);
+  if (ns == 0)
+    return (-1);
+  if (v && *v) {
+    nv = strlen(v);
+    total = ns + nv + 2;
+  }
+  else {
+    nv = 0;
+    total = ns + 1;
+  }
+  if (total > 255 || total > ENV_AVAIL - nvram_getshort(NVOFF_ENVSIZE))
+    return(-1);
+
+  envp = ENV_BASE + nvram_getshort(NVOFF_ENVSIZE);
+
+  nvram_setbyte(envp, (unsigned char) total); 
+  envp++;
+
+  while (ns--) {
+    nvram_setbyte(envp, *s); 
+    envp++; 
+    s++;
+  }
+
+  if (nv) {
+    nvram_setbyte(envp, '='); 
+    envp++;
+    while (nv--) {
+      nvram_setbyte(envp, *v); 
+      envp++; 
+      v++;
+    }
+  }
+  nvram_setshort(NVOFF_ENVSIZE, envp-ENV_BASE);
+  nvram_updatesum();
+  return 0;
+}
+
+static char *
+nvram_getenv(char *s)
+{
+  static char buf[256];   /* FIXME: this cannot be static */
+  int envp, ns, nbytes, i;
+
+  if (!nvram_isvalid())
+    return "INVALID NVRAM"; //((char *)0);
+
+  envp = nvram_matchenv(s);
+  if (envp == 0)
+    return "NOT FOUND"; //((char *)0);
+  ns = strlen(s);
+  if (nvram_getbyte(envp) == ns + 1)  /* boolean */
+    buf[0] = '\0';
+  else {
+    nbytes = nvram_getbyte(envp) - (ns + 2);
+    envp += ns + 2;
+    for (i = 0; i < nbytes; i++)
+      buf[i] = nvram_getbyte(envp++);
+    buf[i] = '\0';
+  }
+  return(buf);
+}
+
+static void
+nvram_unsetenv(char *s)
+{
+  if (!nvram_isvalid())
+    return;
+
+  nvram_delenv(s);
+}
+
+/*
+ * apply func to each string in environment
+ */
+static void
+nvram_mapenv(int (*func)(char *, char *))
+{
+  int envsize, envp, n, i, seeneql;
+  char name[256], value[256];
+  char c, *s;
+
+  if (!nvram_isvalid())
+    return;
+
+  envsize = nvram_getshort(NVOFF_ENVSIZE);
+  envp = ENV_BASE;
+
+  while (envsize > 0) {
+    value[0] = '\0';
+    seeneql = 0;
+    s = name;
+    n = nvram_getbyte(envp);
+    for (i = envp + 1; i < envp + n; i++) {
+      c = nvram_getbyte(i);
+      if ((c == '=') && !seeneql) {
+        *s = '\0';
+        s = value;
+        seeneql = 1;
+        continue;
+      }
+      *s++ = c;
+    }
+    *s = '\0';
+    (*func)(name, value);
+    envsize -= n;
+    envp += n;
+  }
+}
+#if 0
+static unsigned int
+digit(char c)
+{
+  if ('0' <= c && c <= '9')
+    return (c - '0');
+  if ('A' <= c && c <= 'Z')
+    return (10 + c - 'A');
+  if ('a' <= c && c <= 'z')
+    return (10 + c - 'a');
+  return (~0);
+}
+#endif
+/*
+ * Wrappers to allow 'special' environment variables to get processed
+ */
+void
+setenv(char *e, char *v, int rewrite)
+{
+  if (nvram_getenv(e) && !rewrite)
+    return;
+    
+  nvram_setenv(e, v);
+}
+
+char *
+getenv(char *e)
+{
+  return(nvram_getenv(e));
+}
+
+void
+unsetenv(char *e)
+{
+  nvram_unsetenv(e);
+}
+
+void
+purgeenv()
+{
+  int i;
+  unsigned char* nvramDataPointer = (unsigned char*)(NVRAM_BASE);
+  
+  for (i = ENV_BASE; i < ENV_TOP; i++)
+    *nvramDataPointer++ = 0;
+  nvram_setshort(NVOFF_MAGIC, NV_MAGIC);
+  nvram_setshort(NVOFF_ENVSIZE, 0);
+  nvram_setshort(NVOFF_CSUM, NV_MAGIC);
+}
+
+void
+mapenv(int (*func)(char *, char *))
+{
+  nvram_mapenv(func);
+}
diff -Nur linux-2.6.16/arch/mips/aruba/nvram/nvram434.h linux-2.6.16-owrt/arch/mips/aruba/nvram/nvram434.h
--- linux-2.6.16/arch/mips/aruba/nvram/nvram434.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/nvram/nvram434.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,66 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     nvram definitions.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+
+#ifndef _NVRAM_
+#define _NVRAM_
+#define NVOFFSET        0                 /* use all of NVRAM */
+
+/* Offsets to reserved locations */
+              /* size description */
+#define NVOFF_MAGIC     (NVOFFSET + 0)    /* 2 magic value */
+#define NVOFF_CSUM      (NVOFFSET + 2)    /* 2 NVRAM environment checksum */
+#define NVOFF_ENVSIZE   (NVOFFSET + 4)    /* 2 size of 'environment' */
+#define NVOFF_TEST      (NVOFFSET + 5)    /* 1 cold start test byte */
+#define NVOFF_ETHADDR   (NVOFFSET + 6)    /* 6 decoded ethernet address */
+#define NVOFF_UNUSED    (NVOFFSET + 12)   /* 0 current end of table */
+
+#define NV_MAGIC        0xdeaf            /* nvram magic number */
+#define NV_RESERVED     6                 /* number of reserved bytes */
+
+#undef  NVOFF_ETHADDR
+#define NVOFF_ETHADDR   (NVOFFSET + NV_RESERVED - 6)
+
+/* number of bytes available for environment */
+#define ENV_BASE        (NVOFFSET + NV_RESERVED)
+#define ENV_TOP         0x2000
+#define ENV_AVAIL       (ENV_TOP - ENV_BASE)
+
+#endif /* _NVRAM_ */
+
+
diff -Nur linux-2.6.16/arch/mips/aruba/prom.c linux-2.6.16-owrt/arch/mips/aruba/prom.c
--- linux-2.6.16/arch/mips/aruba/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/prom.c	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,111 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     prom interface routines
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/console.h>
+#include <asm/bootinfo.h>
+#include <linux/bootmem.h>
+#include <linux/ioport.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <asm/serial.h>
+#include <linux/ioport.h>
+
+unsigned int idt_cpu_freq;
+EXPORT_SYMBOL(idt_cpu_freq);
+
+unsigned int arch_has_pci=0;
+
+/* Kernel Boot parameters */
+static unsigned char bootparm[] = "console=ttyS0,9600 root=/dev/mtdblock1 rootfstype=jffs2";
+
+extern unsigned long mips_machgroup;
+extern unsigned long mips_machtype;
+
+extern void setup_serial_port(void);
+extern char * getenv(char *e);
+
+/* IDT 79EB434 memory map -- we really should be auto sizing it */
+#define RAM_SIZE        32*1024*1024
+
+char *__init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void __init prom_init(void)
+{
+	char *boardname;
+	sprintf(arcs_cmdline, "%s", bootparm);
+
+	/* set our arch type */
+	mips_machgroup = MACH_GROUP_ARUBA;
+	mips_machtype = MACH_ARUBA_UNKNOWN;
+
+	boardname=getenv("boardname");
+
+	if (!strcmp(boardname,"Muscat")) {
+		mips_machtype = MACH_ARUBA_AP70;
+		idt_cpu_freq = 133000000;
+		arch_has_pci=1;
+	} else if (!strcmp(boardname,"Mataro")) {
+		mips_machtype = MACH_ARUBA_AP65;
+		idt_cpu_freq = 110000000;
+	} else if (!strcmp(boardname,"Merlot")) {
+		mips_machtype = MACH_ARUBA_AP60;
+		idt_cpu_freq = 90000000;
+	}
+
+	/* turn on the console */
+	setup_serial_port();
+
+	/*
+	 * give all RAM to boot allocator,
+	 * except where the kernel was loaded
+	 */
+	add_memory_region(0,RAM_SIZE,BOOT_MEM_RAM);
+}
+
+void prom_free_prom_memory(void)
+{
+	printk("stubbed prom_free_prom_memory()\n");
+}
diff -Nur linux-2.6.16/arch/mips/aruba/serial.c linux-2.6.16-owrt/arch/mips/aruba/serial.c
--- linux-2.6.16/arch/mips/aruba/serial.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/serial.c	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,94 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Serial port initialisation.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+
+#include <asm/idt-boards/rc32434/rc32434.h>
+
+extern int __init early_serial_setup(struct uart_port *port);
+
+#define BASE_BAUD (1843200 / 16)
+
+extern unsigned int idt_cpu_freq;
+
+extern int __init setup_serial_port(void)
+{
+	static struct uart_port serial_req[2];
+	
+	memset(serial_req, 0, sizeof(serial_req));
+	serial_req[0].type       = PORT_16550A;
+	serial_req[0].line       = 0;
+	serial_req[0].flags      = STD_COM_FLAGS;
+	serial_req[0].iotype     = SERIAL_IO_MEM;
+	serial_req[0].regshift   = 2;
+	
+	switch (mips_machtype) {
+		case MACH_ARUBA_AP70:
+			serial_req[0].irq        = 104;
+			serial_req[0].mapbase    = KSEG1ADDR(0x18058003);
+			serial_req[0].membase    = (char *) KSEG1ADDR(0x18058003);
+			serial_req[0].uartclk    = idt_cpu_freq;
+			break;
+		case MACH_ARUBA_AP65:
+		case MACH_ARUBA_AP60:
+		default:
+			serial_req[0].irq        = 12;
+			serial_req[0].mapbase    = KSEG1ADDR(0xbc000003);
+			serial_req[0].membase    = (char *) KSEG1ADDR(0xbc000003);
+			serial_req[0].uartclk    = idt_cpu_freq / 2;
+			break;
+	}
+
+	early_serial_setup(&serial_req[0]);
+	
+	return(0);
+}
diff -Nur linux-2.6.16/arch/mips/aruba/setup.c linux-2.6.16-owrt/arch/mips/aruba/setup.c
--- linux-2.6.16/arch/mips/aruba/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/setup.c	2006-03-20 14:30:00.000000000 +0100
@@ -0,0 +1,125 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     setup routines for IDT EB434 boards
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <asm/mipsregs.h>
+#include <asm/pgtable.h>
+#include <asm/reboot.h>
+#include <asm/addrspace.h>	/* for KSEG1ADDR() */
+#include <asm/idt-boards/rc32434/rc32434.h>
+#include <linux/pm.h>
+
+extern char *__init prom_getcmdline(void);
+
+extern void (*board_time_init) (void);
+extern void (*board_timer_setup) (struct irqaction * irq);
+extern void aruba_time_init(void);
+extern void aruba_timer_setup(struct irqaction *irq);
+extern void aruba_reset(void);
+
+#define epldMask ((volatile unsigned char *)0xB900000d)
+
+static void aruba_machine_restart(char *command)
+{
+	switch (mips_machtype) {
+		case MACH_ARUBA_AP70:
+			*(volatile u32 *)KSEG1ADDR(0x18008000) = 0x80000001;
+			break;
+		case MACH_ARUBA_AP65:
+		case MACH_ARUBA_AP60:
+		default:
+			/* Reset*/
+			*((volatile u32 *)KSEG1ADDR(0x1c003020)) = 0x00080350; // reset everything in sight
+			udelay(100);
+			*((volatile u32 *)KSEG1ADDR(0x1c003020)) = 0; // reset everything in sight
+			udelay(100);
+			*((volatile u32 *)KSEG1ADDR(0x1c003020)) = 0x3; // cold reset the cpu & system
+			break;
+	}
+}
+
+static void aruba_machine_halt(void)
+{
+	for (;;) continue;
+}
+
+extern char * getenv(char *e);
+extern void unlock_ap60_70_flash(void);
+
+void __init plat_setup(void)
+{
+	board_time_init = aruba_time_init;
+
+	board_timer_setup = aruba_timer_setup;
+
+	_machine_restart = aruba_machine_restart;
+	_machine_halt = aruba_machine_halt;
+	pm_power_off = aruba_machine_halt;
+
+	set_io_port_base(KSEG1);
+
+	/* Enable PCI interrupts in EPLD Mask register */
+	*epldMask = 0x0;
+	*(epldMask + 1) = 0x0;
+
+	write_c0_wired(0);
+	unlock_ap60_70_flash();
+
+	printk("BOARD - %s\n",getenv("boardname"));
+
+	return 0;
+}
+
+int page_is_ram(unsigned long pagenr)
+{
+	return 1;
+}
+
+const char *get_system_type(void)
+{
+	return "MIPS IDT32434 - ARUBA";
+}
+
+EXPORT_SYMBOL(get_system_type);
diff -Nur linux-2.6.16/arch/mips/aruba/time.c linux-2.6.16-owrt/arch/mips/aruba/time.c
--- linux-2.6.16/arch/mips/aruba/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/aruba/time.c	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,108 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     timer routines for IDT EB434 boards
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/mc146818rtc.h>
+#include <linux/irq.h>
+#include <linux/timex.h>
+
+#include <linux/param.h>
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/time.h>
+#include <asm/hardirq.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/debug.h>
+#include <asm/time.h>
+
+#include <asm/idt-boards/rc32434/rc32434.h>
+
+static unsigned long r4k_offset;	/* Amount to incr compare reg each time */
+static unsigned long r4k_cur;	/* What counter should be at next timer irq */
+
+extern unsigned int idt_cpu_freq;
+
+static unsigned long __init cal_r4koff(void)
+{
+	mips_hpt_frequency = idt_cpu_freq * IDT_CLOCK_MULT / 2;
+	return (mips_hpt_frequency / HZ);
+}
+
+void __init aruba_time_init(void)
+{
+	unsigned int est_freq, flags;
+	local_irq_save(flags);
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int)r4k_offset);
+
+	est_freq = 2 * r4k_offset * HZ;
+	est_freq += 5000;	/* round */
+	est_freq -= est_freq % 10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq / 1000000,
+	       (est_freq % 1000000) * 100 / 1000000);
+	local_irq_restore(flags);
+
+}
+
+void __init aruba_timer_setup(struct irqaction *irq)
+{
+	/* we are using the cpu counter for timer interrupts */
+	setup_irq(MIPS_CPU_TIMER_IRQ, irq);
+
+	/* to generate the first timer interrupt */
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+
+}
+
+asmlinkage void aruba_timer_interrupt(int irq, struct pt_regs *regs)
+{
+	irq_enter();
+	kstat_this_cpu.irqs[irq]++;
+
+	timer_interrupt(irq, NULL, regs);
+	irq_exit();
+}
diff -Nur linux-2.6.16/arch/mips/Kconfig linux-2.6.16-owrt/arch/mips/Kconfig
--- linux-2.6.16/arch/mips/Kconfig	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/Kconfig	2006-03-20 14:25:10.000000000 +0100
@@ -227,6 +227,17 @@
 	  either a NEC Vr5432 or QED RM5231. Say Y here if you wish to build
 	  a kernel for this platform.
 
+config MACH_ARUBA
+	bool "Support for the ARUBA product line"
+	select DMA_NONCOHERENT
+	select CPU_HAS_PREFETCH
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_BIG_ENDIAN
+
+
 config MACH_JAZZ
 	bool "Support for the Jazz family of machines"
 	select ARC
diff -Nur linux-2.6.16/arch/mips/Makefile linux-2.6.16-owrt/arch/mips/Makefile
--- linux-2.6.16/arch/mips/Makefile	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/Makefile	2006-03-20 14:25:10.000000000 +0100
@@ -279,6 +279,14 @@
 #
 
 #
+# Aruba
+#
+
+core-$(CONFIG_MACH_ARUBA)	+= arch/mips/aruba/
+cflags-$(CONFIG_MACH_ARUBA)	+= -Iinclude/asm-mips/aruba
+load-$(CONFIG_MACH_ARUBA)	+= 0x80100000
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
diff -Nur linux-2.6.16/arch/mips/mm/tlbex.c linux-2.6.16-owrt/arch/mips/mm/tlbex.c
--- linux-2.6.16/arch/mips/mm/tlbex.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/mm/tlbex.c	2006-03-20 14:25:10.000000000 +0100
@@ -852,7 +852,6 @@
 
 	case CPU_R10000:
 	case CPU_R12000:
-	case CPU_4KC:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_4KSC:
@@ -880,6 +879,7 @@
 		tlbw(p);
 		break;
 
+	case CPU_4KC:
 	case CPU_4KEC:
 	case CPU_24K:
 	case CPU_34K:
diff -Nur linux-2.6.16/drivers/net/Kconfig linux-2.6.16-owrt/drivers/net/Kconfig
--- linux-2.6.16/drivers/net/Kconfig	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/drivers/net/Kconfig	2006-03-20 14:25:10.000000000 +0100
@@ -187,6 +187,13 @@
 
 source "drivers/net/arm/Kconfig"
 
+config IDT_RC32434_ETH
+        tristate "IDT RC32434 Local Ethernet support"
+        depends on NET_ETHERNET
+        help
+        IDT RC32434 has one local ethernet port. Say Y here to enable it.
+        To compile this driver as a module, choose M here.
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on NET_ETHERNET && PPC_PMAC && PPC32
diff -Nur linux-2.6.16/drivers/net/Makefile linux-2.6.16-owrt/drivers/net/Makefile
--- linux-2.6.16/drivers/net/Makefile	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/drivers/net/Makefile	2006-03-20 14:25:10.000000000 +0100
@@ -38,6 +38,7 @@
 
 obj-$(CONFIG_OAKNET) += oaknet.o 8390.o
 
+obj-$(CONFIG_IDT_RC32434_ETH) += rc32434_eth.o
 obj-$(CONFIG_DGRS) += dgrs.o
 obj-$(CONFIG_VORTEX) += 3c59x.o
 obj-$(CONFIG_TYPHOON) += typhoon.o
diff -Nur linux-2.6.16/drivers/net/natsemi.c linux-2.6.16-owrt/drivers/net/natsemi.c
--- linux-2.6.16/drivers/net/natsemi.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/drivers/net/natsemi.c	2006-03-20 14:25:10.000000000 +0100
@@ -771,6 +771,49 @@
 static int netdev_get_eeprom(struct net_device *dev, u8 *buf);
 static struct ethtool_ops ethtool_ops;
 
+#ifdef CONFIG_MACH_ARUBA
+
+#include <linux/ctype.h>
+
+#ifndef ERR
+#define ERR(fmt, args...) printk("%s: " fmt, __func__, ##args)
+#endif
+
+static int parse_mac_addr(struct net_device *dev, char* macstr)
+{
+        int i, j;
+        unsigned char result, value;
+
+        for (i=0; i<6; i++) {
+                result = 0;
+                if (i != 5 && *(macstr+2) != ':') {
+                        ERR("invalid mac address format: %d %c\n",
+                            i, *(macstr+2));
+                        return -EINVAL;
+                }
+                for (j=0; j<2; j++) {
+                        if (isxdigit(*macstr) && (value = isdigit(*macstr) ? *macstr-'0' :
+                                                  toupper(*macstr)-'A'+10) < 16) {
+                                result = result*16 + value;
+                                macstr++;
+                        }
+                        else {
+                                ERR("invalid mac address "
+                                    "character: %c\n", *macstr);
+                                return -EINVAL;
+                        }
+                }
+
+                macstr++;
+                dev->dev_addr[i] = result;
+        }
+
+	dev->dev_addr[5]++;
+        return 0;
+}
+
+#endif
+
 static inline void __iomem *ns_ioaddr(struct net_device *dev)
 {
 	return (void __iomem *) dev->base_addr;
@@ -859,6 +902,7 @@
 		goto err_ioremap;
 	}
 
+#ifndef CONFIG_MACH_ARUBA
 	/* Work around the dropped serial bit. */
 	prev_eedata = eeprom_read(ioaddr, 6);
 	for (i = 0; i < 3; i++) {
@@ -867,6 +911,19 @@
 		dev->dev_addr[i*2+1] = eedata >> 7;
 		prev_eedata = eedata;
 	}
+#else
+	{
+		char mac[32];
+		unsigned char def_mac[6] = {00, 0x0b, 0x86, 0xba, 0xdb, 0xad};
+		extern char *getenv(char *e);
+		memset(mac, 0, 32);
+		memcpy(mac, getenv("ethaddr"), 17);
+		if (parse_mac_addr(dev, mac)){
+			printk("%s: MAC address not found\n", __func__);
+			memcpy(dev->dev_addr, def_mac, 6);
+		}
+	}
+#endif
 
 	dev->base_addr = (unsigned long __force) ioaddr;
 	dev->irq = irq;
diff -Nur linux-2.6.16/drivers/net/rc32434_eth.c linux-2.6.16-owrt/drivers/net/rc32434_eth.c
--- linux-2.6.16/drivers/net/rc32434_eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/drivers/net/rc32434_eth.c	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,1268 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Driver for the IDT RC32434 on-chip ethernet controller.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Based on the driver developed by B. Maruthanayakam, H. Kou and others.
+ *
+ * Aug 2004 Sadik
+ *
+ * Added NAPI
+ *
+ **************************************************************************
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/ctype.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <asm/bootinfo.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/pgtable.h>
+#include <asm/segment.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include "rc32434_eth.h"
+
+#define DRIVER_VERSION "(mar2904)"
+
+#define DRIVER_NAME "rc32434 Ethernet driver. " DRIVER_VERSION
+
+
+#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \
+			           ((dev)->dev_addr[1]))
+#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \
+				   ((dev)->dev_addr[3] << 16) | \
+				   ((dev)->dev_addr[4] << 8)  | \
+				   ((dev)->dev_addr[5]))
+
+#define MII_CLOCK 1250000 				/* no more than 2.5MHz */
+static char mac0[18] = "08:00:06:05:40:01"; 
+
+MODULE_PARM(mac0, "c18");
+MODULE_PARM_DESC(mac0, "MAC address for RC32434 ethernet0");
+
+static struct rc32434_if_t {
+	char *name;
+	struct net_device *dev;
+	char* mac_str;
+	int weight;
+	u32 iobase;
+	u32 rxdmabase;
+	u32 txdmabase;
+	int rx_dma_irq;
+	int tx_dma_irq;
+	int rx_ovr_irq;
+	int tx_und_irq;			
+} rc32434_iflist[] = 
+{
+	{
+		"rc32434_eth0",      NULL,       mac0, 
+		64,
+		ETH0_PhysicalAddress,
+		ETH0_RX_DMA_ADDR,
+		ETH0_TX_DMA_ADDR,
+		ETH0_DMA_RX_IRQ,
+		ETH0_DMA_TX_IRQ,
+		ETH0_RX_OVR_IRQ,
+		ETH0_TX_UND_IRQ
+	}
+};
+
+
+static int parse_mac_addr(struct net_device *dev, char* macstr)
+{
+	int i, j;
+	unsigned char result, value;
+	
+	for (i=0; i<6; i++) {
+		result = 0;
+		if (i != 5 && *(macstr+2) != ':') {
+			ERR("invalid mac address format: %d %c\n",
+			    i, *(macstr+2));
+			return -EINVAL;
+		}				
+		for (j=0; j<2; j++) {
+			if (isxdigit(*macstr) && (value = isdigit(*macstr) ? *macstr-'0' : 
+						  toupper(*macstr)-'A'+10) < 16) {
+				result = result*16 + value;
+				macstr++;
+			} 
+			else {
+				ERR("invalid mac address "
+				    "character: %c\n", *macstr);
+				return -EINVAL;
+			}
+		}
+		
+		macstr++; 
+		dev->dev_addr[i] = result;
+	}
+	
+	return 0;
+}
+
+
+
+static inline void rc32434_abort_tx(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	rc32434_abort_dma(dev, lp->tx_dma_regs);
+	
+}
+
+static inline void rc32434_abort_rx(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	rc32434_abort_dma(dev, lp->rx_dma_regs);
+	
+}
+
+static inline void rc32434_start_tx(struct rc32434_local *lp,  volatile DMAD_t td)
+{
+	rc32434_start_dma(lp->tx_dma_regs, CPHYSADDR(td));
+}
+
+static inline void rc32434_start_rx(struct rc32434_local *lp, volatile DMAD_t rd)
+{
+	rc32434_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));
+}
+
+static inline void rc32434_chain_tx(struct rc32434_local *lp, volatile DMAD_t td)
+{
+	rc32434_chain_dma(lp->tx_dma_regs, CPHYSADDR(td));
+}
+
+static inline void rc32434_chain_rx(struct rc32434_local *lp, volatile DMAD_t rd)
+{
+	rc32434_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));
+}
+
+#ifdef RC32434_PROC_DEBUG
+static int rc32434_read_proc(char *buf, char **start, off_t fpos,
+			     int length, int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	int len = 0;
+	
+	/* print out header */
+	len += sprintf(buf + len, "\n\tRC32434 Ethernet Debug\n\n");
+	len += sprintf (buf + len,
+			"DMA halt count      = %10d, DMA run count = %10d\n",
+			lp->dma_halt_cnt, lp->dma_run_cnt);
+	
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	
+	if ((len -= fpos) > length) 
+		return length;	
+	*eof = 1;
+	
+	return len;
+	
+}
+#endif
+
+
+/*
+ * Restart the RC32434 ethernet controller. 
+ */
+static int rc32434_restart(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	
+	/*
+	 * Disable interrupts
+	 */
+	disable_irq(lp->rx_irq);
+	disable_irq(lp->tx_irq);
+#ifdef	RC32434_REVISION
+	disable_irq(lp->ovr_irq);
+#endif	
+	disable_irq(lp->und_irq);
+	
+	/* Mask F E bit in Tx DMA */
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) | DMASM_f_m | DMASM_e_m, &lp->tx_dma_regs->dmasm);
+	/* Mask D H E bit in Rx DMA */
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) | DMASM_d_m | DMASM_h_m | DMASM_e_m, &lp->rx_dma_regs->dmasm);
+	
+	rc32434_init(dev);
+	rc32434_multicast_list(dev);
+	
+	enable_irq(lp->und_irq);
+#ifdef	RC32434_REVISION
+	enable_irq(lp->ovr_irq);
+#endif
+	enable_irq(lp->tx_irq);
+	enable_irq(lp->rx_irq);
+	
+	return 0;
+}
+
+int rc32434_init_module(void)
+{
+#ifdef CONFIG_MACH_ARUBA
+	if (mips_machtype != MACH_ARUBA_AP70)
+		return 1;
+#endif
+
+	printk(KERN_INFO DRIVER_NAME " \n");
+	return rc32434_probe(0);
+}
+
+static int rc32434_probe(int port_num)
+{
+	struct rc32434_if_t *bif = &rc32434_iflist[port_num];
+	struct rc32434_local *lp = NULL;
+	struct net_device *dev = NULL;
+	int i, retval,err;
+	
+	dev = alloc_etherdev(sizeof(struct rc32434_local));
+	if(!dev) {
+		ERR("rc32434_eth: alloc_etherdev failed\n");
+		return -1;
+	}
+	
+	SET_MODULE_OWNER(dev);
+	bif->dev = dev;
+
+#ifdef CONFIG_MACH_ARUBA
+	{
+		extern char * getenv(char *e);
+		memcpy(bif->mac_str, getenv("ethaddr"), 17);
+	}
+#endif
+	
+	printk("mac: %s\n", bif->mac_str);
+	if ((retval = parse_mac_addr(dev, bif->mac_str))) {
+		ERR("MAC address parse failed\n");
+		free_netdev(dev);
+		return -1;
+	}
+	
+	
+	/* Initialize the device structure. */
+	if (dev->priv == NULL) {
+		lp = (struct rc32434_local *)kmalloc(sizeof(*lp), GFP_KERNEL);
+		memset(lp, 0, sizeof(struct rc32434_local));
+	} 
+	else {
+		lp = (struct rc32434_local *)dev->priv;
+	}
+	
+	lp->rx_irq = bif->rx_dma_irq;
+	lp->tx_irq = bif->tx_dma_irq;
+	lp->ovr_irq = bif->rx_ovr_irq;
+	lp->und_irq = bif->tx_und_irq;
+	
+	lp->eth_regs = ioremap_nocache(bif->iobase, sizeof(*lp->eth_regs));
+
+	if (!lp->eth_regs) {
+		ERR("Can't remap eth registers\n");
+		retval = -ENXIO;
+		goto probe_err_out;
+	}
+	
+	lp->rx_dma_regs = ioremap_nocache(bif->rxdmabase, sizeof(struct DMA_Chan_s));
+	
+	if (!lp->rx_dma_regs) {
+		ERR("Can't remap Rx DMA registers\n");
+		retval = -ENXIO;
+		goto probe_err_out;
+	}
+	lp->tx_dma_regs = ioremap_nocache(bif->txdmabase,sizeof(struct DMA_Chan_s));
+	
+	if (!lp->tx_dma_regs) {
+		ERR("Can't remap Tx DMA registers\n");
+		retval = -ENXIO;
+		goto probe_err_out;
+	}
+	
+#ifdef RC32434_PROC_DEBUG
+	lp->ps = create_proc_read_entry (bif->name, 0, proc_net,
+					 rc32434_read_proc, dev);
+#endif
+	
+	lp->td_ring =	(DMAD_t)kmalloc(TD_RING_SIZE + RD_RING_SIZE, GFP_KERNEL);
+	if (!lp->td_ring) {
+		ERR("Can't allocate descriptors\n");
+		retval = -ENOMEM;
+		goto probe_err_out;
+	}
+	
+	dma_cache_inv((unsigned long)(lp->td_ring), TD_RING_SIZE + RD_RING_SIZE);
+	
+	/* now convert TD_RING pointer to KSEG1 */
+	lp->td_ring = (DMAD_t )KSEG1ADDR(lp->td_ring);
+	lp->rd_ring = &lp->td_ring[RC32434_NUM_TDS];
+	
+	
+	spin_lock_init(&lp->lock);
+	
+	dev->base_addr = bif->iobase;
+	/* just use the rx dma irq */
+	dev->irq = bif->rx_dma_irq; 
+	
+	dev->priv = lp;
+	
+	dev->open = rc32434_open;
+	dev->stop = rc32434_close;
+	dev->hard_start_xmit = rc32434_send_packet;
+	dev->get_stats	= rc32434_get_stats;
+	dev->set_multicast_list = &rc32434_multicast_list;
+	dev->tx_timeout = rc32434_tx_timeout;
+	dev->watchdog_timeo = RC32434_TX_TIMEOUT;
+
+#ifdef CONFIG_IDT_USE_NAPI
+	dev->poll = rc32434_poll;
+	dev->weight = bif->weight;
+	printk("Using NAPI with weight %d\n",dev->weight);
+#else
+	lp->rx_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
+	tasklet_init(lp->rx_tasklet, rc32434_rx_tasklet, (unsigned long)dev);
+#endif
+	lp->tx_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
+	tasklet_init(lp->tx_tasklet, rc32434_tx_tasklet, (unsigned long)dev);
+	
+	if ((err = register_netdev(dev))) {
+		printk(KERN_ERR "rc32434 ethernet. Cannot register net device %d\n", err);
+		free_netdev(dev);
+		retval = -EINVAL;
+		goto probe_err_out;
+	}
+	
+	INFO("Rx IRQ %d, Tx IRQ %d, ", bif->rx_dma_irq, bif->tx_dma_irq);
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", dev->dev_addr[i]);
+		if (i<5)
+			printk(":");
+	}
+	printk("\n");
+	
+	return 0;
+	
+ probe_err_out:
+	rc32434_cleanup_module();
+	ERR(" failed.  Returns %d\n", retval);
+	return retval;
+	
+}
+
+
+static void rc32434_cleanup_module(void)
+{
+	int i;
+	
+	for (i = 0; rc32434_iflist[i].iobase; i++) {
+		struct rc32434_if_t * bif = &rc32434_iflist[i];
+		if (bif->dev != NULL) {
+			struct rc32434_local *lp = (struct rc32434_local *)bif->dev->priv;
+			if (lp != NULL) {
+				if (lp->eth_regs)
+					iounmap((void*)lp->eth_regs);
+				if (lp->rx_dma_regs)
+					iounmap((void*)lp->rx_dma_regs);
+				if (lp->tx_dma_regs)
+					iounmap((void*)lp->tx_dma_regs);
+				if (lp->td_ring)
+					kfree((void*)KSEG0ADDR(lp->td_ring));
+				
+#ifdef RC32434_PROC_DEBUG
+				if (lp->ps) {
+					remove_proc_entry(bif->name, proc_net);
+				}
+#endif
+				kfree(lp);
+			}
+			
+			unregister_netdev(bif->dev);
+			free_netdev(bif->dev);
+			kfree(bif->dev);
+		}
+	}
+}
+
+
+
+static int rc32434_open(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	
+	/* Initialize */
+	if (rc32434_init(dev)) {
+		ERR("Error: cannot open the Ethernet device\n");
+		return -EAGAIN;
+	}
+	
+	/* Install the interrupt handler that handles the Done Finished Ovr and Und Events */	
+	if (request_irq(lp->rx_irq, &rc32434_rx_dma_interrupt,
+		  SA_SHIRQ | SA_INTERRUPT,
+			"rc32434 ethernet Rx", dev)) {
+		ERR(": unable to get Rx DMA IRQ %d\n",
+		    lp->rx_irq);
+		return -EAGAIN;
+	}
+	if (request_irq(lp->tx_irq, &rc32434_tx_dma_interrupt,
+		  SA_SHIRQ | SA_INTERRUPT,
+			"rc32434 ethernet Tx", dev)) {
+		ERR(": unable to get Tx DMA IRQ %d\n",
+		    lp->tx_irq);
+		free_irq(lp->rx_irq, dev);
+		return -EAGAIN;
+	}
+	
+#ifdef	RC32434_REVISION
+	/* Install handler for overrun error. */
+	if (request_irq(lp->ovr_irq, &rc32434_ovr_interrupt,
+			SA_SHIRQ | SA_INTERRUPT,
+			"Ethernet Overflow", dev)) {
+		ERR(": unable to get OVR IRQ %d\n",
+		    lp->ovr_irq);
+		free_irq(lp->rx_irq, dev);
+		free_irq(lp->tx_irq, dev);
+		return -EAGAIN;
+	}
+#endif
+	
+	/* Install handler for underflow error. */
+	if (request_irq(lp->und_irq, &rc32434_und_interrupt,
+			SA_SHIRQ | SA_INTERRUPT,
+			"Ethernet Underflow", dev)) {
+		ERR(": unable to get UND IRQ %d\n",
+		    lp->und_irq);
+		free_irq(lp->rx_irq, dev);
+		free_irq(lp->tx_irq, dev);
+#ifdef	RC32434_REVISION		
+		free_irq(lp->ovr_irq, dev);		
+#endif
+		return -EAGAIN;
+	}
+	
+	
+	return 0;
+}
+
+
+
+
+static int rc32434_close(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	u32 tmp;
+	
+	/* Disable interrupts */
+	disable_irq(lp->rx_irq);
+	disable_irq(lp->tx_irq);
+#ifdef	RC32434_REVISION
+	disable_irq(lp->ovr_irq);
+#endif
+	disable_irq(lp->und_irq);
+	
+	tmp = rc32434_readl(&lp->tx_dma_regs->dmasm);
+	tmp = tmp | DMASM_f_m | DMASM_e_m;
+	rc32434_writel(tmp, &lp->tx_dma_regs->dmasm);
+	
+	tmp = rc32434_readl(&lp->rx_dma_regs->dmasm);
+	tmp = tmp | DMASM_d_m | DMASM_h_m | DMASM_e_m;
+	rc32434_writel(tmp, &lp->rx_dma_regs->dmasm);
+	
+	free_irq(lp->rx_irq, dev);
+	free_irq(lp->tx_irq, dev);
+#ifdef	RC32434_REVISION	
+	free_irq(lp->ovr_irq, dev);
+#endif
+	free_irq(lp->und_irq, dev);
+	return 0;
+}
+
+
+/* transmit packet */
+static int rc32434_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct rc32434_local		*lp = (struct rc32434_local *)dev->priv;
+	unsigned long 			flags;
+	u32					length;
+	DMAD_t				td;
+	
+	
+	spin_lock_irqsave(&lp->lock, flags);
+	
+	td = &lp->td_ring[lp->tx_chain_tail];
+	
+	/* stop queue when full, drop pkts if queue already full */
+	if(lp->tx_count >= (RC32434_NUM_TDS - 2)) {
+		lp->tx_full = 1;
+		
+		if(lp->tx_count == (RC32434_NUM_TDS - 2)) {
+			netif_stop_queue(dev);
+		}
+		else {
+			lp->stats.tx_dropped++;
+			dev_kfree_skb_any(skb);
+			spin_unlock_irqrestore(&lp->lock, flags);
+			return 1;
+		}	   
+	}	 
+	
+	lp->tx_count ++;
+	
+	lp->tx_skb[lp->tx_chain_tail] = skb;
+	
+	length = skb->len;
+	
+	/* Setup the transmit descriptor. */
+	td->ca = CPHYSADDR(skb->data);
+	
+	if(rc32434_readl(&(lp->tx_dma_regs->dmandptr)) == 0) {
+		if( lp->tx_chain_status == empty ) {
+			td->control = DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;                                /*  Update tail      */
+			lp->tx_chain_tail = (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;                          /*   Move tail       */
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), &(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR    */
+			lp->tx_chain_head = lp->tx_chain_tail;                                                  /* Move head to tail */
+		}
+		else {
+			td->control = DMA_COUNT(length) |DMAD_cof_m|DMAD_iof_m;                                 /* Update tail */
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].control &=  ~(DMAD_cof_m);          /* Link to prev */
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].link =  CPHYSADDR(td);              /* Link to prev */
+			lp->tx_chain_tail = (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;                          /* Move tail */
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), &(lp->tx_dma_regs->dmandptr)); /* Write to NDPTR */
+			lp->tx_chain_head = lp->tx_chain_tail;                                                  /* Move head to tail */
+			lp->tx_chain_status = empty;
+		}
+	}
+	else {
+		if( lp->tx_chain_status == empty ) {
+			td->control = DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;                                /* Update tail */
+			lp->tx_chain_tail = (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;                          /* Move tail */
+			lp->tx_chain_status = filled;
+		}
+		else {
+			td->control = DMA_COUNT(length) |DMAD_cof_m |DMAD_iof_m;                                /* Update tail */
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].control &=  ~(DMAD_cof_m);          /* Link to prev */
+			lp->td_ring[(lp->tx_chain_tail-1)& RC32434_TDS_MASK].link =  CPHYSADDR(td);              /* Link to prev */
+			lp->tx_chain_tail = (lp->tx_chain_tail + 1) & RC32434_TDS_MASK;                          /* Move tail */
+		}
+	}
+	
+	dev->trans_start = jiffies;				
+	
+	spin_unlock_irqrestore(&lp->lock, flags);
+	
+	return 0;
+}
+
+
+/* Ethernet MII-PHY Handler */
+static void rc32434_mii_handler(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *)data;		
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	unsigned long 	flags;
+	unsigned long duplex_status;
+	int port_addr = (lp->rx_irq == 0x2c? 1:0) << 8;
+	
+	spin_lock_irqsave(&lp->lock, flags);
+	
+	/* Two ports are using the same MII, the difference is the PHY address */
+	rc32434_writel(0, &rc32434_eth0_regs->miimcfg);  
+	rc32434_writel(0, &rc32434_eth0_regs->miimcmd);  
+	rc32434_writel(port_addr |0x05, &rc32434_eth0_regs->miimaddr);  
+	rc32434_writel(MIIMCMD_scn_m, &rc32434_eth0_regs->miimcmd);  
+	while(rc32434_readl(&rc32434_eth0_regs->miimind) & MIIMIND_nv_m);
+	
+	ERR("irq:%x		port_addr:%x	RDD:%x\n", 
+	    lp->rx_irq, port_addr, rc32434_readl(&rc32434_eth0_regs->miimrdd));
+	duplex_status = (rc32434_readl(&rc32434_eth0_regs->miimrdd) & 0x140)? ETHMAC2_fd_m: 0;
+	if(duplex_status != lp->duplex_mode) {
+		ERR("The MII-PHY is Auto-negotiated to %s-Duplex mode for Eth-%x\n", duplex_status? "Full":"Half", lp->rx_irq == 0x2c? 1:0);		
+		lp->duplex_mode = duplex_status;
+		rc32434_restart(dev);		
+	}
+	
+	lp->mii_phy_timer.expires = jiffies + 10 * HZ;	
+	add_timer(&lp->mii_phy_timer);
+	
+	spin_unlock_irqrestore(&lp->lock, flags);
+	
+}
+
+#ifdef	RC32434_REVISION	
+/* Ethernet Rx Overflow interrupt */
+static irqreturn_t
+rc32434_ovr_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct rc32434_local *lp;
+	unsigned int ovr;
+	irqreturn_t retval = IRQ_NONE;
+	
+	ASSERT(dev != NULL);
+	
+	lp = (struct rc32434_local *)dev->priv;
+	spin_lock(&lp->lock);
+	ovr = rc32434_readl(&lp->eth_regs->ethintfc);
+	
+	if(ovr & ETHINTFC_ovr_m) {
+		netif_stop_queue(dev);
+		
+		/* clear OVR bit */
+		rc32434_writel((ovr & ~ETHINTFC_ovr_m), &lp->eth_regs->ethintfc);
+		
+		/* Restart interface */
+		rc32434_restart(dev);
+		retval = IRQ_HANDLED;
+	}
+	spin_unlock(&lp->lock);
+	
+	return retval;
+}
+
+#endif
+
+
+/* Ethernet Tx Underflow interrupt */
+static irqreturn_t
+rc32434_und_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct rc32434_local *lp;
+	unsigned int und;
+	irqreturn_t retval = IRQ_NONE;
+	
+	ASSERT(dev != NULL);
+	
+	lp = (struct rc32434_local *)dev->priv;
+	
+	spin_lock(&lp->lock);
+	
+	und = rc32434_readl(&lp->eth_regs->ethintfc);
+	
+	if(und & ETHINTFC_und_m) {
+		netif_stop_queue(dev);
+		
+		rc32434_writel((und & ~ETHINTFC_und_m), &lp->eth_regs->ethintfc);
+		
+		/* Restart interface */
+		rc32434_restart(dev);
+		retval = IRQ_HANDLED;
+	}
+	
+	spin_unlock(&lp->lock);
+	
+	return retval;
+}
+
+
+/* Ethernet Rx DMA interrupt */
+static irqreturn_t
+rc32434_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct rc32434_local* lp;
+	volatile u32 dmas,dmasm;
+	irqreturn_t retval;
+	
+	ASSERT(dev != NULL);
+	
+	lp = (struct rc32434_local *)dev->priv;
+	
+	spin_lock(&lp->lock);
+	dmas = rc32434_readl(&lp->rx_dma_regs->dmas);
+	if(dmas & (DMAS_d_m|DMAS_h_m|DMAS_e_m)) {
+		/* Mask D H E bit in Rx DMA */
+		dmasm = rc32434_readl(&lp->rx_dma_regs->dmasm);
+		rc32434_writel(dmasm | (DMASM_d_m | DMASM_h_m | DMASM_e_m), &lp->rx_dma_regs->dmasm);
+#ifdef CONFIG_IDT_USE_NAPI
+		if(netif_rx_schedule_prep(dev))
+                        __netif_rx_schedule(dev);
+#else
+		tasklet_hi_schedule(lp->rx_tasklet);
+#endif
+		
+		if (dmas & DMAS_e_m)
+			ERR(": DMA error\n");
+		
+		retval = IRQ_HANDLED;
+	}
+	else
+		retval = IRQ_NONE;
+	
+	spin_unlock(&lp->lock);
+	return retval;
+}
+
+#ifdef CONFIG_IDT_USE_NAPI
+static int rc32434_poll(struct net_device *rx_data_dev, int *budget)
+#else
+static void rc32434_rx_tasklet(unsigned long rx_data_dev)
+#endif
+{
+	struct net_device *dev = (struct net_device *)rx_data_dev;	
+	struct rc32434_local* lp = netdev_priv(dev);
+	volatile DMAD_t  rd = &lp->rd_ring[lp->rx_next_done];
+	struct sk_buff *skb, *skb_new;
+	u8* pkt_buf;
+	u32 devcs, count, pkt_len, pktuncrc_len;
+	volatile u32 dmas;
+#ifdef CONFIG_IDT_USE_NAPI
+	u32 received = 0;
+	int rx_work_limit = min(*budget,dev->quota);
+#else
+	unsigned long 	flags;
+	spin_lock_irqsave(&lp->lock, flags);
+#endif
+	
+	while ( (count = RC32434_RBSIZE - (u32)DMA_COUNT(rd->control)) != 0) {
+#ifdef CONFIG_IDT_USE_NAPI
+		if(--rx_work_limit <0)
+                {
+                        break;
+                }
+#endif
+		/* init the var. used for the later operations within the while loop */
+		skb_new = NULL;
+		devcs = rd->devcs;
+		pkt_len = RCVPKT_LENGTH(devcs);
+		skb = lp->rx_skb[lp->rx_next_done];
+      
+		if (count < 64) {
+			lp->stats.rx_errors++;
+			lp->stats.rx_dropped++;			
+		}
+		else if ((devcs & ( ETHRX_ld_m)) !=	ETHRX_ld_m) {
+			/* check that this is a whole packet */
+			/* WARNING: DMA_FD bit incorrectly set in Rc32434 (errata ref #077) */
+			lp->stats.rx_errors++;
+			lp->stats.rx_dropped++;
+		}
+		else if ( (devcs & ETHRX_rok_m)  ) {
+			
+			{
+				/* must be the (first and) last descriptor then */
+				pkt_buf = (u8*)lp->rx_skb[lp->rx_next_done]->data;
+				
+				pktuncrc_len = pkt_len - 4;
+				/* invalidate the cache */
+				dma_cache_inv((unsigned long)pkt_buf, pktuncrc_len);
+				
+				/* Malloc up new buffer. */					  
+				skb_new = dev_alloc_skb(RC32434_RBSIZE + 2);					             	
+				
+				if (skb_new != NULL){
+					/* Make room */
+					skb_put(skb, pktuncrc_len);		    
+					
+					skb->protocol = eth_type_trans(skb, dev);
+					
+					/* pass the packet to upper layers */
+#ifdef CONFIG_IDT_USE_NAPI
+					netif_receive_skb(skb);
+#else
+					netif_rx(skb);
+#endif
+					
+					dev->last_rx = jiffies;
+					lp->stats.rx_packets++;
+					lp->stats.rx_bytes += pktuncrc_len;
+					
+					if (IS_RCV_MP(devcs))
+						lp->stats.multicast++;
+					
+					/* 16 bit align */						  
+					skb_reserve(skb_new, 2);	
+					
+					skb_new->dev = dev;
+					lp->rx_skb[lp->rx_next_done] = skb_new;
+				}
+				else {
+					ERR("no memory, dropping rx packet.\n");
+					lp->stats.rx_errors++;		
+					lp->stats.rx_dropped++;					
+				}
+			}
+			
+		}			
+		else {
+			/* This should only happen if we enable accepting broken packets */
+			lp->stats.rx_errors++;
+			lp->stats.rx_dropped++;
+			
+			/* add statistics counters */
+			if (IS_RCV_CRC_ERR(devcs)) {
+				DBG(2, "RX CRC error\n");
+				lp->stats.rx_crc_errors++;
+			} 
+			else if (IS_RCV_LOR_ERR(devcs)) {
+				DBG(2, "RX LOR error\n");
+				lp->stats.rx_length_errors++;
+			}				
+			else if (IS_RCV_LE_ERR(devcs)) {
+				DBG(2, "RX LE error\n");
+				lp->stats.rx_length_errors++;
+			}
+			else if (IS_RCV_OVR_ERR(devcs)) {
+				lp->stats.rx_over_errors++;
+			}
+			else if (IS_RCV_CV_ERR(devcs)) {
+				/* code violation */
+				DBG(2, "RX CV error\n");
+				lp->stats.rx_frame_errors++;
+			}
+			else if (IS_RCV_CES_ERR(devcs)) {
+				DBG(2, "RX Preamble error\n");
+			}
+		}
+		
+		rd->devcs = 0;
+		
+		/* restore descriptor's curr_addr */
+		if(skb_new)
+			rd->ca = CPHYSADDR(skb_new->data); 
+		else
+			rd->ca = CPHYSADDR(skb->data);
+		
+		rd->control = DMA_COUNT(RC32434_RBSIZE) |DMAD_cod_m |DMAD_iod_m;
+		lp->rd_ring[(lp->rx_next_done-1)& RC32434_RDS_MASK].control &=  ~(DMAD_cod_m); 	
+		
+		lp->rx_next_done = (lp->rx_next_done + 1) & RC32434_RDS_MASK;
+		rd = &lp->rd_ring[lp->rx_next_done];
+		rc32434_writel( ~DMAS_d_m, &lp->rx_dma_regs->dmas);
+	}	
+#ifdef CONFIG_IDT_USE_NAPI
+        dev->quota -= received;
+        *budget =- received;
+        if(rx_work_limit < 0)
+                goto not_done;
+#endif
+	
+	dmas = rc32434_readl(&lp->rx_dma_regs->dmas);
+	
+	if(dmas & DMAS_h_m) {
+		rc32434_writel( ~(DMAS_h_m | DMAS_e_m), &lp->rx_dma_regs->dmas);
+#ifdef RC32434_PROC_DEBUG
+		lp->dma_halt_cnt++;
+#endif
+		rd->devcs = 0;
+		skb = lp->rx_skb[lp->rx_next_done];
+		rd->ca = CPHYSADDR(skb->data);
+		rc32434_chain_rx(lp,rd);
+	}
+	
+#ifdef CONFIG_IDT_USE_NAPI
+	netif_rx_complete(dev);
+#endif
+	/* Enable D H E bit in Rx DMA */
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | DMASM_h_m |DMASM_e_m), &lp->rx_dma_regs->dmasm); 
+#ifdef CONFIG_IDT_USE_NAPI
+	return 0;
+ not_done:
+	return 1;
+#else
+	spin_unlock_irqrestore(&lp->lock, flags);
+	return;
+#endif
+
+	
+}	
+
+
+
+/* Ethernet Tx DMA interrupt */
+static irqreturn_t
+rc32434_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct rc32434_local *lp;
+	volatile u32 dmas,dmasm;
+	irqreturn_t retval;
+	
+	ASSERT(dev != NULL);
+	
+	lp = (struct rc32434_local *)dev->priv;
+	
+	spin_lock(&lp->lock);
+	
+	dmas = rc32434_readl(&lp->tx_dma_regs->dmas);
+	
+	if (dmas & (DMAS_f_m | DMAS_e_m)) {
+		dmasm = rc32434_readl(&lp->tx_dma_regs->dmasm);
+		/* Mask F E bit in Tx DMA */
+		rc32434_writel(dmasm | (DMASM_f_m | DMASM_e_m), &lp->tx_dma_regs->dmasm);
+		
+		tasklet_hi_schedule(lp->tx_tasklet);
+		
+		if(lp->tx_chain_status == filled && (rc32434_readl(&(lp->tx_dma_regs->dmandptr)) == 0)) {
+			rc32434_writel(CPHYSADDR(&lp->td_ring[lp->tx_chain_head]), &(lp->tx_dma_regs->dmandptr));			
+			lp->tx_chain_status = empty;
+			lp->tx_chain_head = lp->tx_chain_tail;
+			dev->trans_start = jiffies;
+		}
+		
+		if (dmas & DMAS_e_m)
+			ERR(": DMA error\n");
+		
+		retval = IRQ_HANDLED;
+	}
+	else
+		retval = IRQ_NONE;
+	
+	spin_unlock(&lp->lock);
+	
+	return retval;
+}
+
+
+static void rc32434_tx_tasklet(unsigned long tx_data_dev)
+{
+	struct net_device *dev = (struct net_device *)tx_data_dev;	
+	struct rc32434_local* lp = (struct rc32434_local *)dev->priv;
+	volatile DMAD_t td = &lp->td_ring[lp->tx_next_done];
+	u32 devcs;
+	unsigned long 	flags;
+	volatile u32 dmas;
+	
+	spin_lock_irqsave(&lp->lock, flags);
+	
+	/* process all desc that are done */
+	while(IS_DMA_FINISHED(td->control)) {
+		if(lp->tx_full == 1) {
+			netif_wake_queue(dev);
+			lp->tx_full = 0;
+		}
+		
+		devcs = lp->td_ring[lp->tx_next_done].devcs;    
+		if ((devcs & (ETHTX_fd_m | ETHTX_ld_m)) != (ETHTX_fd_m | ETHTX_ld_m)) {
+			lp->stats.tx_errors++;
+			lp->stats.tx_dropped++;				
+			
+			/* should never happen */
+			DBG(1, __FUNCTION__ ": split tx ignored\n");
+		}
+		else if (IS_TX_TOK(devcs)) {
+			lp->stats.tx_packets++;
+		}
+		else {
+			lp->stats.tx_errors++;
+			lp->stats.tx_dropped++;				
+			
+			/* underflow */
+			if (IS_TX_UND_ERR(devcs)) 
+				lp->stats.tx_fifo_errors++;
+			
+			/* oversized frame */
+			if (IS_TX_OF_ERR(devcs))
+				lp->stats.tx_aborted_errors++;
+			
+			/* excessive deferrals */
+			if (IS_TX_ED_ERR(devcs))
+				lp->stats.tx_carrier_errors++;
+			
+			/* collisions: medium busy */
+			if (IS_TX_EC_ERR(devcs))
+				lp->stats.collisions++;
+			
+			/* late collision */
+			if (IS_TX_LC_ERR(devcs))
+				lp->stats.tx_window_errors++;
+			
+		}
+		
+		/* We must always free the original skb */
+		if (lp->tx_skb[lp->tx_next_done] != NULL) {
+			dev_kfree_skb_any(lp->tx_skb[lp->tx_next_done]);
+			lp->tx_skb[lp->tx_next_done] = NULL;
+		}
+		
+		lp->td_ring[lp->tx_next_done].control = DMAD_iof_m;
+		lp->td_ring[lp->tx_next_done].devcs = ETHTX_fd_m | ETHTX_ld_m;	
+		lp->td_ring[lp->tx_next_done].link = 0;
+		lp->td_ring[lp->tx_next_done].ca = 0;
+		lp->tx_count --;
+		
+		/* go on to next transmission */
+		lp->tx_next_done = (lp->tx_next_done + 1) & RC32434_TDS_MASK;
+		td = &lp->td_ring[lp->tx_next_done];
+		
+	}
+	
+	dmas = rc32434_readl(&lp->tx_dma_regs->dmas);
+	rc32434_writel( ~dmas, &lp->tx_dma_regs->dmas);
+	
+	/* Enable F E bit in Tx DMA */
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | DMASM_e_m), &lp->tx_dma_regs->dmasm); 
+	spin_unlock_irqrestore(&lp->lock, flags);
+	
+}
+
+
+static struct net_device_stats * rc32434_get_stats(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	return &lp->stats;
+}
+
+
+/*
+ * Set or clear the multicast filter for this adaptor.
+ */
+static void rc32434_multicast_list(struct net_device *dev)
+{   
+	/* listen to broadcasts always and to treat 	*/
+	/*       IFF bits independantly	*/
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	unsigned long flags;
+	u32 recognise = ETHARC_ab_m; 		/* always accept broadcasts */
+	
+	if (dev->flags & IFF_PROMISC)         		/* set promiscuous mode */
+		recognise |= ETHARC_pro_m;
+	
+	if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 15))
+		recognise |= ETHARC_am_m;    	  	/* all multicast & bcast */
+	else if (dev->mc_count > 0) {
+		DBG(2, __FUNCTION__ ": mc_count %d\n", dev->mc_count);
+		recognise |= ETHARC_am_m;    	  	/* for the time being */
+	}
+	
+	spin_lock_irqsave(&lp->lock, flags);
+	rc32434_writel(recognise, &lp->eth_regs->etharc);
+	spin_unlock_irqrestore(&lp->lock, flags);
+}
+
+
+static void rc32434_tx_timeout(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&lp->lock, flags);
+	rc32434_restart(dev);
+	spin_unlock_irqrestore(&lp->lock, flags);
+	
+}
+
+
+/*
+ * Initialize the RC32434 ethernet controller.
+ */
+static int rc32434_init(struct net_device *dev)
+{
+	struct rc32434_local *lp = (struct rc32434_local *)dev->priv;
+	int i, j;
+	
+	/* Disable DMA */       
+	rc32434_abort_tx(dev);
+	rc32434_abort_rx(dev); 
+	
+	/* reset ethernet logic */ 
+	rc32434_writel(0, &lp->eth_regs->ethintfc);
+	while((rc32434_readl(&lp->eth_regs->ethintfc) & ETHINTFC_rip_m))
+		dev->trans_start = jiffies;	
+	
+	/* Enable Ethernet Interface */ 
+	rc32434_writel(ETHINTFC_en_m, &lp->eth_regs->ethintfc); 
+	
+#ifndef CONFIG_IDT_USE_NAPI
+	tasklet_disable(lp->rx_tasklet);
+#endif
+	tasklet_disable(lp->tx_tasklet);
+	
+	/* Initialize the transmit Descriptors */
+	for (i = 0; i < RC32434_NUM_TDS; i++) {
+		lp->td_ring[i].control = DMAD_iof_m;
+		lp->td_ring[i].devcs = ETHTX_fd_m | ETHTX_ld_m;
+		lp->td_ring[i].ca = 0;
+		lp->td_ring[i].link = 0;
+		if (lp->tx_skb[i] != NULL) {
+			dev_kfree_skb_any(lp->tx_skb[i]);
+			lp->tx_skb[i] = NULL;
+		}
+	}
+	lp->tx_next_done = lp->tx_chain_head = lp->tx_chain_tail = 	lp->tx_full = lp->tx_count = 0;
+	lp->	tx_chain_status = empty;
+	
+	/*
+	 * Initialize the receive descriptors so that they
+	 * become a circular linked list, ie. let the last
+	 * descriptor point to the first again.
+	 */
+	for (i=0; i<RC32434_NUM_RDS; i++) {
+		struct sk_buff *skb = lp->rx_skb[i];
+		
+		if (lp->rx_skb[i] == NULL) {
+			skb = dev_alloc_skb(RC32434_RBSIZE + 2);
+			if (skb == NULL) {
+				ERR("No memory in the system\n");
+				for (j = 0; j < RC32434_NUM_RDS; j ++)
+					if (lp->rx_skb[j] != NULL) 
+						dev_kfree_skb_any(lp->rx_skb[j]);
+				
+				return 1;
+			}
+			else {
+				skb->dev = dev;
+				skb_reserve(skb, 2);
+				lp->rx_skb[i] = skb;
+				lp->rd_ring[i].ca = CPHYSADDR(skb->data); 
+				
+			}
+		}
+		lp->rd_ring[i].control =	DMAD_iod_m | DMA_COUNT(RC32434_RBSIZE);
+		lp->rd_ring[i].devcs = 0;
+		lp->rd_ring[i].ca = CPHYSADDR(skb->data);
+		lp->rd_ring[i].link = CPHYSADDR(&lp->rd_ring[i+1]);
+		
+	}
+	/* loop back */
+	lp->rd_ring[RC32434_NUM_RDS-1].link = CPHYSADDR(&lp->rd_ring[0]);
+	lp->rx_next_done   = 0;
+	
+	lp->rd_ring[RC32434_NUM_RDS-1].control |= DMAD_cod_m;
+	lp->rx_chain_head = 0;
+	lp->rx_chain_tail = 0;
+	lp->rx_chain_status = empty;
+	
+	rc32434_writel(0, &lp->rx_dma_regs->dmas);
+	/* Start Rx DMA */
+	rc32434_start_rx(lp, &lp->rd_ring[0]);
+	
+	/* Enable F E bit in Tx DMA */
+	rc32434_writel(rc32434_readl(&lp->tx_dma_regs->dmasm) & ~(DMASM_f_m | DMASM_e_m), &lp->tx_dma_regs->dmasm); 
+	/* Enable D H E bit in Rx DMA */
+	rc32434_writel(rc32434_readl(&lp->rx_dma_regs->dmasm) & ~(DMASM_d_m | DMASM_h_m | DMASM_e_m), &lp->rx_dma_regs->dmasm); 
+	
+	/* Accept only packets destined for this Ethernet device address */
+	rc32434_writel(ETHARC_ab_m, &lp->eth_regs->etharc); 
+	
+	/* Set all Ether station address registers to their initial values */ 
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0); 
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);
+	
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1); 
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);
+	
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2); 
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);
+	
+	rc32434_writel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3); 
+	rc32434_writel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3); 
+	
+	
+	/* Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set */ 
+	rc32434_writel(ETHMAC2_pe_m | ETHMAC2_cen_m | ETHMAC2_fd_m, &lp->eth_regs->ethmac2);  
+	//ETHMAC2_flc_m		ETHMAC2_fd_m	lp->duplex_mode
+	
+	/* Back to back inter-packet-gap */ 
+	rc32434_writel(0x15, &lp->eth_regs->ethipgt); 
+	/* Non - Back to back inter-packet-gap */ 
+	rc32434_writel(0x12, &lp->eth_regs->ethipgr); 
+	
+	/* Management Clock Prescaler Divisor */
+	/* Clock independent setting */
+	rc32434_writel(((idt_cpu_freq)/MII_CLOCK+1) & ~1,
+		       &lp->eth_regs->ethmcp);
+	
+	/* don't transmit until fifo contains 48b */
+	rc32434_writel(48, &lp->eth_regs->ethfifott);
+	
+	rc32434_writel(ETHMAC1_re_m, &lp->eth_regs->ethmac1);
+	
+#ifndef CONFIG_IDT_USE_NAPI
+	tasklet_enable(lp->rx_tasklet);
+#endif
+	tasklet_enable(lp->tx_tasklet);
+	
+	netif_start_queue(dev);
+	
+	
+	return 0; 
+	
+}
+
+
+#ifndef MODULE
+
+static int __init rc32434_setup(char *options)
+{
+	/* no options yet */
+	return 1;
+}
+
+static int __init rc32434_setup_ethaddr0(char *options)
+{
+	memcpy(mac0, options, 17);
+	mac0[17]= '\0';
+	return 1;
+}
+
+__setup("rc32434eth=", rc32434_setup);
+__setup("ethaddr0=", rc32434_setup_ethaddr0);
+
+
+#endif /* MODULE */
+
+module_init(rc32434_init_module);
+module_exit(rc32434_cleanup_module);
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Nur linux-2.6.16/drivers/net/rc32434_eth.h linux-2.6.16-owrt/drivers/net/rc32434_eth.h
--- linux-2.6.16/drivers/net/rc32434_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/drivers/net/rc32434_eth.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,187 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Definitions for IDT RC32434 on-chip ethernet controller.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * Aug 2004
+ *
+ * Added NAPI
+ *
+ **************************************************************************
+ */
+
+
+#include  <asm/idt-boards/rc32434/rc32434.h>
+#include  <asm/idt-boards/rc32434/rc32434_dma_v.h>
+#include  <asm/idt-boards/rc32434/rc32434_eth_v.h>
+
+#define RC32434_DEBUG	2
+//#define RC32434_PROC_DEBUG
+#undef	RC32434_DEBUG
+
+#ifdef RC32434_DEBUG
+
+/* use 0 for production, 1 for verification, >2 for debug */
+static int rc32434_debug = RC32434_DEBUG;
+#define ASSERT(expr) \
+	if(!(expr)) {	\
+		printk( "Assertion failed! %s,%s,%s,line=%d\n",	\
+		#expr,__FILE__,__FUNCTION__,__LINE__);		}
+#define DBG(lvl, format, arg...) if (rc32434_debug > lvl) printk(KERN_INFO "%s: " format, dev->name , ## arg)
+#else
+#define ASSERT(expr) do {} while (0)
+#define DBG(lvl, format, arg...) do {} while (0)
+#endif
+
+#define INFO(format, arg...) printk(KERN_INFO "%s: " format, dev->name , ## arg)
+#define ERR(format, arg...) printk(KERN_ERR "%s: " format, dev->name , ## arg)
+#define WARN(format, arg...) printk(KERN_WARNING "%s: " format, dev->name , ## arg)		
+
+#define ETH0_DMA_RX_IRQ   	GROUP1_IRQ_BASE + 0
+#define ETH0_DMA_TX_IRQ   	GROUP1_IRQ_BASE + 1 
+#define ETH0_RX_OVR_IRQ   	GROUP3_IRQ_BASE + 9
+#define ETH0_TX_UND_IRQ   	GROUP3_IRQ_BASE + 10
+
+#define ETH0_RX_DMA_ADDR  (DMA0_PhysicalAddress + 0*DMA_CHAN_OFFSET)
+#define ETH0_TX_DMA_ADDR  (DMA0_PhysicalAddress + 1*DMA_CHAN_OFFSET)
+
+/* the following must be powers of two */
+#ifdef CONFIG_IDT_USE_NAPI
+#define RC32434_NUM_RDS    64    		/* number of receive descriptors */
+#define RC32434_NUM_TDS    64    		/* number of transmit descriptors */
+#else
+#define RC32434_NUM_RDS    128    		/* number of receive descriptors */
+#define RC32434_NUM_TDS    128    		/* number of transmit descriptors */
+#endif
+
+#define RC32434_RBSIZE     1536  		/* size of one resource buffer = Ether MTU */
+#define RC32434_RDS_MASK   (RC32434_NUM_RDS-1)
+#define RC32434_TDS_MASK   (RC32434_NUM_TDS-1)
+#define RD_RING_SIZE (RC32434_NUM_RDS * sizeof(struct DMAD_s))
+#define TD_RING_SIZE (RC32434_NUM_TDS * sizeof(struct DMAD_s))
+
+#define RC32434_TX_TIMEOUT HZ * 100
+
+#define rc32434_eth0_regs ((ETH_t)(ETH0_VirtualAddress))
+#define rc32434_eth1_regs ((ETH_t)(ETH1_VirtualAddress))
+
+enum status	{ filled,	empty};
+#define IS_DMA_FINISHED(X)   (((X) & (DMAD_f_m)) != 0)
+#define IS_DMA_DONE(X)   (((X) & (DMAD_d_m)) != 0)
+
+
+/* Information that need to be kept for each board. */
+struct rc32434_local {
+	ETH_t  eth_regs;
+	DMA_Chan_t  rx_dma_regs;
+	DMA_Chan_t  tx_dma_regs;
+	volatile DMAD_t   td_ring;			/* transmit descriptor ring */ 
+	volatile DMAD_t   rd_ring;			/* receive descriptor ring  */
+	
+	struct sk_buff* tx_skb[RC32434_NUM_TDS]; 	/* skbuffs for pkt to trans */
+	struct sk_buff* rx_skb[RC32434_NUM_RDS]; 	/* skbuffs for pkt to trans */
+	
+#ifndef CONFIG_IDT_USE_NAPI
+	struct tasklet_struct * rx_tasklet;
+#endif
+	struct tasklet_struct * tx_tasklet;
+	
+	int	rx_next_done;
+	int	rx_chain_head;
+	int	rx_chain_tail;
+	enum status	rx_chain_status;
+	
+	int	tx_next_done;
+	int	tx_chain_head;
+	int	tx_chain_tail;
+	enum status	tx_chain_status;
+	int tx_count;			
+	int	tx_full;
+	
+	struct timer_list    mii_phy_timer;
+	unsigned long duplex_mode;
+	
+	int   	rx_irq;
+	int    tx_irq;
+	int    ovr_irq;
+	int    und_irq;
+	
+	struct net_device_stats stats;
+	spinlock_t lock; 
+	
+	/* debug /proc entry */
+	struct proc_dir_entry *ps;
+	int dma_halt_cnt;  int dma_run_cnt;
+};
+
+extern unsigned int idt_cpu_freq;
+
+/* Index to functions, as function prototypes. */
+static int rc32434_open(struct net_device *dev);
+static int rc32434_send_packet(struct sk_buff *skb, struct net_device *dev);
+static void rc32434_mii_handler(unsigned long data);
+static irqreturn_t  rc32434_und_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+static irqreturn_t rc32434_rx_dma_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+static irqreturn_t rc32434_tx_dma_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+#ifdef	RC32434_REVISION	
+static irqreturn_t rc32434_ovr_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+#endif
+static int  rc32434_close(struct net_device *dev);
+static struct net_device_stats *rc32434_get_stats(struct net_device *dev);
+static void rc32434_multicast_list(struct net_device *dev);
+static int  rc32434_init(struct net_device *dev);
+static void rc32434_tx_timeout(struct net_device *dev);
+
+static void rc32434_tx_tasklet(unsigned long tx_data_dev);
+#ifdef CONFIG_IDT_USE_NAPI
+static int rc32434_poll(struct net_device *rx_data_dev, int *budget);
+#else
+static void rc32434_rx_tasklet(unsigned long rx_data_dev);
+#endif
+static void rc32434_cleanup_module(void);
+static int rc32434_probe(int port_num);
+int rc32434_init_module(void);
+
+
+static inline void rc32434_abort_dma(struct net_device *dev, DMA_Chan_t ch)
+{
+	if (rc32434_readl(&ch->dmac) & DMAC_run_m) {
+		rc32434_writel(0x10, &ch->dmac); 
+		
+		while (!(rc32434_readl(&ch->dmas) & DMAS_h_m))
+			dev->trans_start = jiffies;		
+		
+		rc32434_writel(0, &ch->dmas);  
+	}
+	
+	rc32434_writel(0, &ch->dmadptr); 
+	rc32434_writel(0, &ch->dmandptr); 
+}
diff -Nur linux-2.6.16/include/asm-mips/bootinfo.h linux-2.6.16-owrt/include/asm-mips/bootinfo.h
--- linux-2.6.16/include/asm-mips/bootinfo.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/bootinfo.h	2006-03-20 14:25:10.000000000 +0100
@@ -218,6 +218,17 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+
+/*
+ * Valid machtype for group ARUBA
+ */
+#define MACH_GROUP_ARUBA	23
+#define  MACH_ARUBA_UNKNOWN	0
+#define  MACH_ARUBA_AP60	1
+#define  MACH_ARUBA_AP65	2
+#define  MACH_ARUBA_AP70	3
+#define  MACH_ARUBA_AP40	4
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -Nur linux-2.6.16/include/asm-mips/cpu.h linux-2.6.16-owrt/include/asm-mips/cpu.h
--- linux-2.6.16/include/asm-mips/cpu.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/cpu.h	2006-03-20 14:25:10.000000000 +0100
@@ -53,6 +53,9 @@
 #define PRID_IMP_R12000		0x0e00
 #define PRID_IMP_R8000		0x1000
 #define PRID_IMP_PR4450		0x1200
+#define PRID_IMP_RC32334	0x1800
+#define PRID_IMP_RC32355	0x1900
+#define PRID_IMP_RC32365	0x1900
 #define PRID_IMP_R4600		0x2000
 #define PRID_IMP_R4700		0x2100
 #define PRID_IMP_TX39		0x2200
@@ -196,7 +199,8 @@
 #define CPU_34K			60
 #define CPU_PR4450		61
 #define CPU_SB1A		62
-#define CPU_LAST		62
+#define CPU_RC32300		63
+#define CPU_LAST		63
 
 /*
  * ISA Level encodings
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32300.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32300.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32300.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32300.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,142 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32300 helper routines
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32300_H__
+#define __IDT_RC32300_H__
+
+#include <linux/delay.h>
+#include <asm/io.h>
+
+
+/* cpu pipeline flush */
+static inline void rc32300_sync(void)
+{
+	__asm__ volatile ("sync");
+}
+
+static inline void rc32300_sync_udelay(int us)
+{
+	__asm__ volatile ("sync");
+	udelay(us);
+}
+
+static inline void rc32300_sync_delay(int ms)
+{
+	__asm__ volatile ("sync");
+	mdelay(ms);
+}
+
+/*
+ * Macros to access internal RC32300 registers. No byte
+ * swapping should be done when accessing the internal
+ * registers.
+ */
+
+static inline u8 rc32300_readb(unsigned long pa)
+{
+	return *((volatile u8 *)KSEG1ADDR(pa));
+}
+static inline u16 rc32300_readw(unsigned long pa)
+{
+	return *((volatile u16 *)KSEG1ADDR(pa));
+}
+static inline u32 rc32300_readl(unsigned long pa)
+{
+	return *((volatile u32 *)KSEG1ADDR(pa));
+}
+static inline void rc32300_writeb(u8 val, unsigned long pa)
+{
+	*((volatile u8 *)KSEG1ADDR(pa)) = val;
+}
+static inline void rc32300_writew(u16 val, unsigned long pa)
+{
+	*((volatile u16 *)KSEG1ADDR(pa)) = val;
+}
+static inline void rc32300_writel(u32 val, unsigned long pa)
+{
+	*((volatile u32 *)KSEG1ADDR(pa)) = val;
+}
+
+
+#define local_readb __raw_readb
+#define local_readw __raw_readw
+#define local_readl __raw_readl
+
+#define local_writeb __raw_writeb
+#define local_writew __raw_writew
+#define local_writel __raw_writel
+
+
+/*
+ * C access to CLZ and CLO instructions
+ * (count leading zeroes/ones).
+ */
+static inline int rc32300_clz(unsigned long val)
+{
+	int ret;
+	__asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clz\t%0,%1\n\t"
+		".set\tmips0\n\t"
+		".set\tat\n\t"
+		".set\treorder"
+		: "=r" (ret)
+		: "r" (val));
+	
+	return ret;
+}
+static inline int rc32300_clo(unsigned long val)
+{
+	int ret;
+	__asm__ volatile (
+		    ".set\tnoreorder\n\t"
+		    ".set\tnoat\n\t"
+		    ".set\tmips32\n\t"
+		    "clo\t%0,%1\n\t"
+		    ".set\tmips0\n\t"
+		    ".set\tat\n\t"
+		    ".set\treorder"
+		    : "=r" (ret)
+		    : "r" (val));
+	
+	return ret;
+}
+
+#endif  // __IDT_RC32300_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32334.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32334.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32334.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32334.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,207 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32334 CPU.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+
+#ifndef __IDT_RC32334_H__
+#define __IDT_RC32334_H__
+
+#include <linux/delay.h>
+#include <asm/io.h>
+
+/* Base address of internal registers */
+#define RC32334_REG_BASE   0x18000000
+
+/* CPU and IP Bus Control */
+#define CPU_PORT_WIDTH     0xffffe200 // virtual!
+#define CPU_BTA            0xffffe204 // virtual!
+#define CPU_BUSERR_ADDR    0xffffe208 // virtual!
+#define CPU_IP_BTA         (RC32334_REG_BASE + 0x0000)
+#define CPU_IP_ADDR_LATCH  (RC32334_REG_BASE + 0x0004)
+#define CPU_IP_ARBITRATION (RC32334_REG_BASE + 0x0008)
+#define CPU_IP_BUSERR_CNTL (RC32334_REG_BASE + 0x0010)
+#define CPU_IP_BUSERR_ADDR (RC32334_REG_BASE + 0x0014)
+#define CPU_IP_SYSID       (RC32334_REG_BASE + 0x0018)
+
+/* Memory Controller */
+#define MEM_BASE_BANK0     (RC32334_REG_BASE + 0x0080)
+#define MEM_MASK_BANK0     (RC32334_REG_BASE + 0x0084)
+#define MEM_CNTL_BANK0     (RC32334_REG_BASE + 0x0200)
+#define MEM_BASE_BANK1     (RC32334_REG_BASE + 0x0088)
+#define MEM_MASK_BANK1     (RC32334_REG_BASE + 0x008c)
+#define MEM_CNTL_BANK1     (RC32334_REG_BASE + 0x0204)
+#define MEM_CNTL_BANK2     (RC32334_REG_BASE + 0x0208)
+#define MEM_CNTL_BANK3     (RC32334_REG_BASE + 0x020c)
+#define MEM_CNTL_BANK4     (RC32334_REG_BASE + 0x0210)
+#define MEM_CNTL_BANK5     (RC32334_REG_BASE + 0x0214)
+
+/* PCI Controller */
+#define PCI_INTR_PEND      (RC32334_REG_BASE + 0x05b0)
+#define PCI_INTR_MASK      (RC32334_REG_BASE + 0x05b4)
+#define PCI_INTR_CLEAR     (RC32334_REG_BASE + 0x05b8)
+#define CPU2PCI_INTR_PEND  (RC32334_REG_BASE + 0x05c0)
+#define CPU2PCI_INTR_MASK  (RC32334_REG_BASE + 0x05c4)
+#define CPU2PCI_INTR_CLEAR (RC32334_REG_BASE + 0x05c8)
+#define PCI2CPU_INTR_PEND  (RC32334_REG_BASE + 0x05d0)
+#define PCI2CPU_INTR_MASK  (RC32334_REG_BASE + 0x05d4)
+#define PCI2CPU_INTR_CLEAR (RC32334_REG_BASE + 0x05d8)
+#define PCI_MEM1_BASE      (RC32334_REG_BASE + 0x20b0)
+#define PCI_MEM2_BASE      (RC32334_REG_BASE + 0x20b8)
+#define PCI_MEM3_BASE      (RC32334_REG_BASE + 0x20c0)
+#define PCI_IO1_BASE       (RC32334_REG_BASE + 0x20c8)
+#define PCI_ARBITRATION    (RC32334_REG_BASE + 0x20e0)
+#define PCI_CPU_MEM1_BASE  (RC32334_REG_BASE + 0x20e8)
+#define PCI_CPU_IO_BASE    (RC32334_REG_BASE + 0x2100)
+#define PCI_CFG_CNTL	   (RC32334_REG_BASE + 0x2cf8)
+#define PCI_CFG_DATA	   (RC32334_REG_BASE + 0x2cfc)
+
+/* Timers */
+#define TIMER0_CNTL        (RC32334_REG_BASE + 0x0700)
+#define TIMER0_COUNT       (RC32334_REG_BASE + 0x0704)
+#define TIMER0_COMPARE     (RC32334_REG_BASE + 0x0708)
+#define TIMER_REG_OFFSET   0x10
+
+/* Programmable I/O */
+#define PIO_DATA0          (RC32334_REG_BASE + 0x0600)
+#define PIO_DATA1          (RC32334_REG_BASE + 0x0610)
+
+/*
+ * DMA
+ *
+ * NOTE: DMA_IO is a trick for non linear RC32300_IO_DMA stuff
+ *
+ * DMA0: 18001400
+ * DMA1: 18001440
+ * DMA2: 18001900
+ * DMA3: 18001940
+ * NB: dma number must be immediate value or variable.
+ *      It MUST NOT be a function since it would get called twice!
+ */
+#define DMA_IO(n)       (((n)>1?0x500:0)+((n)&1?0x40:0))
+ 
+#define RC32300_IO_DMA(n)       (RC32334_REG_BASE + 0x1400 + DMA_IO(n))
+#define RC32300_DMA_CONFREG(n)  RC32300_IO_DMA(n)
+#define RC32300_DMA_BASEREG(n)  (RC32300_IO_DMA(n)+0x4)
+
+#define RC32300_DMA_CURRREG(n)  (RC32300_IO_DMA(n)+0x8)
+#define RC32300_DMA_STATREG(n)  (RC32300_IO_DMA(n)+0x10)
+#define RC32300_DMA_SRCREG(n)   (RC32300_IO_DMA(n)+0x14)
+#define RC32300_DMA_DSTREG(n)   (RC32300_IO_DMA(n)+0x18)
+#define RC32300_DMA_NEXTREG(n)  (RC32300_IO_DMA(n)+0x1c)
+
+#define RC32300_DMA_IRQ(n)  (GROUP7_IRQ_BASE+5*(n))
+
+/* Expansion Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32334_REG_BASE + 0x0500)
+#define IC_GROUP0_MASK     (RC32334_REG_BASE + 0x0504)
+#define IC_GROUP0_CLEAR    (RC32334_REG_BASE + 0x0508)
+#define IC_GROUP_OFFSET    0x10
+
+#define NUM_INTR_GROUPS    15
+/*
+ * The IRQ mapping is as follows:
+ *
+ *    IRQ         Mapped To
+ *    ---     -------------------
+ *     0      SW0  (IP0) SW0 intr
+ *     1      SW1  (IP1) SW1 intr
+ *     2      Int0 (IP2) board-specific
+ *     3      Int1 (IP3) board-specific
+ *     4      Int2 (IP4) board-specific
+ *     -      Int3 (IP5) not used, mapped to IRQ's 8 and up
+ *     6      Int4 (IP6) board-specific
+ *     7      Int5 (IP7) CP0 Timer
+ *
+ * IRQ's 8 and up are all mapped to Int3 (IP5), which
+ * internally on the RC32334 is routed to the Expansion
+ * Interrupt Controller.
+ */
+#define MIPS_CPU_TIMER_IRQ 7
+
+#define GROUP1_IRQ_BASE  8                       // bus error
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 1)   // PIO active low
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 12)  // PIO active high
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 8)   // Timer Rollovers
+#define GROUP5_IRQ_BASE  (GROUP4_IRQ_BASE + 8)   // UART0
+#define GROUP6_IRQ_BASE  (GROUP5_IRQ_BASE + 3)   // UART1
+#define GROUP7_IRQ_BASE  (GROUP6_IRQ_BASE + 3)   // DMA Ch0
+#define GROUP8_IRQ_BASE  (GROUP7_IRQ_BASE + 5)   // DMA Ch1
+#define GROUP9_IRQ_BASE  (GROUP8_IRQ_BASE + 5)   // DMA Ch2
+#define GROUP10_IRQ_BASE (GROUP9_IRQ_BASE + 5)   // DMA Ch3
+#define GROUP11_IRQ_BASE (GROUP10_IRQ_BASE + 5)  // PCI Ctlr errors
+#define GROUP12_IRQ_BASE (GROUP11_IRQ_BASE + 4)  // PCI Satellite Mode
+#define GROUP13_IRQ_BASE (GROUP12_IRQ_BASE + 16) // PCI to CPU Mailbox
+#define GROUP14_IRQ_BASE (GROUP13_IRQ_BASE + 4)  // SPI
+
+#define RC32334_NR_IRQS  (GROUP14_IRQ_BASE + 1)
+
+/* 16550 UARTs */
+#ifdef __MIPSEB__
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0803)
+#define RC32300_UART1_BASE (RC32334_REG_BASE + 0x0823)
+#else
+#define RC32300_UART0_BASE (RC32334_REG_BASE + 0x0800)
+#define RC32300_UART1_BASE (RC32334_REG_BASE + 0x0820)
+#endif
+
+#define RC32300_UART0_IRQ  GROUP5_IRQ_BASE
+#define RC32300_UART1_IRQ  GROUP6_IRQ_BASE
+
+#define IDT_CLOCK_MULT 2
+
+/* NVRAM */
+#define NVRAM_BASE         0x12000000
+#define NVRAM_ENVSIZE_OFF  4
+#define NVRAM_ENVSTART_OFF 0x40
+
+/* LCD 4-digit display */
+#define LCD_CLEAR          0x14000400
+#define LCD_DIGIT0         0x1400000f
+#define LCD_DIGIT1         0x14000008
+#define LCD_DIGIT2         0x14000007
+#define LCD_DIGIT3         0x14000003
+
+/* Interrupts routed on 79S334A board (see rc32334.h) */
+#define RC32334_SCC8530_IRQ  2
+#define RC32334_PCI_INTA_IRQ 3
+#define RC32334_PCI_INTB_IRQ 4
+#define RC32334_PCI_INTC_IRQ 6
+#define RC32334_PCI_INTD_IRQ 7
+
+#define RAM_SIZE	(32*1024*1024)
+
+#endif // __IDT_RC32334_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355_dma.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355_dma.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355_dma.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,206 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     DMA controller defines on IDT RC32355
+ *
+ *  Copyright 2004 IDT Inc.
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com
+ *
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  May 2004 rkt
+ *  Initial Release
+ *
+ **************************************************************************
+ */
+
+#ifndef BANYAN_DMA_H
+#define BANYAN_DMA_H
+#include  <asm/idt-boards/rc32300/rc32300.h>
+
+/*
+ * An image of one RC32355 dma channel registers
+ */
+typedef struct {
+	u32 dmac;
+	u32 dmas;
+	u32 dmasm;
+	u32 dmadptr;
+	u32 dmandptr;
+} rc32355_dma_ch_t;
+
+/*
+ * An image of all RC32355 dma channel registers
+ */
+typedef struct {
+	rc32355_dma_ch_t ch[16];
+} rc32355_dma_regs_t;
+
+
+#define rc32355_dma_regs ((rc32355_dma_regs_t*)KSEG1ADDR(RC32355_DMA_BASE))
+
+
+/* DMAC register layout */
+
+#define DMAC_RUN	0x1	/* Halts processing when cleared	*/
+#define DMAC_DM		0x2	/* Done Mask, ignore DMA events		*/
+#define DMAC_MODE_MASK	0xC	/* DMA operating mode			*/
+
+#define DMAC_MODE_AUTO	0x0	/* DMA Auto Request Mode		*/
+#define DMAC_MODE_BURST	0x4	/* DMA Burst Request Mode		*/
+#define DMAC_MODE_TFER	0x8	/* DMA Transfer Request Mode		*/
+
+/* DMAS and DMASM register layout */
+
+#define DMAS_F		0x01	/* Finished */
+#define DMAS_D		0x02	/* Done */
+#define DMAS_C		0x04	/* Chain */
+#define DMAS_E		0x08	/* Error */
+#define DMAS_H		0x10	/* Halt */
+
+/* Polling count for DMAS_H bit in DMAS register after halting DMA */
+#define DMA_HALT_TIMEOUT 500
+
+
+static inline int rc32355_halt_dma(rc32355_dma_ch_t* ch)
+{
+	int timeout=1;
+	
+	if (local_readl(&ch->dmac) & DMAC_RUN) {
+		local_writel(0, &ch->dmac); 
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (local_readl(&ch->dmas) & DMAS_H) {
+				local_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+	}
+
+	return timeout ? 0 : 1;
+}
+
+static inline void rc32355_start_dma(rc32355_dma_ch_t* ch, u32 dma_addr)
+{
+	local_writel(0, &ch->dmandptr); 
+	local_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32355_chain_dma(rc32355_dma_ch_t* ch, u32 dma_addr)
+{
+	local_writel(dma_addr, &ch->dmandptr);
+}
+
+
+/* The following can be used to describe DMA channels 0 to 15, and the	*/
+/* sub device's needed to select them in the DMADESC_DS_MASK field	*/
+
+#define DMA_CHAN_ATM01		0	     /* ATM interface 0,1 chan	*/
+
+#define DMA_CHAN_ATM0IN		0	     /* ATM interface 0 input	*/
+#define DMA_DEV_ATM0IN		0	     /* ATM interface 0 input	*/
+
+#define DMA_CHAN_ATM1IN		0	     /* ATM interface 1 input	*/
+#define DMA_DEV_ATM1IN		1	     /* ATM interface 1 input	*/
+
+#define DMA_CHAN_ATM0OUT	0	     /* ATM interface 0 output	*/
+#define DMA_DEV_ATM0OUT		2	     /* ATM interface 0 output	*/
+
+#define DMA_CHAN_ATM1OUT	0	     /* ATM interface 1 output	*/
+#define DMA_DEV_ATM1OUT		3	     /* ATM interface 1 output	*/
+
+/* for entry in {0,1,2,3,4,5,6,7} - note 5,6,7 share with those below */
+#define DMA_CHAN_ATMVCC(entry)	((entry)+1)  /* ATM VC cache entry 	*/
+#define DMA_DEV_ATMVCC(entry)	0
+
+#define DMA_CHAN_MEMTOMEM	6	     /* Memory to memory DMA 	*/
+#define DMA_DEV_MEMTOMEM	1	     /* Memory to memory DMA 	*/
+
+#define DMA_CHAN_ATMFMB0	7	     /* ATM Frame Mode Buffer 0	*/
+#define DMA_DEV_ATMFMB0		1	     /* ATM Frame Mode Buffer 0	*/
+
+#define DMA_CHAN_ATMFMB1	8	     /* ATM Frame Mode Buffer 1	*/
+#define DMA_DEV_ATMFMB1		1	     /* ATM Frame Mode Buffer 1	*/
+
+#define DMA_CHAN_ETHERIN	9	     /* Ethernet input		*/
+#define DMA_DEV_ETHERIN		0	     /* Ethernet input		*/
+
+#define DMA_CHAN_ETHEROUT	10	     /* Ethernet output		*/
+#define DMA_DEV_ETHEROUT	0	     /* Ethernet output		*/
+
+#define DMA_CHAN_TDMIN		11	     /* TDM Bus input		*/
+#define DMA_DEV_TDMIN		0	     /* TDM Bus input		*/
+
+#define DMA_CHAN_TDMOUT		12	     /* TDM Bus output		*/
+#define DMA_DEV_TDMOUT		0	     /* TDM Bus output		*/
+
+#define DMA_CHAN_USBIN		13	     /* USB input		*/
+#define DMA_DEV_USBIN		0	     /* USB input		*/
+
+#define DMA_CHAN_USBOUT		14	     /* USB output		*/
+#define DMA_DEV_USBOUT		0	     /* USB output		*/
+
+#define DMA_CHAN_EXTERN		15	     /* External DMA		*/
+#define DMA_DEV_EXTERN		0	     /* External DMA		*/
+
+/*
+ * An RC32355 dma descriptor in system memory
+ */
+typedef struct {
+	u32 cmdstat;	/* control and status */
+	u32 curr_addr;	/* current address of data */
+	u32 devcs;	/* peripheral-specific control and status */
+	u32 link;	/* link to next descriptor */
+} rc32355_dma_desc_t;
+
+/* Values for the descriptor cmdstat word */
+
+#define DMADESC_F		0x80000000u  /* Finished bit		*/
+#define DMADESC_D		0x40000000u  /* Done bit		*/
+#define DMADESC_T		0x20000000u  /* Terminated bit		*/
+#define DMADESC_IOD		0x10000000u  /* Interrupt On Done	*/
+#define DMADESC_IOF		0x08000000u  /* Interrupt On Finished	*/
+#define DMADESC_COD		0x04000000u  /* Chain On Done		*/
+#define DMADESC_COF		0x02000000u  /* Chain On Finished	*/
+
+#define DMADESC_DEVCMD_MASK	0x01C00000u  /* Device Command mask	*/
+#define DMADESC_DEVCMD_SHIFT	22	     /* Device Command shift	*/
+
+#define DMADESC_DS_MASK		0x00300000u  /* Device Select mask	*/
+#define DMADESC_DS_SHIFT	20	     /* Device Select shift	*/
+
+#define DMADESC_COUNT_MASK	0x0003FFFFu  /* Byte Count mask		*/
+#define DMADESC_COUNT_SHIFT	0	     /* Byte Count shift	*/
+
+#define IS_DMA_FINISHED(X)   ( ( (X) & DMADESC_F ) >> 31)   /* F Bit    */
+#define IS_DMA_DONE(X)       ( ( (X) & DMADESC_D ) >> 30)   /* D Bit    */
+#define IS_DMA_TERMINATED(X) ( ( (X) & DMADESC_T ) >> 29)   /* T Bit    */
+#define IS_DMA_USED(X) (((X) & (DMADESC_F | DMADESC_D | DMADESC_T)) != 0)
+
+#define DMA_DEVCMD(devcmd) \
+  (((devcmd) << DMADESC_DEVCMD_SHIFT) & DMADESC_DS_MASK)
+#define DMA_DS(ds)         \
+  (((ds) << DMADESC_DS_SHIFT) & DMADESC_DS_MASK)
+#define DMA_COUNT(count)   \
+  ((count) & DMADESC_COUNT_MASK)
+
+#endif /* RC32355_DMA_H */
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355_eth.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355_eth.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355_eth.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,442 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Ethernet registers on IDT RC32355
+ *
+ *  Copyright 2004 IDT Inc.
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com
+ *
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  May 2004 rkt
+ *  Initial Release
+ *
+ **************************************************************************
+ */
+
+
+#ifndef RC32355_ETHER_H
+#define RC32355_ETHER_H
+
+#include <asm/idt-boards/rc32300/rc32355_dma.h>
+
+/*
+ * A partial image of the RC32355 ethernet registers
+ */
+typedef struct {
+	u32 ethintfc;
+	u32 ethfifott;
+	u32 etharc;
+	u32 ethhash0;
+	u32 ethhash1;
+	u32 ethfifost;
+	u32 ethfifos;
+	u32 ethodeops;
+	u32 ethis;
+	u32 ethos;
+	u32 ethmcp;
+	u32 _u1;
+	u32 ethid;
+	u32 _u2;
+	u32 _u3;
+	u32 _u4;
+	u32 ethod;
+	u32 _u5;
+	u32 _u6;
+	u32 _u7;
+	u32 ethodeop;
+	u32 _u8[43]; 
+	u32 ethsal0;
+	u32 ethsah0;
+	u32 ethsal1;
+	u32 ethsah1;
+	u32 ethsal2;
+	u32 ethsah2;
+	u32 ethsal3;
+	u32 ethsah3;
+	u32 ethrbc;
+	u32 ethrpc;
+	u32 ethrupc;
+	u32 ethrfc;
+	u32 ethtbc;
+	u32 ethgpf;
+	u32 _u9[50];
+	u32 ethmac1;
+	u32 ethmac2;
+	u32 ethipgt;
+	u32 ethipgr;
+	u32 ethclrt;
+	u32 ethmaxf;
+	u32 _u10;
+	u32 ethmtest;
+	u32 miimcfg;
+	u32 miimcmd;
+	u32 miimaddr;
+	u32 miimwtd;
+	u32 miimrdd;
+	u32 miimind;
+	u32 _u11;
+	u32 _u12;
+	u32 ethcfsa0;
+	u32 ethcfsa1;
+	u32 ethcfsa2;
+} rc32355_eth_regs_t;
+ 
+#define rc32355_eth_regs ((rc32355_eth_regs_t*)KSEG1ADDR(RC32355_ETH_BASE))
+
+#define ETH_INTFC   (RC32355_ETH_BASE + 0x000) /* INTerFace Control  */
+#define ETH_FIFOTT  (RC32355_ETH_BASE + 0x004) /* FIFO Transmit Threshold  */
+#define ETH_ARC     (RC32355_ETH_BASE + 0x008) /* Address Recognition Ctrl  */
+#define ETH_HASH0   (RC32355_ETH_BASE + 0x00C) /* 32 multicast Hash bits */
+#define ETH_HASH1   (RC32355_ETH_BASE + 0x010) /* another 32 Hash bits */
+#define ETH_FIFOST  (RC32355_ETH_BASE + 0x014) /* FIFO Status Threshold */
+#define ETH_FIFOS   (RC32355_ETH_BASE + 0x018) /* FIFO Status Register */
+#define ETH_ODEOPS  (RC32355_ETH_BASE + 0x01C) /* Out Data End-Of-Pkt Size */
+#define ETH_IS      (RC32355_ETH_BASE + 0x020) /* Input Status */
+#define ETH_OS      (RC32355_ETH_BASE + 0x024) /* Output Status  */
+#define ETH_MCP     (RC32355_ETH_BASE + 0x028) /* Managemt Clock Prescaler */
+#define ETH_ID      (RC32355_ETH_BASE + 0x030) /* Input Data register */
+#define ETH_OD      (RC32355_ETH_BASE + 0x040) /* Output Data register */
+#define ETH_ODEOP   (RC32355_ETH_BASE + 0x050) /* OD End-Of-Packet Size */
+
+/* for n in { 0, 1, 2, 3 } */
+#define ETH_SAL(n)  (RC32355_ETH_BASE + 0x100 + (n * 8)) /* Stn Address 2-5 */
+#define ETH_SAH(n)  (RC32355_ETH_BASE + 0x104 + (n * 8)) /* Stn Address 0-1 */
+
+#define ETH_RBC     (RC32355_ETH_BASE + 0x120) /* Receive Byte Count */
+#define ETH_RPC     (RC32355_ETH_BASE + 0x124) /* Receive Packet Count */
+#define ETH_RUPC    (RC32355_ETH_BASE + 0x128) /* Rx Undersized Pkt count */
+#define ETH_RFC     (RC32355_ETH_BASE + 0x12C) /* Receive Fragment Count */
+#define ETH_TBC     (RC32355_ETH_BASE + 0x130) /* Transmit Byte Count */
+#define ETH_GPF     (RC32355_ETH_BASE + 0x134) /* Generate Pause Frame */
+#define ETH_MAC1    (RC32355_ETH_BASE + 0x200) /* Medium Access Control 1 */
+#define ETH_MAC2    (RC32355_ETH_BASE + 0x204) /* Medium Access Control 2 */
+#define ETH_IPGT    (RC32355_ETH_BASE + 0x208) /* Back-to-back InterPkt Gap */
+#define ETH_IPGR    (RC32355_ETH_BASE + 0x20C) /* Non " InterPkt Gap */
+#define ETH_CLRT    (RC32355_ETH_BASE + 0x210) /* Collis'n Window and Retry */
+#define ETH_MAXF    (RC32355_ETH_BASE + 0x214) /* Maximum Frame Length */
+#define ETH_MTEST   (RC32355_ETH_BASE + 0x21C) /* MAC Test */
+
+#define ETHMIIM_CFG (RC32355_ETH_BASE + 0x220) /* MII Mgmt Configuration */
+#define ETHMIIM_CMD (RC32355_ETH_BASE + 0x224) /* MII Mgmt Command  */
+#define ETHMIIM_ADDR (RC32355_ETH_BASE + 0x228) /* MII Mgmt Address */
+#define ETHMIIM_WTD (RC32355_ETH_BASE + 0x22C) /* MII Mgmt Write Data */
+#define ETHMIIM_RDD (RC32355_ETH_BASE + 0x230) /* MII Mgmt Read Data */
+#define ETHMIIM_IND (RC32355_ETH_BASE + 0x234) /* MII Mgmt Indicators */
+
+/* for n in { 0, 1, 2 } */
+#define ETH_CFSA(n) (RC32355_ETH_BASE + 0x240 + ((n) * 4))  /* Station Addr */
+
+
+/*
+ * Register Interpretations follow
+ */
+
+/******************************************************************************
+ * ETHINTFC register
+ *****************************************************************************/
+
+#define ETHERINTFC_EN            (1<<0)
+#define ETHERINTFC_ITS           (1<<1)
+#define ETHERINTFC_RES           (1<<2)
+#define ETHERINTFC_RIP           (1<<2)
+#define ETHERINTFC_JAM           (1<<3)
+
+/******************************************************************************
+ * ETHFIFOTT register
+ *****************************************************************************/
+
+#define ETHERFIFOTT_TTH(v)      (((v)&0x3f)<<0)
+
+/******************************************************************************
+ * ETHARC register
+ *****************************************************************************/
+
+#define ETHERARC_PRO             (1<<0)
+#define ETHERARC_AM              (1<<1)
+#define ETHERARC_AFM             (1<<2)
+#define ETHERARC_AB              (1<<3)
+
+/******************************************************************************
+ * ETHHASH registers
+ *****************************************************************************/
+
+#define ETHERHASH0(v)            (((v)&0xffff)<<0)
+#define ETHERHASH1(v)            (((v)&0xffff)<<0)
+
+/******************************************************************************
+ * ETHSA registers
+ *****************************************************************************/
+
+#define ETHERSAL0(v)             (((v)&0xffff)<<0)
+#define ETHERSAL1(v)             (((v)&0xffff)<<0)
+#define ETHERSAL2(v)             (((v)&0xffff)<<0)
+#define ETHERSAL3(v)             (((v)&0xffff)<<0)
+#define ETHERSAH0(v)             (((v)&0xff)<<0)
+#define ETHERSAH1(v)             (((v)&0xff)<<0)
+#define ETHERSAH2(v)             (((v)&0xff)<<0)
+#define ETHERSAH3(v)             (((v)&0xff)<<0)
+
+/******************************************************************************
+ * ETHFIFOST register
+ *****************************************************************************/
+
+#define ETHERFIFOST_IRTH(v)      (((v)&0x3f)<<0)
+#define ETHERFIFOST_ORTH(v)      (((v)&0x3f)<<16)
+
+/******************************************************************************
+ * ETHFIFOS register
+ *****************************************************************************/
+
+#define ETHERFIFOS_IR            (1<<0)
+#define ETHERFIFOS_OR            (1<<1)  
+#define ETHERFIFOS_OVR           (1<<2)  
+#define ETHERFIFOS_UND           (1<<3)  
+
+/******************************************************************************
+ * DATA registers
+ *****************************************************************************/
+
+#define ETHERID(v)               (((v)&0xffff)<<0)
+#define ETHEROD(v)               (((v)&0xffff)<<0)
+
+/******************************************************************************
+ * ETHODEOPS register
+ *****************************************************************************/
+
+#define ETHERODEOPS_SIZE(v)      (((v)&0x3)<<0)
+
+/******************************************************************************
+ * ETHODEOP register
+ *****************************************************************************/
+
+#define ETHERODEOP(v)            (((v)&0xffff)<<0)
+
+/******************************************************************************
+ * ETHIS register
+ *****************************************************************************/
+
+#define ETHERIS_EOP              (1<<0)  
+#define ETHERIS_ROK              (1<<2)  
+#define ETHERIS_FM               (1<<3)  
+#define ETHERIS_MP               (1<<4)  
+#define ETHERIS_BP               (1<<5)  
+#define ETHERIS_VLT              (1<<6)  
+#define ETHERIS_CF               (1<<7)  
+#define ETHERIS_OVR              (1<<8)  
+#define ETHERIS_CRC              (1<<9)  
+#define ETHERIS_CV               (1<<10)  
+#define ETHERIS_DB               (1<<11)  
+#define ETHERIS_LE               (1<<12)  
+#define ETHERIS_LOR              (1<<13)  
+#define ETHERIS_SIZE(v)          (((v)&0x3)<<14)
+#define ETHERIS_LENGTH(v)        (((v)&0xff)<<16)
+
+/******************************************************************************
+ * ETHOS register
+ *****************************************************************************/
+
+#define ETHEROS_T                (1<<0)  
+#define ETHEROS_TOK              (1<<6)  
+#define ETHEROS_MP               (1<<7)  
+#define ETHEROS_BP               (1<<8)  
+#define ETHEROS_UND              (1<<9)  
+#define ETHEROS_OF               (1<<10)  
+#define ETHEROS_ED               (1<<11)  
+#define ETHEROS_EC               (1<<12)  
+#define ETHEROS_LC               (1<<13)  
+#define ETHEROS_TD               (1<<14)  
+#define ETHEROS_CRC              (1<<15)  
+#define ETHEROS_LE               (1<<16)  
+#define ETHEROS_CC(v)            (((v)&0xf)<<17)
+#define ETHEROS_PFD              (1<<21)  
+
+/******************************************************************************
+ * Statistics registers
+ *****************************************************************************/
+
+#define ETHERRBC(v)              (((v)&0xffff)<<0)
+#define ETHERRPC(v)              (((v)&0xffff)<<0)
+#define ETHERRUPC(v)             (((v)&0xffff)<<0)
+#define ETHERRFC(v)              (((v)&0xffff)<<0)
+#define ETHERTBC(v)              (((v)&0xffff)<<0)
+
+/******************************************************************************
+ * ETHGPF register
+ *****************************************************************************/
+
+#define ETHERGPF_PTV(v)          (((v)&0xff)<<0)
+
+/******************************************************************************
+ * MAC registers
+ *****************************************************************************/
+//ETHMAC1
+#define ETHERMAC1_RE             (1<<0)
+#define ETHERMAC1_PAF            (1<<1)
+#define ETHERMAC1_RFC            (1<<2)
+#define ETHERMAC1_TFC            (1<<3)
+#define ETHERMAC1_LB             (1<<4)
+#define ETHERMAC1_MR             (1<<15)
+
+//ETHMAC2
+#define ETHERMAC2_FD             (1<<0)
+#define ETHERMAC2_FLC            (1<<1)
+#define ETHERMAC2_HFE            (1<<2)
+#define ETHERMAC2_DC             (1<<3)
+#define ETHERMAC2_CEN            (1<<4)
+#define ETHERMAC2_PE             (1<<5)
+#define ETHERMAC2_VPE            (1<<6)
+#define ETHERMAC2_APE            (1<<7)
+#define ETHERMAC2_PPE            (1<<8)
+#define ETHERMAC2_LPE            (1<<9)
+#define ETHERMAC2_NB             (1<<12)
+#define ETHERMAC2_BP             (1<<13)
+#define ETHERMAC2_ED             (1<<14)
+
+//ETHIPGT
+#define ETHERIPGT(v)             (((v)&0x3f)<<0)
+
+//ETHIPGR
+#define ETHERIPGR_IPGR1(v)       (((v)&0x3f)<<0)
+#define ETHERIPGR_IPGR2(v)       (((v)&0x3f)<<8)
+
+//ETHCLRT
+#define ETHERCLRT_MAXRET(v)      (((v)&0x3f)<<0)
+#define ETHERCLRT_COLWIN(v)      (((v)&0x3f)<<8)
+
+//ETHMAXF
+#define ETHERMAXF(v)             (((v)&0x3f)<<0)
+
+//ETHMTEST
+#define ETHERMTEST_TB            (1<<2)
+
+//ETHMCP
+#define ETHERMCP_DIV(v)          (((v)&0xff)<<0)
+
+//MIIMCFG
+#define ETHERMIIMCFG_CS(v)          (((v)&0x3)<<2)
+#define ETHERMIIMCFG_R              (1<<15)
+
+//MIIMCMD
+#define ETHERMIIMCMD_RD             (1<<0)
+#define ETHERMIIMCMD_SCN            (1<<1)
+
+//MIIMADDR
+#define ETHERMIIMADDR_REGADDR(v)    (((v)&0x1f)<<0)
+#define ETHERMIIMADDR_PHYADDR(v)    (((v)&0x1f)<<8)
+
+//MIIMWTD
+#define ETHERMIIMWTD(v)             (((v)&0xff)<<0)
+
+//MIIMRDD
+#define ETHERMIIMRDD(v)             (((v)&0xff)<<0)
+
+//MIIMIND
+#define ETHERMIIMIND_BSY            (1<<0)
+#define ETHERMIIMIND_SCN            (1<<1)
+#define ETHERMIIMIND_NV             (1<<2)
+
+//DMA DEVCS IN
+#define ETHERDMA_IN_LENGTH(v)	(((v)&0xffff)<<16)
+#define ETHERDMA_IN_CES		(1<<14)
+#define ETHERDMA_IN_LOR		(1<<13)
+#define ETHERDMA_IN_LE		(1<<12)
+#define ETHERDMA_IN_DB		(1<<11)
+#define ETHERDMA_IN_CV		(1<<10)
+#define ETHERDMA_IN_CRC		(1<<9)
+#define ETHERDMA_IN_OVR		(1<<8)
+#define ETHERDMA_IN_CF		(1<<7)
+#define ETHERDMA_IN_VLT		(1<<6)
+#define ETHERDMA_IN_BP		(1<<5)
+#define ETHERDMA_IN_MP		(1<<4)
+#define ETHERDMA_IN_FM		(1<<3)
+#define ETHERDMA_IN_ROK		(1<<2)
+#define ETHERDMA_IN_LD		(1<<1)
+#define ETHERDMA_IN_FD		(1<<0)
+
+//DMA DEVCS OUT
+#define ETHERDMA_OUT_CC(v)	(((v)&0xf)<<17)
+#define ETHERDMA_OUT_CNT         0x001e0000
+#define ETHERDMA_OUT_SHFT       17
+#define ETHERDMA_OUT_LE		(1<<16)
+
+#define ETHERDMA_OUT_CRC	(1<<15)
+#define ETHERDMA_OUT_TD		(1<<14)
+#define ETHERDMA_OUT_LC		(1<<13)
+#define ETHERDMA_OUT_EC		(1<<12)
+#define ETHERDMA_OUT_ED		(1<<11)
+#define ETHERDMA_OUT_OF		(1<<10)
+#define ETHERDMA_OUT_UND	(1<<9)
+#define ETHERDMA_OUT_BP		(1<<8)
+#define ETHERDMA_OUT_MP		(1<<7)
+#define ETHERDMA_OUT_TOK	(1<<6)
+#define ETHERDMA_OUT_HEN	(1<<5)
+#define ETHERDMA_OUT_CEN	(1<<4)
+#define ETHERDMA_OUT_PEN	(1<<3)
+#define ETHERDMA_OUT_OEN	(1<<2)
+#define ETHERDMA_OUT_LD		(1<<1)
+#define ETHERDMA_OUT_FD		(1<<0)
+
+#define RCV_ERRS \
+  (ETHERDMA_IN_OVR | ETHERDMA_IN_CRC | ETHERDMA_IN_CV | ETHERDMA_IN_LE)
+#define TX_ERRS  \
+  (ETHERDMA_OUT_LC | ETHERDMA_OUT_EC | ETHERDMA_OUT_ED | \
+   ETHERDMA_OUT_OF | ETHERDMA_OUT_UND)
+
+#define IS_RCV_ROK(X)        (((X) & (1<<2)) >> 2)       /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<3)) >> 3)       /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<4)) >> 4)       /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<5)) >> 5)       /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<6)) >> 6)       /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<7)) >> 7)       /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<8)) >> 8)       /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<9)) >> 9)       /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<10))>>10)       /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<11))>>11)       /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<12))>>12)       /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<13))>>13)       /* Length Out of
+                                                            Range            */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<14))>>14)       /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & 0xFFFF0000)>>16)    /* Length of the
+                                                            received packet  */
+
+#define IS_TX_TOK(X)         (((X) & (1<<6) ) >> 6 )     /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<7) ) >> 7 )     /* Multicast        */
+
+#define IS_TX_BP(X)          (((X) & (1<<8) ) >> 8 )     /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<9) ) >> 9 )     /* Transmit FIFO
+                                                            Underflow        */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<10)) >>10 )     /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<11)) >>11 )     /* Excessive
+							    deferral        */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<12)) >>12 )     /* Excessive
+							    collisions      */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<13)) >>13 )     /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<14)) >>14 )     /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<15)) >>15 )     /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<16)) >>16 )     /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & 0x001E0000u)>>17)  /* Collision Count  */
+
+#endif /* RC32355_ETHER_H */
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32355.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32355.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,177 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     Definitions for IDT RC32355 CPU.
+ *
+ *  Copyright 2004 IDT Inc.
+ *  Author: Integrated Device Technology Inc. rischelp@idt.com
+ *
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  May 2004 rkt
+ *  Initial Release
+ *
+ **************************************************************************
+ */
+
+
+#ifndef _RC32355_H_
+#define _RC32355_H_
+
+#include <linux/delay.h>
+#include <asm/io.h>
+
+/* Base address of internal registers */
+#define RC32355_REG_BASE   0x18000000
+
+/* System ID Registers */
+#define CPU_SYSID          (RC32355_REG_BASE + 0x00018)
+#define CPU_BTADDR         (RC32355_REG_BASE + 0x0001c)
+#define CPU_REV            (RC32355_REG_BASE + 0x0002c)
+
+/* Reset Controller */
+#define RESET_CNTL         (RC32355_REG_BASE + 0x08000)
+
+/* Device Controller */
+#define DEV0_BASE          (RC32355_REG_BASE + 0x10000)
+#define DEV0_MASK          (RC32355_REG_BASE + 0x10004)
+#define DEV0_CNTL          (RC32355_REG_BASE + 0x10008)
+#define DEV0_TIMING        (RC32355_REG_BASE + 0x1000c)
+#define DEV_REG_OFFSET     0x10
+
+/* SDRAM Controller */
+#define SDRAM0_BASE        (RC32355_REG_BASE + 0x18000)
+#define SDRAM0_MASK        (RC32355_REG_BASE + 0x18004)
+#define SDRAM1_BASE        (RC32355_REG_BASE + 0x18008)
+#define SDRAM1_MASK        (RC32355_REG_BASE + 0x1800c)
+#define SDRAM_CNTL         (RC32355_REG_BASE + 0x18010)
+
+/* Bus Arbiter */
+#define BUS_ARB_CNTL0      (RC32355_REG_BASE + 0x20000)
+#define BUS_ARB_CNTL1      (RC32355_REG_BASE + 0x20004)
+
+/* Counters/Timers */
+#define TIMER0_COUNT       (RC32355_REG_BASE + 0x28000)
+#define TIMER0_COMPARE     (RC32355_REG_BASE + 0x28004)
+#define TIMER0_CNTL        (RC32355_REG_BASE + 0x28008)
+#define TIMER_REG_OFFSET   0x0C
+
+/* System Integrity */
+
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32355_REG_BASE + 0x30000)
+#define IC_GROUP0_MASK     (RC32355_REG_BASE + 0x30004)
+#define IC_GROUP_OFFSET    0x08
+
+#define NUM_INTR_GROUPS    5
+/*
+ * The IRQ mapping is as follows:
+ *
+ *    IRQ         Mapped To
+ *    ---     -------------------
+ *     0      SW0  (IP0) SW0 intr
+ *     1      SW1  (IP1) SW1 intr
+ *     -      Int0 (IP2) mapped to GROUP0_IRQ_BASE
+ *     -      Int1 (IP3) mapped to GROUP1_IRQ_BASE
+ *     -      Int2 (IP4) mapped to GROUP2_IRQ_BASE
+ *     -      Int3 (IP5) mapped to GROUP3_IRQ_BASE
+ *     -      Int4 (IP6) mapped to GROUP4_IRQ_BASE
+ *     7      Int5 (IP7) CP0 Timer
+ *
+ * IRQ's 8 and up are all mapped to Int0-4 (IP2-IP6), which
+ * internally on the RC32355 is routed to the Expansion
+ * Interrupt Controller.
+ */
+#define MIPS_CPU_TIMER_IRQ 7
+
+#define GROUP0_IRQ_BASE  8                      // Counter/Timers, UCW
+#define GROUP1_IRQ_BASE  (GROUP0_IRQ_BASE + 32) // DMA
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 32) // ATM
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 32) // TDM, Eth, USB, UARTs, I2C
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 32) // GPIO
+
+#define RC32355_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+/* DMA - see rc32355_dma.h for full list of registers */
+
+#define RC32355_DMA_BASE (RC32355_REG_BASE + 0x38000)
+#define DMA_CHAN_OFFSET  0x14
+
+/* GPIO Controller */
+
+/* TDM Bus */
+
+/* 16550 UARTs */
+#ifdef __MIPSEB__
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50003)
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50023)
+#else
+#define RC32300_UART0_BASE (RC32355_REG_BASE + 0x50000)
+#define RC32300_UART1_BASE (RC32355_REG_BASE + 0x50020)
+#endif
+
+#define RC32300_UART0_IRQ  (GROUP3_IRQ_BASE + 14)
+#define RC32300_UART1_IRQ  (GROUP3_IRQ_BASE + 17)
+
+/* ATM */
+
+/* Ethernet - see rc32355_eth.h for full list of registers */
+
+#define RC32355_ETH_BASE   (RC32355_REG_BASE + 0x60000)
+
+
+#define IDT_CLOCK_MULT 2
+
+/* Memory map of 79EB355 board */
+
+/* DRAM */
+#define RAM_BASE        0x00000000
+#define RAM_SIZE	(32*1024*1024)
+
+/* SRAM (device 1) */
+#define SRAM_BASE       0x02000000
+#define SRAM_SIZE       0x00100000
+
+/* FLASH (device 2) */
+#define FLASH_BASE      0x0C000000
+#define FLASH_SIZE      0x00C00000
+
+/* ATM PHY (device 4) */
+#define ATM_PHY_BASE    0x14000000
+
+/* TDM switch (device 3) */
+#define TDM_BASE        0x1A000000
+
+/* LCD panel (device 3) */
+#define LCD_BASE        0x1A002000
+
+/* RTC (DS1511W) (device 3) */
+#define RTC_BASE        0x1A004000
+
+/* NVRAM (256 bytes internal to the DS1511 RTC) */
+#define NVRAM_ADDR      RTC_BASE + 0x10
+#define NVRAM_DATA      RTC_BASE + 0x13
+#define NVRAM_ENVSIZE_OFF  4
+#define NVRAM_ENVSTART_OFF 32
+
+#endif /* _RC32355_H_ */
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_dma.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_dma.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_dma.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,226 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32365/336 DMA hardware abstraction.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_DMA_H__
+#define __IDT_RC32365_DMA_H__
+
+enum
+{
+	DMA0_PhysicalAddress	= 0x18038000,
+	DMA_PhysicalAddress	= DMA0_PhysicalAddress,		// Default
+
+	DMA0_VirtualAddress	= 0xb8038000,
+	DMA_VirtualAddress	= DMA0_VirtualAddress,		// Default
+} ;
+
+/*
+ * DMA descriptor (in physical memory).
+ */
+
+typedef struct DMAD_s
+{
+	u32			control ;	// Control. use DMAD_*
+	u32			ca ;		// Current Address.
+	u32			devcs ; 	// Device control and status.
+	u32			link ;		// Next descriptor in chain.
+} volatile *DMAD_t ;
+
+enum
+{
+	DMAD_size		= sizeof (struct DMAD_s),
+	DMAD_count_b		= 0,		// in DMAD_t -> control
+	DMAD_count_m		= 0x0003ffff,	// in DMAD_t -> control
+	DMAD_ds_b		= 20,		// in DMAD_t -> control
+	DMAD_ds_m		= 0x00300000,	// in DMAD_t -> control
+	DMAD_ds_extToMem0_v	= 0,
+	DMAD_ds_memToExt0_v	= 1,
+	DMAD_ds_extToMem1_v	= 0,
+	DMAD_ds_memToExt1_v	= 1,
+	DMAD_ds_ethRcv0_v	= 0,
+	DMAD_ds_ethXmt0_v	= 0,
+	DMAD_ds_ethRcv1_v	= 0,
+	DMAD_ds_ethXmt2_v	= 0,
+	DMAD_ds_memToFifo_v	= 0,
+	DMAD_ds_fifoToMem_v	= 0,
+	DMAD_ds_rng_de_v	   = 1,//randomNumberGenerator on LC/DE
+	DMAD_ds_pciToMem_v	= 0,
+	DMAD_ds_memToPci_v	= 0,
+	DMAD_ds_securityInput_v = 0,
+	DMAD_ds_securityOutput_v = 0,
+	DMAD_ds_rng_se_v	= 0,//randomNumberGenerator on SE
+	
+	DMAD_devcmd_b		= 22,		// in DMAD_t -> control
+	DMAD_devcmd_m		= 0x01c00000,	// in DMAD_t -> control
+	DMAD_devcmd_byte_v	= 0,	//memory-to-memory
+	DMAD_devcmd_halfword_v	= 1,	//memory-to-memory
+	DMAD_devcmd_word_v	= 2,	//memory-to-memory
+	DMAD_devcmd_2words_v	= 3,	//memory-to-memory
+	DMAD_devcmd_4words_v	= 4,	//memory-to-memory
+	DMAD_devcmd_6words_v	= 5,	//memory-to-memory
+	DMAD_devcmd_8words_v	= 6,	//memory-to-memory
+	DMAD_devcmd_16words_v	= 7,	//memory-to-memory
+	DMAD_cof_b		= 25,		// chain on finished
+	DMAD_cof_m		= 0x02000000,	// 
+	DMAD_cod_b		= 26,		// chain on done
+	DMAD_cod_m		= 0x04000000,	// 
+	DMAD_iof_b		= 27,		// interrupt on finished
+	DMAD_iof_m		= 0x08000000,	// 
+	DMAD_iod_b		= 28,		// interrupt on done
+	DMAD_iod_m		= 0x10000000,	// 
+	DMAD_t_b		= 29,		// terminated
+	DMAD_t_m		= 0x20000000,	// 
+	DMAD_d_b		= 30,		// done
+	DMAD_d_m		= 0x40000000,	// 
+	DMAD_f_b		= 31,		// finished
+	DMAD_f_m		= 0x80000000,	// 
+} ;
+
+/*
+ * DMA register (within Internal Register Map).
+ */
+
+struct DMA_Chan_s
+{
+	u32		dmac ;		// Control.
+	u32		dmas ;		// Status.	
+	u32		dmasm ; 	// Mask.
+	u32		dmadptr ;	// Descriptor pointer.
+	u32		dmandptr ;	// Next descriptor pointer.
+};
+
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;
+
+//DMA_Channels	  use DMACH_count instead
+
+enum
+{
+	DMAC_run_b	= 0,		// 
+	DMAC_run_m	= 0x00000001,	// 
+	DMAC_dm_b	= 1,		// done mask
+	DMAC_dm_m	= 0x00000002,	// 
+	DMAC_mode_b	= 2,		// 
+	DMAC_mode_m	= 0x0000000c,	// 
+	DMAC_mode_auto_v	= 0,
+	DMAC_mode_burst_v	= 1,
+	DMAC_mode_transfer_v	= 2, //usually used
+	DMAC_mode_reserved_v	= 3,
+	DMAC_a_b	= 4,		// 
+	DMAC_a_m	= 0x00000010,	// 
+	
+	DMAS_f_b	= 0,		// finished (sticky) 
+	DMAS_f_m	= 0x00000001,	//		     
+	DMAS_d_b	= 1,		// done (sticky)     
+	DMAS_d_m	= 0x00000002,	//		     
+	DMAS_c_b	= 2,		// chain (sticky)    
+	DMAS_c_m	= 0x00000004,	//		     
+	DMAS_e_b	= 3,		// error (sticky)    
+	DMAS_e_m	= 0x00000008,	//		     
+	DMAS_h_b	= 4,		// halt (sticky)     
+	DMAS_h_m	= 0x00000010,	//		     
+
+	DMASM_f_b	= 0,		// finished (1=mask)
+	DMASM_f_m	= 0x00000001,	// 
+	DMASM_d_b	= 1,		// done (1=mask)
+	DMASM_d_m	= 0x00000002,	// 
+	DMASM_c_b	= 2,		// chain (1=mask)
+	DMASM_c_m	= 0x00000004,	// 
+	DMASM_e_b	= 3,		// error (1=mask)
+	DMASM_e_m	= 0x00000008,	// 
+	DMASM_h_b	= 4,		// halt (1=mask)
+	DMASM_h_m	= 0x00000010,	// 
+} ;
+
+/*
+ * DMA channel definitions
+ */
+
+enum
+{
+	DMACH_ethRcv0 = 0,
+	DMACH_ethXmt0 = 1,
+	DMACH_ethRcv1 = 2,
+	DMACH_ethXmt2 = 3,
+	DMACH_pciToMem = 4,
+	DMACH_memToPci = 5,
+	DMACH_securityInput = 6,
+	DMACH_securityOutput = 7,
+	DMACH_rng = 8, 
+	
+	DMACH_count //must be last
+};
+
+
+typedef struct DMAC_s
+{
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]
+} volatile *DMA_t ;
+
+
+/*
+ * External DMA parameters
+*/
+
+enum
+{
+	DMADEVCMD_ts_b	= 0,		// ts field in devcmd
+	DMADEVCMD_ts_m	= 0x00000007,	// ts field in devcmd
+	DMADEVCMD_ts_byte_v	= 0,
+	DMADEVCMD_ts_halfword_v	= 1,
+	DMADEVCMD_ts_word_v	= 2,
+	DMADEVCMD_ts_2word_v	= 3,
+	DMADEVCMD_ts_4word_v	= 4,
+	DMADEVCMD_ts_6word_v	= 5,
+	DMADEVCMD_ts_8word_v	= 6,
+	DMADEVCMD_ts_16word_v	= 7
+};
+
+
+#if 1	// aws - Compatibility.
+#	define	EXTDMA_ts_b		DMADEVCMD_ts_b
+#	define	EXTDMA_ts_m		DMADEVCMD_ts_m
+#	define	EXTDMA_ts_byte_v	DMADEVCMD_ts_byte_v
+#	define	EXTDMA_ts_halfword_v	DMADEVCMD_ts_halfword_v
+#	define	EXTDMA_ts_word_v	DMADEVCMD_ts_word_v
+#	define	EXTDMA_ts_2word_v	DMADEVCMD_ts_2word_v
+#	define	EXTDMA_ts_4word_v	DMADEVCMD_ts_4word_v
+#	define	EXTDMA_ts_6word_v	DMADEVCMD_ts_6word_v
+#	define	EXTDMA_ts_8word_v	DMADEVCMD_ts_8word_v
+#	define	EXTDMA_ts_16word_v	DMADEVCMD_ts_16word_v
+#endif	// aws - Compatibility.
+
+#endif	// __IDT_RC32365_DMA_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_dma_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,86 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32365/336 DMA interface routines.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_DMA_V_H__
+#define __IDT_RC32365_DMA_V_H__
+
+
+#include  <asm/idt-boards/rc32300/rc32300.h>
+#include  <asm/idt-boards/rc32300/rc32365_dma.h> 
+#include  <asm/idt-boards/rc32300/rc32365.h>
+
+#define DMA_CHAN_OFFSET  0x14
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) != 0)
+#define IS_DMA_FINISHED(X)   (((X) & (DMAD_f_m)) != 0)
+#define IS_DMA_DONE(X)   (((X) & (DMAD_d_m)) != 0)
+
+#define DMA_COUNT(count)   \
+  ((count) & DMAD_count_m)
+
+#define DMA_HALT_TIMEOUT 500
+
+static inline int rc32365_halt_dma(DMA_Chan_t ch)
+{
+	int timeout=1;
+	if (local_readl(&ch->dmac) & DMAC_run_m) {
+		local_writel(0, &ch->dmac); 
+		
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (local_readl(&ch->dmas) & DMAS_h_m) {
+				local_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+
+	}
+
+	return timeout ? 0 : 1;
+}
+
+
+static inline void rc32365_start_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(0, &ch->dmandptr); 
+	local_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32365_chain_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	local_writel(dma_addr, &ch->dmandptr);
+}
+#endif //__IDT_RC32365_DMA_V_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_eth.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_eth.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_eth.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,344 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32365/336 Ethernet hardware abstraction.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef	__IDT_RC32365_ETH_H__
+#define	__IDT_RC32365_ETH_H__
+
+enum
+{
+	ETH0_PhysicalAddress	= 0x18058000,
+	ETH_PhysicalAddress	= ETH0_PhysicalAddress,		// Default
+	ETH0_VirtualAddress	= 0xb8058000,
+
+	ETH_VirtualAddress	= ETH0_VirtualAddress,		// Default
+
+	ETH1_PhysicalAddress	= 0x18060000,
+	ETH1_VirtualAddress	= 0xb8060000,			// Default
+} ;
+
+typedef struct
+{
+	u32 ethintfc		;
+	u32 ethfifott		;
+	u32 etharc		;
+	u32 ethhash0		;
+	u32 ethhash1		;
+	u32 ethu0 [4]		;	// Reserved.	
+	u32 ethpfs		;
+	u32 ethmcp		;
+	u32 eth_u1 [10]		;	// Reserved.
+	u32 ethspare		;
+	u32 eth_u2 [42]		;	// Reserved. 
+	u32 ethsal0		;
+	u32 ethsah0		;
+	u32 ethsal1		;
+	u32 ethsah1		;
+	u32 ethsal2		;
+	u32 ethsah2		;
+	u32 ethsal3		;
+	u32 ethsah3		;
+	u32 ethrbc		;
+	u32 ethrpc		;
+	u32 ethrupc		;
+	u32 ethrfc		;
+	u32 ethtbc		;
+	u32 ethgpf		;
+	u32 eth_u9 [50]		;	// Reserved.	
+	u32 ethmac1		;
+	u32 ethmac2		;
+	u32 ethipgt		;
+	u32 ethipgr		;
+	u32 ethclrt		;
+	u32 ethmaxf		;
+	u32 eth_u10		;	// Reserved.	
+	u32 ethmtest		;
+	u32 miimcfg		;
+	u32 miimcmd		;
+	u32 miimaddr		;
+	u32 miimwtd		;
+	u32 miimrdd		;
+	u32 miimind		;
+	u32 eth_u11		;	// Reserved.
+	u32 eth_u12		;	// Reserved.
+	u32 ethcfsa0		;
+	u32 ethcfsa1		;
+	u32 ethcfsa2		;
+} volatile *ETH_t;
+
+enum
+{
+	ETHINTFC_en_b		= 0,
+	ETHINTFC_en_m		= 0x00000001,
+	ETHINTFC_its_b		= 1,
+	ETHINTFC_its_m		= 0x00000002,
+	ETHINTFC_rip_b		= 2,
+	ETHINTFC_rip_m		= 0x00000004,
+	ETHINTFC_jam_b		= 3,
+	ETHINTFC_jam_m		= 0x00000008,
+	ETHINTFC_ovr_b		= 4,
+	ETHINTFC_ovr_m		= 0x00000010,
+	ETHINTFC_und_b		= 5,
+	ETHINTFC_und_m		= 0x00000020,
+
+	ETHFIFOTT_tth_b		= 0,
+	ETHFIFOTT_tth_m		= 0x0000007f,
+
+	ETHARC_pro_b		= 0,
+	ETHARC_pro_m		= 0x00000001,
+	ETHARC_am_b		= 1,
+	ETHARC_am_m		= 0x00000002,
+	ETHARC_afm_b		= 2,
+	ETHARC_afm_m		= 0x00000004,
+	ETHARC_ab_b		= 3,
+	ETHARC_ab_m		= 0x00000008,
+
+	ETHSAL_byte5_b		= 0,
+	ETHSAL_byte5_m		= 0x000000ff,
+	ETHSAL_byte4_b		= 8,
+	ETHSAL_byte4_m		= 0x0000ff00,
+	ETHSAL_byte3_b		= 16,
+	ETHSAL_byte3_m		= 0x00ff0000,
+	ETHSAL_byte2_b		= 24,
+	ETHSAL_byte2_m		= 0xff000000,
+
+	ETHSAH_byte1_b		= 0,
+	ETHSAH_byte1_m		= 0x000000ff,
+	ETHSAH_byte0_b		= 8,
+	ETHSAH_byte0_m		= 0x0000ff00,
+	
+	ETHGPF_ptv_b		= 0,
+	ETHGPF_ptv_m		= 0x0000ffff,
+
+	ETHPFS_pfd_b		= 0,
+	ETHPFS_pfd_m		= 0x00000001,
+
+	ETHCFSA0_cfsa4_b	= 0,
+	ETHCFSA0_cfsa4_m	= 0x000000ff,
+	ETHCFSA0_cfsa5_b	= 8,
+	ETHCFSA0_cfsa5_m	= 0x0000ff00,
+
+	ETHCFSA1_cfsa2_b	= 0,
+	ETHCFSA1_cfsa2_m	= 0x000000ff,
+	ETHCFSA1_cfsa3_b	= 8,
+	ETHCFSA1_cfsa3_m	= 0x0000ff00,
+
+	ETHCFSA2_cfsa0_b	= 0,
+	ETHCFSA2_cfsa0_m	= 0x000000ff,
+	ETHCFSA2_cfsa1_b	= 8,
+	ETHCFSA2_cfsa1_m	= 0x0000ff00,
+
+	ETHMAC1_re_b		= 0,
+	ETHMAC1_re_m		= 0x00000001,
+	ETHMAC1_paf_b		= 1,
+	ETHMAC1_paf_m		= 0x00000002,
+	ETHMAC1_rfc_b		= 2,
+	ETHMAC1_rfc_m		= 0x00000004,
+	ETHMAC1_tfc_b		= 3,
+	ETHMAC1_tfc_m		= 0x00000008,
+	ETHMAC1_lb_b		= 4,
+	ETHMAC1_lb_m		= 0x00000010,
+	ETHMAC1_mr_b		= 31,
+	ETHMAC1_mr_m		= 0x80000000,
+
+	ETHMAC2_fd_b		= 0,
+	ETHMAC2_fd_m		= 0x00000001,
+	ETHMAC2_flc_b		= 1,
+	ETHMAC2_flc_m		= 0x00000002,
+	ETHMAC2_hfe_b		= 2,
+	ETHMAC2_hfe_m		= 0x00000004,
+	ETHMAC2_dc_b		= 3,
+	ETHMAC2_dc_m		= 0x00000008,
+	ETHMAC2_cen_b		= 4,
+	ETHMAC2_cen_m		= 0x00000010,
+	ETHMAC2_pe_b		= 5,
+	ETHMAC2_pe_m		= 0x00000020,
+	ETHMAC2_vpe_b		= 6,
+	ETHMAC2_vpe_m		= 0x00000040,
+	ETHMAC2_ape_b		= 7,
+	ETHMAC2_ape_m		= 0x00000080,
+	ETHMAC2_ppe_b		= 8,
+	ETHMAC2_ppe_m		= 0x00000100,
+	ETHMAC2_lpe_b		= 9,
+	ETHMAC2_lpe_m		= 0x00000200,
+	ETHMAC2_nb_b		= 12,
+	ETHMAC2_nb_m		= 0x00001000,
+	ETHMAC2_bp_b		= 13,
+	ETHMAC2_bp_m		= 0x00002000,
+	ETHMAC2_ed_b		= 14,
+	ETHMAC2_ed_m		= 0x00004000,
+
+	ETHIPGT_ipgt_b		= 0,
+	ETHIPGT_ipgt_m		= 0x0000007f,
+
+	ETHIPGR_ipgr2_b		= 0,
+	ETHIPGR_ipgr2_m		= 0x0000007f,
+	ETHIPGR_ipgr1_b		= 8,
+	ETHIPGR_ipgr1_m		= 0x00007f00,
+
+	ETHCLRT_maxret_b	= 0,
+	ETHCLRT_maxret_m	= 0x0000000f,
+	ETHCLRT_colwin_b	= 8,
+	ETHCLRT_colwin_m	= 0x00003f00,
+
+	ETHMAXF_maxf_b		= 0,
+	ETHMAXF_maxf_m		= 0x0000ffff,
+
+	ETHMTEST_tb_b		= 2,
+	ETHMTEST_tb_m		= 0x00000004,
+
+	ETHMCP_div_b		= 0,
+	ETHMCP_div_m		= 0x000000ff,
+	
+	MIIMCFG_rsv_b		= 0,
+	MIIMCFG_rsv_m		= 0x0000000c,
+
+	MIIMCMD_rd_b		= 0,
+	MIIMCMD_rd_m		= 0x00000001,
+	MIIMCMD_scn_b		= 1,
+	MIIMCMD_scn_m		= 0x00000002,
+
+	MIIMADDR_regaddr_b	= 0,
+	MIIMADDR_regaddr_m	= 0x0000001f,
+	MIIMADDR_phyaddr_b	= 8,
+	MIIMADDR_phyaddr_m	= 0x00001f00,
+
+	MIIMWTD_wdata_b		= 0,
+	MIIMWTD_wdata_m		= 0x0000ffff,
+
+	MIIMRDD_rdata_b		= 0,
+	MIIMRDD_rdata_m		= 0x0000ffff,
+
+	MIIMIND_bsy_b		= 0,
+	MIIMIND_bsy_m		= 0x00000001,
+	MIIMIND_scn_b		= 1,
+	MIIMIND_scn_m		= 0x00000002,
+	MIIMIND_nv_b		= 2,
+	MIIMIND_nv_m		= 0x00000004,
+
+} ;
+
+/*
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors.
+ */
+enum
+{
+	ETHRX_fd_b		= 0,
+	ETHRX_fd_m		= 0x00000001,
+	ETHRX_ld_b		= 1,
+	ETHRX_ld_m		= 0x00000002,
+	ETHRX_rok_b		= 2,
+	ETHRX_rok_m		= 0x00000004,
+	ETHRX_fm_b		= 3,
+	ETHRX_fm_m		= 0x00000008,
+	ETHRX_mp_b		= 4,
+	ETHRX_mp_m		= 0x00000010,
+	ETHRX_bp_b		= 5,
+	ETHRX_bp_m		= 0x00000020,
+	ETHRX_vlt_b		= 6,
+	ETHRX_vlt_m		= 0x00000040,
+	ETHRX_cf_b		= 7,
+	ETHRX_cf_m		= 0x00000080,
+	ETHRX_ovr_b		= 8,
+	ETHRX_ovr_m		= 0x00000100,
+	ETHRX_crc_b		= 9,
+	ETHRX_crc_m		= 0x00000200,
+	ETHRX_cv_b		= 10,
+	ETHRX_cv_m		= 0x00000400,
+	ETHRX_db_b		= 11,
+	ETHRX_db_m		= 0x00000800,
+	ETHRX_le_b		= 12,
+	ETHRX_le_m		= 0x00001000,
+	ETHRX_lor_b		= 13,
+	ETHRX_lor_m		= 0x00002000,
+	ETHRX_ces_b		= 14,
+	ETHRX_ces_m		= 0x00004000,
+	ETHRX_length_b		= 16,
+	ETHRX_length_m		= 0xffff0000,
+
+	ETHTX_fd_b		= 0,
+	ETHTX_fd_m		= 0x00000001,
+	ETHTX_ld_b		= 1,
+	ETHTX_ld_m		= 0x00000002,
+	ETHTX_oen_b		= 2,
+	ETHTX_oen_m		= 0x00000004,
+	ETHTX_pen_b		= 3,
+	ETHTX_pen_m		= 0x00000008,
+	ETHTX_cen_b		= 4,
+	ETHTX_cen_m		= 0x00000010,
+	ETHTX_hen_b		= 5,
+	ETHTX_hen_m		= 0x00000020,
+	ETHTX_tok_b		= 6,
+	ETHTX_tok_m		= 0x00000040,
+	ETHTX_mp_b		= 7,
+	ETHTX_mp_m		= 0x00000080,
+	ETHTX_bp_b		= 8,
+	ETHTX_bp_m		= 0x00000100,
+	ETHTX_und_b		= 9,
+	ETHTX_und_m		= 0x00000200,
+	ETHTX_of_b		= 10,
+	ETHTX_of_m		= 0x00000400,
+	ETHTX_ed_b		= 11,
+	ETHTX_ed_m		= 0x00000800,
+	ETHTX_ec_b		= 12,
+	ETHTX_ec_m		= 0x00001000,
+	ETHTX_lc_b		= 13,
+	ETHTX_lc_m		= 0x00002000,
+	ETHTX_td_b		= 14,
+	ETHTX_td_m		= 0x00004000,
+	ETHTX_crc_b		= 15,
+	ETHTX_crc_m		= 0x00008000,
+	ETHTX_le_b		= 16,
+	ETHTX_le_m		= 0x00010000,
+	ETHTX_cc_b		= 17,
+	ETHTX_cc_m		= 0x001E0000,
+} ;
+
+enum
+{
+	ETH0_IPABMC_PhysicalAddress	= 0x18040010,
+	ETH0_IPABMC_VirtualAddress	= 0xb8040000,
+	ETH1_IPABMC_PhysicalAddress	= 0x18040018,
+	ETH1_IPABMC_VirtualAddress	= 0xb8040018,
+} ;
+
+typedef struct
+{
+	u32 ipabmcrx		;
+	u32 ipabmctx		;
+}volatile *IPABM_ETH_t;
+#endif //__IDT_RC32365_ETH_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_eth_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,72 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32365/336 Ethernet status checking.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_ETH_V_H__
+#define __IDT_RC32365_ETH_V_H__
+#include  <asm/idt-boards/rc32300/rc32365_eth.h> 
+
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b )   /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b )    /* Multicast        */
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b )    /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b )   /* Transmit FIFO Underflow */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b )    /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b )    /* Excessive deferral  */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)     /* Excessive collisions  */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b )    /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b )    /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b )   /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b )    /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* Collision Count  */
+
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b)    /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)     /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)     /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)     /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b)    /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)     /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b)    /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b)    /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)     /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)     /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)     /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b)    /* Length Out of Range */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b)  /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> ETHRX_length_b)   /* Length of the received packet */
+
+#endif //__IDT_RC32365_ETH_V_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_gpio.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,181 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   RC32365/336 GPIO hardware abstraction.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef	__IDT_RC32365_GPIO_H__
+#define	__IDT_RC32365_GPIO_H__
+
+enum
+{
+	GPIO0_PhysicalAddress	= 0x18048000,
+	GPIO_PhysicalAddress	= GPIO0_PhysicalAddress,	// Default
+	
+	GPIO0_VirtualAddress	= 0xb8048000,
+	GPIO_VirtualAddress	= GPIO0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32   gpiofunc;   /* GPIO Function Register
+			   * gpiofunc[x]==0 bit = gpio
+			   * func[x]==1  bit = altfunc
+			   */
+	u32   gpiocfg;    /* GPIO Configuration Register
+			   * gpiocfg[x]==0 bit = input
+			   * gpiocfg[x]==1 bit = output
+			   */
+	u32   gpiod;	    /* GPIO Data Register
+			     * gpiod[x] read/write gpio pinX status
+			     */
+	u32   gpioilevel; /* GPIO Interrupt Status Register
+			   * interrupt level (see gpioistat)
+			   */
+	u32   gpioistat;  /* Gpio Interrupt Status Register
+			   * istat[x] = (gpiod[x] == level[x])
+			   * cleared in ISR (STICKY bits)
+			   */
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register */
+} volatile * GPIO_t ;
+
+typedef enum
+{
+	GPIO_gpio_v	    = 0,		// gpiofunc use pin as GPIO.
+	GPIO_alt_v	    = 1,		// gpiofunc use pin as alt.
+	GPIO_input_v	    = 0,		// gpiocfg use pin as input.
+	GPIO_output_v	    = 1,		// gpiocfg use pin as output.
+	GPIO_pin0_b	    = 0,
+	GPIO_pin0_m	    = 0x00000001,
+	GPIO_pin1_b	    = 1,
+	GPIO_pin1_m	    = 0x00000002,
+	GPIO_pin2_b	    = 2,
+	GPIO_pin2_m	    = 0x00000004,
+	GPIO_pin3_b	    = 3,
+	GPIO_pin3_m	    = 0x00000008,
+	GPIO_pin4_b	    = 4,
+	GPIO_pin4_m	    = 0x00000010,
+	GPIO_pin5_b	    = 5,
+	GPIO_pin5_m	    = 0x00000020,
+	GPIO_pin6_b	    = 6,
+	GPIO_pin6_m	    = 0x00000040,
+	GPIO_pin7_b	    = 7,
+	GPIO_pin7_m	    = 0x00000080,
+	GPIO_pin8_b	    = 8,
+	GPIO_pin8_m	    = 0x00000100,
+	GPIO_pin9_b	    = 9,
+	GPIO_pin9_m	    = 0x00000200,
+	GPIO_pin10_b	    = 10,
+	GPIO_pin10_m	    = 0x00000400,
+	GPIO_pin11_b	    = 11,
+	GPIO_pin11_m	    = 0x00000800,
+	GPIO_pin12_b	    = 12,
+	GPIO_pin12_m	    = 0x00001000,
+	GPIO_pin13_b	    = 13,
+	GPIO_pin13_m	    = 0x00002000,
+	GPIO_pin14_b	    = 14,
+	GPIO_pin14_m	    = 0x00004000,
+	GPIO_pin15_b	    = 15,
+	GPIO_pin15_m	    = 0x00008000,
+	
+// Alternate function pins.  Corrsponding gpiofunc bit set to GPIO_alt_v.
+	
+	GPIO_u0sout_b	    = GPIO_pin0_b,		// UART 0 serial out.
+	GPIO_u0sout_m	    = GPIO_pin0_m,
+	GPIO_u0sout_cfg_v   = GPIO_output_v,
+	
+	GPIO_u0sinp_b	    = GPIO_pin1_b,			// UART 0 serial in.
+	GPIO_u0sinp_m	    = GPIO_pin1_m,
+	GPIO_u0sinp_cfg_v   = GPIO_input_v,
+	
+	GPIO_maddr22_b	    = GPIO_pin2_b, 	// M&P bus bit 22.
+	GPIO_maddr22_m	    = GPIO_pin2_m,
+	GPIO_maddr22_cfg_v  = GPIO_output_v,
+	
+	GPIO_maddr23_b	    = GPIO_pin3_b, 	// M&P bus bit 23.
+	GPIO_maddr23_m	    = GPIO_pin3_m,
+	GPIO_maddr23_cfg_v  = GPIO_output_v,
+	
+	GPIO_maddr24_b	    = GPIO_pin4_b, 	// M&P bus bit 24.
+	GPIO_maddr24_m	    = GPIO_pin4_m,
+	GPIO_maddr24_cfg_v  = GPIO_output_v,
+	
+	GPIO_maddr25_b	    = GPIO_pin5_b, 	// M&P bus bit 25.
+	GPIO_maddr25_m	    = GPIO_pin5_m,
+	GPIO_maddr25_cfg_v  = GPIO_output_v,
+	
+	GPIO_rngclk_b 	    = GPIO_pin6_b, 	// reserved.
+	GPIO_rngclk_m 	    = GPIO_pin6_m,
+	GPIO_rngclk_cfg_v   = GPIO_input_v,
+
+	GPIO_sdckenp_b 	    = GPIO_pin7_b, 	// reserved.
+	GPIO_sdckenp_m 	    = GPIO_pin7_m,
+	GPIO_sdckenp_cfg_v  = GPIO_output_v,
+
+	GPIO_cen1_b 	    = GPIO_pin8_b, 	// reserved.
+	GPIO_cen1_m 	    = GPIO_pin8_m,
+	GPIO_cen1_cfg_v	    = GPIO_output_v,
+
+	GPIO_cen2_b 	    = GPIO_pin9_b, 	// reserved.
+	GPIO_cen2_m 	    = GPIO_pin9_m,
+	GPIO_cen2_cfg_v	    = GPIO_output_v,
+	
+	GPIO_regn_b 	    = GPIO_pin10_b, 	// reserved.
+	GPIO_regn_m 	    = GPIO_pin10_m,
+	GPIO_regn_cfg_v	    = GPIO_output_v,
+	
+	GPIO_iordn_b 	    = GPIO_pin11_b, 	// reserved.
+	GPIO_iordn_m 	    = GPIO_pin11_m,
+	GPIO_iordn_cfg_v    = GPIO_output_v,
+	
+	GPIO_iowrn_b 	    = GPIO_pin12_b, 	// reserved.
+	GPIO_iowrn_m 	    = GPIO_pin12_m,
+	GPIO_iowrn_cfg_v    = GPIO_output_v,
+    
+	GPIO_pcireqn2_b	    = GPIO_pin13_b, 	// PCI messaging int.
+	GPIO_pcireqn2_m	    = GPIO_pin13_m,
+	GPIO_pcireqn2_cfg_v = GPIO_input_v,
+	
+	GPIO_pcigntn2_b	    = GPIO_pin14_b, 	// PCI messaging int.
+	GPIO_pcigntn2_m	    = GPIO_pin14_m,
+	GPIO_pcigntn2_cfg_v = GPIO_output_v,
+	
+	GPIO_pcimuintn_b    = GPIO_pin15_b, 	// PCI messaging int.
+	GPIO_pcimuintn_m    = GPIO_pin15_m,
+	GPIO_pcimuintn_cfg_v= GPIO_output_v,
+	
+} GPIO_DEFS_t;
+
+#endif //__IDT_RC32365_GPIO_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_gpio_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,91 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Routines to set/clear/toggle GPIO on RC32365
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+#ifndef	__IDT_RC32365_GPIO_V_H__
+#define	__IDT_RC32365_GPIO_V_H__
+
+
+#ifdef _LANGUAGE_ASSEMBLY
+#define SET_GPIO(pin) \
+	lui t5,0xb804 ; \
+	ori t5,t5,0x8000 ; \
+	lw  t4,8(t5) ; \
+	ori t4,t4,pin ; \
+	sw  t4,8(t5) ;
+
+#define CLEAR_GPIO(pin) \
+	lui t5,0xb804 ; \
+	ori t5,t5,0x8000 ; \
+	lw  t4,8(t5) ; \
+        lui t6,0xFFFF; \
+        ori t6,t6,0xFFFF; \
+	xori t6,t6,pin ; \
+        and  t4,t6 ; \
+	sw  t4,8(t5) ;
+
+#define TOGGLE_GPIO(pin) \
+	lui t5,0xb804 ; \
+	ori t5,t5,0x8000 ; \
+	lw  t4,8(t5) ; \
+	xori t4,t4,pin ; \
+	sw  t4,8(t5) ;
+
+#else // !_LANGUAGE_ASSEMBLY 
+#include  <asm/rc32300/types.h> 
+#include  <asm/rc32300/rc32365_gpio.h> 
+#include  <asm/rc32300/rc32365.h>
+
+static inline void set_gpio(unsigned long pin)
+{
+  idt_gpio->gpiod |= pin;
+}
+ 
+static inline void clear_gpio(unsigned long pin)
+{
+  idt_gpio->gpiod &= ~pin;
+}
+static inline void toggle_gpio(unsigned long pin)
+{
+  idt_gpio->gpiod ^= pin;
+}
+#define SET_GPIO(pin) set_gpio(pin)
+#define CLEAR_GPIO(pin) clear_gpio(pin)
+#define TOGGLE_GPIO(pin) toggle_gpio(pin)
+#endif // _LANGUAGE_ASSEMBLY 
+
+#endif //__IDT_RC32365_GPIO_V_H__
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,160 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32365 CPU.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_H__
+#define __IDT_RC32365_H__
+
+extern unsigned int cedar_za;
+
+/* Base address of internal registers */
+#define RC32365_REG_BASE   0x18000000
+
+/* System ID Registers */
+#define CPU_SYSID          (RC32365_REG_BASE + 0x00018)
+#define CPU_DEVTYPE        (RC32365_REG_BASE + 0x0001c)
+
+/* Reset Controller */
+#define RESET_CNTL         (RC32365_REG_BASE + 0x08000)
+#define BOOT_VECTOR        (RC32365_REG_BASE + 0x08004)
+
+/* Device Controller */
+#define DEV0_BASE          (RC32365_REG_BASE + 0x10000)
+#define DEV0_MASK          (RC32365_REG_BASE + 0x10004)
+#define DEV0_CNTL          (RC32365_REG_BASE + 0x10008)
+#define DEV0_TIMING        (RC32365_REG_BASE + 0x1000c)
+#define DEV_REG_OFFSET     0x10
+
+/* SDRAM Controller */
+#define SDRAM0_BASE        (RC32365_REG_BASE + 0x18000)
+#define SDRAM0_MASK        (RC32365_REG_BASE + 0x18004)
+#define SDRAM1_BASE        (RC32365_REG_BASE + 0x18008)
+#define SDRAM1_MASK        (RC32365_REG_BASE + 0x1800c)
+#define SDRAM_CNTL         (RC32365_REG_BASE + 0x18010)
+
+/* Counters/Timers */
+#define TIMER0_COUNT       (RC32365_REG_BASE + 0x20000)
+#define TIMER0_COMPARE     (RC32365_REG_BASE + 0x20004)
+#define TIMER0_CNTL        (RC32365_REG_BASE + 0x20008)
+#define TIMER0_SELECT      (RC32365_REG_BASE + 0x2000c)
+#define TIMER_REG_OFFSET   0x10
+
+/* System Integrity */
+
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32365_REG_BASE + 0x30000)
+#define IC_GROUP0_TEST     (RC32365_REG_BASE + 0x30004)
+#define IC_GROUP0_MASK     (RC32365_REG_BASE + 0x30008)
+#define IC_GROUP_OFFSET    0x0c
+
+#define NUM_INTR_GROUPS    5
+/*
+ * The IRQ mapping is as follows:
+ *
+ *    IRQ         Mapped To
+ *    ---     -------------------
+ *     0      SW0  (IP0) SW0 intr
+ *     1      SW1  (IP1) SW1 intr
+ *     -      Int0 (IP2) mapped to GROUP0_IRQ_BASE
+ *     -      Int1 (IP3) mapped to GROUP1_IRQ_BASE
+ *     -      Int2 (IP4) mapped to GROUP2_IRQ_BASE
+ *     -      Int3 (IP5) mapped to GROUP3_IRQ_BASE
+ *     -      Int4 (IP6) mapped to GROUP4_IRQ_BASE
+ *     7      Int5 (IP7) CP0 Timer
+ *
+ * IRQ's 8 and up are all mapped to Int0-4 (IP2-IP6), which
+ * internally on the RC32365 is routed to the Expansion
+ * Interrupt Controller.
+ */
+#define MIPS_CPU_TIMER_IRQ 7
+
+#define GROUP0_IRQ_BASE  8                      // Counter/Timers, UCW
+#define GROUP1_IRQ_BASE  (GROUP0_IRQ_BASE + 32) // DMA
+#define GROUP2_IRQ_BASE  (GROUP1_IRQ_BASE + 32) // RNG, SEC
+#define GROUP3_IRQ_BASE  (GROUP2_IRQ_BASE + 32) // Eth, PCI, UARTs
+#define GROUP4_IRQ_BASE  (GROUP3_IRQ_BASE + 32) // GPIO
+
+#define RC32365_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+/* DMA - see rc32365_dma.h for full list of registers */
+
+#define RC32365_DMA_BASE (RC32365_REG_BASE + 0x38000)
+#define DMA_CHAN_OFFSET  0x14
+
+/* GPIO Controller */
+#define idt_gpio              ((volatile GPIO_t) GPIO0_VirtualAddress)
+
+/* 16550 UARTs */
+#ifdef __MIPSEB__
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50003)
+#else
+#define RC32300_UART0_BASE (RC32365_REG_BASE + 0x50000)
+#endif
+#define RC32300_UART0_IRQ  (GROUP3_IRQ_BASE + 0)
+
+/* Ethernet - see rc32365_eth.h for full list of registers */
+
+#define RC32365_ETH_BASE   (RC32365_REG_BASE + 0x58000)
+
+#define IDT_CLOCK_MULT     2
+
+/* FLASH (device 1) */
+#define FLASH_BASE         0x08000000
+#define FLASH_SIZE         0x00800000
+
+/* LCD 4-digit display (device 2) */
+#define LCD_DIGIT0         0x0C000003
+#define LCD_DIGIT1         0x0C000002
+#define LCD_DIGIT2         0x0C000001
+#define LCD_DIGIT3         0x0C000000
+
+/* RTC (DS1553) (device 2) */
+#define RTC_BASE           0x0c800000
+/* NVRAM */
+#define NVRAM_BASE         RTC_BASE
+#define NVRAM_ENVSIZE_OFF  4
+#define NVRAM_ENVSTART_OFF 32
+
+/* Interrupts routed on 79EB365 board */
+#define RC32365_PCI_INTA_IRQ (GROUP4_IRQ_BASE +  8)
+#define RC32365_PCI_INTB_IRQ (GROUP4_IRQ_BASE +  9)
+#define RC32365_PCI_INTC_IRQ (GROUP4_IRQ_BASE + 10)
+#define RC32365_PCI_INTD_IRQ (GROUP4_IRQ_BASE + 11)
+
+#define RAM_SIZE	   (32 * 1024 * 1024)
+
+#endif //__IDT_RC32365_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_pci.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_pci.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_pci.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,515 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Datatype declaration for IDT 79EB365/336 PCI
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_PCI_H__
+#define __IDT_RC32365_PCI_H__
+
+enum
+{
+	PCI0_PhysicalAddress	= 0x18068000,
+	PCI_PhysicalAddress	= PCI0_PhysicalAddress,
+	
+	PCI0_VirtualAddress	= 0xb8068000,
+	PCI_VirtualAddress	= PCI0_VirtualAddress,
+} ;
+
+enum
+{
+	PCI_LbaCount	= 4,		// Local base addresses.
+} ;
+
+typedef struct
+{
+	u32	a ;		// Address.
+	u32	c ;		// Control.
+	u32	m ;		// mapping.
+} PCI_Map_s ;
+
+typedef struct
+{
+	u32		pcic ;
+	u32		pcis ;
+	u32		pcism ;
+	u32		pcicfga ;
+	u32		pcicfgd ;
+	PCI_Map_s	pcilba [PCI_LbaCount] ;
+	u32		pcidac ;
+	u32		pcidas ;
+	u32		pcidasm ;
+	u32		pcidad ;
+	u32		pcidma8c ;
+	u32		pcidma9c ;
+	u32		pcitc ;
+} volatile *PCI_t ;
+
+// PCI messaging unit.
+enum
+{
+	PCIM_Count	= 2,
+} ;
+typedef struct
+{
+	u32		pciim [PCIM_Count] ;
+	u32		pciom [PCIM_Count] ;
+	u32		pciid ;
+	u32		pciiic ;
+	u32		pciiim ;
+	u32		pciiod ;
+	u32		pciioic ;
+	u32		pciioim ;
+} volatile *PCIM_t ;
+
+/*******************************************************************************
+ *
+ * PCI Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIC_en_b	= 0,
+	PCIC_en_m	= 0x00000001,
+	PCIC_tnr_b	= 1,
+	PCIC_tnr_m	= 0x00000002,
+	PCIC_sce_b	= 2,
+	PCIC_sce_m	= 0x00000004,
+	PCIC_ien_b	= 3,
+	PCIC_ien_m	= 0x00000008,
+	PCIC_aaa_b	= 4,
+	PCIC_aaa_m	= 0x00000010,
+	PCIC_eap_b	= 5,
+	PCIC_eap_m	= 0x00000020,
+	PCIC_pcim_b	= 6,
+	PCIC_pcim_m	= 0x000001c0,
+		PCIC_pcim_disabled_v	= 0,
+		PCIC_pcim_tnr_v 	= 1,	// Satellite - target not ready
+		PCIC_pcim_suspend_v	= 2,	// Satellite - suspended CPU.
+		PCIC_pcim_extern_v	= 3,	// Host - external arbiter.
+		PCIC_pcim_fixed_v	= 4,	// Host - fixed priority arb.
+		PCIC_pcim_roundrobin_v	= 5,	// Host - round robin priority.
+		PCIC_pcim_reserved6_v	= 6,
+		PCIC_pcim_reserved7_v	= 7,
+	PCIC_igm_b	= 9,
+	PCIC_igm_m	= 0x00000200,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIS_eed_b	= 0,
+	PCIS_eed_m	= 0x00000001,
+	PCIS_wr_b	= 1,
+	PCIS_wr_m	= 0x00000002,
+	PCIS_nmi_b	= 2,
+	PCIS_nmi_m	= 0x00000004,
+	PCIS_ii_b	= 3,
+	PCIS_ii_m	= 0x00000008,
+	PCIS_cwe_b	= 4,
+	PCIS_cwe_m	= 0x00000010,
+	PCIS_cre_b	= 5,
+	PCIS_cre_m	= 0x00000020,
+	PCIS_mdpe_b	= 6,
+	PCIS_mdpe_m	= 0x00000040,
+	PCIS_sta_b	= 7,
+	PCIS_sta_m	= 0x00000080,
+	PCIS_rta_b	= 8,
+	PCIS_rta_m	= 0x00000100,
+	PCIS_rma_b	= 9,
+	PCIS_rma_m	= 0x00000200,
+	PCIS_sse_b	= 10,
+	PCIS_sse_m	= 0x00000400,
+	PCIS_ose_b	= 11,
+	PCIS_ose_m	= 0x00000800,
+	PCIS_pe_b	= 12,
+	PCIS_pe_m	= 0x00001000,
+	PCIS_tae_b	= 13,
+	PCIS_tae_m	= 0x00002000,
+	PCIS_rle_b	= 14,
+	PCIS_rle_m	= 0x00004000,
+	PCIS_bme_b	= 15,
+	PCIS_bme_m	= 0x00008000,
+	PCIS_prd_b	= 16,
+	PCIS_prd_m	= 0x00010000,
+	PCIS_rip_b	= 17,
+	PCIS_rip_m	= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Mask Register
+ *
+ ******************************************************************************/
+enum {
+	PCISM_eed_b		= 0,
+	PCISM_eed_m		= 0x00000001,
+	PCISM_wr_b		= 1,
+	PCISM_wr_m		= 0x00000002,
+	PCISM_nmi_b		= 2,
+	PCISM_nmi_m		= 0x00000004,
+	PCISM_ii_b		= 3,
+	PCISM_ii_m		= 0x00000008,
+	PCISM_cwe_b		= 4,
+	PCISM_cwe_m		= 0x00000010,
+	PCISM_cre_b		= 5,
+	PCISM_cre_m		= 0x00000020,
+	PCISM_mdpe_b		= 6,
+	PCISM_mdpe_m		= 0x00000040,
+	PCISM_sta_b		= 7,
+	PCISM_sta_m		= 0x00000080,
+	PCISM_rta_b		= 8,
+	PCISM_rta_m		= 0x00000100,
+	PCISM_rma_b		= 9,
+	PCISM_rma_m		= 0x00000200,
+	PCISM_sse_b		= 10,
+	PCISM_sse_m		= 0x00000400,
+	PCISM_ose_b		= 11,
+	PCISM_ose_m		= 0x00000800,
+	PCISM_pe_b		= 12,
+	PCISM_pe_m		= 0x00001000,
+	PCISM_tae_b		= 13,
+	PCISM_tae_m		= 0x00002000,
+	PCISM_rle_b		= 14,
+	PCISM_rle_m		= 0x00004000,
+	PCISM_bme_b		= 15,
+	PCISM_bme_m		= 0x00008000,
+	PCISM_prd_b		= 16,
+	PCISM_prd_m		= 0x00010000,
+	PCISM_rip_b		= 17,
+	PCISM_rip_m		= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Configuration Address Register
+ *
+ ******************************************************************************/
+enum {
+	PCICFGA_reg_b		= 2,
+	PCICFGA_reg_m		= 0x000000fc,
+	PCICFGA_reg_id_v	= 0x00>>2, //use PCFGID_
+	PCICFGA_reg_04_v	= 0x04>>2, //use PCFG04_
+	PCICFGA_reg_08_v	= 0x08>>2, //use PCFG08_
+	PCICFGA_reg_0C_v	= 0x0C>>2, //use PCFG0C_
+	PCICFGA_reg_pba0_v	= 0x10>>2, //use PCIPBA_
+	PCICFGA_reg_pba1_v	= 0x14>>2, //use PCIPBA_
+	PCICFGA_reg_pba2_v	= 0x18>>2, //use PCIPBA_
+	PCICFGA_reg_pba3_v	= 0x1c>>2, //use PCIPBA_
+	PCICFGA_reg_subsystem_v = 0x2c>>2, //use PCFGSS_
+	PCICFGA_reg_3C_v	= 0x3C>>2, //use PCFG3C_
+	PCICFGA_reg_pba0c_v	= 0x44>>2, //use PCIPBAC_
+	PCICFGA_reg_pba0m_v	= 0x48>>2,
+	PCICFGA_reg_pba1c_v	= 0x4c>>2, //use PCIPBAC_
+	PCICFGA_reg_pba1m_v	= 0x50>>2,
+	PCICFGA_reg_pba2c_v	= 0x54>>2, //use PCIPBAC_
+	PCICFGA_reg_pba2m_v	= 0x58>>2,
+	PCICFGA_reg_pba3c_v	= 0x5c>>2, //use PCIPBAC_
+	PCICFGA_reg_pba3m_v	= 0x60>>2,
+	PCICFGA_reg_pmgt_v	= 0x64>>2,
+	PCICFGA_func_b		= 8,
+	PCICFGA_func_m		= 0x00000700,
+	PCICFGA_dev_b		= 11,
+	PCICFGA_dev_m		= 0x0000f800,
+	PCICFGA_dev_internal_v	= 0,
+	PCICFGA_bus_b		= 16,
+	PCICFGA_bus_m		= 0x00ff0000,
+	PCICFGA_bus_type0_v	= 0,	//local bus
+	PCICFGA_en_b		= 31,		// read only
+	PCICFGA_en_m		= 0x80000000,
+} ;
+
+enum {
+	PCFGID_vendor_b 	= 0,
+	PCFGID_vendor_m 	= 0x0000ffff,
+	PCFGID_vendor_IDT_v		= 0x111d,
+	PCFGID_device_b 	= 16,
+	PCFGID_device_m 	= 0xffff0000,
+	PCFGID_device_Acaciade_v	= 0x0207,
+
+	PCFG04_command_ioena_b		= 1,
+	PCFG04_command_ioena_m		= 0x00000001,
+	PCFG04_command_memena_b 	= 2,
+	PCFG04_command_memena_m 	= 0x00000002,
+	PCFG04_command_bmena_b		= 3,
+	PCFG04_command_bmena_m		= 0x00000004,
+	PCFG04_command_mwinv_b		= 5,
+	PCFG04_command_mwinv_m		= 0x00000010,
+	PCFG04_command_parena_b 	= 7,
+	PCFG04_command_parena_m 	= 0x00000040,
+	PCFG04_command_serrena_b	= 9,
+	PCFG04_command_serrena_m	= 0x00000100,
+	PCFG04_command_fastbbena_b	= 10,
+	PCFG04_command_fastbbena_m	= 0x00000200,
+	PCFG04_status_b 		= 16,
+	PCFG04_status_m 		= 0xffff0000,
+	PCFG04_status_66MHz_b		= 21,	// 66 MHz enable
+	PCFG04_status_66MHz_m		= 0x00200000,
+	PCFG04_status_fbb_b		= 23,
+	PCFG04_status_fbb_m		= 0x00800000,
+	PCFG04_status_mdpe_b		= 24,
+	PCFG04_status_mdpe_m		= 0x01000000,
+	PCFG04_status_dst_b		= 25,
+	PCFG04_status_dst_m		= 0x06000000,
+	PCFG04_status_sta_b		= 27,
+	PCFG04_status_sta_m		= 0x08000000,
+	PCFG04_status_rta_b		= 28,
+	PCFG04_status_rta_m		= 0x10000000,
+	PCFG04_status_rma_b		= 29,
+	PCFG04_status_rma_m		= 0x20000000,
+	PCFG04_status_sse_b		= 30,
+	PCFG04_status_sse_m		= 0x40000000,
+	PCFG04_status_pe_b		= 31,
+	PCFG04_status_pe_m		= 0x40000000,
+
+	PCFG08_revId_b			= 0,
+	PCFG08_revId_m			= 0x000000ff,
+	PCFG08_classCode_b		= 0,
+	PCFG08_classCode_m		= 0xffffff00,
+	PCFG08_classCode_bridge_v	= 06,
+	PCFG08_classCode_proc_v 	= 0x0b3000, // processor-MIPS
+	PCFG0C_cacheline_b		= 0,
+	PCFG0C_cacheline_m		= 0x000000ff,
+	PCFG0C_masterLatency_b		= 8,
+	PCFG0C_masterLatency_m		= 0x0000ff00,
+	PCFG0C_headerType_b		= 16,
+	PCFG0C_headerType_m		= 0x00ff0000,
+	PCFG0C_bist_b			= 24,
+	PCFG0C_bist_m			= 0xff000000,
+
+	PCIPBA_msi_b			= 0,
+	PCIPBA_msi_m			= 0x00000001,
+	PCIPBA_p_b			= 3,
+	PCIPBA_p_m			= 0x00000004,
+	PCIPBA_baddr_b			= 8,
+	PCIPBA_baddr_m			= 0xffffff00,
+
+	PCFGSS_vendorId_b		= 0,
+	PCFGSS_vendorId_m		= 0x0000ffff,
+	PCFGSS_id_b			= 16,
+	PCFGSS_id_m			= 0xffff0000,
+
+	PCFG3C_interruptLine_b		= 0,
+	PCFG3C_interruptLine_m		= 0x000000ff,
+	PCFG3C_interruptPin_b		= 8,
+	PCFG3C_interruptPin_m		= 0x0000ff00,
+	PCFG3C_minGrant_b		= 16,
+	PCFG3C_minGrant_m		= 0x00ff0000,
+	PCFG3C_maxLat_b 		= 24,
+	PCFG3C_maxLat_m 		= 0xff000000,
+
+	PCIPBAC_msi_b			= 0,
+	PCIPBAC_msi_m			= 0x00000001,
+	PCIPBAC_p_b			= 1,
+	PCIPBAC_p_m			= 0x00000002,
+	PCIPBAC_size_b			= 2,
+	PCIPBAC_size_m			= 0x0000007c,
+	PCIPBAC_sb_b			= 7,
+	PCIPBAC_sb_m			= 0x00000080,
+	PCIPBAC_pp_b			= 8,
+	PCIPBAC_pp_m			= 0x00000100,
+	PCIPBAC_mr_b			= 9,
+	PCIPBAC_mr_m			= 0x00000600,
+	PCIPBAC_mr_read_v	=0,	//no prefetching
+	PCIPBAC_mr_readLine_v	=1,
+	PCIPBAC_mr_readMult_v	=2,
+	PCIPBAC_mrl_b			= 11,
+	PCIPBAC_mrl_m			= 0x00000800,
+	PCIPBAC_mrm_b			= 12,
+	PCIPBAC_mrm_m			= 0x00001000,
+	PCIPBAC_trp_b			= 13,
+	PCIPBAC_trp_m			= 0x00002000,
+
+	PCFG40_trdyTimeout_b		= 0,
+	PCFG40_trdyTimeout_m		= 0x000000ff,
+	PCFG40_retryLim_b		= 8,
+	PCFG40_retryLim_m		= 0x0000ff00,
+};
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBA_baddr_b		= 0,		// In PCI_t -> pcilba [] .a
+	PCILBA_baddr_m		= 0xffffff00,
+} ;
+/*******************************************************************************
+ *
+ * PCI Local Base Address Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAC_msi_b		= 0,		// In pPci->pcilba[i].c
+	PCILBAC_msi_m		= 0x00000001,
+	PCILBAC_msi_mem_v	= 0,
+	PCILBAC_msi_io_v	= 1,
+	PCILBAC_size_b		= 2,	// In pPci->pcilba[i].c
+	PCILBAC_size_m		= 0x0000007c,
+	PCILBAC_sb_b		= 7,	// In pPci->pcilba[i].c
+	PCILBAC_sb_m		= 0x00000080,
+	PCILBAC_rt_b		= 8,	// In pPci->pcilba[i].c
+	PCILBAC_rt_m		= 0x00000100,
+	PCILBAC_rt_noprefetch_v = 0, // mem read
+	PCILBAC_rt_prefetch_v	= 1, // mem readline
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Mapping Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAM_maddr_b 	= 8,
+	PCILBAM_maddr_m 	= 0xffffff00,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAC_den_b		= 0,
+	PCIDAC_den_m		= 0x00000001,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAS_d_b	= 0,
+	PCIDAS_d_m	= 0x00000001,
+	PCIDAS_b_b	= 1,
+	PCIDAS_b_m	= 0x00000002,
+	PCIDAS_e_b	= 2,
+	PCIDAS_e_m	= 0x00000004,
+	PCIDAS_ofe_b	= 3,
+	PCIDAS_ofe_m	= 0x00000008,
+	PCIDAS_off_b	= 4,
+	PCIDAS_off_m	= 0x00000010,
+	PCIDAS_ife_b	= 5,
+	PCIDAS_ife_m	= 0x00000020,
+	PCIDAS_iff_b	= 6,
+	PCIDAS_iff_m	= 0x00000040,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 8 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA8C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA8C_mbs_m	= 0x00000fff,	// { pcidma8c }
+	PCIDMA8C_our_b	= 12,		// Optimize Unaligned Burst Reads.
+	PCIDMA8C_our_m	= 0x00001000,	// { pcidma8c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 9 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA9C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA9C_mbs_m	= 0x00000fff, // { pcidma9c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel 9)Descriptors
+ *
+ ******************************************************************************/
+enum {
+	PCIDMAD_pt_b		= 22,		// in DEVCMD field (descriptor)
+	PCIDMAD_pt_m		= 0x00c00000,	// preferred transaction field
+	// These are for reads (DMA channel 8)
+	PCIDMAD_devcmd_mr_v	= 0,	//memory read
+	PCIDMAD_devcmd_mrl_v	= 1,	//memory read line
+	PCIDMAD_devcmd_mrm_v	= 2,	//memory read multiple
+	PCIDMAD_devcmd_ior_v	= 3,	//I/O read
+	// These are for writes (DMA channel 9)
+	PCIDMAD_devcmd_mw_v	= 0,	//memory write
+	PCIDMAD_devcmd_mwi_v	= 1,	//memory write invalidate
+	PCIDMAD_devcmd_iow_v	= 3,	//I/O write
+	
+	// Swap byte field applies to both DMA channel 8 and 9
+	PCIDMAD_sb_b		= 24,		// in DEVCMD field (descriptor)
+	PCIDMAD_sb_m		= 0x01000000,	// swap byte field
+} ;
+
+
+/*******************************************************************************
+ *
+ * PCI Target Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCITC_rtimer_b		= 0,		// In PCITC_t -> pcitc
+	PCITC_rtimer_m		= 0x000000ff,
+	PCITC_dtimer_b		= 8,		// In PCITC_t -> pcitc
+	PCITC_dtimer_m		= 0x0000ff00,
+	PCITC_rdr_b		= 18,		// In PCITC_t -> pcitc
+	PCITC_rdr_m		= 0x00040000,
+	PCITC_ddt_b		= 19,		// In PCITC_t -> pcitc
+	PCITC_ddt_m		= 0x00080000,
+} ;
+/*******************************************************************************
+ *
+ * PCI messaging unit [applies to both inbound and outbound registers ]
+ *
+ ******************************************************************************/
+enum
+{
+	PCIM_m0_b	= 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m0_m	= 0x00000001,	// inbound or outbound message 0
+	PCIM_m1_b	= 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m1_m	= 0x00000002,	// inbound or outbound message 1
+	PCIM_db_b	= 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_db_m	= 0x00000004,	// inbound or outbound doorbell
+};
+
+
+#endif	// __IDT_RC32365_PCI_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32300/rc32365_pci_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,217 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   PCI header values for IDT 79EB365/336                                                   
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32365_PCI_V_H__
+#define __IDT_RC32365_PCI_V_H__
+
+
+#define PCI_MSG_VirtualAddress	0xB806C010
+#define rc32365_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32365_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define CEDAR_CONFIG0_ADDR	0x80000000
+#define CEDAR_CONFIG1_ADDR	0x80000004
+#define CEDAR_CONFIG2_ADDR	0x80000008
+#define CEDAR_CONFIG3_ADDR	0x8000000C
+#define CEDAR_CONFIG4_ADDR	0x80000010
+#define CEDAR_CONFIG5_ADDR	0x80000014
+#define CEDAR_CONFIG6_ADDR	0x80000018
+#define CEDAR_CONFIG7_ADDR	0x8000001C
+#define CEDAR_CONFIG8_ADDR	0x80000020
+#define CEDAR_CONFIG9_ADDR	0x80000024
+#define CEDAR_CONFIG10_ADDR	0x80000028
+#define CEDAR_CONFIG11_ADDR	0x8000002C
+#define CEDAR_CONFIG12_ADDR	0x80000030
+#define CEDAR_CONFIG13_ADDR	0x80000034
+#define CEDAR_CONFIG14_ADDR	0x80000038
+#define CEDAR_CONFIG15_ADDR	0x8000003C
+#define CEDAR_CONFIG16_ADDR	0x80000040
+#define CEDAR_CONFIG17_ADDR	0x80000044
+#define CEDAR_CONFIG18_ADDR	0x80000048
+#define CEDAR_CONFIG19_ADDR	0x8000004C
+#define CEDAR_CONFIG20_ADDR	0x80000050
+#define CEDAR_CONFIG21_ADDR	0x80000054
+#define CEDAR_CONFIG22_ADDR	0x80000058
+#define CEDAR_CONFIG23_ADDR	0x8000005C
+#define CEDAR_CONFIG24_ADDR	0x80000060
+#define CEDAR_CONFIG25_ADDR	0x80000064
+#define CEDAR_CMD 	       (PCFG04_command_ioena_m  | \
+				PCFG04_command_memena_m | \
+				PCFG04_command_bmena_m  | \
+				PCFG04_command_mwinv_m  | \
+				PCFG04_command_parena_m | \
+				PCFG04_command_serrena_m )
+
+#define CEDAR_STAT	       (PCFG04_status_mdpe_m | \
+				PCFG04_status_sta_m  | \
+				PCFG04_status_rta_m  | \
+				PCFG04_status_rma_m  | \
+				PCFG04_status_sse_m  | \
+				PCFG04_status_pe_m)
+
+#define CEDAR_CNFG1	      ((CEDAR_STAT << 16) | \
+                                CEDAR_CMD)
+
+#define CEDAR_REVID		0
+#define CEDAR_CLASS_CODE	0
+#define CEDAR_CNFG2	      ((CEDAR_CLASS_CODE << 8) | \
+				CEDAR_REVID)
+
+#define CEDAR_CACHE_LINE_SIZE	4
+#define CEDAR_MASTER_LAT	0x3c
+#define CEDAR_HEADER_TYPE	0
+#define CEDAR_BIST		0
+
+#define CEDAR_CNFG3           ((CEDAR_BIST        << 24) | \
+		               (CEDAR_HEADER_TYPE << 16) | \
+		               (CEDAR_MASTER_LAT  <<  8) | \
+		                CEDAR_CACHE_LINE_SIZE)
+
+#define CEDAR_BAR0	        0x00000008 /* 128 MB Memory */
+#define CEDAR_BAR1	        0x18800001 /* 1 MB IO */
+#define CEDAR_BAR2	        0x18000001 /* 2 MB IO window for Cedar
+				              internal Registers */
+#define CEDAR_BAR3	        0x48000008 /* Spare 128 MB Memory */
+
+#define CEDAR_CNFG4	        CEDAR_BAR0
+#define CEDAR_CNFG5             CEDAR_BAR1
+#define CEDAR_CNFG6 	        CEDAR_BAR2
+#define CEDAR_CNFG7	        CEDAR_BAR3
+
+#define CEDAR_SUBSYS_VENDOR_ID  0
+#define CEDAR_SUBSYSTEM_ID	0
+#define CEDAR_CNFG8		0
+#define CEDAR_CNFG9		0
+#define CEDAR_CNFG10		0
+#define CEDAR_CNFG11 	      ((CEDAR_SUBSYS_VENDOR_ID << 16) | \
+			        CEDAR_SUBSYSTEM_ID)
+#define CEDAR_INT_LINE		1
+#define CEDAR_INT_PIN		1
+#define CEDAR_MIN_GNT		8
+#define CEDAR_MAX_LAT		0x38
+#define CEDAR_CNFG12		0
+#define CEDAR_CNFG13 		0
+#define CEDAR_CNFG14		0
+#define CEDAR_CNFG15	      ((CEDAR_MAX_LAT << 24) | \
+			       (CEDAR_MIN_GNT << 16) | \
+			       (CEDAR_INT_PIN <<  8) | \
+			        CEDAR_INT_LINE)
+#define	CEDAR_RETRY_LIMIT	0x80
+#define CEDAR_TRDY_LIMIT	0x80
+#define CEDAR_CNFG16          ((CEDAR_RETRY_LIMIT << 8) | \
+			        CEDAR_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+#ifdef __MIPSEB__
+#define CEDAR_PBA0C	       (((1 & 0x3) << PCIPBAC_mr_b) | \
+			        PCIPBAC_pp_m | \
+				PCIPBAC_sb_m | \
+			       (SIZE_128MB << SIZE_SHFT) | \
+			        PCIPBAC_p_m)
+#else
+
+#define CEDAR_PBA0C	       (((1 & 0x3) << PCIPBAC_mr_b) | \
+			        PCIPBAC_pp_m | \
+			       (SIZE_128MB << SIZE_SHFT) | \
+			        PCIPBAC_p_m)
+#endif
+#define CEDAR_CNFG17	        CEDAR_PBA0C
+#define CEDAR_PBA0M	        0x0
+#define CEDAR_CNFG18	        CEDAR_PBA0M
+
+#ifdef __MIPSEB__
+#define CEDAR_PBA1C	      ((SIZE_1MB << SIZE_SHFT) | \
+				PCIPBAC_sb_m | \
+			        PCIPBAC_msi_m)
+#else
+#define CEDAR_PBA1C	      ((SIZE_1MB << SIZE_SHFT) | \
+			        PCIPBAC_msi_m)
+#endif
+#define CEDAR_CNFG19	        CEDAR_PBA1C
+#define CEDAR_PBA1M	        0x0
+#define CEDAR_CNFG20	        CEDAR_PBA1M
+
+#ifdef __MIPSEB__
+#define CEDAR_PBA2C	      ((SIZE_2MB << SIZE_SHFT) |  \
+				PCIPBAC_sb_m | \
+			        PCIPBAC_msi_m)
+#else
+#define CEDAR_PBA2C	      ((SIZE_2MB << SIZE_SHFT) |  \
+			        PCIPBAC_msi_m)
+#endif
+
+#define CEDAR_CNFG21	        CEDAR_PBA2C
+#define CEDAR_PBA2M	        0x18000000
+#define CEDAR_CNFG22	        CEDAR_PBA2M
+
+#ifdef __MIPSEB__
+#define CEDAR_PBA3C	        PCIPBAC_sb_m
+#else
+#define CEDAR_PBA3C	        0 
+#endif
+
+#define CEDAR_CNFG23	        CEDAR_PBA3C
+#define CEDAR_PBA3M	        0
+#define CEDAR_CNFG24	        CEDAR_PBA3M
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
+#endif //__IDT_RC32365_PCI_V_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_dma.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_dma.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_dma.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,205 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   DMA register definition
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_DMA_H__
+#define __IDT_DMA_H__
+
+enum
+{
+	DMA0_PhysicalAddress	= 0x18040000,
+	DMA_PhysicalAddress	= DMA0_PhysicalAddress,		// Default
+
+	DMA0_VirtualAddress	= 0xb8040000,
+	DMA_VirtualAddress	= DMA0_VirtualAddress,		// Default
+} ;
+
+/*
+ * DMA descriptor (in physical memory).
+ */
+
+typedef struct DMAD_s
+{
+	u32			control ;	// Control. use DMAD_*
+	u32			ca ;		// Current Address.
+	u32			devcs ; 	// Device control and status.
+	u32			link ;		// Next descriptor in chain.
+} volatile *DMAD_t ;
+
+enum
+{
+	DMAD_size		= sizeof (struct DMAD_s),
+	DMAD_count_b		= 0,		// in DMAD_t -> control
+	DMAD_count_m		= 0x0003ffff,	// in DMAD_t -> control
+	DMAD_ds_b		= 20,		// in DMAD_t -> control
+	DMAD_ds_m		= 0x00300000,	// in DMAD_t -> control
+		DMAD_ds_ethRcv0_v	= 0,
+		DMAD_ds_ethXmt0_v	= 0,
+		DMAD_ds_memToFifo_v	= 0,
+		DMAD_ds_fifoToMem_v	= 0,
+		DMAD_ds_pciToMem_v	= 0,
+		DMAD_ds_memToPci_v	= 0,
+	
+	DMAD_devcmd_b		= 22,		// in DMAD_t -> control
+	DMAD_devcmd_m		= 0x01c00000,	// in DMAD_t -> control
+		DMAD_devcmd_byte_v	= 0,	//memory-to-memory
+		DMAD_devcmd_halfword_v	= 1,	//memory-to-memory
+		DMAD_devcmd_word_v	= 2,	//memory-to-memory
+		DMAD_devcmd_2words_v	= 3,	//memory-to-memory
+		DMAD_devcmd_4words_v	= 4,	//memory-to-memory
+		DMAD_devcmd_6words_v	= 5,	//memory-to-memory
+		DMAD_devcmd_8words_v	= 6,	//memory-to-memory
+		DMAD_devcmd_16words_v	= 7,	//memory-to-memory
+	DMAD_cof_b		= 25,		// chain on finished
+	DMAD_cof_m		= 0x02000000,	// 
+	DMAD_cod_b		= 26,		// chain on done
+	DMAD_cod_m		= 0x04000000,	// 
+	DMAD_iof_b		= 27,		// interrupt on finished
+	DMAD_iof_m		= 0x08000000,	// 
+	DMAD_iod_b		= 28,		// interrupt on done
+	DMAD_iod_m		= 0x10000000,	// 
+	DMAD_t_b		= 29,		// terminated
+	DMAD_t_m		= 0x20000000,	// 
+	DMAD_d_b		= 30,		// done
+	DMAD_d_m		= 0x40000000,	// 
+	DMAD_f_b		= 31,		// finished
+	DMAD_f_m		= 0x80000000,	// 
+} ;
+
+/*
+ * DMA register (within Internal Register Map).
+ */
+
+struct DMA_Chan_s
+{
+	u32		dmac ;		// Control.
+	u32		dmas ;		// Status.	
+	u32		dmasm ; 	// Mask.
+	u32		dmadptr ;	// Descriptor pointer.
+	u32		dmandptr ;	// Next descriptor pointer.
+};
+
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;
+
+//DMA_Channels	  use DMACH_count instead
+
+enum
+{
+	DMAC_run_b	= 0,		// 
+	DMAC_run_m	= 0x00000001,	// 
+	DMAC_dm_b	= 1,		// done mask
+	DMAC_dm_m	= 0x00000002,	// 
+	DMAC_mode_b	= 2,		// 
+	DMAC_mode_m	= 0x0000000c,	// 
+		DMAC_mode_auto_v	= 0,
+		DMAC_mode_burst_v	= 1,
+		DMAC_mode_transfer_v	= 2, //usually used
+		DMAC_mode_reserved_v	= 3,
+	DMAC_a_b	= 4,		// 
+	DMAC_a_m	= 0x00000010,	// 
+
+	DMAS_f_b	= 0,		// finished (sticky) 
+	DMAS_f_m	= 0x00000001,	//		     
+	DMAS_d_b	= 1,		// done (sticky)     
+	DMAS_d_m	= 0x00000002,	//		     
+	DMAS_c_b	= 2,		// chain (sticky)    
+	DMAS_c_m	= 0x00000004,	//		     
+	DMAS_e_b	= 3,		// error (sticky)    
+	DMAS_e_m	= 0x00000008,	//		     
+	DMAS_h_b	= 4,		// halt (sticky)     
+	DMAS_h_m	= 0x00000010,	//		     
+
+	DMASM_f_b	= 0,		// finished (1=mask)
+	DMASM_f_m	= 0x00000001,	// 
+	DMASM_d_b	= 1,		// done (1=mask)
+	DMASM_d_m	= 0x00000002,	// 
+	DMASM_c_b	= 2,		// chain (1=mask)
+	DMASM_c_m	= 0x00000004,	// 
+	DMASM_e_b	= 3,		// error (1=mask)
+	DMASM_e_m	= 0x00000008,	// 
+	DMASM_h_b	= 4,		// halt (1=mask)
+	DMASM_h_m	= 0x00000010,	// 
+} ;
+
+/*
+ * DMA channel definitions
+ */
+
+enum
+{
+	DMACH_ethRcv0 = 0,
+	DMACH_ethXmt0 = 1,
+	DMACH_memToFifo = 2,
+	DMACH_fifoToMem = 3,
+	DMACH_pciToMem = 4,
+	DMACH_memToPci = 5,
+
+	DMACH_count //must be last
+};
+
+
+typedef struct DMAC_s
+{
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]
+} volatile *DMA_t ;
+
+
+/*
+ * External DMA parameters
+*/
+
+enum
+{
+	DMADEVCMD_ts_b	= 0,		// ts field in devcmd
+	DMADEVCMD_ts_m	= 0x00000007,	// ts field in devcmd
+		DMADEVCMD_ts_byte_v	= 0,
+		DMADEVCMD_ts_halfword_v	= 1,
+		DMADEVCMD_ts_word_v	= 2,
+		DMADEVCMD_ts_2word_v	= 3,
+		DMADEVCMD_ts_4word_v	= 4,
+		DMADEVCMD_ts_6word_v	= 5,
+		DMADEVCMD_ts_8word_v	= 6,
+		DMADEVCMD_ts_16word_v	= 7
+};
+
+
+#endif	// __IDT_DMA_H__
+
+
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_dma_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,89 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for DMA controller.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_DMA_V_H__
+#define __IDT_DMA_V_H__
+
+#include  <asm/idt-boards/rc32434/rc32434_dma.h> 
+#include  <asm/idt-boards/rc32434/rc32434.h>
+
+#define DMA_CHAN_OFFSET  0x14
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) != 0)
+#define DMA_COUNT(count)   \
+  ((count) & DMAD_count_m)
+
+#define DMA_HALT_TIMEOUT 500
+
+
+static inline int rc32434_halt_dma(DMA_Chan_t ch)
+{
+	int timeout=1;
+	if (rc32434_readl(&ch->dmac) & DMAC_run_m) {
+		rc32434_writel(0, &ch->dmac); 
+		
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (rc32434_readl(&ch->dmas) & DMAS_h_m) {
+				rc32434_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+
+	}
+	
+	return timeout ? 0 : 1;
+}
+
+static inline void rc32434_start_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	rc32434_writel(0, &ch->dmandptr); 
+	rc32434_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32434_chain_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	rc32434_writel(dma_addr, &ch->dmandptr);
+}
+
+#endif	// __IDT_DMA_V_H__
+
+
+
+
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_eth.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_eth.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_eth.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,333 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Ethernet register definition
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef	__IDT_ETH_H__
+#define	__IDT_ETH_H__
+
+
+enum
+{
+	ETH0_PhysicalAddress	= 0x18060000,
+	ETH_PhysicalAddress	= ETH0_PhysicalAddress,		// Default
+
+	ETH0_VirtualAddress	= 0xb8060000,
+	ETH_VirtualAddress	= ETH0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32 ethintfc		;
+	u32 ethfifott		;
+	u32 etharc		;
+	u32 ethhash0		;
+	u32 ethhash1		;
+	u32 ethu0 [4]		;	// Reserved.	
+	u32 ethpfs		;
+	u32 ethmcp		;
+	u32 eth_u1 [10]		;	// Reserved.
+	u32 ethspare		;
+	u32 eth_u2 [42]		;	// Reserved. 
+	u32 ethsal0		;
+	u32 ethsah0		;
+	u32 ethsal1		;
+	u32 ethsah1		;
+	u32 ethsal2		;
+	u32 ethsah2		;
+	u32 ethsal3		;
+	u32 ethsah3		;
+	u32 ethrbc		;
+	u32 ethrpc		;
+	u32 ethrupc		;
+	u32 ethrfc		;
+	u32 ethtbc		;
+	u32 ethgpf		;
+	u32 eth_u9 [50]		;	// Reserved.	
+	u32 ethmac1		;
+	u32 ethmac2		;
+	u32 ethipgt		;
+	u32 ethipgr		;
+	u32 ethclrt		;
+	u32 ethmaxf		;
+	u32 eth_u10		;	// Reserved.	
+	u32 ethmtest		;
+	u32 miimcfg		;
+	u32 miimcmd		;
+	u32 miimaddr		;
+	u32 miimwtd		;
+	u32 miimrdd		;
+	u32 miimind		;
+	u32 eth_u11		;	// Reserved.
+	u32 eth_u12		;	// Reserved.
+	u32 ethcfsa0		;
+	u32 ethcfsa1		;
+	u32 ethcfsa2		;
+} volatile *ETH_t;
+
+enum
+{
+	ETHINTFC_en_b		= 0,
+	ETHINTFC_en_m		= 0x00000001,
+	ETHINTFC_its_b		= 1,
+	ETHINTFC_its_m		= 0x00000002,
+	ETHINTFC_rip_b		= 2,
+	ETHINTFC_rip_m		= 0x00000004,
+	ETHINTFC_jam_b		= 3,
+	ETHINTFC_jam_m		= 0x00000008,
+	ETHINTFC_ovr_b		= 4,
+	ETHINTFC_ovr_m		= 0x00000010,
+	ETHINTFC_und_b		= 5,
+	ETHINTFC_und_m		= 0x00000020,
+
+	ETHFIFOTT_tth_b		= 0,
+	ETHFIFOTT_tth_m		= 0x0000007f,
+
+	ETHARC_pro_b		= 0,
+	ETHARC_pro_m		= 0x00000001,
+	ETHARC_am_b		= 1,
+	ETHARC_am_m		= 0x00000002,
+	ETHARC_afm_b		= 2,
+	ETHARC_afm_m		= 0x00000004,
+	ETHARC_ab_b		= 3,
+	ETHARC_ab_m		= 0x00000008,
+
+	ETHSAL_byte5_b		= 0,
+	ETHSAL_byte5_m		= 0x000000ff,
+	ETHSAL_byte4_b		= 8,
+	ETHSAL_byte4_m		= 0x0000ff00,
+	ETHSAL_byte3_b		= 16,
+	ETHSAL_byte3_m		= 0x00ff0000,
+	ETHSAL_byte2_b		= 24,
+	ETHSAL_byte2_m		= 0xff000000,
+
+	ETHSAH_byte1_b		= 0,
+	ETHSAH_byte1_m		= 0x000000ff,
+	ETHSAH_byte0_b		= 8,
+	ETHSAH_byte0_m		= 0x0000ff00,
+	
+	ETHGPF_ptv_b		= 0,
+	ETHGPF_ptv_m		= 0x0000ffff,
+
+	ETHPFS_pfd_b		= 0,
+	ETHPFS_pfd_m		= 0x00000001,
+
+	ETHCFSA0_cfsa4_b	= 0,
+	ETHCFSA0_cfsa4_m	= 0x000000ff,
+	ETHCFSA0_cfsa5_b	= 8,
+	ETHCFSA0_cfsa5_m	= 0x0000ff00,
+
+	ETHCFSA1_cfsa2_b	= 0,
+	ETHCFSA1_cfsa2_m	= 0x000000ff,
+	ETHCFSA1_cfsa3_b	= 8,
+	ETHCFSA1_cfsa3_m	= 0x0000ff00,
+
+	ETHCFSA2_cfsa0_b	= 0,
+	ETHCFSA2_cfsa0_m	= 0x000000ff,
+	ETHCFSA2_cfsa1_b	= 8,
+	ETHCFSA2_cfsa1_m	= 0x0000ff00,
+
+	ETHMAC1_re_b		= 0,
+	ETHMAC1_re_m		= 0x00000001,
+	ETHMAC1_paf_b		= 1,
+	ETHMAC1_paf_m		= 0x00000002,
+	ETHMAC1_rfc_b		= 2,
+	ETHMAC1_rfc_m		= 0x00000004,
+	ETHMAC1_tfc_b		= 3,
+	ETHMAC1_tfc_m		= 0x00000008,
+	ETHMAC1_lb_b		= 4,
+	ETHMAC1_lb_m		= 0x00000010,
+	ETHMAC1_mr_b		= 31,
+	ETHMAC1_mr_m		= 0x80000000,
+
+	ETHMAC2_fd_b		= 0,
+	ETHMAC2_fd_m		= 0x00000001,
+	ETHMAC2_flc_b		= 1,
+	ETHMAC2_flc_m		= 0x00000002,
+	ETHMAC2_hfe_b		= 2,
+	ETHMAC2_hfe_m		= 0x00000004,
+	ETHMAC2_dc_b		= 3,
+	ETHMAC2_dc_m		= 0x00000008,
+	ETHMAC2_cen_b		= 4,
+	ETHMAC2_cen_m		= 0x00000010,
+	ETHMAC2_pe_b		= 5,
+	ETHMAC2_pe_m		= 0x00000020,
+	ETHMAC2_vpe_b		= 6,
+	ETHMAC2_vpe_m		= 0x00000040,
+	ETHMAC2_ape_b		= 7,
+	ETHMAC2_ape_m		= 0x00000080,
+	ETHMAC2_ppe_b		= 8,
+	ETHMAC2_ppe_m		= 0x00000100,
+	ETHMAC2_lpe_b		= 9,
+	ETHMAC2_lpe_m		= 0x00000200,
+	ETHMAC2_nb_b		= 12,
+	ETHMAC2_nb_m		= 0x00001000,
+	ETHMAC2_bp_b		= 13,
+	ETHMAC2_bp_m		= 0x00002000,
+	ETHMAC2_ed_b		= 14,
+	ETHMAC2_ed_m		= 0x00004000,
+
+	ETHIPGT_ipgt_b		= 0,
+	ETHIPGT_ipgt_m		= 0x0000007f,
+
+	ETHIPGR_ipgr2_b		= 0,
+	ETHIPGR_ipgr2_m		= 0x0000007f,
+	ETHIPGR_ipgr1_b		= 8,
+	ETHIPGR_ipgr1_m		= 0x00007f00,
+
+	ETHCLRT_maxret_b	= 0,
+	ETHCLRT_maxret_m	= 0x0000000f,
+	ETHCLRT_colwin_b	= 8,
+	ETHCLRT_colwin_m	= 0x00003f00,
+
+	ETHMAXF_maxf_b		= 0,
+	ETHMAXF_maxf_m		= 0x0000ffff,
+
+	ETHMTEST_tb_b		= 2,
+	ETHMTEST_tb_m		= 0x00000004,
+
+	ETHMCP_div_b		= 0,
+	ETHMCP_div_m		= 0x000000ff,
+	
+	MIIMCFG_rsv_b		= 0,
+	MIIMCFG_rsv_m		= 0x0000000c,
+
+	MIIMCMD_rd_b		= 0,
+	MIIMCMD_rd_m		= 0x00000001,
+	MIIMCMD_scn_b		= 1,
+	MIIMCMD_scn_m		= 0x00000002,
+
+	MIIMADDR_regaddr_b	= 0,
+	MIIMADDR_regaddr_m	= 0x0000001f,
+	MIIMADDR_phyaddr_b	= 8,
+	MIIMADDR_phyaddr_m	= 0x00001f00,
+
+	MIIMWTD_wdata_b		= 0,
+	MIIMWTD_wdata_m		= 0x0000ffff,
+
+	MIIMRDD_rdata_b		= 0,
+	MIIMRDD_rdata_m		= 0x0000ffff,
+
+	MIIMIND_bsy_b		= 0,
+	MIIMIND_bsy_m		= 0x00000001,
+	MIIMIND_scn_b		= 1,
+	MIIMIND_scn_m		= 0x00000002,
+	MIIMIND_nv_b		= 2,
+	MIIMIND_nv_m		= 0x00000004,
+
+} ;
+
+/*
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors.
+ */
+enum
+{
+	ETHRX_fd_b		= 0,
+	ETHRX_fd_m		= 0x00000001,
+	ETHRX_ld_b		= 1,
+	ETHRX_ld_m		= 0x00000002,
+	ETHRX_rok_b		= 2,
+	ETHRX_rok_m		= 0x00000004,
+	ETHRX_fm_b		= 3,
+	ETHRX_fm_m		= 0x00000008,
+	ETHRX_mp_b		= 4,
+	ETHRX_mp_m		= 0x00000010,
+	ETHRX_bp_b		= 5,
+	ETHRX_bp_m		= 0x00000020,
+	ETHRX_vlt_b		= 6,
+	ETHRX_vlt_m		= 0x00000040,
+	ETHRX_cf_b		= 7,
+	ETHRX_cf_m		= 0x00000080,
+	ETHRX_ovr_b		= 8,
+	ETHRX_ovr_m		= 0x00000100,
+	ETHRX_crc_b		= 9,
+	ETHRX_crc_m		= 0x00000200,
+	ETHRX_cv_b		= 10,
+	ETHRX_cv_m		= 0x00000400,
+	ETHRX_db_b		= 11,
+	ETHRX_db_m		= 0x00000800,
+	ETHRX_le_b		= 12,
+	ETHRX_le_m		= 0x00001000,
+	ETHRX_lor_b		= 13,
+	ETHRX_lor_m		= 0x00002000,
+	ETHRX_ces_b		= 14,
+	ETHRX_ces_m		= 0x00004000,
+	ETHRX_length_b		= 16,
+	ETHRX_length_m		= 0xffff0000,
+
+	ETHTX_fd_b		= 0,
+	ETHTX_fd_m		= 0x00000001,
+	ETHTX_ld_b		= 1,
+	ETHTX_ld_m		= 0x00000002,
+	ETHTX_oen_b		= 2,
+	ETHTX_oen_m		= 0x00000004,
+	ETHTX_pen_b		= 3,
+	ETHTX_pen_m		= 0x00000008,
+	ETHTX_cen_b		= 4,
+	ETHTX_cen_m		= 0x00000010,
+	ETHTX_hen_b		= 5,
+	ETHTX_hen_m		= 0x00000020,
+	ETHTX_tok_b		= 6,
+	ETHTX_tok_m		= 0x00000040,
+	ETHTX_mp_b		= 7,
+	ETHTX_mp_m		= 0x00000080,
+	ETHTX_bp_b		= 8,
+	ETHTX_bp_m		= 0x00000100,
+	ETHTX_und_b		= 9,
+	ETHTX_und_m		= 0x00000200,
+	ETHTX_of_b		= 10,
+	ETHTX_of_m		= 0x00000400,
+	ETHTX_ed_b		= 11,
+	ETHTX_ed_m		= 0x00000800,
+	ETHTX_ec_b		= 12,
+	ETHTX_ec_m		= 0x00001000,
+	ETHTX_lc_b		= 13,
+	ETHTX_lc_m		= 0x00002000,
+	ETHTX_td_b		= 14,
+	ETHTX_td_m		= 0x00004000,
+	ETHTX_crc_b		= 15,
+	ETHTX_crc_m		= 0x00008000,
+	ETHTX_le_b		= 16,
+	ETHTX_le_m		= 0x00010000,
+	ETHTX_cc_b		= 17,
+	ETHTX_cc_m		= 0x001E0000,
+} ;
+
+#endif	// __IDT_ETH_H__
+
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_eth_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,77 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Ethernet register definition
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef	__IDT_ETH_V_H__
+#define	__IDT_ETH_V_H__
+
+#include  <asm/idt-boards/rc32434/rc32434_eth.h> 
+
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b )   /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b )    /* Multicast        */
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b )    /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b )   /* Transmit FIFO Underflow */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b )    /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b )    /* Excessive deferral  */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)     /* Excessive collisions  */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b )    /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b )    /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b )   /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b )    /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* Collision Count  */
+
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b)    /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)     /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)     /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)     /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b)    /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)     /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b)    /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b)    /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)     /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)     /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)     /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b)    /* Length Out of Range */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b)  /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> ETHRX_length_b)   /* Length of the received packet */
+#endif	// __IDT_ETH_V_H__
+
+
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_gpio.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,167 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   GPIO register definition
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_GPIO_H__
+#define __IDT_GPIO_H__
+
+enum
+{
+	GPIO0_PhysicalAddress	= 0x18050000,
+	GPIO_PhysicalAddress	= GPIO0_PhysicalAddress,	// Default
+
+	GPIO0_VirtualAddress	= 0xb8050000,
+	GPIO_VirtualAddress	= GPIO0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32   gpiofunc;   /* GPIO Function Register
+			   * gpiofunc[x]==0 bit = gpio
+			   * func[x]==1  bit = altfunc
+			   */
+	u32   gpiocfg;	  /* GPIO Configuration Register
+			   * gpiocfg[x]==0 bit = input
+			   * gpiocfg[x]==1 bit = output
+			   */
+	u32   gpiod;	  /* GPIO Data Register
+			   * gpiod[x] read/write gpio pinX status
+			   */
+	u32   gpioilevel; /* GPIO Interrupt Status Register
+			   * interrupt level (see gpioistat)
+			   */
+	u32   gpioistat;  /* Gpio Interrupt Status Register
+			   * istat[x] = (gpiod[x] == level[x])
+			   * cleared in ISR (STICKY bits)
+			   */
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register */
+} volatile * GPIO_t ;
+
+typedef enum
+{
+	GPIO_gpio_v		= 0,		// gpiofunc use pin as GPIO.
+	GPIO_alt_v		= 1,		// gpiofunc use pin as alt.
+	GPIO_input_v		= 0,		// gpiocfg use pin as input.
+	GPIO_output_v		= 1,		// gpiocfg use pin as output.
+	GPIO_pin0_b		= 0,
+	GPIO_pin0_m		= 0x00000001,
+	GPIO_pin1_b		= 1,
+	GPIO_pin1_m		= 0x00000002,
+	GPIO_pin2_b		= 2,
+	GPIO_pin2_m		= 0x00000004,
+	GPIO_pin3_b		= 3,
+	GPIO_pin3_m		= 0x00000008,
+	GPIO_pin4_b		= 4,
+	GPIO_pin4_m		= 0x00000010,
+	GPIO_pin5_b		= 5,
+	GPIO_pin5_m		= 0x00000020,
+	GPIO_pin6_b		= 6,
+	GPIO_pin6_m		= 0x00000040,
+	GPIO_pin7_b		= 7,
+	GPIO_pin7_m		= 0x00000080,
+	GPIO_pin8_b		= 8,
+	GPIO_pin8_m		= 0x00000100,
+	GPIO_pin9_b		= 9,
+	GPIO_pin9_m		= 0x00000200,
+	GPIO_pin10_b		= 10,
+	GPIO_pin10_m		= 0x00000400,
+	GPIO_pin11_b		= 11,
+	GPIO_pin11_m		= 0x00000800,
+	GPIO_pin12_b		= 12,
+	GPIO_pin12_m		= 0x00001000,
+	GPIO_pin13_b		= 13,
+	GPIO_pin13_m		= 0x00002000,
+
+// Alternate function pins.  Corrsponding gpiofunc bit set to GPIO_alt_v.
+
+	GPIO_u0sout_b		= GPIO_pin0_b,		// UART 0 serial out.
+	GPIO_u0sout_m		= GPIO_pin0_m,
+		GPIO_u0sout_cfg_v	= GPIO_output_v,
+	GPIO_u0sinp_b	= GPIO_pin1_b,			// UART 0 serial in.
+	GPIO_u0sinp_m	= GPIO_pin1_m,
+		GPIO_u0sinp_cfg_v	= GPIO_input_v,
+	GPIO_u0rtsn_b	= GPIO_pin2_b,			// UART 0 req. to send.
+	GPIO_u0rtsn_m	= GPIO_pin2_m,
+		GPIO_u0rtsn_cfg_v	= GPIO_output_v,
+	GPIO_u0ctsn_b	= GPIO_pin3_b,			// UART 0 clear to send.
+	GPIO_u0ctsn_m	= GPIO_pin3_m,
+		GPIO_u0ctsn_cfg_v	= GPIO_input_v,
+
+	GPIO_maddr22_b		= GPIO_pin4_b, 	// M&P bus bit 22.
+	GPIO_maddr22_m		= GPIO_pin4_m,
+		GPIO_maddr22_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr23_b		= GPIO_pin5_b, 	// M&P bus bit 23.
+	GPIO_maddr23_m		= GPIO_pin5_m,
+		GPIO_maddr23_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr24_b		= GPIO_pin6_b, 	// M&P bus bit 24.
+	GPIO_maddr24_m		= GPIO_pin6_m,
+		GPIO_maddr24_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr25_b		= GPIO_pin7_b, 	// M&P bus bit 25.
+	GPIO_maddr25_m		= GPIO_pin7_m,
+		GPIO_maddr25_cfg_v	= GPIO_output_v,
+
+	GPIO_cpudmadebug_b 	= GPIO_pin8_b, 	// CPU or DMA debug pin
+	GPIO_cpudmadebug_m 	= GPIO_pin8_m,
+		GPIO_cpudmadebug_cfg_v	= GPIO_output_v,
+
+	GPIO_pcireq4_b 	= GPIO_pin9_b, 	// PCI Request 4
+	GPIO_pcireq4_m 	= GPIO_pin9_m,
+		GPIO_pcireq4_cfg_v	= GPIO_input_v,
+
+	GPIO_pcigrant4_b 	= GPIO_pin10_b, 	// PCI Grant 4
+	GPIO_pcigrant4_m 	= GPIO_pin10_m,
+		GPIO_pcigrant4_cfg_v	= GPIO_output_v,
+
+	GPIO_pcireq5_b 	= GPIO_pin11_b, 	// PCI Request 5
+	GPIO_pcireq5_m 	= GPIO_pin11_m,
+		GPIO_pcireq5_cfg_v	= GPIO_input_v,
+
+	GPIO_pcigrant5_b 	= GPIO_pin12_b, 	// PCI Grant 5
+	GPIO_pcigrant5_m 	= GPIO_pin12_m,
+		GPIO_pcigrant5_cfg_v	= GPIO_output_v,
+
+	GPIO_pcimuintn_b	= GPIO_pin13_b, 	// PCI messaging int.
+	GPIO_pcimuintn_m	= GPIO_pin13_m,
+		GPIO_pcimuintn_cfg_v	= GPIO_output_v,
+
+} GPIO_DEFS_t;
+
+#endif	// __IDT_GPIO_H__
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,199 @@
+ /**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32434 CPU
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef _RC32434_H_
+#define _RC32434_H_
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/idt-boards/rc32434/rc32434_timer.h>
+
+#define RC32434_REG_BASE   0x18000000
+
+
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)
+#define idt_timer     ((volatile TIM_t)  TIM0_VirtualAddress)
+#define idt_gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)
+
+#define IDT_CLOCK_MULT 2
+#define MIPS_CPU_TIMER_IRQ 7
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32434_REG_BASE + 0x38000)
+#define IC_GROUP0_MASK     (RC32434_REG_BASE + 0x38008)
+#define IC_GROUP_OFFSET    0x0C
+#define RTC_BASE           0xBA001FF0
+
+#define NUM_INTR_GROUPS    5
+/* 16550 UARTs */
+
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers start here */
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers start here */
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers start here */
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)
+
+#ifdef __MIPSEB__
+
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58003)
+#define EB434_UART1_BASE   (0x19800003)
+
+#else
+
+#define RC32434_UART0_BASE (RC32434_REG_BASE + 0x58000)
+#define EB434_UART1_BASE   (0x19800000)
+
+#endif
+
+#define RC32434_UART0_IRQ  GROUP3_IRQ_BASE + 0
+#define EB434_UART1_IRQ    GROUP4_IRQ_BASE + 11
+
+#define RC32434_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+/* cpu pipeline flush */
+static inline void rc32434_sync(void)
+{
+        __asm__ volatile ("sync");
+}
+
+static inline void rc32434_sync_udelay(int us)
+{
+        __asm__ volatile ("sync");
+        udelay(us);
+}
+
+static inline void rc32434_sync_delay(int ms)
+{
+        __asm__ volatile ("sync");
+        mdelay(ms);
+}
+
+
+
+/*
+ * Macros to access internal RC32434 registers. No byte
+ * swapping should be done when accessing the internal
+ * registers.
+ */
+
+#define rc32434_readb __raw_readb
+#define rc32434_readw __raw_readw
+#define rc32434_readl __raw_readl
+
+#define rc32434_writeb __raw_writeb
+#define rc32434_writew __raw_writew
+#define rc32434_writel __raw_writel
+
+#if 0
+static inline u8 rc32434_readb(unsigned long pa)
+{
+	return *((volatile u8 *)KSEG1ADDR(pa));
+}
+static inline u16 rc32434_readw(unsigned long pa)
+{
+	return *((volatile u16 *)KSEG1ADDR(pa));
+}
+static inline u32 rc32434_readl(unsigned long pa)
+{
+	return *((volatile u32 *)KSEG1ADDR(pa));
+}
+static inline void rc32434_writeb(u8 val, unsigned long pa)
+{
+	*((volatile u8 *)KSEG1ADDR(pa)) = val;
+}
+static inline void rc32434_writew(u16 val, unsigned long pa)
+{
+	*((volatile u16 *)KSEG1ADDR(pa)) = val;
+}
+static inline void rc32434_writel(u32 val, unsigned long pa)
+{
+	*((volatile u32 *)KSEG1ADDR(pa)) = val;
+}
+
+#endif
+
+
+/*
+ * C access to CLZ and CLO instructions
+ * (count leading zeroes/ones).
+ */
+static inline int rc32434_clz(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clz\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+static inline int rc32434_clo(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clo\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+#endif /* _RC32434_H_ */
+
+
+
+
+
+
+
+
+
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_integ.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_integ.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_integ.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_integ.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,90 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   System Integrity register definition
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_INTEG_H__
+#define __IDT_INTEG_H__
+
+enum
+{
+	INTEG0_PhysicalAddress	= 0x18030000,
+	INTEG_PhysicalAddress	= INTEG0_PhysicalAddress,	// Default
+
+	INTEG0_VirtualAddress	= 0xB8030000,
+	INTEG_VirtualAddress	= INTEG0_VirtualAddress,	// Default
+} ;
+
+// if you are looking for CEA, try rst.h
+typedef struct
+{
+	u32 filler [0xc] ;		// 0x30 bytes unused.
+	u32 errcs ;			// sticky use ERRCS_
+	u32 wtcount ;			// Watchdog timer count reg.
+	u32 wtcompare ;			// Watchdog timer timeout value.
+	u32 wtc ;			// Watchdog timer control. use WTC_
+} volatile *INTEG_t ;
+
+enum
+{
+	ERRCS_wto_b		= 0,		// In INTEG_t -> errcs
+	ERRCS_wto_m		= 0x00000001,
+	ERRCS_wne_b		= 1,		// In INTEG_t -> errcs
+	ERRCS_wne_m		= 0x00000002,
+	ERRCS_ucw_b		= 2,		// In INTEG_t -> errcs
+	ERRCS_ucw_m		= 0x00000004,
+	ERRCS_ucr_b		= 3,		// In INTEG_t -> errcs
+	ERRCS_ucr_m		= 0x00000008,
+	ERRCS_upw_b		= 4,		// In INTEG_t -> errcs
+	ERRCS_upw_m		= 0x00000010,
+	ERRCS_upr_b		= 5,		// In INTEG_t -> errcs
+	ERRCS_upr_m		= 0x00000020,
+	ERRCS_udw_b		= 6,		// In INTEG_t -> errcs
+	ERRCS_udw_m		= 0x00000040,
+	ERRCS_udr_b		= 7,		// In INTEG_t -> errcs
+	ERRCS_udr_m		= 0x00000080,
+	ERRCS_sae_b		= 8,		// In INTEG_t -> errcs
+	ERRCS_sae_m		= 0x00000100,
+	ERRCS_wre_b		= 9,		// In INTEG_t -> errcs
+	ERRCS_wre_m		= 0x00000200,
+
+	WTC_en_b		= 0,		// In INTEG_t -> wtc
+	WTC_en_m		= 0x00000001,
+	WTC_to_b		= 1,		// In INTEG_t -> wtc
+	WTC_to_m		= 0x00000002,
+} ;
+
+#endif	// __IDT_INTEG_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_int.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_int.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_int.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_int.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,174 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Interrupt Controller register definition.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_INT_H__
+#define __IDT_INT_H__
+
+enum
+{
+	INT0_PhysicalAddress	= 0x18038000,
+	INT_PhysicalAddress	= INT0_PhysicalAddress,		// Default
+
+	INT0_VirtualAddress	= 0xB8038000,
+	INT_VirtualAddress	= INT0_VirtualAddress,		// Default
+} ;
+
+struct INT_s
+{
+	u32		ipend ;		//Pending interrupts. use INT?_
+	u32		itest ;		//Test bits.		use INT?_
+	u32		imask ;		//Interrupt disabled when set. use INT?_
+} ;
+
+enum
+{
+	IPEND2	= 0,			// HW 2 interrupt to core. use INT2_
+	IPEND3	= 1,			// HW 3 interrupt to core. use INT3_
+	IPEND4	= 2,			// HW 4 interrupt to core. use INT4_
+	IPEND5	= 3,			// HW 5 interrupt to core. use INT5_
+	IPEND6	= 4,			// HW 6 interrupt to core. use INT6_
+
+	IPEND_count,			// must be last (used in loops)
+	IPEND_min	= IPEND2	// min IPEND (used in loops)
+};
+
+typedef struct INTC_s
+{
+	struct INT_s	i [IPEND_count] ;// use i[IPEND?] = INT?_
+	u32		nmips ;		// use NMIPS_
+} volatile *INT_t ;
+
+enum
+{
+	INT2_timer0_b			= 0,
+	INT2_timer0_m			= 0x00000001,
+	INT2_timer1_b			= 1,
+	INT2_timer1_m			= 0x00000002,
+	INT2_timer2_b			= 2,
+	INT2_timer2_m			= 0x00000004,
+	INT2_refresh_b			= 3,
+	INT2_refresh_m			= 0x00000008,
+	INT2_watchdogTimeout_b		= 4,
+	INT2_watchdogTimeout_m		= 0x00000010,
+	INT2_undecodedCpuWrite_b	= 5,
+	INT2_undecodedCpuWrite_m	= 0x00000020,
+	INT2_undecodedCpuRead_b		= 6,
+	INT2_undecodedCpuRead_m		= 0x00000040,
+	INT2_undecodedPciWrite_b	= 7,
+	INT2_undecodedPciWrite_m	= 0x00000080,
+	INT2_undecodedPciRead_b		= 8,
+	INT2_undecodedPciRead_m		= 0x00000100,
+	INT2_undecodedDmaWrite_b	= 9,
+	INT2_undecodedDmaWrite_m	= 0x00000200,
+	INT2_undecodedDmaRead_b		= 10,
+	INT2_undecodedDmaRead_m		= 0x00000400,
+	INT2_ipBusSlaveAckError_b	= 11,
+	INT2_ipBusSlaveAckError_m	= 0x00000800,
+
+	INT3_dmaChannel0_b		= 0,
+	INT3_dmaChannel0_m		= 0x00000001,
+	INT3_dmaChannel1_b		= 1,
+	INT3_dmaChannel1_m		= 0x00000002,
+	INT3_dmaChannel2_b		= 2,
+	INT3_dmaChannel2_m		= 0x00000004,
+	INT3_dmaChannel3_b		= 3,
+	INT3_dmaChannel3_m		= 0x00000008,
+	INT3_dmaChannel4_b		= 4,
+	INT3_dmaChannel4_m		= 0x00000010,
+	INT3_dmaChannel5_b		= 5,
+	INT3_dmaChannel5_m		= 0x00000020,
+
+	INT5_uartGeneral0_b		= 0,
+	INT5_uartGeneral0_m		= 0x00000001,
+	INT5_uartTxrdy0_b		= 1,
+	INT5_uartTxrdy0_m		= 0x00000002,
+	INT5_uartRxrdy0_b		= 2,
+	INT5_uartRxrdy0_m		= 0x00000004,
+	INT5_pci_b			= 3,
+	INT5_pci_m			= 0x00000008,
+	INT5_pciDecoupled_b		= 4,
+	INT5_pciDecoupled_m		= 0x00000010,
+	INT5_spi_b			= 5,
+	INT5_spi_m			= 0x00000020,
+	INT5_deviceDecoupled_b		= 6,
+	INT5_deviceDecoupled_m		= 0x00000040,
+	INT5_eth0Ovr_b			= 9,
+	INT5_eth0Ovr_m			= 0x00000200,
+	INT5_eth0Und_b			= 10,
+	INT5_eth0Und_m			= 0x00000400,
+	INT5_eth0Pfd_b			= 11,
+	INT5_eth0Pfd_m			= 0x00000800,
+	INT5_nvram_b			= 12,
+	INT5_nvram_m			= 0x00001000,
+
+	INT6_gpio0_b			= 0,
+	INT6_gpio0_m			= 0x00000001,
+	INT6_gpio1_b			= 1,
+	INT6_gpio1_m			= 0x00000002,
+	INT6_gpio2_b			= 2,
+	INT6_gpio2_m			= 0x00000004,
+	INT6_gpio3_b			= 3,
+	INT6_gpio3_m			= 0x00000008,
+	INT6_gpio4_b			= 4,
+	INT6_gpio4_m			= 0x00000010,
+	INT6_gpio5_b			= 5,
+	INT6_gpio5_m			= 0x00000020,
+	INT6_gpio6_b			= 6,
+	INT6_gpio6_m			= 0x00000040,
+	INT6_gpio7_b			= 7,
+	INT6_gpio7_m			= 0x00000080,
+	INT6_gpio8_b			= 8,
+	INT6_gpio8_m			= 0x00000100,
+	INT6_gpio9_b			= 9,
+	INT6_gpio9_m			= 0x00000200,
+	INT6_gpio10_b			= 10,
+	INT6_gpio10_m			= 0x00000400,
+	INT6_gpio11_b			= 11,
+	INT6_gpio11_m			= 0x00000800,
+	INT6_gpio12_b			= 12,
+	INT6_gpio12_m			= 0x00001000,
+	INT6_gpio13_b			= 13,
+	INT6_gpio13_m			= 0x00002000,
+
+	NMIPS_gpio_b			= 0,
+	NMIPS_gpio_m			= 0x00000001,
+} ;
+
+#endif	// __IDT_INT_H__
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_iparb.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,111 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   IP Arbiter register definitions
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt,neb
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_IPARB_H__
+#define __IDT_IPARB_H__
+
+enum
+{
+	IPARB0_PhysicalAddress	= 0x18048000,
+	IPARB_PhysicalAddress	= IPARB0_PhysicalAddress,	// Default
+
+	IPARB0_VirtualAddress	= 0xB8048000,
+	IPARB_VirtualAddress	= IPARB0_VirtualAddress,	// Default
+} ;
+
+enum
+{
+	IPABMXC_ethernet0Receive	= 0,
+	IPABMXC_ethernet0Transmit	= 1,
+	IPABMXC_memoryToHoldFifo	= 2,
+	IPABMXC_holdFifoToMemory	= 3,
+	IPABMXC_pciToMemory		= 4,
+	IPABMXC_memoryToPci		= 5,
+	IPABMXC_pciTarget		= 6,
+	IPABMXC_pciTargetStart		= 7,
+	IPABMXC_cpuToIpBus		= 8,
+
+	IPABMXC_Count,				// Must be last in list !
+	IPABMXC_Min			= IPABMXC_ethernet0Receive,
+
+	IPAPXC_PriorityCount	= 4,		// 3-highest, 0-lowest.
+} ;
+
+typedef struct
+{
+	u32	ipapc [IPAPXC_PriorityCount] ;	// ipapc[IPAPXC_] = IPAPC_
+	u32	ipabmc [IPABMXC_Count] ;	// ipabmc[IPABMXC_] = IPABMC_
+	u32	ipac ;				// use IPAC_
+	u32	ipaitcc;			// use IPAITCC_
+	u32	ipaspare ;
+} volatile * IPARB_t ;
+
+enum
+{
+	IPAC_dp_b			= 0,
+	IPAC_dp_m			= 0x00000001,
+	IPAC_dep_b			= 1,
+	IPAC_dep_m			= 0x00000002,
+	IPAC_drm_b			= 2,
+	IPAC_drm_m			= 0x00000004,
+	IPAC_dwm_b			= 3,
+	IPAC_dwm_m			= 0x00000008,
+	IPAC_msk_b			= 4,
+	IPAC_msk_m			= 0x00000010,
+
+	IPAPC_ptc_b			= 0,
+	IPAPC_ptc_m			= 0x00003fff,
+	IPAPC_mf_b			= 14,
+	IPAPC_mf_m			= 0x00004000,
+	IPAPC_cptc_b			= 16,
+	IPAPC_cptc_m			= 0x3fff0000,
+
+	IPAITCC_itcc			= 0,
+	IPAITCC_itcc,			= 0x000001ff,
+
+	IPABMC_mtc_b			= 0,
+	IPABMC_mtc_m			= 0x00000fff,
+	IPABMC_p_b			= 12,
+	IPABMC_p_m			= 0x00003000,
+	IPABMC_msk_b			= 14,
+	IPABMC_msk_m			= 0x00004000,
+	IPABMC_cmtc_b			= 16,
+	IPABMC_cmtc_m			= 0x0fff0000,
+};
+
+#endif	// __IDT_IPARB_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_pci.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_pci.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_pci.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,695 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   PCI register definitio
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_PCI_H__
+#define __IDT_PCI_H__
+
+enum
+{
+	PCI0_PhysicalAddress	= 0x18080000,
+	PCI_PhysicalAddress	= PCI0_PhysicalAddress,
+
+	PCI0_VirtualAddress	= 0xB8080000,
+	PCI_VirtualAddress	= PCI0_VirtualAddress,
+} ;
+
+enum
+{
+	PCI_LbaCount	= 4,		// Local base addresses.
+} ;
+
+typedef struct
+{
+	u32	a ;		// Address.
+	u32	c ;		// Control.
+	u32	m ;		// mapping.
+} PCI_Map_s ;
+
+typedef struct
+{
+	u32		pcic ;
+	u32		pcis ;
+	u32		pcism ;
+	u32		pcicfga ;
+	u32		pcicfgd ;
+	PCI_Map_s	pcilba [PCI_LbaCount] ;
+	u32		pcidac ;
+	u32		pcidas ;
+	u32		pcidasm ;
+	u32		pcidad ;
+	u32		pcidma8c ;
+	u32		pcidma9c ;
+	u32		pcitc ;
+} volatile *PCI_t ;
+
+// PCI messaging unit.
+enum
+{
+	PCIM_Count	= 2,
+} ;
+typedef struct
+{
+	u32		pciim [PCIM_Count] ;
+	u32		pciom [PCIM_Count] ;
+	u32		pciid ;
+	u32		pciiic ;
+	u32		pciiim ;
+	u32		pciiod ;
+	u32		pciioic ;
+	u32		pciioim ;
+} volatile *PCIM_t ;
+
+/*******************************************************************************
+ *
+ * PCI Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIC_en_b	= 0,
+	PCIC_en_m	= 0x00000001,
+	PCIC_tnr_b	= 1,
+	PCIC_tnr_m	= 0x00000002,
+	PCIC_sce_b	= 2,
+	PCIC_sce_m	= 0x00000004,
+	PCIC_ien_b	= 3,
+	PCIC_ien_m	= 0x00000008,
+	PCIC_aaa_b	= 4,
+	PCIC_aaa_m	= 0x00000010,
+	PCIC_eap_b	= 5,
+	PCIC_eap_m	= 0x00000020,
+	PCIC_pcim_b	= 6,
+	PCIC_pcim_m	= 0x000001c0,
+		PCIC_pcim_disabled_v	= 0,
+		PCIC_pcim_tnr_v 	= 1,	// Satellite - target not ready
+		PCIC_pcim_suspend_v	= 2,	// Satellite - suspended CPU.
+		PCIC_pcim_extern_v	= 3,	// Host - external arbiter.
+		PCIC_pcim_fixed_v	= 4,	// Host - fixed priority arb.
+		PCIC_pcim_roundrobin_v	= 5,	// Host - round robin priority.
+		PCIC_pcim_reserved6_v	= 6,
+		PCIC_pcim_reserved7_v	= 7,
+	PCIC_igm_b	= 9,
+	PCIC_igm_m	= 0x00000200,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIS_eed_b	= 0,
+	PCIS_eed_m	= 0x00000001,
+	PCIS_wr_b	= 1,
+	PCIS_wr_m	= 0x00000002,
+	PCIS_nmi_b	= 2,
+	PCIS_nmi_m	= 0x00000004,
+	PCIS_ii_b	= 3,
+	PCIS_ii_m	= 0x00000008,
+	PCIS_cwe_b	= 4,
+	PCIS_cwe_m	= 0x00000010,
+	PCIS_cre_b	= 5,
+	PCIS_cre_m	= 0x00000020,
+	PCIS_mdpe_b	= 6,
+	PCIS_mdpe_m	= 0x00000040,
+	PCIS_sta_b	= 7,
+	PCIS_sta_m	= 0x00000080,
+	PCIS_rta_b	= 8,
+	PCIS_rta_m	= 0x00000100,
+	PCIS_rma_b	= 9,
+	PCIS_rma_m	= 0x00000200,
+	PCIS_sse_b	= 10,
+	PCIS_sse_m	= 0x00000400,
+	PCIS_ose_b	= 11,
+	PCIS_ose_m	= 0x00000800,
+	PCIS_pe_b	= 12,
+	PCIS_pe_m	= 0x00001000,
+	PCIS_tae_b	= 13,
+	PCIS_tae_m	= 0x00002000,
+	PCIS_rle_b	= 14,
+	PCIS_rle_m	= 0x00004000,
+	PCIS_bme_b	= 15,
+	PCIS_bme_m	= 0x00008000,
+	PCIS_prd_b	= 16,
+	PCIS_prd_m	= 0x00010000,
+	PCIS_rip_b	= 17,
+	PCIS_rip_m	= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Mask Register
+ *
+ ******************************************************************************/
+enum {
+	PCISM_eed_b		= 0,
+	PCISM_eed_m		= 0x00000001,
+	PCISM_wr_b		= 1,
+	PCISM_wr_m		= 0x00000002,
+	PCISM_nmi_b		= 2,
+	PCISM_nmi_m		= 0x00000004,
+	PCISM_ii_b		= 3,
+	PCISM_ii_m		= 0x00000008,
+	PCISM_cwe_b		= 4,
+	PCISM_cwe_m		= 0x00000010,
+	PCISM_cre_b		= 5,
+	PCISM_cre_m		= 0x00000020,
+	PCISM_mdpe_b		= 6,
+	PCISM_mdpe_m		= 0x00000040,
+	PCISM_sta_b		= 7,
+	PCISM_sta_m		= 0x00000080,
+	PCISM_rta_b		= 8,
+	PCISM_rta_m		= 0x00000100,
+	PCISM_rma_b		= 9,
+	PCISM_rma_m		= 0x00000200,
+	PCISM_sse_b		= 10,
+	PCISM_sse_m		= 0x00000400,
+	PCISM_ose_b		= 11,
+	PCISM_ose_m		= 0x00000800,
+	PCISM_pe_b		= 12,
+	PCISM_pe_m		= 0x00001000,
+	PCISM_tae_b		= 13,
+	PCISM_tae_m		= 0x00002000,
+	PCISM_rle_b		= 14,
+	PCISM_rle_m		= 0x00004000,
+	PCISM_bme_b		= 15,
+	PCISM_bme_m		= 0x00008000,
+	PCISM_prd_b		= 16,
+	PCISM_prd_m		= 0x00010000,
+	PCISM_rip_b		= 17,
+	PCISM_rip_m		= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Configuration Address Register
+ *
+ ******************************************************************************/
+enum {
+	PCICFGA_reg_b		= 2,
+	PCICFGA_reg_m		= 0x000000fc,
+		PCICFGA_reg_id_v	= 0x00>>2, //use PCFGID_
+		PCICFGA_reg_04_v	= 0x04>>2, //use PCFG04_
+		PCICFGA_reg_08_v	= 0x08>>2, //use PCFG08_
+		PCICFGA_reg_0C_v	= 0x0C>>2, //use PCFG0C_
+		PCICFGA_reg_pba0_v	= 0x10>>2, //use PCIPBA_
+		PCICFGA_reg_pba1_v	= 0x14>>2, //use PCIPBA_
+		PCICFGA_reg_pba2_v	= 0x18>>2, //use PCIPBA_
+		PCICFGA_reg_pba3_v	= 0x1c>>2, //use PCIPBA_
+		PCICFGA_reg_subsystem_v = 0x2c>>2, //use PCFGSS_
+		PCICFGA_reg_3C_v	= 0x3C>>2, //use PCFG3C_
+		PCICFGA_reg_pba0c_v	= 0x44>>2, //use PCIPBAC_
+		PCICFGA_reg_pba0m_v	= 0x48>>2,
+		PCICFGA_reg_pba1c_v	= 0x4c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba1m_v	= 0x50>>2,
+		PCICFGA_reg_pba2c_v	= 0x54>>2, //use PCIPBAC_
+		PCICFGA_reg_pba2m_v	= 0x58>>2,
+		PCICFGA_reg_pba3c_v	= 0x5c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba3m_v	= 0x60>>2,
+		PCICFGA_reg_pmgt_v	= 0x64>>2,
+	PCICFGA_func_b		= 8,
+	PCICFGA_func_m		= 0x00000700,
+	PCICFGA_dev_b		= 11,
+	PCICFGA_dev_m		= 0x0000f800,
+		PCICFGA_dev_internal_v	= 0,
+	PCICFGA_bus_b		= 16,
+	PCICFGA_bus_m		= 0x00ff0000,
+		PCICFGA_bus_type0_v	= 0,	//local bus
+	PCICFGA_en_b		= 31,		// read only
+	PCICFGA_en_m		= 0x80000000,
+} ;
+
+enum {
+	PCFGID_vendor_b 	= 0,
+	PCFGID_vendor_m 	= 0x0000ffff,
+		PCFGID_vendor_IDT_v		= 0x111d,
+	PCFGID_device_b 	= 16,
+	PCFGID_device_m 	= 0xffff0000,
+		PCFGID_device_Korinade_v	= 0x0214,
+
+	PCFG04_command_ioena_b		= 1,
+	PCFG04_command_ioena_m		= 0x00000001,
+	PCFG04_command_memena_b 	= 2,
+	PCFG04_command_memena_m 	= 0x00000002,
+	PCFG04_command_bmena_b		= 3,
+	PCFG04_command_bmena_m		= 0x00000004,
+	PCFG04_command_mwinv_b		= 5,
+	PCFG04_command_mwinv_m		= 0x00000010,
+	PCFG04_command_parena_b 	= 7,
+	PCFG04_command_parena_m 	= 0x00000040,
+	PCFG04_command_serrena_b	= 9,
+	PCFG04_command_serrena_m	= 0x00000100,
+	PCFG04_command_fastbbena_b	= 10,
+	PCFG04_command_fastbbena_m	= 0x00000200,
+	PCFG04_status_b 		= 16,
+	PCFG04_status_m 		= 0xffff0000,
+	PCFG04_status_66MHz_b		= 21,	// 66 MHz enable
+	PCFG04_status_66MHz_m		= 0x00200000,
+	PCFG04_status_fbb_b		= 23,
+	PCFG04_status_fbb_m		= 0x00800000,
+	PCFG04_status_mdpe_b		= 24,
+	PCFG04_status_mdpe_m		= 0x01000000,
+	PCFG04_status_dst_b		= 25,
+	PCFG04_status_dst_m		= 0x06000000,
+	PCFG04_status_sta_b		= 27,
+	PCFG04_status_sta_m		= 0x08000000,
+	PCFG04_status_rta_b		= 28,
+	PCFG04_status_rta_m		= 0x10000000,
+	PCFG04_status_rma_b		= 29,
+	PCFG04_status_rma_m		= 0x20000000,
+	PCFG04_status_sse_b		= 30,
+	PCFG04_status_sse_m		= 0x40000000,
+	PCFG04_status_pe_b		= 31,
+	PCFG04_status_pe_m		= 0x40000000,
+
+	PCFG08_revId_b			= 0,
+	PCFG08_revId_m			= 0x000000ff,
+	PCFG08_classCode_b		= 0,
+	PCFG08_classCode_m		= 0xffffff00,
+		PCFG08_classCode_bridge_v	= 06,
+		PCFG08_classCode_proc_v 	= 0x0b3000, // processor-MIPS
+	PCFG0C_cacheline_b		= 0,
+	PCFG0C_cacheline_m		= 0x000000ff,
+	PCFG0C_masterLatency_b		= 8,
+	PCFG0C_masterLatency_m		= 0x0000ff00,
+	PCFG0C_headerType_b		= 16,
+	PCFG0C_headerType_m		= 0x00ff0000,
+	PCFG0C_bist_b			= 24,
+	PCFG0C_bist_m			= 0xff000000,
+
+	PCIPBA_msi_b			= 0,
+	PCIPBA_msi_m			= 0x00000001,
+	PCIPBA_p_b			= 3,
+	PCIPBA_p_m			= 0x00000004,
+	PCIPBA_baddr_b			= 8,
+	PCIPBA_baddr_m			= 0xffffff00,
+
+	PCFGSS_vendorId_b		= 0,
+	PCFGSS_vendorId_m		= 0x0000ffff,
+	PCFGSS_id_b			= 16,
+	PCFGSS_id_m			= 0xffff0000,
+
+	PCFG3C_interruptLine_b		= 0,
+	PCFG3C_interruptLine_m		= 0x000000ff,
+	PCFG3C_interruptPin_b		= 8,
+	PCFG3C_interruptPin_m		= 0x0000ff00,
+	PCFG3C_minGrant_b		= 16,
+	PCFG3C_minGrant_m		= 0x00ff0000,
+	PCFG3C_maxLat_b 		= 24,
+	PCFG3C_maxLat_m 		= 0xff000000,
+
+	PCIPBAC_msi_b			= 0,
+	PCIPBAC_msi_m			= 0x00000001,
+	PCIPBAC_p_b			= 1,
+	PCIPBAC_p_m			= 0x00000002,
+	PCIPBAC_size_b			= 2,
+	PCIPBAC_size_m			= 0x0000007c,
+	PCIPBAC_sb_b			= 7,
+	PCIPBAC_sb_m			= 0x00000080,
+	PCIPBAC_pp_b			= 8,
+	PCIPBAC_pp_m			= 0x00000100,
+	PCIPBAC_mr_b			= 9,
+	PCIPBAC_mr_m			= 0x00000600,
+		PCIPBAC_mr_read_v	=0,	//no prefetching
+		PCIPBAC_mr_readLine_v	=1,
+		PCIPBAC_mr_readMult_v	=2,
+	PCIPBAC_mrl_b			= 11,
+	PCIPBAC_mrl_m			= 0x00000800,
+	PCIPBAC_mrm_b			= 12,
+	PCIPBAC_mrm_m			= 0x00001000,
+	PCIPBAC_trp_b			= 13,
+	PCIPBAC_trp_m			= 0x00002000,
+
+	PCFG40_trdyTimeout_b		= 0,
+	PCFG40_trdyTimeout_m		= 0x000000ff,
+	PCFG40_retryLim_b		= 8,
+	PCFG40_retryLim_m		= 0x0000ff00,
+};
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBA_baddr_b		= 0,		// In PCI_t -> pcilba [] .a
+	PCILBA_baddr_m		= 0xffffff00,
+} ;
+/*******************************************************************************
+ *
+ * PCI Local Base Address Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAC_msi_b		= 0,		// In pPci->pcilba[i].c
+	PCILBAC_msi_m		= 0x00000001,
+		PCILBAC_msi_mem_v	= 0,
+		PCILBAC_msi_io_v	= 1,
+	PCILBAC_size_b		= 2,	// In pPci->pcilba[i].c
+	PCILBAC_size_m		= 0x0000007c,
+	PCILBAC_sb_b		= 7,	// In pPci->pcilba[i].c
+	PCILBAC_sb_m		= 0x00000080,
+	PCILBAC_rt_b		= 8,	// In pPci->pcilba[i].c
+	PCILBAC_rt_m		= 0x00000100,
+		PCILBAC_rt_noprefetch_v = 0, // mem read
+		PCILBAC_rt_prefetch_v	= 1, // mem readline
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Mapping Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAM_maddr_b 	= 8,
+	PCILBAM_maddr_m 	= 0xffffff00,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAC_den_b		= 0,
+	PCIDAC_den_m		= 0x00000001,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAS_d_b	= 0,
+	PCIDAS_d_m	= 0x00000001,
+	PCIDAS_b_b	= 1,
+	PCIDAS_b_m	= 0x00000002,
+	PCIDAS_e_b	= 2,
+	PCIDAS_e_m	= 0x00000004,
+	PCIDAS_ofe_b	= 3,
+	PCIDAS_ofe_m	= 0x00000008,
+	PCIDAS_off_b	= 4,
+	PCIDAS_off_m	= 0x00000010,
+	PCIDAS_ife_b	= 5,
+	PCIDAS_ife_m	= 0x00000020,
+	PCIDAS_iff_b	= 6,
+	PCIDAS_iff_m	= 0x00000040,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 8 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA8C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA8C_mbs_m	= 0x00000fff,	// { pcidma8c }
+	PCIDMA8C_our_b	= 12,		// Optimize Unaligned Burst Reads.
+	PCIDMA8C_our_m	= 0x00001000,	// { pcidma8c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 9 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA9C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA9C_mbs_m	= 0x00000fff, // { pcidma9c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel 9)Descriptors
+ *
+ ******************************************************************************/
+enum {
+	PCIDMAD_pt_b		= 22,		// in DEVCMD field (descriptor)
+	PCIDMAD_pt_m		= 0x00c00000,	// preferred transaction field
+		// These are for reads (DMA channel 8)
+		PCIDMAD_devcmd_mr_v	= 0,	//memory read
+		PCIDMAD_devcmd_mrl_v	= 1,	//memory read line
+		PCIDMAD_devcmd_mrm_v	= 2,	//memory read multiple
+		PCIDMAD_devcmd_ior_v	= 3,	//I/O read
+		// These are for writes (DMA channel 9)
+		PCIDMAD_devcmd_mw_v	= 0,	//memory write
+		PCIDMAD_devcmd_mwi_v	= 1,	//memory write invalidate
+		PCIDMAD_devcmd_iow_v	= 3,	//I/O write
+
+	// Swap byte field applies to both DMA channel 8 and 9
+	PCIDMAD_sb_b		= 24,		// in DEVCMD field (descriptor)
+	PCIDMAD_sb_m		= 0x01000000,	// swap byte field
+} ;
+
+
+/*******************************************************************************
+ *
+ * PCI Target Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCITC_rtimer_b		= 0,		// In PCITC_t -> pcitc
+	PCITC_rtimer_m		= 0x000000ff,
+	PCITC_dtimer_b		= 8,		// In PCITC_t -> pcitc
+	PCITC_dtimer_m		= 0x0000ff00,
+	PCITC_rdr_b		= 18,		// In PCITC_t -> pcitc
+	PCITC_rdr_m		= 0x00040000,
+	PCITC_ddt_b		= 19,		// In PCITC_t -> pcitc
+	PCITC_ddt_m		= 0x00080000,
+} ;
+/*******************************************************************************
+ *
+ * PCI messaging unit [applies to both inbound and outbound registers ]
+ *
+ ******************************************************************************/
+enum
+{
+	PCIM_m0_b	= 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m0_m	= 0x00000001,	// inbound or outbound message 0
+	PCIM_m1_b	= 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m1_m	= 0x00000002,	// inbound or outbound message 1
+	PCIM_db_b	= 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_db_m	= 0x00000004,	// inbound or outbound doorbell
+};
+
+
+
+
+
+
+#define PCI_MSG_VirtualAddress	     0xB8088010
+#define rc32434_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32434_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+#if 0
+#define PCI_ADDR_START		0x13000000
+#endif
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define KORINA_CONFIG0_ADDR	0x80000000
+#define KORINA_CONFIG1_ADDR	0x80000004
+#define KORINA_CONFIG2_ADDR	0x80000008
+#define KORINA_CONFIG3_ADDR	0x8000000C
+#define KORINA_CONFIG4_ADDR	0x80000010
+#define KORINA_CONFIG5_ADDR	0x80000014
+#define KORINA_CONFIG6_ADDR	0x80000018
+#define KORINA_CONFIG7_ADDR	0x8000001C
+#define KORINA_CONFIG8_ADDR	0x80000020
+#define KORINA_CONFIG9_ADDR	0x80000024
+#define KORINA_CONFIG10_ADDR	0x80000028
+#define KORINA_CONFIG11_ADDR	0x8000002C
+#define KORINA_CONFIG12_ADDR	0x80000030
+#define KORINA_CONFIG13_ADDR	0x80000034
+#define KORINA_CONFIG14_ADDR	0x80000038
+#define KORINA_CONFIG15_ADDR	0x8000003C
+#define KORINA_CONFIG16_ADDR	0x80000040
+#define KORINA_CONFIG17_ADDR	0x80000044
+#define KORINA_CONFIG18_ADDR	0x80000048
+#define KORINA_CONFIG19_ADDR	0x8000004C
+#define KORINA_CONFIG20_ADDR	0x80000050
+#define KORINA_CONFIG21_ADDR	0x80000054
+#define KORINA_CONFIG22_ADDR	0x80000058
+#define KORINA_CONFIG23_ADDR	0x8000005C
+#define KORINA_CONFIG24_ADDR	0x80000060
+#define KORINA_CONFIG25_ADDR	0x80000064
+#define KORINA_CMD 		(PCFG04_command_ioena_m | \
+				 PCFG04_command_memena_m | \
+				 PCFG04_command_bmena_m | \
+				 PCFG04_command_mwinv_m | \
+				 PCFG04_command_parena_m | \
+				 PCFG04_command_serrena_m )
+
+#define KORINA_STAT		(PCFG04_status_mdpe_m | \
+				 PCFG04_status_sta_m  | \
+				 PCFG04_status_rta_m  | \
+				 PCFG04_status_rma_m  | \
+				 PCFG04_status_sse_m  | \
+				 PCFG04_status_pe_m)
+
+#define KORINA_CNFG1		((KORINA_STAT<<16)|KORINA_CMD)
+
+#define KORINA_REVID		0
+#define KORINA_CLASS_CODE	0
+#define KORINA_CNFG2		((KORINA_CLASS_CODE<<8) | \
+				  KORINA_REVID)
+
+#define KORINA_CACHE_LINE_SIZE	4
+#define KORINA_MASTER_LAT	0x3c
+#define KORINA_HEADER_TYPE	0
+#define KORINA_BIST		0
+
+#define KORINA_CNFG3 ((KORINA_BIST << 24) | \
+		      (KORINA_HEADER_TYPE<<16) | \
+		      (KORINA_MASTER_LAT<<8) | \
+		      KORINA_CACHE_LINE_SIZE )
+
+#define KORINA_BAR0	0x00000008 /* 128 MB Memory */
+#define KORINA_BAR1	0x18800001 /* 1 MB IO */
+#define KORINA_BAR2	0x18000001 /* 2 MB IO window for Korina
+					internal Registers */
+#define KORINA_BAR3	0x48000008 /* Spare 128 MB Memory */
+
+#define KORINA_CNFG4	KORINA_BAR0
+#define KORINA_CNFG5    KORINA_BAR1
+#define KORINA_CNFG6 	KORINA_BAR2
+#define KORINA_CNFG7	KORINA_BAR3
+
+#define KORINA_SUBSYS_VENDOR_ID 0x011d
+#define KORINA_SUBSYSTEM_ID	0x0214
+#define KORINA_CNFG8		0
+#define KORINA_CNFG9		0
+#define KORINA_CNFG10		0
+#define KORINA_CNFG11 	((KORINA_SUBSYS_VENDOR_ID<<16) | \
+			  KORINA_SUBSYSTEM_ID)
+#define KORINA_INT_LINE		1
+#define KORINA_INT_PIN		1
+#define KORINA_MIN_GNT		8
+#define KORINA_MAX_LAT		0x38
+#define KORINA_CNFG12		0
+#define KORINA_CNFG13 		0
+#define KORINA_CNFG14		0
+#define KORINA_CNFG15	((KORINA_MAX_LAT<<24) | \
+			 (KORINA_MIN_GNT<<16) | \
+			 (KORINA_INT_PIN<<8)  | \
+			  KORINA_INT_LINE)
+#define	KORINA_RETRY_LIMIT	0x80
+#define KORINA_TRDY_LIMIT	0x80
+#define KORINA_CNFG16 ((KORINA_RETRY_LIMIT<<8) | \
+			KORINA_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#else
+#define KORINA_PBA0C	( PCIPBAC_mrl_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+#endif
+#define KORINA_CNFG17	KORINA_PBA0C
+#define KORINA_PBA0M	0x0
+#define KORINA_CNFG18	KORINA_PBA0M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG19	KORINA_PBA1C
+#define KORINA_PBA1M	0x0
+#define KORINA_CNFG20	KORINA_PBA1M
+
+#if defined(__MIPSEB__)
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+#else
+#define KORINA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | \
+			  PCIPBAC_msi_m)
+#endif
+#define KORINA_CNFG21	KORINA_PBA2C
+#define KORINA_PBA2M	0x18000000
+#define KORINA_CNFG22	KORINA_PBA2M
+#define KORINA_PBA3C	0
+#define KORINA_CNFG23	KORINA_PBA3C
+#define KORINA_PBA3M	0
+#define KORINA_CNFG24	KORINA_PBA3M
+
+
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
+
+
+
+#endif	// __IDT_PCI_H__
+
+
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_rst.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_rst.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_rst.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_rst.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,119 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Reset register definitions.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RST_H__
+#define __IDT_RST_H__
+
+enum
+{
+	RST0_PhysicalAddress	= 0x18000000,
+	RST_PhysicalAddress	= RST0_PhysicalAddress,		// Default
+
+	RST0_VirtualAddress	= 0xb8000000,
+	RST_VirtualAddress	= RST0_VirtualAddress,		// Default
+} ;
+
+typedef struct RST_s
+{
+	u32	filler [0x0006] ;
+	u32	sysid ;
+	u32	filler2 [0x2000-8] ;		// Pad out to offset 0x8000
+	u32	reset ;
+	u32	bcv ;
+	u32	cea ;
+} volatile * RST_t ;
+
+enum
+{
+	SYSID_rev_b		= 0,
+	SYSID_rev_m		= 0x000000ff,
+	SYSID_imp_b		= 8,
+	SYSID_imp_m		= 0x000fff00,
+	SYSID_vendor_b		= 8,
+	SYSID_vendor_m		= 0xfff00000,
+
+	BCV_pll_b		= 0,
+	BCV_pll_m		= 0x0000000f,
+		BCV_pll_PLLBypass_v	= 0x0,	// PCLK=1*CLK.
+		BCV_pll_Mul3_v		= 0x1,	// PCLK=3*CLK.
+		BCV_pll_Mul4_v		= 0x2,	// PCLK=4*CLK.
+		BCV_pll_SlowMul5_v	= 0x3,	// PCLK=5*CLK.
+		BCV_pll_Mul5_v		= 0x4,	// PCLK=5*CLK.
+		BCV_pll_SlowMul6_v	= 0x5,	// PCLK=6*CLK.
+		BCV_pll_Mul6_v		= 0x6,	// PCLK=6*CLK.
+		BCV_pll_Mul8_v		= 0x7,	// PCLK=8*CLK.
+		BCV_pll_Mul10_v		= 0x8,	// PCLK=10*CLK.
+	        BCV_pll_Res9_v	        = 0x9,
+		BCV_pll_Res10_v	        = 0xa,
+		BCV_pll_Res11_v	        = 0xb,
+		BCV_pll_Res12_v	        = 0xc,
+		BCV_pll_Res13_v		= 0xd,
+		BCV_pll_Res14_v		= 0xe,
+		BCV_pll_Res15_v		= 0xf,
+	BCV_clkDiv_b		= 4,
+	BCV_clkDiv_m		= 0x00000030,
+		BCV_clkDiv_Div1_v	= 0x0,
+		BCV_clkDiv_Div2_v	= 0x1,
+		BCV_clkDiv_Div4_v	= 0x2,
+		BCV_clkDiv_Res3_v	= 0x3,
+	BCV_bigEndian_b		= 6,
+	BCV_bigEndian_m		= 0x00000040,
+	BCV_resetFast_b		= 7,
+	BCV_resetFast_m		= 0x00000080,
+	BCV_pciMode_b		= 8,
+	BCV_pciMode_m		= 0x00000700,
+		BCV_pciMode_disabled_v	= 0,	// PCI is disabled.
+		BCV_pciMode_tnr_v	= 1,	// satellite Target Not Ready.
+		BCV_pciMode_suspended_v	= 2,	// satellite with suspended CPU.
+		BCV_pciMode_external_v	= 3,	// host, external arbiter.
+		BCV_pciMode_fixed_v	= 4,	// host, fixed priority arbiter.
+		BCV_pciMode_roundRobin_v= 5,	// host, round robin arbiter.
+		BCV_pciMode_res6_v	= 6,
+		BCV_pciMode_res7_v	= 7,
+	BCV_watchDisable_b	= 11,
+	BCV_watchDisable_m	= 0x00000800,
+	BCV_res12_b		= 12,
+	BCV_res12_m		= 0x00001000,
+	BCV_res13_b		= 13,
+	BCV_res13_m		= 0x00002000,
+	BCV_res14_b		= 14,
+	BCV_res14_m		= 0x00004000,
+	BCV_res15_b		= 15,
+	BCV_res15_m		= 0x00008000,
+} ;
+#endif	// __IDT_RST_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_spi.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_spi.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_spi.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,120 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Serial Peripheral Interface register definitions.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_SPI_H__
+#define __IDT_SPI_H__
+
+enum
+{
+	SPI0_PhysicalAddress	= 0x18070000,
+	SPI_PhysicalAddress	= SPI0_PhysicalAddress,
+
+	SPI0_VirtualAddress	= 0xB8070000,
+	SPI_VirtualAddress	= SPI0_VirtualAddress,
+} ;
+
+typedef struct
+{
+	u32 spcp ;	// prescalar. 0=off, * spiClk = sysClk/(2*(spcp+1)*SPR)
+	u32 spc ;	// spi control reg use SPC_
+	u32 sps ;	// spi status reg use SPS_
+	u32 spd ;	// spi data reg use SPD_
+	u32 siofunc ;	// serial IO function use SIOFUNC_
+	u32 siocfg ;	// serial IO config use SIOCFG_
+	u32 siod;	// serial IO data use SIOD_
+} volatile *SPI_t ;
+
+enum
+{
+	SPCP_div_b	 = 0,	       
+	SPCP_div_m	 = 0x000000ff,
+	SPC_spr_b	= 0,	       
+	SPC_spr_m	= 0x00000003,
+	     SPC_spr_div2_v  = 0,
+	     SPC_spr_div4_v  = 1,
+	     SPC_spr_div16_v = 2,
+	     SPC_spr_div32_v = 3,
+	SPC_cpha_b	= 2,	       
+	SPC_cpha_m	= 0x00000004,
+	SPC_cpol_b	= 3,	       
+	SPC_cpol_m	= 0x00000008,
+	SPC_mstr_b	= 4,	       
+	SPC_mstr_m	= 0x00000010,
+	SPC_spe_b	= 6,	       
+	SPC_spe_m	= 0x00000040,
+	SPC_spie_b	= 7,	       
+	SPC_spie_m	= 0x00000080,
+
+	SPS_modf_b	= 4,	       
+	SPS_modf_m	= 0x00000010,
+	SPS_wcol_b	= 6,	       
+	SPS_wcol_m	= 0x00000040,
+	SPS_spif_b	= 7,	       
+	SPS_spif_m	= 0x00000070,
+
+	SPD_data_b	= 0,	       
+	SPD_data_m	= 0x000000ff,
+
+	SIOFUNC_sdo_b	    = 0,	   
+	SIOFUNC_sdo_m	    = 0x00000001,
+	SIOFUNC_sdi_b	    = 1,	   
+	SIOFUNC_sdi_m	    = 0x00000002,
+	SIOFUNC_sck_b	    = 2,	   
+	SIOFUNC_sck_m	    = 0x00000004,
+	SIOFUNC_pci_b	    = 3,	   
+	SIOFUNC_pci_m	    = 0x00000008,
+	
+	SIOCFG_sdo_b	   = 0, 	   
+	SIOCFG_sdo_m	   = 0x00000001,
+	SIOCFG_sdi_b	   = 1, 	   
+	SIOCFG_sdi_m	   = 0x00000002,
+	SIOCFG_sck_b	   = 2, 	   
+	SIOCFG_sck_m	   = 0x00000004,
+	SIOCFG_pci_b	   = 3, 	   
+	SIOCFG_pci_m	   = 0x00000008,
+	
+	SIOD_sdo_b	 = 0,		 
+	SIOD_sdo_m	 = 0x00000001,
+	SIOD_sdi_b	 = 1,		 
+	SIOD_sdi_m	 = 0x00000002,
+	SIOD_sck_b	 = 2,		 
+	SIOD_sck_m	 = 0x00000004,
+	SIOD_pci_b	 = 3,		 
+	SIOD_pci_m	 = 0x00000008,
+} ;
+#endif	// __IDT_SPI_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_timer.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_timer.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_timer.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,91 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for timer registers
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt,neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_TIM_H__
+#define __IDT_TIM_H__
+
+enum
+{
+	TIM0_PhysicalAddress	= 0x18028000,
+	TIM_PhysicalAddress	= TIM0_PhysicalAddress,		// Default
+
+	TIM0_VirtualAddress	= 0xb8028000,
+	TIM_VirtualAddress	= TIM0_VirtualAddress,		// Default
+} ;
+
+enum
+{
+	TIM_Count = 3,
+} ;
+
+struct TIM_CNTR_s
+{
+  u32 count ;
+  u32 compare ;
+  u32 ctc ;	//use CTC_
+} ;
+
+typedef struct TIM_s
+{
+  struct TIM_CNTR_s	tim [TIM_Count] ;
+  u32			rcount ;	//use RCOUNT_
+  u32			rcompare ;	//use RCOMPARE_
+  u32			rtc ;		//use RTC_
+} volatile * TIM_t ;
+
+enum
+{
+  CTC_en_b	= 0,		
+  CTC_en_m	= 0x00000001,
+  CTC_to_b	= 1,		 
+  CTC_to_m	= 0x00000002,
+  
+  RCOUNT_count_b		= 0,	     
+  RCOUNT_count_m		= 0x0000ffff,
+  RCOMPARE_compare_b	= 0,	   
+  RCOMPARE_compare_m	= 0x0000ffff,
+  RTC_ce_b		= 0,		
+  RTC_ce_m		= 0x00000001,
+  RTC_to_b		= 1,		
+  RTC_to_m		= 0x00000002,
+  RTC_rqe_b		= 2,		
+  RTC_rqe_m		= 0x00000004,
+  
+} ;
+#endif	// __IDT_TIM_H__
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_uart.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_uart.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32434/rc32434_uart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32434/rc32434_uart.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,189 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   UART register definitions
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 rkt, neb.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_UART_H__
+#define __IDT_UART_H__
+
+enum
+{
+	UART0_PhysicalAddress	= 0x1c000000,
+	UART_PhysicalAddress	= UART0_PhysicalAddress,	// Default
+
+	UART0_VirtualAddress	= 0xbc000000,
+	UART_VirtualAddress	= UART0_VirtualAddress,		// Default
+} ;
+
+/*
+ * Register definitions are in bytes so we can handle endian problems.
+ */
+
+typedef struct UART_s
+{
+	union
+	{
+		u32 const	uartrb ;	// 0x00 - DLAB=0, read.
+		u32		uartth ;	// 0x00 - DLAB=0, write.
+		u32		uartdll ;	// 0x00 - DLAB=1, read/write.
+	} ;
+
+	union
+	{
+		u32		uartie ;	// 0x04 - DLAB=0, read/write.
+		u32		uartdlh ;	// 0x04 - DLAB=1, read/write.
+	} ;
+	union
+	{
+		u32 const	uartii ;	// 0x08 - DLAB=0, read.
+		u32		uartfc ;	// 0x08 - DLAB=0, write.
+	} ;
+
+	u32		uartlc ;		// 0x0c
+	u32		uartmc ;		// 0x10
+	u32		uartls ;		// 0x14
+	u32		uartms ;		// 0x18
+	u32		uarts ;			// 0x1c
+} volatile *UART_t ;
+
+// Reset registers.
+typedef u32	volatile *UARTRR_t ;
+
+enum
+{
+	UARTIE_rda_b	= 0,
+	UARTIE_rda_m	= 0x00000001,
+	UARTIE_the_b	= 1,
+	UARTIE_the_m	= 0x00000002,
+	UARTIE_rls_b	= 2,
+	UARTIE_rls_m	= 0x00000004,
+	UARTIE_ems_b	= 3,
+	UARTIE_ems_m	= 0x00000008,
+
+	UARTII_pi_b	= 0,
+	UARTII_pi_m	= 0x00000001,
+	UARTII_iid_b	= 1,
+	UARTII_iid_m	= 0x0000000e,
+		UARTII_iid_ms_v		= 0,	// Modem stat-CTS,DSR,RI or DCD.
+		UARTII_iid_thre_v	= 1,	// Trans. Holding Reg. empty.
+		UARTII_iid_rda_v	= 2,	// Receive data available
+		UARTII_iid_rls_v	= 3,	// Overrun, parity, etc, error.
+		UARTII_iid_res4_v	= 4,	// reserved.
+		UARTII_iid_res5_v	= 5,	// reserved.
+		UARTII_iid_cto_v	= 6,	// Character timeout.
+		UARTII_iid_res7_v	= 7,	// reserved.
+
+	UARTFC_en_b	= 0,
+	UARTFC_en_m	= 0x00000001,
+	UARTFC_rr_b	= 1,
+	UARTFC_rr_m	= 0x00000002,
+	UARTFC_tr_b	= 2,
+	UARTFC_tr_m	= 0x00000004,
+	UARTFC_dms_b	= 3,
+	UARTFC_dms_m	= 0x00000008,
+	UARTFC_rt_b	= 6,
+	UARTFC_rt_m	= 0x000000c0,
+		UARTFC_rt_1Byte_v	= 0,
+		UARTFC_rt_4Byte_v	= 1,
+		UARTFC_rt_8Byte_v	= 2,
+		UARTFC_rt_14Byte_v	= 3,
+
+	UARTLC_wls_b	= 0,
+	UARTLC_wls_m	= 0x00000003,
+		UARTLC_wls_5Bits_v	= 0,
+		UARTLC_wls_6Bits_v	= 1,
+		UARTLC_wls_7Bits_v	= 2,
+		UARTLC_wls_8Bits_v	= 3,
+	UARTLC_stb_b	= 2,
+	UARTLC_stb_m	= 0x00000004,
+	UARTLC_pen_b	= 3,
+	UARTLC_pen_m	= 0x00000008,
+	UARTLC_eps_b	= 4,
+	UARTLC_eps_m	= 0x00000010,
+	UARTLC_sp_b	= 5,
+	UARTLC_sp_m	= 0x00000020,
+	UARTLC_sb_b	= 6,
+	UARTLC_sb_m	= 0x00000040,
+	UARTLC_dlab_b	= 7,
+	UARTLC_dlab_m	= 0x00000080,
+
+	UARTMC_dtr_b	= 0,
+	UARTMC_dtr_m	= 0x00000001,
+	UARTMC_rts_b	= 1,
+	UARTMC_rts_m	= 0x00000002,
+	UARTMC_o1_b	= 2,
+	UARTMC_o1_m	= 0x00000004,
+	UARTMC_o2_b	= 3,
+	UARTMC_o2_m	= 0x00000008,
+	UARTMC_lp_b	= 4,
+	UARTMC_lp_m	= 0x00000010,
+
+	UARTLS_dr_b	= 0,
+	UARTLS_dr_m	= 0x00000001,
+	UARTLS_oe_b	= 1,
+	UARTLS_oe_m	= 0x00000002,
+	UARTLS_pe_b	= 2,
+	UARTLS_pe_m	= 0x00000004,
+	UARTLS_fe_b	= 3,
+	UARTLS_fe_m	= 0x00000008,
+	UARTLS_bi_b	= 4,
+	UARTLS_bi_m	= 0x00000010,
+	UARTLS_thr_b	= 5,
+	UARTLS_thr_m	= 0x00000020,
+	UARTLS_te_b	= 6,
+	UARTLS_te_m	= 0x00000040,
+	UARTLS_rfe_b	= 7,
+	UARTLS_rfe_m	= 0x00000080,
+
+	UARTMS_dcts_b	= 0,
+	UARTMS_dcts_m	= 0x00000001,
+	UARTMS_ddsr_b	= 1,
+	UARTMS_ddsr_m	= 0x00000002,
+	UARTMS_teri_b	= 2,
+	UARTMS_teri_m	= 0x00000004,
+	UARTMS_ddcd_b	= 3,
+	UARTMS_ddcd_m	= 0x00000008,
+	UARTMS_cts_b	= 4,
+	UARTMS_cts_m	= 0x00000010,
+	UARTMS_dsr_b	= 5,
+	UARTMS_dsr_m	= 0x00000020,
+	UARTMS_ri_b	= 6,
+	UARTMS_ri_m	= 0x00000040,
+	UARTMS_dcd_b	= 7,
+	UARTMS_dcd_m	= 0x00000080,
+} ;
+
+#endif	// __IDT_UART_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_dma.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_dma.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_dma.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,231 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Register definitions for  IDT RC32438 DMA.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+#ifndef __IDT_RC32438_DMA_H__
+#define __IDT_RC32438_DMA_H__
+enum
+{
+	DMA0_PhysicalAddress	= 0x18040000,
+	DMA_PhysicalAddress	= DMA0_PhysicalAddress,		// Default
+
+	DMA0_VirtualAddress	= 0xb8040000,
+	DMA_VirtualAddress	= DMA0_VirtualAddress,		// Default
+} ;
+
+/*
+ * DMA descriptor (in physical memory).
+ */
+
+typedef struct DMAD_s
+{
+	u32			control ;	// Control. use DMAD_*
+	u32			ca ;		// Current Address.
+	u32			devcs ; 	// Device control and status.
+	u32			link ;		// Next descriptor in chain.
+} volatile *DMAD_t ;
+
+enum
+{
+	DMAD_size		= sizeof (struct DMAD_s),
+	DMAD_count_b		= 0,		// in DMAD_t -> control
+	DMAD_count_m		= 0x0003ffff,	// in DMAD_t -> control
+	DMAD_ds_b		= 20,		// in DMAD_t -> control
+	DMAD_ds_m		= 0x00300000,	// in DMAD_t -> control
+		DMAD_ds_extToMem0_v	= 0,
+		DMAD_ds_memToExt0_v	= 1,
+		DMAD_ds_extToMem1_v	= 0,
+		DMAD_ds_memToExt1_v	= 1,
+		DMAD_ds_ethRcv0_v	= 0,
+		DMAD_ds_ethXmt0_v	= 0,
+		DMAD_ds_ethRcv1_v	= 0,
+		DMAD_ds_ethXmt2_v	= 0,
+		DMAD_ds_memToFifo_v	= 0,
+		DMAD_ds_fifoToMem_v	= 0,
+		DMAD_ds_rng_de_v	   = 1,//randomNumberGenerator on LC/DE
+		DMAD_ds_pciToMem_v	= 0,
+		DMAD_ds_memToPci_v	= 0,
+		DMAD_ds_securityInput_v = 0,
+		DMAD_ds_securityOutput_v = 0,
+		DMAD_ds_rng_se_v	= 0,//randomNumberGenerator on SE
+	
+	DMAD_devcmd_b		= 22,		// in DMAD_t -> control
+	DMAD_devcmd_m		= 0x01c00000,	// in DMAD_t -> control
+		DMAD_devcmd_byte_v	= 0,	//memory-to-memory
+		DMAD_devcmd_halfword_v	= 1,	//memory-to-memory
+		DMAD_devcmd_word_v	= 2,	//memory-to-memory
+		DMAD_devcmd_2words_v	= 3,	//memory-to-memory
+		DMAD_devcmd_4words_v	= 4,	//memory-to-memory
+		DMAD_devcmd_6words_v	= 5,	//memory-to-memory
+		DMAD_devcmd_8words_v	= 6,	//memory-to-memory
+		DMAD_devcmd_16words_v	= 7,	//memory-to-memory
+	DMAD_cof_b		= 25,		// chain on finished
+	DMAD_cof_m		= 0x02000000,	// 
+	DMAD_cod_b		= 26,		// chain on done
+	DMAD_cod_m		= 0x04000000,	// 
+	DMAD_iof_b		= 27,		// interrupt on finished
+	DMAD_iof_m		= 0x08000000,	// 
+	DMAD_iod_b		= 28,		// interrupt on done
+	DMAD_iod_m		= 0x10000000,	// 
+	DMAD_t_b		= 29,		// terminated
+	DMAD_t_m		= 0x20000000,	// 
+	DMAD_d_b		= 30,		// done
+	DMAD_d_m		= 0x40000000,	// 
+	DMAD_f_b		= 31,		// finished
+	DMAD_f_m		= 0x80000000,	// 
+} ;
+
+/*
+ * DMA register (within Internal Register Map).
+ */
+
+struct DMA_Chan_s
+{
+	u32		dmac ;		// Control.
+	u32		dmas ;		// Status.	
+	u32		dmasm ; 	// Mask.
+	u32		dmadptr ;	// Descriptor pointer.
+	u32		dmandptr ;	// Next descriptor pointer.
+};
+
+typedef struct DMA_Chan_s volatile *DMA_Chan_t ;
+
+//DMA_Channels	  use DMACH_count instead
+
+enum
+{
+	DMAC_run_b	= 0,		// 
+	DMAC_run_m	= 0x00000001,	// 
+	DMAC_dm_b	= 1,		// done mask
+	DMAC_dm_m	= 0x00000002,	// 
+	DMAC_mode_b	= 2,		// 
+	DMAC_mode_m	= 0x0000000c,	// 
+		DMAC_mode_auto_v	= 0,
+		DMAC_mode_burst_v	= 1,
+		DMAC_mode_transfer_v	= 2, //usually used
+		DMAC_mode_reserved_v	= 3,
+	DMAC_a_b	= 4,		// 
+	DMAC_a_m	= 0x00000010,	// 
+
+	DMAS_f_b	= 0,		// finished (sticky) 
+	DMAS_f_m	= 0x00000001,	//		     
+	DMAS_d_b	= 1,		// done (sticky)     
+	DMAS_d_m	= 0x00000002,	//		     
+	DMAS_c_b	= 2,		// chain (sticky)    
+	DMAS_c_m	= 0x00000004,	//		     
+	DMAS_e_b	= 3,		// error (sticky)    
+	DMAS_e_m	= 0x00000008,	//		     
+	DMAS_h_b	= 4,		// halt (sticky)     
+	DMAS_h_m	= 0x00000010,	//		     
+
+	DMASM_f_b	= 0,		// finished (1=mask)
+	DMASM_f_m	= 0x00000001,	// 
+	DMASM_d_b	= 1,		// done (1=mask)
+	DMASM_d_m	= 0x00000002,	// 
+	DMASM_c_b	= 2,		// chain (1=mask)
+	DMASM_c_m	= 0x00000004,	// 
+	DMASM_e_b	= 3,		// error (1=mask)
+	DMASM_e_m	= 0x00000008,	// 
+	DMASM_h_b	= 4,		// halt (1=mask)
+	DMASM_h_m	= 0x00000010,	// 
+} ;
+
+/*
+ * DMA channel definitions
+ */
+
+enum
+{
+	DMACH_extToMem0 = 0,
+	DMACH_memToExt0 = 0,
+	DMACH_extToMem1 = 1,
+	DMACH_memToExt1 = 1,
+	DMACH_ethRcv0 = 2,
+	DMACH_ethXmt0 = 3,
+	DMACH_ethRcv1 = 4,
+	DMACH_ethXmt2 = 5,
+	DMACH_memToFifo = 6,
+	DMACH_fifoToMem = 7,
+	DMACH_rng_de = 7,//randomNumberGenerator on LC/DE
+	DMACH_pciToMem = 8,
+	DMACH_memToPci = 9,
+	DMACH_securityInput = 10,
+	DMACH_securityOutput = 11,
+	DMACH_rng_se = 12, //randomNumberGenerator on SE
+	
+	DMACH_count //must be last
+};
+
+
+typedef struct DMAC_s
+{
+	struct DMA_Chan_s ch [DMACH_count] ; //use ch[DMACH_]
+} volatile *DMA_t ;
+
+
+/*
+ * External DMA parameters
+*/
+
+enum
+{
+	DMADEVCMD_ts_b	= 0,		// ts field in devcmd
+	DMADEVCMD_ts_m	= 0x00000007,	// ts field in devcmd
+		DMADEVCMD_ts_byte_v	= 0,
+		DMADEVCMD_ts_halfword_v	= 1,
+		DMADEVCMD_ts_word_v	= 2,
+		DMADEVCMD_ts_2word_v	= 3,
+		DMADEVCMD_ts_4word_v	= 4,
+		DMADEVCMD_ts_6word_v	= 5,
+		DMADEVCMD_ts_8word_v	= 6,
+		DMADEVCMD_ts_16word_v	= 7
+};
+
+
+#if 1	// aws - Compatibility.
+#	define	EXTDMA_ts_b		DMADEVCMD_ts_b
+#	define	EXTDMA_ts_m		DMADEVCMD_ts_m
+#	define	EXTDMA_ts_byte_v	DMADEVCMD_ts_byte_v
+#	define	EXTDMA_ts_halfword_v	DMADEVCMD_ts_halfword_v
+#	define	EXTDMA_ts_word_v	DMADEVCMD_ts_word_v
+#	define	EXTDMA_ts_2word_v	DMADEVCMD_ts_2word_v
+#	define	EXTDMA_ts_4word_v	DMADEVCMD_ts_4word_v
+#	define	EXTDMA_ts_6word_v	DMADEVCMD_ts_6word_v
+#	define	EXTDMA_ts_8word_v	DMADEVCMD_ts_8word_v
+#	define	EXTDMA_ts_16word_v	DMADEVCMD_ts_16word_v
+#endif	// aws - Compatibility.
+
+#endif //__IDT_RC32438_DMA_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_dma_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,82 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   DMA operations for IDT RC32438.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32438_DMA_V_H__
+#define __IDT_RC32438_DMA_V_H__
+#include  <asm/idt-boards/rc32438/rc32438_dma.h> 
+
+#define DMA_CHAN_OFFSET  0x14
+#define IS_DMA_USED(X) (((X) & (DMAD_f_m | DMAD_d_m | DMAD_t_m)) != 0)
+#define DMA_COUNT(count)   \
+  ((count) & DMAD_count_m)
+
+#define DMA_HALT_TIMEOUT 500
+
+
+static inline int rc32438_halt_dma(DMA_Chan_t ch)
+{
+	int timeout=1;
+	if (rc32438_readl(&ch->dmac) & DMAC_run_m) {
+		rc32438_writel(0, &ch->dmac); 
+		
+		for (timeout = DMA_HALT_TIMEOUT; timeout > 0; timeout--) {
+			if (rc32438_readl(&ch->dmas) & DMAS_h_m) {
+				rc32438_writel(0, &ch->dmas);  
+				break;
+			}
+		}
+
+	}
+	
+	return timeout ? 0 : 1;
+}
+
+
+
+
+static inline void rc32438_start_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	rc32438_writel(0, &ch->dmandptr); 
+	rc32438_writel(dma_addr, &ch->dmadptr);
+}
+
+static inline void rc32438_chain_dma(DMA_Chan_t ch, u32 dma_addr)
+{
+	rc32438_writel(dma_addr, &ch->dmandptr);
+}
+#endif //__IDT_RC32438_DMA_V_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_eth.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_eth.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_eth.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,328 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT EB438 ethernet
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32438_ETH_H__
+#define __IDT_RC32438_ETH_H__
+enum
+{
+	ETH0_PhysicalAddress	= 0x18058000,
+	ETH_PhysicalAddress	= ETH0_PhysicalAddress,		// Default
+
+	ETH0_VirtualAddress	= 0xb8058000,
+	ETH_VirtualAddress	= ETH0_VirtualAddress,		// Default
+	ETH1_PhysicalAddress	= 0x18060000,
+	ETH1_VirtualAddress	= 0xb8060000,			// Default
+} ;
+
+typedef struct
+{
+	u32 ethintfc		;
+	u32 ethfifott		;
+	u32 etharc		;
+	u32 ethhash0		;
+	u32 ethhash1		;
+	u32 ethu0 [4]		;	// Reserved.	
+	u32 ethpfs		;
+	u32 ethmcp		;
+	u32 eth_u1 [10]		;	// Reserved.
+	u32 ethspare		;
+	u32 eth_u2 [42]		;	// Reserved. 
+	u32 ethsal0		;
+	u32 ethsah0		;
+	u32 ethsal1		;
+	u32 ethsah1		;
+	u32 ethsal2		;
+	u32 ethsah2		;
+	u32 ethsal3		;
+	u32 ethsah3		;
+	u32 ethrbc		;
+	u32 ethrpc		;
+	u32 ethrupc		;
+	u32 ethrfc		;
+	u32 ethtbc		;
+	u32 ethgpf		;
+	u32 eth_u9 [50]		;	// Reserved.	
+	u32 ethmac1		;
+	u32 ethmac2		;
+	u32 ethipgt		;
+	u32 ethipgr		;
+	u32 ethclrt		;
+	u32 ethmaxf		;
+	u32 eth_u10		;	// Reserved.	
+	u32 ethmtest		;
+	u32 miimcfg		;
+	u32 miimcmd		;
+	u32 miimaddr		;
+	u32 miimwtd		;
+	u32 miimrdd		;
+	u32 miimind		;
+	u32 eth_u11		;	// Reserved.
+	u32 eth_u12		;	// Reserved.
+	u32 ethcfsa0		;
+	u32 ethcfsa1		;
+	u32 ethcfsa2		;
+} volatile *ETH_t;
+
+enum
+{
+	ETHINTFC_en_b		= 0,
+	ETHINTFC_en_m		= 0x00000001,
+	ETHINTFC_its_b		= 1,
+	ETHINTFC_its_m		= 0x00000002,
+	ETHINTFC_rip_b		= 2,
+	ETHINTFC_rip_m		= 0x00000004,
+	ETHINTFC_jam_b		= 3,
+	ETHINTFC_jam_m		= 0x00000008,
+	ETHINTFC_ovr_b		= 4,
+	ETHINTFC_ovr_m		= 0x00000010,
+	ETHINTFC_und_b		= 5,
+	ETHINTFC_und_m		= 0x00000020,
+
+	ETHFIFOTT_tth_b		= 0,
+	ETHFIFOTT_tth_m		= 0x0000007f,
+
+	ETHARC_pro_b		= 0,
+	ETHARC_pro_m		= 0x00000001,
+	ETHARC_am_b		= 1,
+	ETHARC_am_m		= 0x00000002,
+	ETHARC_afm_b		= 2,
+	ETHARC_afm_m		= 0x00000004,
+	ETHARC_ab_b		= 3,
+	ETHARC_ab_m		= 0x00000008,
+
+	ETHSAL_byte5_b		= 0,
+	ETHSAL_byte5_m		= 0x000000ff,
+	ETHSAL_byte4_b		= 8,
+	ETHSAL_byte4_m		= 0x0000ff00,
+	ETHSAL_byte3_b		= 16,
+	ETHSAL_byte3_m		= 0x00ff0000,
+	ETHSAL_byte2_b		= 24,
+	ETHSAL_byte2_m		= 0xff000000,
+
+	ETHSAH_byte1_b		= 0,
+	ETHSAH_byte1_m		= 0x000000ff,
+	ETHSAH_byte0_b		= 8,
+	ETHSAH_byte0_m		= 0x0000ff00,
+	
+	ETHGPF_ptv_b		= 0,
+	ETHGPF_ptv_m		= 0x0000ffff,
+
+	ETHPFS_pfd_b		= 0,
+	ETHPFS_pfd_m		= 0x00000001,
+
+	ETHCFSA0_cfsa4_b	= 0,
+	ETHCFSA0_cfsa4_m	= 0x000000ff,
+	ETHCFSA0_cfsa5_b	= 8,
+	ETHCFSA0_cfsa5_m	= 0x0000ff00,
+
+	ETHCFSA1_cfsa2_b	= 0,
+	ETHCFSA1_cfsa2_m	= 0x000000ff,
+	ETHCFSA1_cfsa3_b	= 8,
+	ETHCFSA1_cfsa3_m	= 0x0000ff00,
+
+	ETHCFSA2_cfsa0_b	= 0,
+	ETHCFSA2_cfsa0_m	= 0x000000ff,
+	ETHCFSA2_cfsa1_b	= 8,
+	ETHCFSA2_cfsa1_m	= 0x0000ff00,
+
+	ETHMAC1_re_b		= 0,
+	ETHMAC1_re_m		= 0x00000001,
+	ETHMAC1_paf_b		= 1,
+	ETHMAC1_paf_m		= 0x00000002,
+	ETHMAC1_rfc_b		= 2,
+	ETHMAC1_rfc_m		= 0x00000004,
+	ETHMAC1_tfc_b		= 3,
+	ETHMAC1_tfc_m		= 0x00000008,
+	ETHMAC1_lb_b		= 4,
+	ETHMAC1_lb_m		= 0x00000010,
+	ETHMAC1_mr_b		= 31,
+	ETHMAC1_mr_m		= 0x80000000,
+
+	ETHMAC2_fd_b		= 0,
+	ETHMAC2_fd_m		= 0x00000001,
+	ETHMAC2_flc_b		= 1,
+	ETHMAC2_flc_m		= 0x00000002,
+	ETHMAC2_hfe_b		= 2,
+	ETHMAC2_hfe_m		= 0x00000004,
+	ETHMAC2_dc_b		= 3,
+	ETHMAC2_dc_m		= 0x00000008,
+	ETHMAC2_cen_b		= 4,
+	ETHMAC2_cen_m		= 0x00000010,
+	ETHMAC2_pe_b		= 5,
+	ETHMAC2_pe_m		= 0x00000020,
+	ETHMAC2_vpe_b		= 6,
+	ETHMAC2_vpe_m		= 0x00000040,
+	ETHMAC2_ape_b		= 7,
+	ETHMAC2_ape_m		= 0x00000080,
+	ETHMAC2_ppe_b		= 8,
+	ETHMAC2_ppe_m		= 0x00000100,
+	ETHMAC2_lpe_b		= 9,
+	ETHMAC2_lpe_m		= 0x00000200,
+	ETHMAC2_nb_b		= 12,
+	ETHMAC2_nb_m		= 0x00001000,
+	ETHMAC2_bp_b		= 13,
+	ETHMAC2_bp_m		= 0x00002000,
+	ETHMAC2_ed_b		= 14,
+	ETHMAC2_ed_m		= 0x00004000,
+
+	ETHIPGT_ipgt_b		= 0,
+	ETHIPGT_ipgt_m		= 0x0000007f,
+
+	ETHIPGR_ipgr2_b		= 0,
+	ETHIPGR_ipgr2_m		= 0x0000007f,
+	ETHIPGR_ipgr1_b		= 8,
+	ETHIPGR_ipgr1_m		= 0x00007f00,
+
+	ETHCLRT_maxret_b	= 0,
+	ETHCLRT_maxret_m	= 0x0000000f,
+	ETHCLRT_colwin_b	= 8,
+	ETHCLRT_colwin_m	= 0x00003f00,
+
+	ETHMAXF_maxf_b		= 0,
+	ETHMAXF_maxf_m		= 0x0000ffff,
+
+	ETHMTEST_tb_b		= 2,
+	ETHMTEST_tb_m		= 0x00000004,
+
+	ETHMCP_div_b		= 0,
+	ETHMCP_div_m		= 0x000000ff,
+	
+	MIIMCFG_rsv_b		= 0,
+	MIIMCFG_rsv_m		= 0x0000000c,
+
+	MIIMCMD_rd_b		= 0,
+	MIIMCMD_rd_m		= 0x00000001,
+	MIIMCMD_scn_b		= 1,
+	MIIMCMD_scn_m		= 0x00000002,
+
+	MIIMADDR_regaddr_b	= 0,
+	MIIMADDR_regaddr_m	= 0x0000001f,
+	MIIMADDR_phyaddr_b	= 8,
+	MIIMADDR_phyaddr_m	= 0x00001f00,
+
+	MIIMWTD_wdata_b		= 0,
+	MIIMWTD_wdata_m		= 0x0000ffff,
+
+	MIIMRDD_rdata_b		= 0,
+	MIIMRDD_rdata_m		= 0x0000ffff,
+
+	MIIMIND_bsy_b		= 0,
+	MIIMIND_bsy_m		= 0x00000001,
+	MIIMIND_scn_b		= 1,
+	MIIMIND_scn_m		= 0x00000002,
+	MIIMIND_nv_b		= 2,
+	MIIMIND_nv_m		= 0x00000004,
+
+} ;
+
+/*
+ * Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors.
+ */
+enum
+{
+	ETHRX_fd_b		= 0,
+	ETHRX_fd_m		= 0x00000001,
+	ETHRX_ld_b		= 1,
+	ETHRX_ld_m		= 0x00000002,
+	ETHRX_rok_b		= 2,
+	ETHRX_rok_m		= 0x00000004,
+	ETHRX_fm_b		= 3,
+	ETHRX_fm_m		= 0x00000008,
+	ETHRX_mp_b		= 4,
+	ETHRX_mp_m		= 0x00000010,
+	ETHRX_bp_b		= 5,
+	ETHRX_bp_m		= 0x00000020,
+	ETHRX_vlt_b		= 6,
+	ETHRX_vlt_m		= 0x00000040,
+	ETHRX_cf_b		= 7,
+	ETHRX_cf_m		= 0x00000080,
+	ETHRX_ovr_b		= 8,
+	ETHRX_ovr_m		= 0x00000100,
+	ETHRX_crc_b		= 9,
+	ETHRX_crc_m		= 0x00000200,
+	ETHRX_cv_b		= 10,
+	ETHRX_cv_m		= 0x00000400,
+	ETHRX_db_b		= 11,
+	ETHRX_db_m		= 0x00000800,
+	ETHRX_le_b		= 12,
+	ETHRX_le_m		= 0x00001000,
+	ETHRX_lor_b		= 13,
+	ETHRX_lor_m		= 0x00002000,
+	ETHRX_ces_b		= 14,
+	ETHRX_ces_m		= 0x00004000,
+	ETHRX_length_b		= 16,
+	ETHRX_length_m		= 0xffff0000,
+
+	ETHTX_fd_b		= 0,
+	ETHTX_fd_m		= 0x00000001,
+	ETHTX_ld_b		= 1,
+	ETHTX_ld_m		= 0x00000002,
+	ETHTX_oen_b		= 2,
+	ETHTX_oen_m		= 0x00000004,
+	ETHTX_pen_b		= 3,
+	ETHTX_pen_m		= 0x00000008,
+	ETHTX_cen_b		= 4,
+	ETHTX_cen_m		= 0x00000010,
+	ETHTX_hen_b		= 5,
+	ETHTX_hen_m		= 0x00000020,
+	ETHTX_tok_b		= 6,
+	ETHTX_tok_m		= 0x00000040,
+	ETHTX_mp_b		= 7,
+	ETHTX_mp_m		= 0x00000080,
+	ETHTX_bp_b		= 8,
+	ETHTX_bp_m		= 0x00000100,
+	ETHTX_und_b		= 9,
+	ETHTX_und_m		= 0x00000200,
+	ETHTX_of_b		= 10,
+	ETHTX_of_m		= 0x00000400,
+	ETHTX_ed_b		= 11,
+	ETHTX_ed_m		= 0x00000800,
+	ETHTX_ec_b		= 12,
+	ETHTX_ec_m		= 0x00001000,
+	ETHTX_lc_b		= 13,
+	ETHTX_lc_m		= 0x00002000,
+	ETHTX_td_b		= 14,
+	ETHTX_td_m		= 0x00004000,
+	ETHTX_crc_b		= 15,
+	ETHTX_crc_m		= 0x00008000,
+	ETHTX_le_b		= 16,
+	ETHTX_le_m		= 0x00010000,
+	ETHTX_cc_b		= 17,
+	ETHTX_cc_m		= 0x001E0000,
+} ;
+#endif //__IDT_RC32438_ETH_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_eth_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,72 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   macros for IDT EB438 ethernet
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32438_ETH_V_H__
+#define __IDT_RC32438_ETH_V_H__
+#include  <asm/idt-boards/rc32438/rc32438_eth.h> 
+
+#define IS_TX_TOK(X)         (((X) & (1<<ETHTX_tok_b)) >> ETHTX_tok_b )   /* Transmit Okay    */
+#define IS_TX_MP(X)          (((X) & (1<<ETHTX_mp_b))  >> ETHTX_mp_b )    /* Multicast        */
+#define IS_TX_BP(X)          (((X) & (1<<ETHTX_bp_b))  >> ETHTX_bp_b )    /* Broadcast        */
+#define IS_TX_UND_ERR(X)     (((X) & (1<<ETHTX_und_b)) >> ETHTX_und_b )   /* Transmit FIFO Underflow */
+#define IS_TX_OF_ERR(X)      (((X) & (1<<ETHTX_of_b))  >> ETHTX_of_b )    /* Oversized frame  */
+#define IS_TX_ED_ERR(X)      (((X) & (1<<ETHTX_ed_b))  >> ETHTX_ed_b )    /* Excessive deferral  */
+#define IS_TX_EC_ERR(X)      (((X) & (1<<ETHTX_ec_b))  >> ETHTX_ec_b)     /* Excessive collisions  */
+#define IS_TX_LC_ERR(X)      (((X) & (1<<ETHTX_lc_b))  >> ETHTX_lc_b )    /* Late Collision   */
+#define IS_TX_TD_ERR(X)      (((X) & (1<<ETHTX_td_b))  >> ETHTX_td_b )    /* Transmit deferred*/
+#define IS_TX_CRC_ERR(X)     (((X) & (1<<ETHTX_crc_b)) >> ETHTX_crc_b )   /* CRC Error        */
+#define IS_TX_LE_ERR(X)      (((X) & (1<<ETHTX_le_b))  >>  ETHTX_le_b )    /* Length Error     */
+
+#define TX_COLLISION_COUNT(X) (((X) & ETHTX_cc_m)>>ETHTX_cc_b)  /* Collision Count  */
+
+#define IS_RCV_ROK(X)        (((X) & (1<<ETHRX_rok_b)) >> ETHRX_rok_b)    /* Receive Okay     */
+#define IS_RCV_FM(X)         (((X) & (1<<ETHRX_fm_b))  >> ETHRX_fm_b)     /* Is Filter Match  */
+#define IS_RCV_MP(X)         (((X) & (1<<ETHRX_mp_b))  >> ETHRX_mp_b)     /* Is it MP         */
+#define IS_RCV_BP(X)         (((X) & (1<<ETHRX_bp_b))  >> ETHRX_bp_b)     /* Is it BP         */
+#define IS_RCV_VLT(X)        (((X) & (1<<ETHRX_vlt_b)) >> ETHRX_vlt_b)    /* VLAN Tag Detect  */
+#define IS_RCV_CF(X)         (((X) & (1<<ETHRX_cf_b))  >> ETHRX_cf_b)     /* Control Frame    */
+#define IS_RCV_OVR_ERR(X)    (((X) & (1<<ETHRX_ovr_b)) >> ETHRX_ovr_b)    /* Receive Overflow */
+#define IS_RCV_CRC_ERR(X)    (((X) & (1<<ETHRX_crc_b)) >> ETHRX_crc_b)    /* CRC Error        */
+#define IS_RCV_CV_ERR(X)     (((X) & (1<<ETHRX_cv_b))  >> ETHRX_cv_b)     /* Code Violation   */
+#define IS_RCV_DB_ERR(X)     (((X) & (1<<ETHRX_db_b))  >> ETHRX_db_b)     /* Dribble Bits     */
+#define IS_RCV_LE_ERR(X)     (((X) & (1<<ETHRX_le_b))  >> ETHRX_le_b)     /* Length error     */
+#define IS_RCV_LOR_ERR(X)    (((X) & (1<<ETHRX_lor_b)) >> ETHRX_lor_b)    /* Length Out of Range */
+#define IS_RCV_CES_ERR(X)    (((X) & (1<<ETHRX_ces_b)) >> ETHRX_ces_b)  /* Preamble error   */
+#define RCVPKT_LENGTH(X)     (((X) & ETHRX_length_m) >> ETHRX_length_b)   /* Length of the received packet */
+
+#endif //__IDT_RC32438_ETH_V_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_gpio.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,257 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32438 GPIO.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+#ifndef __IDT_RC32438_GPIO_H__
+#define __IDT_RC32438_GPIO_H__ 
+enum
+{
+	GPIO0_PhysicalAddress	= 0x18048000,
+	GPIO_PhysicalAddress	= GPIO0_PhysicalAddress,	// Default
+
+	GPIO0_VirtualAddress	= 0xb8048000,
+	GPIO_VirtualAddress	= GPIO0_VirtualAddress,		// Default
+} ;
+
+typedef struct
+{
+	u32   gpiofunc;   /* GPIO Function Register
+			   * gpiofunc[x]==0 bit = gpio
+			   * func[x]==1  bit = altfunc
+			   */
+	u32   gpiocfg;	  /* GPIO Configuration Register
+			   * gpiocfg[x]==0 bit = input
+			   * gpiocfg[x]==1 bit = output
+			   */
+	u32   gpiod;	  /* GPIO Data Register
+			   * gpiod[x] read/write gpio pinX status
+			   */
+	u32   gpioilevel; /* GPIO Interrupt Status Register
+			   * interrupt level (see gpioistat)
+			   */
+	u32   gpioistat;  /* Gpio Interrupt Status Register
+			   * istat[x] = (gpiod[x] == level[x])
+			   * cleared in ISR (STICKY bits)
+			   */
+	u32   gpionmien;  /* GPIO Non-maskable Interrupt Enable Register */
+} volatile * GPIO_t ;
+
+typedef enum
+{
+	GPIO_gpio_v		= 0,		// gpiofunc use pin as GPIO.
+	GPIO_alt_v		= 1,		// gpiofunc use pin as alt.
+	GPIO_input_v		= 0,		// gpiocfg use pin as input.
+	GPIO_output_v		= 1,		// gpiocfg use pin as output.
+	GPIO_pin0_b		= 0,
+	GPIO_pin0_m		= 0x00000001,
+	GPIO_pin1_b		= 1,
+	GPIO_pin1_m		= 0x00000002,
+	GPIO_pin2_b		= 2,
+	GPIO_pin2_m		= 0x00000004,
+	GPIO_pin3_b		= 3,
+	GPIO_pin3_m		= 0x00000008,
+	GPIO_pin4_b		= 4,
+	GPIO_pin4_m		= 0x00000010,
+	GPIO_pin5_b		= 5,
+	GPIO_pin5_m		= 0x00000020,
+	GPIO_pin6_b		= 6,
+	GPIO_pin6_m		= 0x00000040,
+	GPIO_pin7_b		= 7,
+	GPIO_pin7_m		= 0x00000080,
+	GPIO_pin8_b		= 8,
+	GPIO_pin8_m		= 0x00000100,
+	GPIO_pin9_b		= 9,
+	GPIO_pin9_m		= 0x00000200,
+	GPIO_pin10_b		= 10,
+	GPIO_pin10_m		= 0x00000400,
+	GPIO_pin11_b		= 11,
+	GPIO_pin11_m		= 0x00000800,
+	GPIO_pin12_b		= 12,
+	GPIO_pin12_m		= 0x00001000,
+	GPIO_pin13_b		= 13,
+	GPIO_pin13_m		= 0x00002000,
+	GPIO_pin14_b		= 14,
+	GPIO_pin14_m		= 0x00004000,
+	GPIO_pin15_b		= 15,
+	GPIO_pin15_m		= 0x00008000,
+	GPIO_pin16_b		= 16,
+	GPIO_pin16_m		= 0x00010000,
+	GPIO_pin17_b		= 17,
+	GPIO_pin17_m		= 0x00020000,
+	GPIO_pin18_b		= 18,
+	GPIO_pin18_m		= 0x00040000,
+	GPIO_pin19_b		= 19,
+	GPIO_pin19_m		= 0x00080000,
+	GPIO_pin20_b		= 20,
+	GPIO_pin20_m		= 0x00100000,
+	GPIO_pin21_b		= 21,
+	GPIO_pin21_m		= 0x00200000,
+	GPIO_pin22_b		= 22,
+	GPIO_pin22_m		= 0x00400000,
+	GPIO_pin23_b		= 23,
+	GPIO_pin23_m		= 0x00800000,
+	GPIO_pin24_b		= 24,
+	GPIO_pin24_m		= 0x01000000,
+	GPIO_pin25_b		= 25,
+	GPIO_pin25_m		= 0x02000000,
+	GPIO_pin26_b		= 26,
+	GPIO_pin26_m		= 0x04000000,
+	GPIO_pin27_b		= 27,
+	GPIO_pin27_m		= 0x08000000,
+	GPIO_pin28_b		= 28,
+	GPIO_pin28_m		= 0x10000000,
+	GPIO_pin29_b		= 29,
+	GPIO_pin29_m		= 0x20000000,
+	GPIO_pin30_b		= 30,
+	GPIO_pin30_m		= 0x40000000,
+	GPIO_pin31_b		= 31,
+	GPIO_pin31_m		= 0x80000000,
+
+// Alternate function pins.  Corrsponding gpiofunc bit set to GPIO_alt_v.
+
+	GPIO_u0sout_b		= GPIO_pin0_b,		// UART 0 serial out.
+	GPIO_u0sout_m		= GPIO_pin0_m,
+		GPIO_u0sout_cfg_v	= GPIO_output_v,
+	GPIO_u0sinp_b	= GPIO_pin1_b,			// UART 0 serial in.
+	GPIO_u0sinp_m	= GPIO_pin1_m,
+		GPIO_u0sinp_cfg_v	= GPIO_input_v,
+	GPIO_u0rin_b	= GPIO_pin2_b,			// UART 0 ring indic.
+	GPIO_u0rin_m	= GPIO_pin2_m,
+		GPIO_u0rin_cfg_v	= GPIO_input_v,
+	GPIO_u0dcdn_b	= GPIO_pin3_b,			// UART 0 data carr.det.
+	GPIO_u0dcdn_m	= GPIO_pin3_m,
+		GPIO_u0dcdn_cfg_v	= GPIO_input_v,
+	GPIO_u0dtrn_b	= GPIO_pin4_b,			// UART 0 data term rdy.
+	GPIO_u0dtrn_m	= GPIO_pin4_m,
+		GPIO_u0dtrn_cfg_v	= GPIO_output_v,
+	GPIO_u0dsrn_b	= GPIO_pin5_b,			// UART 0 data set rdy.
+	GPIO_u0dsrn_m	= GPIO_pin5_m,
+		GPIO_u0dsrn_cfg_v	= GPIO_input_v,
+	GPIO_u0rtsn_b	= GPIO_pin6_b,			// UART 0 req. to send.
+	GPIO_u0rtsn_m	= GPIO_pin6_m,
+		GPIO_u0rtsn_cfg_v	= GPIO_output_v,
+	GPIO_u0ctsn_b	= GPIO_pin7_b,			// UART 0 clear to send.
+	GPIO_u0ctsn_m	= GPIO_pin7_m,
+		GPIO_u0ctsn_cfg_v	= GPIO_input_v,
+
+	GPIO_u1sout_b		= GPIO_pin8_b,		// UART 1 serial out.
+	GPIO_u1sout_m		= GPIO_pin8_m,
+		GPIO_u1sout_cfg_v	= GPIO_output_v,
+	GPIO_u1sinp_b		= GPIO_pin9_b,		// UART 1 serial in.
+	GPIO_u1sinp_m		= GPIO_pin9_m,
+		GPIO_u1sinp_cfg_v	= GPIO_input_v,
+	GPIO_u1dtrn_b		= GPIO_pin10_b, 	// UART 1 data term rdy.
+	GPIO_u1dtrn_m		= GPIO_pin10_m,
+		GPIO_u1dtrn_cfg_v	= GPIO_output_v,
+	GPIO_u1dsrn_b		= GPIO_pin11_b, 	// UART 1 data set rdy.
+	GPIO_u1dsrn_m		= GPIO_pin11_m,
+		GPIO_u1dsrn_cfg_v	= GPIO_input_v,
+	GPIO_u1rtsn_b		= GPIO_pin12_b, 	// UART 1 req. to send.
+	GPIO_u1rtsn_m		= GPIO_pin12_m,
+		GPIO_u1rtsn_cfg_v	= GPIO_output_v,
+	GPIO_u1ctsn_b		= GPIO_pin13_b, 	// UART 1 clear to send.
+	GPIO_u1ctsn_m		= GPIO_pin13_m,
+		GPIO_u1ctsn_cfg_v	= GPIO_input_v,
+
+	GPIO_dmareqn0_b 	= GPIO_pin14_b, 	// Ext. DMA 0 request
+	GPIO_dmareqn0_m 	= GPIO_pin14_m,
+		GPIO_dmareqn0_cfg_v	= GPIO_input_v,
+
+	GPIO_dmareqn1_b 	= GPIO_pin15_b, 	// Ext. DMA 1 request
+	GPIO_dmareqn1_m 	= GPIO_pin15_m,
+		GPIO_dmareqn1_cfg_v	= GPIO_input_v,
+
+	GPIO_dmadonen0_b	= GPIO_pin16_b, 	// Ext. DMA 0 done
+	GPIO_dmadonen0_m	= GPIO_pin16_m,
+		GPIO_dmadonen0_cfg_v	= GPIO_input_v,
+
+	GPIO_dmadonen1_b	= GPIO_pin17_b, 	// Ext. DMA 1 done
+	GPIO_dmadonen1_m	= GPIO_pin17_m,
+		GPIO_dmadonen1_cfg_v	= GPIO_input_v,
+
+	GPIO_dmafinn0_b 	= GPIO_pin18_b, 	// Ext. DMA 0 finished
+	GPIO_dmafinn0_m 	= GPIO_pin18_m,
+		GPIO_dmafinn0_cfg_v	= GPIO_output_v,
+
+	GPIO_dmafinn1_b 	= GPIO_pin19_b, 	// Ext. DMA 1 finished
+	GPIO_dmafinn1_m 	= GPIO_pin19_m,
+		GPIO_dmafinn1_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr22_b		= GPIO_pin20_b, 	// M&P bus bit 22.
+	GPIO_maddr22_m		= GPIO_pin20_m,
+		GPIO_maddr22_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr23_b		= GPIO_pin21_b, 	// M&P bus bit 23.
+	GPIO_maddr23_m		= GPIO_pin21_m,
+		GPIO_maddr23_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr24_b		= GPIO_pin22_b, 	// M&P bus bit 24.
+	GPIO_maddr24_m		= GPIO_pin22_m,
+		GPIO_maddr24_cfg_v	= GPIO_output_v,
+
+	GPIO_maddr25_b		= GPIO_pin23_b, 	// M&P bus bit 25.
+	GPIO_maddr25_m		= GPIO_pin23_m,
+		GPIO_maddr25_cfg_v	= GPIO_output_v,
+
+	GPIO_afspare6_b 	= GPIO_pin24_b, 	// reserved.
+	GPIO_afspare6_m 	= GPIO_pin24_m,
+		GPIO_afspare6_cfg_v	= GPIO_input_v,
+	GPIO_afspare5_b 	= GPIO_pin25_b, 	// reserved.
+	GPIO_afspare5_m 	= GPIO_pin25_m,
+		GPIO_afspare5_cfg_v	= GPIO_input_v,
+	GPIO_afspare4_b 	= GPIO_pin26_b, 	// reserved.
+	GPIO_afspare4_m 	= GPIO_pin26_m,
+		GPIO_afspare4_cfg_v	= GPIO_input_v,
+	GPIO_afspare3_b 	= GPIO_pin27_b, 	// reserved.
+	GPIO_afspare3_m 	= GPIO_pin27_m,
+		GPIO_afspare3_cfg_v	= GPIO_input_v,
+	GPIO_afspare2_b 	= GPIO_pin28_b, 	// reserved.
+	GPIO_afspare2_m 	= GPIO_pin28_m,
+		GPIO_afspare2_cfg_v	= GPIO_input_v,
+	GPIO_afspare1_b 	= GPIO_pin29_b, 	// reserved.
+	GPIO_afspare1_m 	= GPIO_pin29_m,
+		GPIO_afspare1_cfg_v	= GPIO_input_v,
+
+	GPIO_pcimuintn_b	= GPIO_pin30_b, 	// PCI messaging int.
+	GPIO_pcimuintn_m	= GPIO_pin30_m,
+		GPIO_pcimuintn_cfg_v	= GPIO_output_v,
+
+	GPIO_rngclk_b		= GPIO_pin31_b, 	// RNG external clock
+	GPIO_rngclk_m		= GPIO_pin31_m,
+		GPIO_rncclk_cfg_v	= GPIO_input_v,
+} GPIO_DEFS_t;
+
+#endif //__IDT_RC32438_GPIO_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,152 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32438 CPU.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#ifndef __IDT_RC32438_H__
+#define  __IDT_RC32438_H__
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/idt-boards/rc32438/rc32438_timer.h>
+
+#define RC32438_REG_BASE   0x18000000
+
+#define interrupt ((volatile INT_t ) INT0_VirtualAddress)
+#define idttimer     ((volatile TIM_t)  TIM0_VirtualAddress)
+#define idt_gpio	  ((volatile GPIO_t) GPIO0_VirtualAddress)
+
+#define IDT_CLOCK_MULT 2
+#define MIPS_CPU_TIMER_IRQ 7
+/* Interrupt Controller */
+#define IC_GROUP0_PEND     (RC32438_REG_BASE + 0x38000)
+#define IC_GROUP0_MASK     (RC32438_REG_BASE + 0x38008)
+#define IC_GROUP_OFFSET    0x0C
+#define RTC_BASE           0xAC0801FF0
+
+#define NUM_INTR_GROUPS    5
+/* 16550 UARTs */
+
+#define GROUP0_IRQ_BASE 8		/* GRP2 IRQ numbers start here */
+#define GROUP1_IRQ_BASE (GROUP0_IRQ_BASE + 32) /* GRP3 IRQ numbers start here */
+#define GROUP2_IRQ_BASE (GROUP1_IRQ_BASE + 32) /* GRP4 IRQ numbers start here */
+#define GROUP3_IRQ_BASE (GROUP2_IRQ_BASE + 32)	/* GRP5 IRQ numbers start here */
+#define GROUP4_IRQ_BASE (GROUP3_IRQ_BASE + 32)
+
+#ifdef __MIPSEB__
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50003)
+#define RC32438_UART1_BASE (RC32438_REG_BASE + 0x50023)
+#else
+#define RC32438_UART0_BASE (RC32438_REG_BASE + 0x50000)
+#define RC32438_UART1_BASE (RC32438_REG_BASE + 0x50020)
+#endif
+
+#define RC32438_UART0_IRQ  GROUP3_IRQ_BASE + 0
+#define RC32438_UART1_IRQ  GROUP3_IRQ_BASE + 3
+
+#define RC32438_NR_IRQS  (GROUP4_IRQ_BASE + 32)
+
+
+
+/* cpu pipeline flush */
+static inline void rc32438_sync(void)
+{
+        __asm__ volatile ("sync");
+}
+
+static inline void rc32438_sync_udelay(int us)
+{
+        __asm__ volatile ("sync");
+        udelay(us);
+}
+
+static inline void rc32438_sync_delay(int ms)
+{
+        __asm__ volatile ("sync");
+        mdelay(ms);
+}
+
+/*
+ * Macros to access internal RC32438 registers. No byte
+ * swapping should be done when accessing the internal
+ * registers.
+ */
+
+#define rc32438_readb __raw_readb
+#define rc32438_readw __raw_readw
+#define rc32438_readl __raw_readl
+
+#define rc32438_writeb __raw_writeb
+#define rc32438_writew __raw_writew
+#define rc32438_writel __raw_writel
+
+/*
+ * C access to CLZ and CLO instructions
+ * (count leading zeroes/ones).
+ */
+static inline int rc32438_clz(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clz\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+static inline int rc32438_clo(unsigned long val)
+{
+	int ret;
+        __asm__ volatile (
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		".set\tmips32\n\t"
+		"clo\t%0,%1\n\t"
+                ".set\tmips0\n\t"
+                ".set\tat\n\t"
+                ".set\treorder"
+                : "=r" (ret)
+		: "r" (val));
+
+	return ret;
+}
+#endif //__IDT_RC32438_H__
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_pci.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_pci.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_pci.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,510 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32438 PCI.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+enum
+{
+	PCI0_PhysicalAddress	= 0x18080000,
+	PCI_PhysicalAddress	= PCI0_PhysicalAddress,
+
+	PCI0_VirtualAddress	= 0xb8080000,
+	PCI_VirtualAddress	= PCI0_VirtualAddress,
+} ;
+
+enum
+{
+	PCI_LbaCount	= 4,		// Local base addresses.
+} ;
+
+typedef struct
+{
+	u32	a ;		// Address.
+	u32	c ;		// Control.
+	u32	m ;		// mapping.
+} PCI_Map_s ;
+
+typedef struct
+{
+	u32		pcic ;
+	u32		pcis ;
+	u32		pcism ;
+	u32		pcicfga ;
+	u32		pcicfgd ;
+	PCI_Map_s	pcilba [PCI_LbaCount] ;
+	u32		pcidac ;
+	u32		pcidas ;
+	u32		pcidasm ;
+	u32		pcidad ;
+	u32		pcidma8c ;
+	u32		pcidma9c ;
+	u32		pcitc ;
+} volatile *PCI_t ;
+
+// PCI messaging unit.
+enum
+{
+	PCIM_Count	= 2,
+} ;
+typedef struct
+{
+	u32		pciim [PCIM_Count] ;
+	u32		pciom [PCIM_Count] ;
+	u32		pciid ;
+	u32		pciiic ;
+	u32		pciiim ;
+	u32		pciiod ;
+	u32		pciioic ;
+	u32		pciioim ;
+} volatile *PCIM_t ;
+
+/*******************************************************************************
+ *
+ * PCI Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIC_en_b	= 0,
+	PCIC_en_m	= 0x00000001,
+	PCIC_tnr_b	= 1,
+	PCIC_tnr_m	= 0x00000002,
+	PCIC_sce_b	= 2,
+	PCIC_sce_m	= 0x00000004,
+	PCIC_ien_b	= 3,
+	PCIC_ien_m	= 0x00000008,
+	PCIC_aaa_b	= 4,
+	PCIC_aaa_m	= 0x00000010,
+	PCIC_eap_b	= 5,
+	PCIC_eap_m	= 0x00000020,
+	PCIC_pcim_b	= 6,
+	PCIC_pcim_m	= 0x000001c0,
+		PCIC_pcim_disabled_v	= 0,
+		PCIC_pcim_tnr_v 	= 1,	// Satellite - target not ready
+		PCIC_pcim_suspend_v	= 2,	// Satellite - suspended CPU.
+		PCIC_pcim_extern_v	= 3,	// Host - external arbiter.
+		PCIC_pcim_fixed_v	= 4,	// Host - fixed priority arb.
+		PCIC_pcim_roundrobin_v	= 5,	// Host - round robin priority.
+		PCIC_pcim_reserved6_v	= 6,
+		PCIC_pcim_reserved7_v	= 7,
+	PCIC_igm_b	= 9,
+	PCIC_igm_m	= 0x00000200,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIS_eed_b	= 0,
+	PCIS_eed_m	= 0x00000001,
+	PCIS_wr_b	= 1,
+	PCIS_wr_m	= 0x00000002,
+	PCIS_nmi_b	= 2,
+	PCIS_nmi_m	= 0x00000004,
+	PCIS_ii_b	= 3,
+	PCIS_ii_m	= 0x00000008,
+	PCIS_cwe_b	= 4,
+	PCIS_cwe_m	= 0x00000010,
+	PCIS_cre_b	= 5,
+	PCIS_cre_m	= 0x00000020,
+	PCIS_mdpe_b	= 6,
+	PCIS_mdpe_m	= 0x00000040,
+	PCIS_sta_b	= 7,
+	PCIS_sta_m	= 0x00000080,
+	PCIS_rta_b	= 8,
+	PCIS_rta_m	= 0x00000100,
+	PCIS_rma_b	= 9,
+	PCIS_rma_m	= 0x00000200,
+	PCIS_sse_b	= 10,
+	PCIS_sse_m	= 0x00000400,
+	PCIS_ose_b	= 11,
+	PCIS_ose_m	= 0x00000800,
+	PCIS_pe_b	= 12,
+	PCIS_pe_m	= 0x00001000,
+	PCIS_tae_b	= 13,
+	PCIS_tae_m	= 0x00002000,
+	PCIS_rle_b	= 14,
+	PCIS_rle_m	= 0x00004000,
+	PCIS_bme_b	= 15,
+	PCIS_bme_m	= 0x00008000,
+	PCIS_prd_b	= 16,
+	PCIS_prd_m	= 0x00010000,
+	PCIS_rip_b	= 17,
+	PCIS_rip_m	= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Status Mask Register
+ *
+ ******************************************************************************/
+enum {
+	PCISM_eed_b		= 0,
+	PCISM_eed_m		= 0x00000001,
+	PCISM_wr_b		= 1,
+	PCISM_wr_m		= 0x00000002,
+	PCISM_nmi_b		= 2,
+	PCISM_nmi_m		= 0x00000004,
+	PCISM_ii_b		= 3,
+	PCISM_ii_m		= 0x00000008,
+	PCISM_cwe_b		= 4,
+	PCISM_cwe_m		= 0x00000010,
+	PCISM_cre_b		= 5,
+	PCISM_cre_m		= 0x00000020,
+	PCISM_mdpe_b		= 6,
+	PCISM_mdpe_m		= 0x00000040,
+	PCISM_sta_b		= 7,
+	PCISM_sta_m		= 0x00000080,
+	PCISM_rta_b		= 8,
+	PCISM_rta_m		= 0x00000100,
+	PCISM_rma_b		= 9,
+	PCISM_rma_m		= 0x00000200,
+	PCISM_sse_b		= 10,
+	PCISM_sse_m		= 0x00000400,
+	PCISM_ose_b		= 11,
+	PCISM_ose_m		= 0x00000800,
+	PCISM_pe_b		= 12,
+	PCISM_pe_m		= 0x00001000,
+	PCISM_tae_b		= 13,
+	PCISM_tae_m		= 0x00002000,
+	PCISM_rle_b		= 14,
+	PCISM_rle_m		= 0x00004000,
+	PCISM_bme_b		= 15,
+	PCISM_bme_m		= 0x00008000,
+	PCISM_prd_b		= 16,
+	PCISM_prd_m		= 0x00010000,
+	PCISM_rip_b		= 17,
+	PCISM_rip_m		= 0x00020000,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Configuration Address Register
+ *
+ ******************************************************************************/
+enum {
+	PCICFGA_reg_b		= 2,
+	PCICFGA_reg_m		= 0x000000fc,
+		PCICFGA_reg_id_v	= 0x00>>2, //use PCFGID_
+		PCICFGA_reg_04_v	= 0x04>>2, //use PCFG04_
+		PCICFGA_reg_08_v	= 0x08>>2, //use PCFG08_
+		PCICFGA_reg_0C_v	= 0x0C>>2, //use PCFG0C_
+		PCICFGA_reg_pba0_v	= 0x10>>2, //use PCIPBA_
+		PCICFGA_reg_pba1_v	= 0x14>>2, //use PCIPBA_
+		PCICFGA_reg_pba2_v	= 0x18>>2, //use PCIPBA_
+		PCICFGA_reg_pba3_v	= 0x1c>>2, //use PCIPBA_
+		PCICFGA_reg_subsystem_v = 0x2c>>2, //use PCFGSS_
+		PCICFGA_reg_3C_v	= 0x3C>>2, //use PCFG3C_
+		PCICFGA_reg_pba0c_v	= 0x44>>2, //use PCIPBAC_
+		PCICFGA_reg_pba0m_v	= 0x48>>2,
+		PCICFGA_reg_pba1c_v	= 0x4c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba1m_v	= 0x50>>2,
+		PCICFGA_reg_pba2c_v	= 0x54>>2, //use PCIPBAC_
+		PCICFGA_reg_pba2m_v	= 0x58>>2,
+		PCICFGA_reg_pba3c_v	= 0x5c>>2, //use PCIPBAC_
+		PCICFGA_reg_pba3m_v	= 0x60>>2,
+		PCICFGA_reg_pmgt_v	= 0x64>>2,
+	PCICFGA_func_b		= 8,
+	PCICFGA_func_m		= 0x00000700,
+	PCICFGA_dev_b		= 11,
+	PCICFGA_dev_m		= 0x0000f800,
+		PCICFGA_dev_internal_v	= 0,
+	PCICFGA_bus_b		= 16,
+	PCICFGA_bus_m		= 0x00ff0000,
+		PCICFGA_bus_type0_v	= 0,	//local bus
+	PCICFGA_en_b		= 31,		// read only
+	PCICFGA_en_m		= 0x80000000,
+} ;
+
+enum {
+	PCFGID_vendor_b 	= 0,
+	PCFGID_vendor_m 	= 0x0000ffff,
+		PCFGID_vendor_IDT_v		= 0x111d,
+	PCFGID_device_b 	= 16,
+	PCFGID_device_m 	= 0xffff0000,
+		PCFGID_device_Acaciade_v	= 0x0207,
+
+	PCFG04_command_ioena_b		= 1,
+	PCFG04_command_ioena_m		= 0x00000001,
+	PCFG04_command_memena_b 	= 2,
+	PCFG04_command_memena_m 	= 0x00000002,
+	PCFG04_command_bmena_b		= 3,
+	PCFG04_command_bmena_m		= 0x00000004,
+	PCFG04_command_mwinv_b		= 5,
+	PCFG04_command_mwinv_m		= 0x00000010,
+	PCFG04_command_parena_b 	= 7,
+	PCFG04_command_parena_m 	= 0x00000040,
+	PCFG04_command_serrena_b	= 9,
+	PCFG04_command_serrena_m	= 0x00000100,
+	PCFG04_command_fastbbena_b	= 10,
+	PCFG04_command_fastbbena_m	= 0x00000200,
+	PCFG04_status_b 		= 16,
+	PCFG04_status_m 		= 0xffff0000,
+	PCFG04_status_66MHz_b		= 21,	// 66 MHz enable
+	PCFG04_status_66MHz_m		= 0x00200000,
+	PCFG04_status_fbb_b		= 23,
+	PCFG04_status_fbb_m		= 0x00800000,
+	PCFG04_status_mdpe_b		= 24,
+	PCFG04_status_mdpe_m		= 0x01000000,
+	PCFG04_status_dst_b		= 25,
+	PCFG04_status_dst_m		= 0x06000000,
+	PCFG04_status_sta_b		= 27,
+	PCFG04_status_sta_m		= 0x08000000,
+	PCFG04_status_rta_b		= 28,
+	PCFG04_status_rta_m		= 0x10000000,
+	PCFG04_status_rma_b		= 29,
+	PCFG04_status_rma_m		= 0x20000000,
+	PCFG04_status_sse_b		= 30,
+	PCFG04_status_sse_m		= 0x40000000,
+	PCFG04_status_pe_b		= 31,
+	PCFG04_status_pe_m		= 0x40000000,
+
+	PCFG08_revId_b			= 0,
+	PCFG08_revId_m			= 0x000000ff,
+	PCFG08_classCode_b		= 0,
+	PCFG08_classCode_m		= 0xffffff00,
+		PCFG08_classCode_bridge_v	= 06,
+		PCFG08_classCode_proc_v 	= 0x0b3000, // processor-MIPS
+	PCFG0C_cacheline_b		= 0,
+	PCFG0C_cacheline_m		= 0x000000ff,
+	PCFG0C_masterLatency_b		= 8,
+	PCFG0C_masterLatency_m		= 0x0000ff00,
+	PCFG0C_headerType_b		= 16,
+	PCFG0C_headerType_m		= 0x00ff0000,
+	PCFG0C_bist_b			= 24,
+	PCFG0C_bist_m			= 0xff000000,
+
+	PCIPBA_msi_b			= 0,
+	PCIPBA_msi_m			= 0x00000001,
+	PCIPBA_p_b			= 3,
+	PCIPBA_p_m			= 0x00000004,
+	PCIPBA_baddr_b			= 8,
+	PCIPBA_baddr_m			= 0xffffff00,
+
+	PCFGSS_vendorId_b		= 0,
+	PCFGSS_vendorId_m		= 0x0000ffff,
+	PCFGSS_id_b			= 16,
+	PCFGSS_id_m			= 0xffff0000,
+
+	PCFG3C_interruptLine_b		= 0,
+	PCFG3C_interruptLine_m		= 0x000000ff,
+	PCFG3C_interruptPin_b		= 8,
+	PCFG3C_interruptPin_m		= 0x0000ff00,
+	PCFG3C_minGrant_b		= 16,
+	PCFG3C_minGrant_m		= 0x00ff0000,
+	PCFG3C_maxLat_b 		= 24,
+	PCFG3C_maxLat_m 		= 0xff000000,
+
+	PCIPBAC_msi_b			= 0,
+	PCIPBAC_msi_m			= 0x00000001,
+	PCIPBAC_p_b			= 1,
+	PCIPBAC_p_m			= 0x00000002,
+	PCIPBAC_size_b			= 2,
+	PCIPBAC_size_m			= 0x0000007c,
+	PCIPBAC_sb_b			= 7,
+	PCIPBAC_sb_m			= 0x00000080,
+	PCIPBAC_pp_b			= 8,
+	PCIPBAC_pp_m			= 0x00000100,
+	PCIPBAC_mr_b			= 9,
+	PCIPBAC_mr_m			= 0x00000600,
+		PCIPBAC_mr_read_v	=0,	//no prefetching
+		PCIPBAC_mr_readLine_v	=1,
+		PCIPBAC_mr_readMult_v	=2,
+	PCIPBAC_mrl_b			= 11,
+	PCIPBAC_mrl_m			= 0x00000800,
+	PCIPBAC_mrm_b			= 12,
+	PCIPBAC_mrm_m			= 0x00001000,
+	PCIPBAC_trp_b			= 13,
+	PCIPBAC_trp_m			= 0x00002000,
+
+	PCFG40_trdyTimeout_b		= 0,
+	PCFG40_trdyTimeout_m		= 0x000000ff,
+	PCFG40_retryLim_b		= 8,
+	PCFG40_retryLim_m		= 0x0000ff00,
+};
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBA_baddr_b		= 0,		// In PCI_t -> pcilba [] .a
+	PCILBA_baddr_m		= 0xffffff00,
+} ;
+/*******************************************************************************
+ *
+ * PCI Local Base Address Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAC_msi_b		= 0,		// In pPci->pcilba[i].c
+	PCILBAC_msi_m		= 0x00000001,
+		PCILBAC_msi_mem_v	= 0,
+		PCILBAC_msi_io_v	= 1,
+	PCILBAC_size_b		= 2,	// In pPci->pcilba[i].c
+	PCILBAC_size_m		= 0x0000007c,
+	PCILBAC_sb_b		= 7,	// In pPci->pcilba[i].c
+	PCILBAC_sb_m		= 0x00000080,
+	PCILBAC_rt_b		= 8,	// In pPci->pcilba[i].c
+	PCILBAC_rt_m		= 0x00000100,
+		PCILBAC_rt_noprefetch_v = 0, // mem read
+		PCILBAC_rt_prefetch_v	= 1, // mem readline
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Local Base Address [0|1|2|3] Mapping Register
+ *
+ ******************************************************************************/
+enum {
+	PCILBAM_maddr_b 	= 8,
+	PCILBAM_maddr_m 	= 0xffffff00,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Control Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAC_den_b		= 0,
+	PCIDAC_den_m		= 0x00000001,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI Decoupled Access Status Register
+ *
+ ******************************************************************************/
+enum {
+	PCIDAS_d_b	= 0,
+	PCIDAS_d_m	= 0x00000001,
+	PCIDAS_b_b	= 1,
+	PCIDAS_b_m	= 0x00000002,
+	PCIDAS_e_b	= 2,
+	PCIDAS_e_m	= 0x00000004,
+	PCIDAS_ofe_b	= 3,
+	PCIDAS_ofe_m	= 0x00000008,
+	PCIDAS_off_b	= 4,
+	PCIDAS_off_m	= 0x00000010,
+	PCIDAS_ife_b	= 5,
+	PCIDAS_ife_m	= 0x00000020,
+	PCIDAS_iff_b	= 6,
+	PCIDAS_iff_m	= 0x00000040,
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 8 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA8C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA8C_mbs_m	= 0x00000fff,	// { pcidma8c }
+	PCIDMA8C_our_b	= 12,		// Optimize Unaligned Burst Reads.
+	PCIDMA8C_our_m	= 0x00001000,	// { pcidma8c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI DMA Channel 9 Configuration Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCIDMA9C_mbs_b	= 0,		// Maximum Burst Size.
+	PCIDMA9C_mbs_m	= 0x00000fff, // { pcidma9c }
+} ;
+
+/*******************************************************************************
+ *
+ * PCI to Memory(DMA Channel 8) AND Memory to PCI DMA(DMA Channel 9)Descriptors
+ *
+ ******************************************************************************/
+enum {
+	PCIDMAD_pt_b		= 22,		// in DEVCMD field (descriptor)
+	PCIDMAD_pt_m		= 0x00c00000,	// preferred transaction field
+		// These are for reads (DMA channel 8)
+		PCIDMAD_devcmd_mr_v	= 0,	//memory read
+		PCIDMAD_devcmd_mrl_v	= 1,	//memory read line
+		PCIDMAD_devcmd_mrm_v	= 2,	//memory read multiple
+		PCIDMAD_devcmd_ior_v	= 3,	//I/O read
+		// These are for writes (DMA channel 9)
+		PCIDMAD_devcmd_mw_v	= 0,	//memory write
+		PCIDMAD_devcmd_mwi_v	= 1,	//memory write invalidate
+		PCIDMAD_devcmd_iow_v	= 3,	//I/O write
+
+	// Swap byte field applies to both DMA channel 8 and 9
+	PCIDMAD_sb_b		= 24,		// in DEVCMD field (descriptor)
+	PCIDMAD_sb_m		= 0x01000000,	// swap byte field
+} ;
+
+
+/*******************************************************************************
+ *
+ * PCI Target Control Register
+ *
+ ******************************************************************************/
+enum
+{
+	PCITC_rtimer_b		= 0,		// In PCITC_t -> pcitc
+	PCITC_rtimer_m		= 0x000000ff,
+	PCITC_dtimer_b		= 8,		// In PCITC_t -> pcitc
+	PCITC_dtimer_m		= 0x0000ff00,
+	PCITC_rdr_b		= 18,		// In PCITC_t -> pcitc
+	PCITC_rdr_m		= 0x00040000,
+	PCITC_ddt_b		= 19,		// In PCITC_t -> pcitc
+	PCITC_ddt_m		= 0x00080000,
+} ;
+/*******************************************************************************
+ *
+ * PCI messaging unit [applies to both inbound and outbound registers ]
+ *
+ ******************************************************************************/
+enum
+{
+	PCIM_m0_b	= 0,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m0_m	= 0x00000001,	// inbound or outbound message 0
+	PCIM_m1_b	= 1,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_m1_m	= 0x00000002,	// inbound or outbound message 1
+	PCIM_db_b	= 2,		// In PCIM_t -> {pci{iic,iim,ioic,ioim}}
+	PCIM_db_m	= 0x00000004,	// inbound or outbound doorbell
+};
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_pci_v.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,190 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *   Definitions for IDT RC32438 PCI setup.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+
+#define PCI_MSG_VirtualAddress	     0xB8088010
+#define rc32438_pci ((volatile PCI_t) PCI0_VirtualAddress)
+#define rc32438_pci_msg ((volatile PCIM_t) PCI_MSG_VirtualAddress)
+
+#define PCIM_SHFT		0x6
+#define PCIM_BIT_LEN		0x7
+#define PCIM_H_EA		0x3
+#define PCIM_H_IA_FIX		0x4
+#define PCIM_H_IA_RR		0x5
+
+#define PCI_ADDR_START		0x50000000
+
+#define CPUTOPCI_MEM_WIN	0x02000000
+#define CPUTOPCI_IO_WIN		0x00100000
+#define PCILBA_SIZE_SHFT	2
+#define PCILBA_SIZE_MASK	0x1F
+#define SIZE_256MB		0x1C
+#define SIZE_128MB		0x1B
+#define SIZE_64MB               0x1A
+#define SIZE_32MB		0x19
+#define SIZE_16MB               0x18
+#define SIZE_4MB		0x16
+#define SIZE_2MB		0x15
+#define SIZE_1MB		0x14
+#define ACACIA_CONFIG0_ADDR	0x80000000
+#define ACACIA_CONFIG1_ADDR	0x80000004
+#define ACACIA_CONFIG2_ADDR	0x80000008
+#define ACACIA_CONFIG3_ADDR	0x8000000C
+#define ACACIA_CONFIG4_ADDR	0x80000010
+#define ACACIA_CONFIG5_ADDR	0x80000014
+#define ACACIA_CONFIG6_ADDR	0x80000018
+#define ACACIA_CONFIG7_ADDR	0x8000001C
+#define ACACIA_CONFIG8_ADDR	0x80000020
+#define ACACIA_CONFIG9_ADDR	0x80000024
+#define ACACIA_CONFIG10_ADDR	0x80000028
+#define ACACIA_CONFIG11_ADDR	0x8000002C
+#define ACACIA_CONFIG12_ADDR	0x80000030
+#define ACACIA_CONFIG13_ADDR	0x80000034
+#define ACACIA_CONFIG14_ADDR	0x80000038
+#define ACACIA_CONFIG15_ADDR	0x8000003C
+#define ACACIA_CONFIG16_ADDR	0x80000040
+#define ACACIA_CONFIG17_ADDR	0x80000044
+#define ACACIA_CONFIG18_ADDR	0x80000048
+#define ACACIA_CONFIG19_ADDR	0x8000004C
+#define ACACIA_CONFIG20_ADDR	0x80000050
+#define ACACIA_CONFIG21_ADDR	0x80000054
+#define ACACIA_CONFIG22_ADDR	0x80000058
+#define ACACIA_CONFIG23_ADDR	0x8000005C
+#define ACACIA_CONFIG24_ADDR	0x80000060
+#define ACACIA_CONFIG25_ADDR	0x80000064
+#define ACACIA_CMD 		(PCFG04_command_ioena_m | \
+				 PCFG04_command_memena_m | \
+				 PCFG04_command_bmena_m | \
+				 PCFG04_command_mwinv_m | \
+				 PCFG04_command_parena_m | \
+				 PCFG04_command_serrena_m )
+
+#define ACACIA_STAT		(PCFG04_status_mdpe_m | \
+				 PCFG04_status_sta_m  | \
+				 PCFG04_status_rta_m  | \
+				 PCFG04_status_rma_m  | \
+				 PCFG04_status_sse_m  | \
+				 PCFG04_status_pe_m)
+
+#define ACACIA_CNFG1		((ACACIA_STAT<<16)|ACACIA_CMD)
+
+#define ACACIA_REVID		0
+#define ACACIA_CLASS_CODE	0
+#define ACACIA_CNFG2		((ACACIA_CLASS_CODE<<8) | \
+				  ACACIA_REVID)
+
+#define ACACIA_CACHE_LINE_SIZE	4
+#define ACACIA_MASTER_LAT	0x3c
+#define ACACIA_HEADER_TYPE	0
+#define ACACIA_BIST		0
+
+#define ACACIA_CNFG3 ((ACACIA_BIST << 24) | \
+		      (ACACIA_HEADER_TYPE<<16) | \
+		      (ACACIA_MASTER_LAT<<8) | \
+		      ACACIA_CACHE_LINE_SIZE )
+
+#define ACACIA_BAR0	0x00000008 /* 128 MB Memory */
+#define ACACIA_BAR1	0x18800001 /* 1 MB IO */
+#define ACACIA_BAR2	0x18000001 /* 2 MB IO window for Acacia
+					internal Registers */
+#define ACACIA_BAR3	0x48000008 /* Spare 128 MB Memory */
+
+#define ACACIA_CNFG4	ACACIA_BAR0
+#define ACACIA_CNFG5    ACACIA_BAR1
+#define ACACIA_CNFG6 	ACACIA_BAR2
+#define ACACIA_CNFG7	ACACIA_BAR3
+
+#define ACACIA_SUBSYS_VENDOR_ID 0
+#define ACACIA_SUBSYSTEM_ID	0
+#define ACACIA_CNFG8		0
+#define ACACIA_CNFG9		0
+#define ACACIA_CNFG10		0
+#define ACACIA_CNFG11 	((ACACIA_SUBSYS_VENDOR_ID<<16) | \
+			  ACACIA_SUBSYSTEM_ID)
+#define ACACIA_INT_LINE		1
+#define ACACIA_INT_PIN		1
+#define ACACIA_MIN_GNT		8
+#define ACACIA_MAX_LAT		0x38
+#define ACACIA_CNFG12		0
+#define ACACIA_CNFG13 		0
+#define ACACIA_CNFG14		0
+#define ACACIA_CNFG15	((ACACIA_MAX_LAT<<24) | \
+			 (ACACIA_MIN_GNT<<16) | \
+			 (ACACIA_INT_PIN<<8)  | \
+			  ACACIA_INT_LINE)
+#define	ACACIA_RETRY_LIMIT	0x80
+#define ACACIA_TRDY_LIMIT	0x80
+#define ACACIA_CNFG16 ((ACACIA_RETRY_LIMIT<<8) | \
+			ACACIA_TRDY_LIMIT)
+#define PCI_PBAxC_R		0x0
+#define PCI_PBAxC_RL		0x1
+#define PCI_PBAxC_RM		0x2
+#define SIZE_SHFT		2
+
+#define ACACIA_PBA0C	( PCIPBAC_mrl_m | PCIPBAC_sb_m | \
+			  ((PCI_PBAxC_RM &0x3) << PCIPBAC_mr_b) | \
+			  PCIPBAC_pp_m | \
+			  (SIZE_128MB<<SIZE_SHFT) | \
+			   PCIPBAC_p_m)
+
+#define ACACIA_CNFG17	ACACIA_PBA0C
+#define ACACIA_PBA0M	0x0
+#define ACACIA_CNFG18	ACACIA_PBA0M
+
+#define ACACIA_PBA1C	((SIZE_1MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+
+#define ACACIA_CNFG19	ACACIA_PBA1C
+#define ACACIA_PBA1M	0x0
+#define ACACIA_CNFG20	ACACIA_PBA1M
+
+#define ACACIA_PBA2C	((SIZE_2MB<<SIZE_SHFT) | PCIPBAC_sb_m | \
+			  PCIPBAC_msi_m)
+
+#define ACACIA_CNFG21	ACACIA_PBA2C
+#define ACACIA_PBA2M	0x18000000
+#define ACACIA_CNFG22	ACACIA_PBA2M
+#define ACACIA_PBA3C	0
+#define ACACIA_CNFG23	ACACIA_PBA3C
+#define ACACIA_PBA3M	0
+#define ACACIA_CNFG24	ACACIA_PBA3M
+
+
+
+#define	PCITC_DTIMER_VAL	8
+#define PCITC_RTIMER_VAL	0x10
+
diff -Nur linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_timer.h linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_timer.h
--- linux-2.6.16/include/asm-mips/idt-boards/rc32438/rc32438_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/idt-boards/rc32438/rc32438_timer.h	2006-03-20 14:25:10.000000000 +0100
@@ -0,0 +1,91 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *    Timer register definition IDT RC32438 CPU.
+ *
+ *  Copyright 2004 IDT Inc. (rischelp@idt.com)
+ *         
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2004 P. Sadik.
+ *
+ * Initial Release
+ *
+ * 
+ *
+ **************************************************************************
+ */
+ 
+#ifndef __IDT_RC32438_TIM_H__
+#define __IDT_RC32438_TIM_H__
+
+enum
+{
+	TIM0_PhysicalAddress	= 0x18028000,
+	TIM_PhysicalAddress	= TIM0_PhysicalAddress,		// Default
+
+	TIM0_VirtualAddress	= 0xb8028000,
+	TIM_VirtualAddress	= TIM0_VirtualAddress,		// Default
+} ;
+
+enum
+{
+	TIM_Count = 3,
+} ;
+
+struct TIM_CNTR_s
+{
+	u32 count ;
+	u32 compare ;
+	u32 ctc ;	//use CTC_
+} ;
+
+typedef struct TIM_s
+{
+	struct TIM_CNTR_s	tim [TIM_Count] ;
+	u32			rcount ;	//use RCOUNT_
+	u32			rcompare ;	//use RCOMPARE_
+	u32			rtc ;		//use RTC_
+} volatile * TIM_t ;
+
+enum
+{
+	CTC_en_b	= 0,		
+	CTC_en_m	= 0x00000001,
+	CTC_to_b	= 1,		 
+	CTC_to_m	= 0x00000002,
+
+	RCOUNT_count_b		= 0,	     
+	RCOUNT_count_m		= 0x0000ffff,
+	RCOMPARE_compare_b	= 0,	   
+	RCOMPARE_compare_m	= 0x0000ffff,
+	RTC_ce_b		= 0,		
+	RTC_ce_m		= 0x00000001,
+	RTC_to_b		= 1,		
+	RTC_to_m		= 0x00000002,
+	RTC_rqe_b		= 2,		
+	RTC_rqe_m		= 0x00000004,
+				 
+} ;
+#endif	//__IDT_RC32438_TIM_H__
+
diff -Nur linux-2.6.16/include/asm-mips/mach-generic/irq.h linux-2.6.16-owrt/include/asm-mips/mach-generic/irq.h
--- linux-2.6.16/include/asm-mips/mach-generic/irq.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/mach-generic/irq.h	2006-03-20 14:25:10.000000000 +0100
@@ -8,6 +8,6 @@
 #ifndef __ASM_MACH_GENERIC_IRQ_H
 #define __ASM_MACH_GENERIC_IRQ_H
 
-#define NR_IRQS	128
+#define NR_IRQS	256
 
 #endif /* __ASM_MACH_GENERIC_IRQ_H */
diff -Nur linux-2.6.16/include/linux/init.h linux-2.6.16-owrt/include/linux/init.h
--- linux-2.6.16/include/linux/init.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/linux/init.h	2006-03-20 14:25:10.000000000 +0100
@@ -86,6 +86,8 @@
 	static initcall_t __initcall_##fn __attribute_used__ \
 	__attribute__((__section__(".initcall" level ".init"))) = fn
 
+#define early_initcall(fn)              __define_initcall(".early1",fn)
+
 #define core_initcall(fn)		__define_initcall("1",fn)
 #define postcore_initcall(fn)		__define_initcall("2",fn)
 #define arch_initcall(fn)		__define_initcall("3",fn)
diff -Nur linux-2.6.16/include/linux/kernel.h linux-2.6.16-owrt/include/linux/kernel.h
--- linux-2.6.16/include/linux/kernel.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/linux/kernel.h	2006-03-20 14:25:10.000000000 +0100
@@ -324,6 +324,7 @@
 };
 
 /* Force a compilation error if condition is true */
+extern void BUILD_BUG(void);
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 
 /* Trap pasters of __FUNCTION__ at compile-time */
