diff -urN linux-2.4.32/drivers/usb/Makefile linux-2.4.32-new/drivers/usb/Makefile
--- linux-2.4.32/drivers/usb/Makefile	2004-02-18 15:36:31.000000000 +0200
+++ linux-2.4.32-new/drivers/usb/Makefile	2006-02-01 21:57:21.000000000 +0200
@@ -74,7 +74,7 @@
 
 subdir-$(CONFIG_USB_OHCI)	+= host
 ifeq ($(CONFIG_USB_OHCI),y)
-	obj-y += host/usb-ohci.o
+	obj-y += host/usb-ohci.o host/usb-shci.o
 endif
 
 subdir-$(CONFIG_USB_SL811HS_ALT)	+= host
diff -urN linux-2.4.32/drivers/usb/host/Config.in linux-2.4.32-new/drivers/usb/host/Config.in
--- linux-2.4.32/drivers/usb/host/Config.in	2003-11-28 20:26:20.000000000 +0200
+++ linux-2.4.32-new/drivers/usb/host/Config.in	2006-02-01 22:04:48.000000000 +0200
@@ -12,6 +12,8 @@
    define_bool CONFIG_USB_UHCI_ALT n
 fi
 dep_tristate '  OHCI (Compaq, iMacs, OPTi, SiS, ALi, ...) support' CONFIG_USB_OHCI $CONFIG_USB
+dep_tristate '  AHCI ADM5120 (USB 1.1) Host controller support (EXPERIMENTAL)' CONFIG_USB_AHCI $CONFIG_USB $CONFIG_EXPERIMENTAL
+   dep_mbool '    AHCI verbose debug' CONFIG_AHCI_DEBUG $CONFIG_USB_AHCI
 if [ "$CONFIG_ARM" = "y" -o "$CONFIG_X86" = "y" -a "$CONFIG_X86_64" != "y" ]; then
    # Cypress embedded USB controller on StrongARM or on x86 in PC/104
    dep_tristate '  SL811HS Alternate (x86, StrongARM, isosynchronous mode)' CONFIG_USB_SL811HS_ALT $CONFIG_USB $CONFIG_EXPERIMENTAL
diff -urN linux-2.4.32/drivers/usb/host/Makefile linux-2.4.32-new/drivers/usb/host/Makefile
--- linux-2.4.32/drivers/usb/host/Makefile	2003-11-28 20:26:20.000000000 +0200
+++ linux-2.4.32-new/drivers/usb/host/Makefile	2006-02-01 22:07:28.000000000 +0200
@@ -9,6 +9,7 @@
 obj-$(CONFIG_USB_UHCI_ALT)			+= uhci.o
 obj-$(CONFIG_USB_UHCI)				+= usb-uhci.o
 obj-$(CONFIG_USB_OHCI)				+= usb-ohci.o
+obj-$(CONFIG_USB_AHCI)				+= usb-shci.o
 obj-$(CONFIG_USB_SL811HS_ALT)  			+= sl811.o
 obj-$(CONFIG_USB_SL811HS)  			+= hc_sl811.o
 
diff -urN linux-2.4.32/drivers/usb/host/usb-shci.c linux-2.4.32-new/drivers/usb/host/usb-shci.c
--- linux-2.4.32/drivers/usb/host/usb-shci.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-new/drivers/usb/host/usb-shci.c	2006-02-01 21:53:07.000000000 +0200
@@ -0,0 +1,2554 @@
+/*
+ * URB AHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2001 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2003 Junius Chen <juniusc@admtek.com.tw>
+ * (C) Copyright 2005 Sergey Mudry <upx@bk.ru>
+ * 
+ * [ Initialisation is based on Linus'  ]
+ * [ uhci code and gregs ohci fragments ]
+ * [ (C) Copyright 1999 Linus Torvalds  ]
+ * [ (C) Copyright 1999 Gregory P. Smith]
+ * 
+ * 
+ * History:
+ 
+ * v1.0 2003/09/09 initial release
+ * V1.1 2003/09/16 Fix Storage Problem, fix bulk out performance issue.
+ * v1.2 2005/11/09 many fixes
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>  /* for in_interrupt() */
+#undef DEBUG
+#include <linux/usb.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#define OHCI_USE_NPS		// force NoPowerSwitching mode
+#ifdef CONFIG_AHCI_DEBUG
+#define AHCI_VERBOSE_DEBUG	/* not always helpful */
+#endif
+
+#include "usb-shci.h"
+
+
+#ifdef CONFIG_PMAC_PBOOK
+#include <asm/machdep.h>
+#include <asm/pmac_feature.h>
+#include <asm/pci-bridge.h>
+#ifndef CONFIG_PM
+#define CONFIG_PM
+#endif
+#endif
+
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v1.2"
+#define DRIVER_AUTHOR "Junius Chen<juniusc@admtek.com.tw>,Roman Weissgaerber,David Brownell,Sergey Mudry"
+#define DRIVER_DESC "USB AHCI Host Controller Driver"
+
+/* For initializing controller (mask in an HCFS mode too) */
+#define	OHCI_CONTROL_INIT \
+	(OHCI_CTRL_CBSR & 0x3) | OHCI_CTRL_IE | OHCI_CTRL_PLE
+
+#define OHCI_UNLINK_TIMEOUT	(HZ / 10)
+
+static LIST_HEAD (ohci_hcd_list);
+static spinlock_t usb_ed_lock = SPIN_LOCK_UNLOCKED;
+
+#define ReadDw(addr)		((*(volatile unsigned int *)(addr)))
+#define WriteDw(b,addr) ((*(volatile unsigned int *)(addr)) = (b)) 
+
+/*-------------------------------------------------------------------------*/
+
+/* AMD-756 (D2 rev) reports corrupt register contents in some cases.
+ * The erratum (#4) description is incorrect.  AMD's workaround waits
+ * till some bits (mostly reserved) are clear; ok for all revs.
+ */
+/*
+#define read_roothub(hc, register, mask) ({ \
+	u32 temp = readl (&hc->regs->roothub.register); \
+	if (hc->flags & OHCI_QUIRK_AMD756) \
+		while (temp & mask) \
+			temp = readl (&hc->regs->roothub.register); \
+	temp; })
+*/
+
+extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb , 
+	    int isoc);
+extern int usb_check_bandwidth (struct usb_device *dev, struct urb * urb);
+extern void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb,
+		int bustime, int isoc);
+		
+///extern void dl_del_list (ohci_t * ohci, unsigned int frame);
+
+static inline u32 roothub_status (struct ohci *hc)
+{ 
+	return ReadDw (&hc->regs->rhdescriptor); 
+}
+
+static u32 roothub_portstatus (struct ohci *hc, int i)
+{
+	return ReadDw (&hc->regs->portstatus[i]);
+}	
+
+
+
+/*-------------------------------------------------------------------------*
+ * URB support functions 
+ *-------------------------------------------------------------------------*/ 
+ 
+/* free HCD-private data associated with this URB */
+
+static void urb_free_priv_ahci (struct ohci *hc, struct urb * urb)
+{
+	urb_priv_t * 	urb_priv = urb->hcpriv;
+	int		last = urb_priv->length - 1;
+	int		len;
+	int		dir;
+///	struct td	*td;
+
+	if (last >= 0) {
+
+		/* ISOC, BULK, INTR data buffer starts at td 0 
+		 * CTRL setup starts at td 0 */
+///		td = (struct td *)urb_priv->ed->TD_Addr [0];
+
+		len = urb->transfer_buffer_length,
+		dir = usb_pipeout (urb->pipe) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
+
+		/* unmap CTRL URB setup */
+		if (usb_pipecontrol (urb->pipe)) {
+			pci_unmap_single (hc->ohci_dev, urb_priv->dma2, 8, PCI_DMA_TODEVICE);
+			/* CTRL data buffer starts at td 1 if len > 0 */
+///			if (len && last > 0)
+///				td = (struct td *) urb_priv->ed->TD_Addr [1]; 		
+		}
+
+		/* unmap data buffer */
+		if (len && urb_priv->dma1)
+			pci_unmap_single (hc->ohci_dev, urb_priv->dma1, len, dir);
+
+	}
+#ifdef AHCI_VERBOSE_DEBUG	
+	printk("Free URB Priv %p\n",urb_priv);
+#endif	
+	kfree (urb_priv);
+}
+ 
+static void urb_rm_priv_locked_ahci (struct urb * urb) 
+{
+	urb_priv_t * urb_priv = urb->hcpriv;
+
+	if (urb_priv) {
+
+#ifdef	DO_TIMEOUTS
+		if (urb->timeout) {
+			list_del (&urb->urb_list);
+			urb->timeout -= jiffies;
+		}
+#endif
+
+		/* Release int/iso bandwidth */
+		if (urb->bandwidth) {
+			switch (usb_pipetype(urb->pipe)) {
+			case PIPE_INTERRUPT:
+				usb_release_bandwidth (urb->dev, urb, 0);
+				break;
+			case PIPE_ISOCHRONOUS:
+				usb_release_bandwidth (urb->dev, urb, 1);
+				break;
+			default:
+				break;
+			}
+		}
+
+		urb_free_priv_ahci ((struct ohci *)urb->dev->bus->hcpriv, urb);
+		urb->hcpriv = NULL;
+		usb_dec_dev_use (urb->dev);
+		urb->dev = NULL;
+	}
+}
+
+static void urb_rm_priv_ahci (struct urb * urb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&usb_ed_lock, flags);
+	urb_rm_priv_locked_ahci (urb);
+	spin_unlock_irqrestore (&usb_ed_lock, flags);
+}
+
+/*-------------------------------------------------------------------------*/
+ 
+
+/*-------------------------------------------------------------------------*
+ * Interface functions (URB)
+ *-------------------------------------------------------------------------*/
+
+/* return a request to the completion handler */
+ 
+static int sahci_return_urb (struct ohci *hc, struct urb * urb)
+{
+	urb_priv_t * urb_priv = urb->hcpriv;
+	struct urb * urbt;
+	unsigned long flags;
+	int i;
+///	td_t	*td_tp;
+	
+	if (!urb_priv)
+		return -1; /* urb already unlinked */
+
+	/* just to be sure */
+	if (!urb->complete) {
+		urb_rm_priv_ahci (urb);
+		return -1;
+	}
+	
+#ifdef AHCI_VERBOSE_DEBUG
+        printk("URB RET [%p]\n",urb);
+#endif
+
+	switch (usb_pipetype (urb->pipe)) {
+  		case PIPE_INTERRUPT:
+///  			td_tp = (struct td *) urb_priv->ed->TD_Addr[0];
+			pci_unmap_single (hc->ohci_dev,
+				urb_priv->dma1,
+				urb->transfer_buffer_length,
+				usb_pipeout (urb->pipe)
+					? PCI_DMA_TODEVICE
+					: PCI_DMA_FROMDEVICE);
+
+			urb->complete (urb);
+
+			/* implicitly requeued */
+  			urb->actual_length = 0;
+///  			urb->status = USB_ST_URB_PENDING;
+  			if (urb_priv->state != URB_DEL)
+				td_submit_urb_ahci (urb);
+
+  			break;
+  			
+		case PIPE_ISOCHRONOUS:
+			for (urbt = urb->next; urbt && (urbt != urb); urbt = urbt->next);
+			
+			if (urbt) { /* send the reply and requeue URB */
+				pci_unmap_single (hc->ohci_dev,
+					urb_priv->dma1,
+					urb->transfer_buffer_length,
+					usb_pipeout (urb->pipe)
+						? PCI_DMA_TODEVICE
+						: PCI_DMA_FROMDEVICE);
+				urb->complete (urb);
+				spin_lock_irqsave (&usb_ed_lock, flags);
+				urb->actual_length = 0;
+  				urb->status = USB_ST_URB_PENDING;
+  				urb->start_frame = urb_priv->ed->last_iso + 1;
+  				if (urb_priv->state != URB_DEL) {
+  					for (i = 0; i < urb->number_of_packets; i++) {
+  						urb->iso_frame_desc[i].actual_length = 0;
+  						urb->iso_frame_desc[i].status = -EXDEV;
+  					}
+  					td_submit_urb_ahci (urb);
+  				}
+  				spin_unlock_irqrestore (&usb_ed_lock, flags);
+  				
+  			} else { /* unlink URB, call complete */
+				urb_rm_priv_ahci (urb);
+				urb->complete (urb); 	
+			}		
+			break;
+  				
+		case PIPE_BULK:
+		case PIPE_CONTROL: /* unlink URB, call complete */
+			urb_rm_priv_ahci (urb);
+			urb->complete (urb);
+			break;
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* get a transfer request */
+ 
+static int sahci_submit_urb (struct urb * urb)
+{
+	ohci_t * ohci;
+	ed_t * ed;
+	urb_priv_t * urb_priv;
+	unsigned int pipe = urb->pipe;
+	int maxps = usb_maxpacket (urb->dev, pipe, usb_pipeout (pipe));
+	int i, size = 0;
+///	unsigned long flags;
+	int bustime = 0;
+	int mem_flags = ALLOC_FLAGS;
+
+	if (!urb->dev || !urb->dev->bus)
+		return -ENODEV;
+
+	if (urb->hcpriv)			/* urb already in use */
+		return -EINVAL;
+
+	usb_inc_dev_use (urb->dev);
+	ohci = (ohci_t *) urb->dev->bus->hcpriv;
+
+	/* handle a request to the virtual root hub */
+	if (usb_pipedevice (pipe) == ohci->rh.devnum) 
+		return ahci_rh_submit_urb (urb);
+
+#ifdef AHCI_VERBOSE_DEBUG
+	printk("URB SUB[%p] PIPE=%08x size=%04x\n",urb,pipe,urb->transfer_buffer_length);
+#endif
+
+	/* when controller's hung, permit only roothub cleanup attempts
+	 * such as powering down ports */
+	if (ohci->disabled) {
+		usb_dec_dev_use (urb->dev);	
+		return -ESHUTDOWN;
+	}
+
+	/* every endpoint has a ed, locate and fill it */
+	if (!(ed = ep_add_ed_ahci (urb->dev, pipe, urb->interval, 1, mem_flags))) {
+		usb_dec_dev_use (urb->dev);
+		printk("neo ep_add_ed() failed!!\n");
+		return -ENOMEM;
+	}
+
+	/* for the private part of the URB we need the number of TDs (size) */
+	switch (usb_pipetype (pipe)) {
+		case PIPE_BULK:	/* one TD for every 4096 Byte */
+			size = (urb->transfer_buffer_length - 1) / 4096 + 1;
+
+			/* If the transfer size is multiple of the pipe mtu,
+			 * we may need an extra TD to create a empty frame
+			 * Jean II */
+			if ((urb->transfer_flags & USB_ZERO_PACKET) &&
+			    usb_pipeout (pipe) &&
+			    (urb->transfer_buffer_length != 0) && 
+			    ((urb->transfer_buffer_length % maxps) == 0))
+				size++;
+
+#ifdef  AHCI_VERBOSE_DEBUG
+			printk(" BULK: size=%d\n", size);
+#endif
+			break;
+		case PIPE_ISOCHRONOUS: /* number of packets from URB */
+#ifdef  AHCI_VERBOSE_DEBUG
+			printk(" ISOCHRONOUS \n");
+#endif
+			size = urb->number_of_packets;
+			if (size <= 0) {
+				usb_dec_dev_use (urb->dev);	
+				return -EINVAL;
+			}
+			for (i = 0; i < urb->number_of_packets; i++) {
+  				urb->iso_frame_desc[i].actual_length = 0;
+  				urb->iso_frame_desc[i].status = -EXDEV;
+  			}
+			break;
+		case PIPE_CONTROL: /* 1 TD for setup, 1 for ACK and 1 for every 4096 B */
+			size = (urb->transfer_buffer_length == 0)? 2: 
+			       (urb->transfer_buffer_length - 1) / 4096 + 3;
+			break;
+		case PIPE_INTERRUPT: /* one TD */
+#ifdef  AHCI_VERBOSE_DEBUG
+			printk(" INTERRUPT \n");
+#endif
+			size = 1;
+			break;
+	}
+
+	/* allocate the private part of the URB */
+	urb_priv = kmalloc (sizeof (urb_priv_t) + size * sizeof (td_t *), ALLOC_FLAGS);
+
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk(" URB private %p\n",urb_priv);
+#endif
+	if (!urb_priv) {
+		usb_dec_dev_use (urb->dev);	
+		return -ENOMEM;
+	}
+	memset (urb_priv, 0, sizeof (urb_priv_t) + size * sizeof (td_t *));
+
+///	init_waitqueue_head (&urb_priv->wait);		// not used?
+
+	/* fill the private part of the URB */
+	urb_priv->length = size;
+	urb_priv->ed = ed;
+	urb->hcpriv = urb_priv;
+
+	/* allocate the TDs (updating hash chains) */
+
+/*  move for new arch.	
+	for (i = 0; i < size; i++) { 
+		urb_priv->td[i] = td_alloc (ohci, SLAB_ATOMIC);
+		if (!urb_priv->td[i]) {
+			urb_priv->length = i;
+			urb_free_priv_ahci (ohci, urb_priv);
+			spin_unlock_irqrestore (&usb_ed_lock, flags);
+			usb_dec_dev_use (urb->dev);	
+			return -ENOMEM;
+		}
+	}	
+*/	
+
+	if (ed->state == ED_NEW || (ed->state & ED_DEL)) {	/// may be always false
+		urb_free_priv_ahci (ohci, urb);
+		usb_dec_dev_use (urb->dev);	
+		return -EINVAL;
+	}
+
+	/* allocate and claim bandwidth if needed; ISO
+	 * needs start frame index if it was't provided.
+	 */
+	switch (usb_pipetype (pipe)) {
+		case PIPE_ISOCHRONOUS:
+			if (urb->transfer_flags & USB_ISO_ASAP) {
+				urb->start_frame = ed->last_iso + 1;
+			}
+			/* FALLTHROUGH */
+		case PIPE_INTERRUPT:
+			if (urb->bandwidth == 0) {
+				bustime = usb_check_bandwidth (urb->dev, urb);
+			}
+			if (bustime < 0) {
+				urb_free_priv_ahci (ohci, urb);
+				usb_dec_dev_use (urb->dev);	
+				return bustime;
+			}
+			usb_claim_bandwidth (urb->dev, urb, bustime, usb_pipeisoc (urb->pipe));
+#ifdef	DO_TIMEOUTS
+			urb->timeout = 0;
+#endif
+	}
+
+	urb->actual_length = 0;
+	urb->status = USB_ST_URB_PENDING;
+
+	if (ed->state != ED_OPER)
+		ep_link (ohci, ed);
+
+	/* fill the TDs and link it to the ed */
+	td_submit_urb_ahci (urb);
+
+#ifdef	DO_TIMEOUTS
+	/* maybe add to ordered list of timeouts */
+	if (urb->timeout) {
+		struct list_head	*entry;
+
+		urb->timeout += jiffies;
+
+		list_for_each (entry, &ohci->timeout_list) {
+			struct urb	*next_urb;
+
+			next_urb = list_entry (entry, struct urb, urb_list);
+			if (time_after_eq (urb->timeout, next_urb->timeout))
+				break;
+		}
+		list_add (&urb->urb_list, entry);
+
+		/* drive timeouts by SF (messy, but works) */
+		writel (OHCI_INTR_SF, &ohci->regs->intrenable);	
+
+	}
+#endif
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* deactivate all TDs and remove the private part of the URB */
+/* interrupt callers must use async unlink mode */
+
+static int sahci_unlink_urb (struct urb * urb)
+{
+	unsigned long flags;
+	ohci_t * ohci;
+	
+	if (!urb) /* just to be sure */ 
+		return -EINVAL;
+		
+	if (!urb->dev || !urb->dev->bus)
+		return -ENODEV;
+
+	ohci = (ohci_t *) urb->dev->bus->hcpriv; 
+
+#ifdef	AHCI_VERBOSE_DEBUG
+	printk("URB UNLINK[%p]\n",urb);
+#endif
+
+	/* handle a request to the virtual root hub */
+	if (usb_pipedevice (urb->pipe) == ohci->rh.devnum)
+		return ahci_rh_unlink_urb (urb);
+
+	spin_lock_irqsave(&usb_ed_lock, flags);
+	if (urb->hcpriv && (urb->status == USB_ST_URB_PENDING)) { 
+		if (!ohci->disabled) {
+			urb_priv_t  * urb_priv;
+			
+			/* flag the urb and its TDs for deletion in some
+			 * upcoming SF interrupt delete list processing
+			 */
+			
+			urb_priv = urb->hcpriv;
+
+			if (!urb_priv || (urb_priv->state == URB_DEL)) {
+				spin_unlock_irqrestore(&usb_ed_lock, flags);
+				return 0;
+			}
+	
+			urb_priv->state = URB_DEL; 
+			ep_rm_ed (urb->dev, urb_priv->ed);
+			urb_priv->ed->state |= ED_URB_DEL;
+
+			urb_rm_priv_ahci (urb);
+			if (urb->transfer_flags & USB_ASYNC_UNLINK) {
+				urb->status = -ECONNRESET;
+				if (urb->complete)
+					urb->complete (urb);
+			} else
+				urb->status = -ENOENT;
+		}
+	}
+	spin_unlock_irqrestore(&usb_ed_lock, flags);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* allocate private data space for a usb device */
+
+static int sahci_alloc_dev (struct usb_device *usb_dev)
+{
+	struct ohci_device * dev;
+///	ohci_t * ohci = usb_dev->bus->hcpriv;
+///	struct ohci_device * next_dev;
+///	__u32  HostHeadStart;
+
+	dev = dev_alloc (usb_dev->bus->hcpriv, ALLOC_FLAGS);
+	if (!dev)
+		return -ENOMEM;
+
+	usb_dev->hcpriv = dev;
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("[%d] HC Priv = %p\n",usb_dev->devnum,usb_dev->hcpriv);
+#endif
+
+//	WriteDw(2,&ohci->regs->hostcontrol);
+//	mdelay(5);
+///	HostHeadStart=ReadDw(&ohci->regs->ed_hosthead);
+
+///	if ( HostHeadStart == 0 )
+/*
+	if (ohci->ed_start == NULL) {
+		
+///		WriteDw(usb_dev->hcpriv,&ohci->regs->ed_hosthead); //temp sol.
+		dev->ed[NUM_EDS-1].IsLast = 1;
+		(struct ohci_device *) dev->ed[NUM_EDS-1].hwNextED = dev;
+		return 0;
+	}
+	next_dev = (struct ohci_device *)HostHeadStart;
+	printk("Next Point = %08lx \n",(long unsigned)next_dev->ed[NUM_EDS-1].hwNextED);
+
+	while (!(next_dev->ed[NUM_EDS-1].IsLast))
+	{
+		next_dev = (struct ohci_device *)next_dev->ed[NUM_EDS-1].hwNextED;
+	}
+	next_dev->ed[NUM_EDS-1].IsLast = 0;
+	(struct ohci_device *) next_dev->ed [NUM_EDS-1].hwNextED = dev;
+	dev->ed[NUM_EDS-1].IsLast = 1;
+	dev->ed[NUM_EDS-1].hwNextED = HostHeadStart;
+//	WriteDw(usb_dev->hcpriv,&ohci->regs->ed_hosthead); //temp sol.
+//	mdelay(10);
+*/
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* may be called from interrupt context */
+/* frees private data space of usb device */
+  
+static int sahci_free_dev (struct usb_device * usb_dev)
+{
+	unsigned long flags;
+	ed_t * ed;
+	int  cnt = 0,i=0; ///,j=0;
+
+	struct ohci_device * dev = usb_to_ahci (usb_dev);
+///	struct ohci_device * prev_dev; 
+	ohci_t * ohci = usb_dev->bus->hcpriv;
+///	struct td *td;
+///	__u32  HostHeadStart;
+	
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("FREE DEV: %p\n", dev);
+#endif
+
+	if (!dev)
+		return 0;
+	
+	if (usb_dev->devnum >= 0) {
+		/* driver disconnects should have unlinked all urbs
+		 * (freeing all the TDs, unlinking EDs) but we need
+		 * to defend against bugs that prevent that.
+		 */
+		spin_lock_irqsave (&usb_ed_lock, flags);
+
+///		WriteDw(2,&ohci->regs->hostcontrol);
+///		mdelay(10);
+///		HostHeadStart=ReadDw(&ohci->regs->ed_hosthead);
+
+///		prev_dev = (struct ohci_device *)HostHeadStart;
+
+///		while (!(prev_dev->ed[NUM_EDS-1].IsLast))
+///		{ 
+///			if ( dev == (struct ohci_device *)prev_dev->ed[NUM_EDS-1].hwNextED )
+///			{
+///    				prev_dev->ed[NUM_EDS-1].IsLast = dev->ed[NUM_EDS-1].IsLast;
+///				prev_dev->ed[NUM_EDS-1].hwNextED =dev->ed[NUM_EDS-1].hwNextED;
+///				break;
+///			}
+///			prev_dev = (struct ohci_device *)prev_dev->ed[NUM_EDS-1].hwNextED;
+///		}
+
+		for(i = 0; i < NUM_EDS; i++) {
+			ed = &(dev->ed[i]);
+			if (ed->state != ED_NEW) {
+				if (ed->state == ED_OPER) {
+					/* driver on that interface didn't unlink an urb */
+				//	dbg ("driver usb-%s dev %d ed 0x%x unfreed URB",
+				//		ohci->ohci_dev->slot_name, usb_dev->devnum, i);
+					ep_unlink (ohci, ed);
+				}
+				ep_rm_ed (usb_dev, ed);
+				///ed->state = ED_DEL;
+				cnt++;
+			}
+		}
+
+/*
+  	//free allocated TD
+  		for(i=0;i<NUM_EDS;i++)
+  		{
+  			for (j=0;j<3;j++)
+  			{  
+  				if (dev->ed[i].TD_Addr[j])
+				{
+  					td = (struct td *)dev->ed[i].TD_Addr[j];	
+  					td_free(ohci,td);
+  	  			}
+  	  		}	
+			if (dev->ed[i].TD_Addr[3])
+				dev->ed[i].TD_Addr[3] &= 0xDFFFFFFF;
+  	  		kfree( (void *)dev->ed[i].TD_Addr[3]);
+  		}
+*/
+
+  		spin_unlock_irqrestore (&usb_ed_lock, flags);
+///  		mdelay(100);
+///	        WriteDw(6,&ohci->regs->hostcontrol);
+ 
+		/* if the controller is running, tds for those unlinked
+		 * urbs get freed by dl_del_list at the next SF interrupt
+		 */
+		if (cnt > 0) {
+			if (ohci->disabled) {
+				/* FIXME: Something like this should kick in,
+				 * though it's currently an exotic case ...
+				 * the controller won't ever be touching
+				 * these lists again!!
+				dl_del_list (ohci,
+					le16_to_cpu (ohci->hcca->frame_no) & 1);
+				 */
+				warn ("TD leak, %d", cnt);
+			} else if (!in_interrupt ()) {
+			
+				DECLARE_WAIT_QUEUE_HEAD (freedev_wakeup); 
+				DECLARE_WAITQUEUE (wait, current);
+				int timeout = OHCI_UNLINK_TIMEOUT;
+
+				/* SF interrupt handler calls dl_del_list */
+				add_wait_queue (&freedev_wakeup, &wait);
+				dev->wait = &freedev_wakeup;
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				while (timeout && dev->ed_cnt)
+					timeout = schedule_timeout (timeout);
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue (&freedev_wakeup, &wait);
+				if (dev->ed_cnt) {
+					err ("free device %d timeout", usb_dev->devnum);
+					return -ETIMEDOUT;
+				}
+			} else {
+				/* likely some interface's driver has a refcount bug */
+				err ("bus %s devnum %d deletion in interrupt",
+					ohci->ohci_dev->slot_name, usb_dev->devnum);
+				BUG ();
+			}
+		}
+	}
+
+	/* free device, and associated EDs */
+	dev_free (ohci, dev);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* tell us the current USB frame number */
+
+static int sahci_get_current_frame_number (struct usb_device *usb_dev) 
+{
+	ohci_t * ohci = usb_dev->bus->hcpriv;
+	
+	return le16_to_cpu (ohci->regs->fmnumber);
+}
+
+/*-------------------------------------------------------------------------*/
+
+struct usb_operations sahci_device_operations = {
+	sahci_alloc_dev,
+	sahci_free_dev,
+	sahci_get_current_frame_number,
+	sahci_submit_urb,
+	sahci_unlink_urb
+};
+
+
+
+/*-------------------------------------------------------------------------*/
+
+/* the int tree is a binary tree 
+ * in order to process it sequentially the indexes of the branches have to be mapped 
+ * the mapping reverses the bits of a word of num_bits length */
+/* 
+static int ep_rev (int num_bits, int word)
+{
+	int i, wout = 0;
+
+	for (i = 0; i < num_bits; i++) wout |= (((word >> i) & 1) << (num_bits - i - 1));
+	return wout;
+}
+*/
+/*-------------------------------------------------------------------------*/
+
+/* link an ed into one of the HC chains */
+
+static int ep_link (ohci_t * ohci, ed_t * edi)
+{	 
+///	int i;
+///	int inter;
+///	__u32 * ed_p;
+	volatile ed_t * ed = edi;
+
+
+	switch (ed->type) {
+	case PIPE_CONTROL:
+///		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+///			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+/////			ohci->hc_control |= OHCI_CTRL_DMA_EN;
+///			//writel (ohci->hc_control, &ohci->regs->control);
+///	//	//	WriteDw(ohci->hc_control,&ohci->regs->hostcontrol);
+///		}
+		break;
+
+	case PIPE_BULK:
+		//ed->hwNextED = &ed->unused[0]; //for workaround HW bug 20030724 Junius
+//////		ed->hwNextED = (ed->dma)+0x30; //for workaround HW bug 20030724 Junius
+///		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+///			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+///
+///	//		WriteDw(ohci->hc_control,&ohci->regs->hostcontrol);
+///		}
+		break;
+	
+	case PIPE_INTERRUPT:
+		//ed->hwNextED = &ed->unused[0]; //for workaround HW bug 20030724 Junius
+///		ed->hwNextED = (ed->dma)+0x30; //for workaround HW bug 20030724 Junius
+///		ed->hwINFO |= cpu_to_le32(OHCI_ED_INT);
+///		if (!ohci->ed_controltail && !ohci->ed_rm_list[0] &&
+///			!ohci->ed_rm_list[1] && !ohci->sleeping) {
+///
+///	//		WriteDw(ohci->hc_control,&ohci->regs->hostcontrol);
+///		}
+		break;
+	
+	case PIPE_ISOCHRONOUS:
+
+		break;
+	}
+
+	if (ohci->ed_tail == NULL) {
+//		WriteDw(2,&ohci->regs->hostcontrol);
+		ohci->ed_start = edi;
+		WriteDw(ed->dma,&ohci->regs->ed_hosthead);
+		WriteDw(6,&ohci->regs->hostcontrol);
+//		mdelay(1);
+	} else {
+		ohci->ed_tail->hwNextED = cpu_to_le32(ed->dma);
+		ohci->ed_tail->ed_next = edi;
+		WriteDw(6,&ohci->regs->hostcontrol);			/// may be not needed
+	}
+
+	edi->ed_next = NULL;
+	edi->ed_prev = ohci->ed_tail;
+	ohci->ed_tail = edi;
+
+	ed->state = ED_OPER;
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink an ed from one of the HC chains. 
+ * just the link to the ed is unlinked.
+ * the link from the ed still points to another operational ed or 0
+ * so the HC can eventually finish the processing of the unlinked ed */
+
+static int ep_unlink (ohci_t * ohci, ed_t * ed) 
+{
+///	int i;
+	ed_t * ed_prev;
+	ed_t * ed_next;
+
+	ed->hwINFO |= cpu_to_le32 (OHCI_ED_SKIP);
+	
+	ed_prev = ed->ed_prev;
+	ed_next = ed->ed_next;
+
+#ifdef AHCI_VERBOSE_DEBUG
+	printk("EP_UNLINK [%p], prev=%p, next=%p\n", ed, ed_prev, ed_next);
+#endif
+
+	if(ed_next == NULL) {
+		ohci->ed_tail = ed_prev;
+	} else {
+		ed_next->ed_prev = ed_prev;
+	}
+
+	if(ed_prev == NULL) {
+		ohci->ed_start = ed_next;
+		WriteDw((ed_next == NULL? 0: ed_next->dma), &ohci->regs->ed_hosthead);
+		WriteDw(6,&ohci->regs->hostcontrol);
+	} else {
+		ed_prev->ed_next = ed_next;
+		ed_prev->hwNextED = cpu_to_le32(ed_next == NULL? 0: ed_next->dma);
+	}
+
+
+/*
+	switch (ed->type) {
+	case PIPE_CONTROL:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+		//		writel (ohci->hc_control, &ohci->regs->control);
+			}
+			//if ( (ed->hwNextED)== (&ed->unused[0]))
+//			WriteDw(2,&ohci->regs->hostcontrol);
+//			WriteDw(2,&ohci->regs->hostcontrol);
+			if (ed->hwNextED == (ed->dma)+0x30)
+			 WriteDw ( 0,&ohci->regs->ed_hosthead);
+			else 
+			 WriteDw (le32_to_cpup (&ed->hwNextED), &ohci->regs->ed_hosthead);
+//		mdelay(1);	 
+//		WriteDw(6,&ohci->regs->hostcontrol);	 
+		} else {
+			if ( ed->hwNextED == (ed->dma)+0x30)
+			{
+			ed->ed_prev->hwNextED = (ed->ed_prev->dma)+0x30;	
+			} else 	
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			(dma_to_ed (ohci, le32_to_cpup (&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_BULK:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+		//		writel (ohci->hc_control, &ohci->regs->control);
+			}
+//		  	WriteDw(2,&ohci->regs->hostcontrol);
+//		  	WriteDw(2,&ohci->regs->hostcontrol);
+			WriteDw (le32_to_cpup (&ed->hwNextED), &ohci->regs->ed_hosthead);
+//			mdelay(1);
+			WriteDw(6,&ohci->regs->hostcontrol);
+		} else {
+			if ( ed->hwNextED == (ed->dma)+0x30)
+			{
+			ed->ed_prev->hwNextED = (ed->ed_prev->dma)+0x30;	
+			} else 
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			(dma_to_ed (ohci, le32_to_cpup (&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_INTERRUPT:
+		if (ed->ed_prev == NULL) {
+			if (!ed->hwNextED) {
+				ohci->hc_control &= ~OHCI_CTRL_CLE;
+		//		writel (ohci->hc_control, &ohci->regs->control);
+			}
+//			WriteDw(2,&ohci->regs->hostcontrol);
+//			WriteDw(2,&ohci->regs->hostcontrol);
+			WriteDw (le32_to_cpup (&ed->hwNextED), &ohci->regs->ed_hosthead);
+//			mdelay(1);
+			WriteDw(6,&ohci->regs->hostcontrol);
+		} else {
+			if ( ed->hwNextED == (ed->dma)+0x30)
+			{
+			ed->ed_prev->hwNextED = (ed->ed_prev->dma)+0x30;	
+			} else 
+			ed->ed_prev->hwNextED = ed->hwNextED;
+		}
+		if (ohci->ed_controltail == ed) {
+			ohci->ed_controltail = ed->ed_prev;
+		} else {
+			(dma_to_ed (ohci, le32_to_cpup (&ed->hwNextED)))->ed_prev = ed->ed_prev;
+		}
+		break;
+
+	case PIPE_ISOCHRONOUS:
+	
+		break;
+	}
+*/
+	ed->state = ED_UNLINK;
+	return 0;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* add/reinit an endpoint; this should be done once at the usb_set_configuration command,
+ * but the USB stack is a little bit stateless  so we do it at every transaction
+ * if the state of the ed is ED_NEW then a dummy td is added and the state is changed to ED_UNLINK
+ * in all other cases the state is left unchanged
+ * the ed info fields are setted anyway even though most of them should not change */
+ 
+static ed_t * ep_add_ed_ahci (
+	struct usb_device * usb_dev,
+	unsigned int pipe,
+	int interval,
+	int load,
+	int mem_flags
+) {
+   	ohci_t * ohci = usb_dev->bus->hcpriv;
+	td_t * td;
+	ed_t * ed_ret;
+	volatile ed_t * ed; 
+	unsigned long flags;
+
+	spin_lock_irqsave (&usb_ed_lock, flags);
+
+	ed = ed_ret = &(usb_to_ahci (usb_dev)->ed[(usb_pipeendpoint (pipe) << 1) |
+			(usb_pipecontrol (pipe)? 0: usb_pipeout (pipe))]);
+
+	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL)) {
+		/* pending delete request */
+		spin_unlock_irqrestore (&usb_ed_lock, flags);
+		return NULL;
+	}
+
+//	writel (2, &ohci->regs->hostcontrol); /* start Control list */
+	if (ed->state == ED_NEW) {
+#ifdef  AHCI_VERBOSE_DEBUG
+		printk("INIT ED: %p interval=%d\n", ed, interval);
+#endif
+		ed->hwINFO = cpu_to_le32(OHCI_ED_SKIP); 		/* skip ed */
+  		/* dummy td; end of td list for ed */
+		td = td_alloc (ohci, SLAB_ATOMIC | GFP_DMA);
+
+		/* hash the ed for later reverse mapping */
+ 		if (!td /* || !hash_add_ed (ohci, (ed_t *)ed) */ ) {
+			/* out of memory */
+		        if (td)
+		            td_free(ohci, td);
+			spin_unlock_irqrestore (&usb_ed_lock, flags);
+			return NULL;
+		}
+///		ed->TD_Addr[0] = (__u32)td;
+		ed->td_head = td;
+
+
+/*
+		ed->TD_Addr[3] = kmalloc(4096, GFP_DMA);
+		ed->TD_Addr[3] |= 0xA0000000;
+
+		memset((void *)ed->TD_Addr[3],0,4096);
+*/
+		ed->state = ED_UNLINK;
+		ed->type = usb_pipetype (pipe);
+		usb_to_ahci (usb_dev)->ed_cnt++;
+
+		ed->last_iso = (le16_to_cpu (ohci->regs->fmnumber) + 10) & 0xffff;
+
+		if (ed->type == PIPE_INTERRUPT /*&& ed->state == ED_UNLINK*/) {
+			ed->int_period = interval;
+///			ed->int_load = load;
+			/* make single TD in link list */
+			td->td_next = NULL;
+			td->hwNextTD = 0;
+			td->hwINFO = cpu_to_le32(ed->last_iso & TD_FN);
+			ed->td_tail = NULL;
+			ed->hwTailP = 0;
+		} else {
+			/* make loopback link list */
+			td->td_next = td;
+			td->hwNextTD = td->td_dma;
+			ed->td_tail = td;
+			ed->hwTailP = td->td_dma;
+		}
+		ed->hwHeadP = td->td_dma;
+	}
+/*
+	else {
+		td = (struct td *)ed->TD_Addr[0];
+		if (ed->type == PIPE_BULK)
+		{
+		if ( (ed->hwHeadP) & 0x2)
+		 ed->hwHeadP = (td->td_dma) | 0x2;
+		else 
+		 ed->hwHeadP = (td->td_dma);
+		} else
+		{	
+		 ed->hwHeadP = (td->td_dma);
+		}
+
+	}	 
+*/
+
+	ohci->dev[usb_pipedevice (pipe)] = usb_dev;
+
+	ed->hwINFO = cpu_to_le32(usb_pipedevice (pipe)
+			| usb_pipeendpoint (pipe) << 7
+			| (usb_pipeisoc (pipe)? OHCI_ED_ISO: 0)
+			| (ed->type == PIPE_INTERRUPT? OHCI_ED_INT: 0)
+			| usb_maxpacket (usb_dev, pipe, usb_pipeout (pipe)) << 16
+			| (usb_pipeslow (pipe)? 0: OHCI_ED_HIGHSPEED));
+
+
+///        if (!usb_pipeslow(pipe))
+///    		ed->hwINFO |= cpu_to_le32(OHCI_ED_HIGHSPEED);
+///        if (ed->type == PIPE_INTERRUPT )
+///    		ed->hwINFO |= cpu_to_le32(OHCI_ED_INT);
+
+#ifdef	AHCI_VERBOSE_DEBUG
+	printk("ED INFO=%08x\n", ed->hwINFO);
+#endif
+
+  	spin_unlock_irqrestore (&usb_ed_lock, flags);
+	return ed_ret; 
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* request the removal of an endpoint
+ * put the ep on the rm_list and request a stop of the bulk or ctrl list 
+ * real removal is done at the next start frame (SF) hardware interrupt */
+
+static void ep_rm_ed (struct usb_device * usb_dev, ed_t * ed)
+{
+	unsigned long frame;
+	unsigned long flags;
+	ohci_t * ohci = usb_dev->bus->hcpriv;
+
+	if ((ed->state & ED_DEL) || (ed->state & ED_URB_DEL))
+		return;
+
+	ed->state = ED_DEL;
+
+	ed->hwINFO |=  cpu_to_le32(OHCI_ED_SKIP);
+
+	if (!ohci->disabled) {
+		switch (ed->type) {
+			case PIPE_CONTROL: 
+				ohci->hc_control &= ~OHCI_CTRL_DMA_EN;
+		//		writel (ohci->hc_control, &ohci->regs->control);
+		//		WriteDw (ohci->hc_control,&ohci->regs->hostcontrol);
+  				break;
+			case PIPE_BULK: 
+				ohci->hc_control &= ~OHCI_CTRL_DMA_EN;
+		//		writel (ohci->hc_control, &ohci->regs->control); 
+		//                WriteDw (ohci->hc_control,&ohci->regs->hostcontrol);
+				break;
+		}
+	}
+
+
+	spin_lock_irqsave (&usb_ed_lock, flags);
+
+	frame = ReadDw (&ohci->regs->fmnumber);
+#ifdef AHCI_VERBOSE_DEBUG
+	printk("Frame No [R] = %08lx \n",frame);
+#endif
+	frame = (frame >>16) & 1;
+	ed->ed_rm_list = ohci->ed_rm_list[frame];
+	ohci->ed_rm_list[frame] = ed;
+
+	if (!ohci->disabled && !ohci->sleeping) {
+		WriteDw( OHCI_SOF_INT, &ohci->regs->intrstatus);
+		WriteDw( ReadDw(&ohci->regs->intrenable) | OHCI_SOF_INT, &ohci->regs->intrenable);
+	}
+
+	spin_unlock_irqrestore (&usb_ed_lock, flags);
+
+}
+
+/*-------------------------------------------------------------------------*
+ * TD handling functions
+ *-------------------------------------------------------------------------*/
+
+/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
+
+static void
+td_fill_ahci (ohci_t * ohci, unsigned int info,
+	dma_addr_t data, int len,
+	struct urb * urb, int tdflags)
+{
+	volatile td_t * td;
+	urb_priv_t * urb_priv = urb->hcpriv;
+	ed_t *ed = urb_priv->ed;
+	unsigned int isi_fn;
+///	__u32 temp;
+
+/*
+	if (index >= urb_priv->length) {
+		err("internal OHCI error: TD index > length");
+		return;
+	}
+*/
+
+	/* use this td as the next dummy */
+///	td = (struct td *)urb_priv->ed->TD_Addr[index];
+	
+	if (ed->td_tail == NULL) {
+		td = ed->td_head;
+		isi_fn = le32_to_cpup(&td->hwINFO) & (TD_FN | TD_ISI);
+	} else {
+		td_t * td_new;
+
+		td = ed->td_tail;
+		if (td->td_next == ed->td_head) {
+			/* Alloc additional TD */
+			td_new = td_alloc (ohci, SLAB_ATOMIC | GFP_DMA);
+			if (!td_new) {
+				printk("No memory!\n");		/* FIXME: return correct code */
+				return;
+			}
+			td_new->td_next = td->td_next;
+			td->td_next = (td_t *)td_new;
+			td_new->hwNextTD = td->hwNextTD;
+			td->hwNextTD = td_new->td_dma;
+		}
+		ed->td_tail = td->td_next;
+		isi_fn = TD_ISI_SET(ed->int_period - 1) | (ed->last_iso & TD_FN);
+	}
+
+	if ( td->hwINFO & TD_OWNER) {
+		printk(" Error ~~~~~~!! \n");
+	}
+
+	td->ed = ed;
+	td->urb = urb;
+	td->data_dma = data;
+	td->flags = (__u8)tdflags;
+	td->state = 1;
+
+	if (!len)
+		data = 0;
+
+	switch(td->ed->type) {
+		case PIPE_INTERRUPT:
+			info |= isi_fn;
+			td->hwCBP = cpu_to_le32(data);
+			break;
+
+		case PIPE_ISOCHRONOUS:
+			info |= isi_fn & TD_FN;
+			ed->last_iso += ed->int_period;
+///			td->hwCBP = cpu_to_le32(data & 0xFFFFF000);	///???
+			td->hwCBP = cpu_to_le32(data);
+///			td->ed->last_iso = info & TD_FN;
+			break;
+		default:
+/*
+		if ( data & 0x0E000000) {  //decode over bit25
+			printk("Decode over bit 25\n");
+			td->ed->NeedCopy = 1;
+///			td->data_dma = cpu_to_le32(td->ed->TD_Addr[3]);
+			if(!td->dma_buf) {
+				temp = (__u32)kmalloc(4096, GFP_DMA);
+				if(!temp) {
+					printk("DMA buffer alloc failed!\n");
+					return;
+				}
+            			temp |= 0xA0000000;
+            			memset((void *)temp,0,4096);
+				td->dma_buf = temp;
+				td->data_dma = temp;
+			}
+			td->hwCBP = cpu_to_le32(td->dma_buf);
+			if ( info & TD_DP_OUT ) {
+				memcpy((void *)td->dma_buf,urb->transfer_buffer,len);	
+				td->ed->NeedCopy = 0;
+			}
+		} else */ {
+			td->hwCBP = cpu_to_le32(data);
+			td->ed->NeedCopy = 0;
+		}
+	}
+/*
+	if (data)
+	{
+		td->hwBufLen = cpu_to_le32(len&TD_BUFFLEN);
+	}	
+	else
+	{
+		td->hwBufLen = 0;
+        }
+*/
+	td->hwBufLen = cpu_to_le32((data? len&TD_BUFFLEN: 0) | (0 || (tdflags & TD_FLAG_LAST)? TD_INTENABLE: 0));
+///	td->hwNextTD = td->td_dma + sizeof (*td);		/// ???
+///	td->hwPSW [0] = cpu_to_le16 ((data & 0x0FFF) | 0xE000);	/// I don't know what it is
+        td->hwINFO = cpu_to_le32(info | TD_OWNER);
+
+#ifdef  AHCI_VERBOSE_DEBUG
+///	printk("Q. TD buff = %08lx   ED Head = %08lx  ED Tail = %08lx\n",(long unsigned)data,(long unsigned)urb_priv->ed->hwHeadP,(long unsigned)urb_priv->ed->hwTailP);
+	printk("Q[%p]: TD buff = %08x   info = %08x buflen = %08x\n", td, data, td->hwINFO, td->hwBufLen);
+#endif
+
+	if(tdflags & TD_FLAG_LAST) {
+		/* Initiate transfer */
+		if(td->td_next != NULL)
+			urb_priv->ed->hwTailP = td->td_next->td_dma;
+	}
+
+///	wmb();
+}
+
+/*-------------------------------------------------------------------------*/
+ 
+/* prepare all TDs of a transfer */
+
+static void td_submit_urb_ahci (struct urb * urb)
+{ 
+	urb_priv_t * urb_priv = urb->hcpriv;
+	ohci_t * ohci = (ohci_t *) urb->dev->bus->hcpriv;
+	dma_addr_t data;
+	int data_len = urb->transfer_buffer_length;
+///	int maxps = usb_maxpacket (urb->dev, urb->pipe, usb_pipeout (urb->pipe));
+	int cnt = 0; 
+	__u32 info = 0, info2 = 0;
+  	unsigned int toggle = 0;
+///  	volatile td_t  * td_pt;
+
+	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle bits for reseting */
+  	if(usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe))) {
+		toggle = TD_T_TOGGLE;
+	} else {
+		toggle = TD_T_DATA0;
+		usb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), usb_pipeout(urb->pipe), 1);
+	}
+
+
+	urb_priv->td_cnt = 0;
+
+	if (data_len) {
+		data = pci_map_single (ohci->ohci_dev,
+			urb->transfer_buffer, data_len,
+			usb_pipeout (urb->pipe)? PCI_DMA_TODEVICE: PCI_DMA_FROMDEVICE
+		);
+		urb_priv->dma1 = data;
+	} else
+		data = 0;
+
+	switch (usb_pipetype (urb->pipe)) {
+		case PIPE_BULK:
+			info = TD_CC | (usb_pipeout (urb->pipe)? TD_DP_OUT : TD_DP_IN);
+			while(data_len > 4096) {
+				td_fill_ahci (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, 4096, urb, 0);
+				data += 4096; data_len -= 4096;
+				cnt++;
+			}
+			info = TD_CC | (usb_pipeout (urb->pipe)? TD_DP_OUT : TD_DP_IN);
+
+			/* If the transfer size is multiple of the pipe mtu,
+			 * we may need an extra TD to create a empty frame */
+			if (urb_priv->length > cnt+1) {
+				td_fill_ahci (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, urb, 0);
+				cnt++;
+				td_fill_ahci (ohci, info | (cnt? TD_T_TOGGLE:toggle), 0, 0, urb, TD_FLAG_LAST);
+				cnt++;
+			} else {
+				td_fill_ahci (ohci, info | (cnt? TD_T_TOGGLE:toggle), data, data_len, urb, TD_FLAG_LAST);
+				cnt++;
+			}
+
+///			if ( cnt >1 )
+///				printk(" %%%%%%%%\n");
+
+///			if (!ohci->sleeping)		// always not sleeping
+				///wmb();
+
+			//	writel (OHCI_BLF, &ohci->regs->cmdstatus); /* start bulk list */
+///			        td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[cnt-1];
+///			 	td_pt->hwBufLen |= cpu_to_le32(TD_INTENABLE);
+///			 	(volatile td_t *)td_pt->hwNextTD = NULL;
+///			 	td_pt->ed->InUse = 1;
+///				td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[0];
+			//	writel (OHCI_CLF, &ohci->regs->cmdstatus); /* start Control list */
+			//	writel (2, &ohci->regs->hostcontrol); /* start Control list */
+///				td_pt->hwINFO |= le32_to_cpu(TD_OWNER);
+///				writel (6, &ohci->regs->hostcontrol); /* start Control list */
+			//        WriteDw(OHCI_CTRL_OPER|OHCI_CTRL_DMA_EN,&ohci->regs->hostcontrol);
+			break;
+
+		case PIPE_INTERRUPT:
+			info = TD_CC ///| TD_T_DATA0 ///toggle 
+///			             | (ed->last_iso & TD_FN) 
+///			             | TD_ISI_SET(ed->int_interval)
+			             | (usb_pipeout (urb->pipe)? TD_DP_OUT : TD_DP_IN);
+			td_fill_ahci (ohci, info, data, data_len, urb, TD_FLAG_LAST);
+
+///			td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[cnt-1];
+///			td_pt->hwBufLen |= cpu_to_le32(TD_INTENABLE);
+///			(volatile td_t *)td_pt->hwNextTD = NULL; 	
+///			td_pt->ed->InUse = 1;
+///			td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[0];
+		//	writel (2, &ohci->regs->hostcontrol); /* start Control list */
+///			td_pt->hwINFO |= le32_to_cpu(TD_OWNER);
+///			writel (6, &ohci->regs->hostcontrol); /* start Control list */
+			break;
+
+		case PIPE_CONTROL:
+		        info = TD_CC | TD_DP_SETUP | TD_T_DATA0;
+			urb_priv->dma2 = pci_map_single (ohci->ohci_dev,
+				    urb->setup_packet, 8, PCI_DMA_TODEVICE);
+			td_fill_ahci (ohci, info, urb_priv->dma2, 8, urb, TD_FLAG_NOLEN);
+			
+			
+			info = TD_CC | (usb_pipeout (urb->pipe)? TD_DP_OUT : TD_DP_IN);
+			info2 = TD_CC | (usb_pipeout (urb->pipe)? TD_DP_IN: TD_DP_OUT);
+			
+			toggle = TD_T_DATA1;
+			if (data_len > 0) {
+/*
+				while(data_len > maxps) {
+					td_fill_ahci (ohci, info | toggle, data, maxps, urb, 0);
+					data += maxps; data_len -= maxps;
+					td_fill_ahci (ohci, info2 | TD_T_DATA1, 0, 0, urb, 0);
+					toggle ^= TD_T_DATA1 ^ TD_T_DATA0;
+				}
+*/
+				td_fill_ahci (ohci, info | toggle, data, data_len, urb, 0);
+///				toggle ^= TD_T_DATA1 ^ TD_T_DATA0;
+			}
+			td_fill_ahci (ohci, info2 | toggle, 0, 0, urb, TD_FLAG_LAST);
+
+
+///			if (!ohci->sleeping)		// always not sleeping
+///			wmb();
+///			td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[cnt-1];
+///			td_pt->hwBufLen |= cpu_to_le32(TD_INTENABLE);
+///			(volatile td_t *)td_pt->hwNextTD = urb_priv->ed->hwTailP; /// NULL;
+///			td_pt->ed->InUse = 1;
+///			td_pt=(volatile td_t *)urb_priv->ed->TD_Addr[0];
+
+	//		writel (2, &ohci->regs->hostcontrol); /* start Control list */
+///			td_pt->hwINFO |= le32_to_cpu(TD_OWNER);
+///			writel (6, &ohci->regs->hostcontrol); /* start Control list */
+			break;
+
+		case PIPE_ISOCHRONOUS:
+			info = TD_CC | TD_T_DATA0 | (usb_pipeout (urb->pipe)? TD_DP_OUT : TD_DP_IN);
+			for (cnt = 0; cnt < urb->number_of_packets; cnt++) {
+				td_fill_ahci (ohci, info | ((urb->start_frame + cnt) & TD_FN), 
+				  data + urb->iso_frame_desc[cnt].offset, 
+				  urb->iso_frame_desc[cnt].length, urb, 
+				  TD_FLAG_ISO | (cnt + 1 == urb->number_of_packets ? TD_FLAG_LAST: 0));
+			}
+			break;
+	} 
+	if (urb_priv->length != cnt)
+		dbg("TD LENGTH %d != CNT %d", urb_priv->length, cnt);
+}
+
+/*-------------------------------------------------------------------------*
+ * Done List handling functions
+ *-------------------------------------------------------------------------*/
+
+
+/* calculate the transfer length and update the urb */
+
+static void dl_transfer_length_ahci(td_t * td)
+{
+	__u32 tdINFO, tdBUFFLEN, tdCBP, tdLastBP,tdCnt;
+/// 	__u16 tdPSW;
+ 	struct urb * urb = td->urb;
+/// 	urb_priv_t * urb_priv = urb->hcpriv;
+	int dlen = 0;
+	int cc = 0;
+
+	tdINFO    = le32_to_cpup (&td->hwINFO);
+  	tdBUFFLEN = le32_to_cpup (&td->hwBufLen) & 0xFFFF;
+  	tdCBP     = le32_to_cpup (&td->hwCBP);
+  	tdCnt     = le32_to_cpup (&td->hwBufLen) & 0xFFFF;
+  	tdLastBP  = td->data_dma;
+
+///  	if (tdINFO & TD_ISO) {
+	if (td->flags & TD_FLAG_ISO) {
+/// 		tdPSW = le16_to_cpu (td->hwPSW[0]);
+/// 		cc = (tdPSW >> 12) & 0xF;
+///		if (cc < 0xE)  {
+			if (usb_pipeout(urb->pipe)) {
+				dlen = urb->iso_frame_desc[td->index].length;
+			} else {
+///				dlen = tdPSW & 0x3ff;
+				dlen = (tdCBP-tdLastBP); //+tdCnt);
+			}
+			urb->actual_length += dlen;
+			urb->iso_frame_desc[td->index].actual_length = dlen;
+			if (!(urb->transfer_flags & USB_DISABLE_SPD) && (cc == TD_DATAUNDERRUN))
+				cc = TD_CC_NOERROR;
+
+			urb->iso_frame_desc[td->index].status = cc_to_error[cc];
+///		}
+	} else 	{ /* BULK, INT, CONTROL DATA */
+///		if (!(usb_pipetype (urb->pipe) == PIPE_CONTROL && 
+///				((td->index == 0) || (td->index == urb_priv->length - 1)))) {
+		if ((td->flags & TD_FLAG_NOLEN) == 0) {
+///			printk("%08x+%08x ", tdCBP-tdLastBP, tdCnt);
+			if (td->hwCBP == 0)
+				urb->actual_length += 0;
+  			else
+				urb->actual_length += (tdCBP-tdLastBP+tdCnt);
+  		}
+  	}
+}
+
+/* handle an urb that is being unlinked */
+/*
+static void dl_del_urb (urb_t * urb)
+{
+	wait_queue_head_t * wait_head = ((urb_priv_t *)(urb->hcpriv))->wait;
+
+	urb_rm_priv_locked_ahci (urb);
+
+	if (urb->transfer_flags & USB_ASYNC_UNLINK) {
+		urb->status = -ECONNRESET;
+		if (urb->complete)
+			urb->complete (urb);
+	} else {
+		urb->status = -ENOENT;
+
+		if (wait_head)
+			wake_up (wait_head);
+	}
+}
+*/
+
+
+/*-------------------------------------------------------------------------*/
+
+/* there are some pending requests to remove 
+ * - some of the eds (if ed->state & ED_DEL (set by sahci_free_dev)
+ * - some URBs/TDs if urb_priv->state == URB_DEL */
+
+static void dl_del_list (ohci_t  * ohci, unsigned int frame)
+{
+	unsigned long flags;
+	ed_t * ed;
+	td_t * td;
+	td_t * tdn;
+	__u32 edINFO;
+	__u32 tdHeadP, tdTailP;
+/*
+	__u32 temp32;
+	td_t  * tdHeadP = NULL, * tdTailP;
+	__u32 * td_p;
+	int ctrl = 0, bulk = 0;
+*/
+
+	spin_lock_irqsave (&usb_ed_lock, flags);
+
+	for (ed = ohci->ed_rm_list[frame]; ed != NULL; ed = ed->ed_rm_list) {
+/*
+		temp32 = (ed->hwTailP) & 0xfffffff0;
+
+		tdTailP = ed->TDTail;
+		tdHeadP = ed->TDHead;
+*/
+		edINFO = le32_to_cpup (&ed->hwINFO);
+///		td_p = &ed->hwHeadP;
+
+		if (ed->state & ED_DEL) {
+			struct ohci_device * dev = usb_to_ahci (ohci->dev[edINFO & 0x7F]);
+
+			ed->hwINFO = cpu_to_le32 (OHCI_ED_SKIP); 
+			ed->state = ED_NEW;
+
+			for (td = ed->td_head; td != NULL ;td = tdn) {
+			  tdn = td->td_next;
+			  td_free(ohci, td);
+			  if (tdn == ed->td_head)		/* Loop complete */
+			    break;
+			}
+
+#ifdef AHCI_VERBOSE_DEBUG
+			printk("2 ED[%p] count=%d\n", ed, dev->ed_cnt);
+#endif
+///			hash_free_ed(ohci, ed);
+
+			if (!--dev->ed_cnt) {
+				wait_queue_head_t *wait_head = dev->wait;
+#ifdef AHCI_VERBOSE_DEBUG
+				printk("Last ED deleted, DEV=%p\n", dev);
+#endif
+				dev->wait = 0;
+				if (wait_head)
+    					wake_up (wait_head);
+			}
+
+		} else {
+			ed->state &= ~ED_URB_DEL;
+			tdHeadP = ed->hwHeadP & 0xFFFFFFF0;
+			tdTailP = ed->hwTailP & 0xFFFFFFF0;
+
+#ifdef AHCI_VERBOSE_DEBUG
+	 		printk("3 TD [%08x]->[%08x]\n", tdHeadP, tdTailP);
+#endif
+//			tdHeadP = dma_to_td (ohci, le32_to_cpup (&ed->hwHeadP) & 0xfffffff0);
+
+			if ( tdHeadP == tdTailP) {
+				if (ed->state == ED_OPER)
+					ep_unlink(ohci, ed);
+/*
+				td_free (ohci, tdTailP);
+				ed->hwINFO = cpu_to_le32 (OHCI_ED_SKIP);
+				ed->state = ED_NEW;
+				printk("4 ED [%08lx]\n",ed);
+				hash_free_ed(ohci, ed);
+				--(usb_to_ahci (ohci->dev[edINFO & 0x7F]))->ed_cnt;
+*/
+			} else
+   	 			ed->hwINFO &= ~cpu_to_le32 (OHCI_ED_SKIP);
+		}
+
+/*
+		switch (ed->type) {
+			case PIPE_CONTROL:
+				ctrl = 1;
+				break;
+			case PIPE_BULK:
+				bulk = 1;
+				break;
+		}
+*/		
+	}
+   	
+/*
+	if (!ohci->disabled) {
+		if (!ohci->ed_rm_list[!frame] && !ohci->sleeping) {
+			if (ohci->ed_controltail)
+				ohci->hc_control |= OHCI_CTRL_CLE;
+			if (ohci->ed_bulktail)
+				ohci->hc_control |= OHCI_CTRL_BLE;
+	//		writel (ohci->hc_control, &ohci->regs->control);   
+		}
+	}
+*/
+   	ohci->ed_rm_list[frame] = NULL;
+   	spin_unlock_irqrestore (&usb_ed_lock, flags);
+}
+
+  		
+/*-------------------------------------------------------------------------*/
+
+/* td done list */
+
+static void dl_done_list (ohci_t * ohci, ed_t * ed)
+{
+	int cc = 0;
+	int head_reached = 0;
+	td_t * td = ed->td_head;
+	struct urb * urb;
+	urb_priv_t * urb_priv;
+ 	__u32 tdINFO;
+	__u32 edhead = ed->hwHeadP & 0xFFFFFFF0;
+
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("ED HEAD -> TD INFO: %08lx\n", le32_to_cpup(&td->hwINFO));
+#endif
+
+  	while (td != ed->td_tail && td->state) { /// && td->td_dma != edhead) {
+  		tdINFO = le32_to_cpup (&td->hwINFO);
+
+		if(tdINFO & TD_OWNER)
+			break;
+
+  		urb = td->urb;
+  		urb_priv = urb->hcpriv;
+
+   		dl_transfer_length_ahci(td);
+
+#ifdef  AHCI_VERBOSE_DEBUG
+		printk("TD [%p] DONE: %08lx, LEN: %08lx, NEXT: %08lx\n", td, (unsigned long)tdINFO, (unsigned long)urb->actual_length, (unsigned long)td->hwNextTD);
+#endif
+		td->state = 0;
+
+ 		if ( ed->NeedCopy ) {
+ 			ed->NeedCopy = 0;
+ 			memcpy(urb->transfer_buffer,(void *)td->dma_buf,urb->actual_length);
+ 		}
+
+  		/* error code of transfer */
+  		cc = TD_CC_GET (tdINFO);
+  		if (cc == TD_CC_STALL)
+			usb_endpoint_halt(urb->dev,
+				usb_pipeendpoint(urb->pipe),
+				usb_pipeout(urb->pipe));
+
+		if (cc == TD_DATAUNDERRUN)
+			cc = TD_CC_NOERROR;
+  		urb->status = cc_to_error[cc];
+
+		if (td->flags & TD_FLAG_LAST) {
+#ifdef  AHCI_VERBOSE_DEBUG
+			printk("CC status = %x  ED HEAD=%p\n",cc, td->td_next);
+#endif
+			sahci_return_urb (ohci, urb);
+///			ed->td_head = td->td_next;
+		}
+
+		if (td->td_dma == edhead) {
+///			head_reached = 1;
+///			ed->td_head = td;
+			break;
+		}
+
+		td = td->td_next;
+  	}
+
+///	if(td)
+	ed->td_head = td;
+}
+
+
+
+
+/*-------------------------------------------------------------------------*
+ * Virtual Root Hub 
+ *-------------------------------------------------------------------------*/
+ 
+/* Device descriptor */
+static __u8 root_hub_dev_des[] =
+{
+	0x12,       /*  __u8  bLength; */
+	0x01,       /*  __u8  bDescriptorType; Device */
+	0x10,	    /*  __u16 bcdUSB; v1.1 */
+	0x01,
+	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
+	0x00,	    /*  __u8  bDeviceSubClass; */
+	0x00,       /*  __u8  bDeviceProtocol; */
+	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x00,       /*  __u16 idVendor; */
+	0x00,
+	0x00,       /*  __u16 idProduct; */
+ 	0x00,
+	0x00,       /*  __u16 bcdDevice; */
+ 	0x00,
+	0x00,       /*  __u8  iManufacturer; */
+	0x02,       /*  __u8  iProduct; */
+	0x01,       /*  __u8  iSerialNumber; */
+	0x01        /*  __u8  bNumConfigurations; */
+};
+
+
+/* Configuration descriptor */
+static __u8 root_hub_config_des[] =
+{
+	0x09,       /*  __u8  bLength; */
+	0x02,       /*  __u8  bDescriptorType; Configuration */
+	0x19,       /*  __u16 wTotalLength; */
+	0x00,
+	0x01,       /*  __u8  bNumInterfaces; */
+	0x01,       /*  __u8  bConfigurationValue; */
+	0x00,       /*  __u8  iConfiguration; */
+	0x40,       /*  __u8  bmAttributes; 
+                 Bit 7: Bus-powered, 6: Self-powered, 5 Remote-wakwup, 4..0: resvd */
+	0x00,       /*  __u8  MaxPower; */
+      
+	/* interface */	  
+	0x09,       /*  __u8  if_bLength; */
+	0x04,       /*  __u8  if_bDescriptorType; Interface */
+	0x00,       /*  __u8  if_bInterfaceNumber; */
+	0x00,       /*  __u8  if_bAlternateSetting; */
+	0x01,       /*  __u8  if_bNumEndpoints; */
+	0x09,       /*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
+	0x00,       /*  __u8  if_bInterfaceSubClass; */
+	0x00,       /*  __u8  if_bInterfaceProtocol; */
+	0x00,       /*  __u8  if_iInterface; */
+     
+	/* endpoint */
+	0x07,       /*  __u8  ep_bLength; */
+	0x05,       /*  __u8  ep_bDescriptorType; Endpoint */
+	0x81,       /*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
+ 	0x03,       /*  __u8  ep_bmAttributes; Interrupt */
+ 	0x02,       /*  __u16 ep_wMaxPacketSize; ((MAX_ROOT_PORTS + 1) / 8 */
+ 	0x00,
+	0xff        /*  __u8  ep_bInterval; 255 ms */
+};
+
+/* Hub class-specific descriptor is constructed dynamically */
+
+
+/*-------------------------------------------------------------------------*/
+
+/* prepare Interrupt pipe data; HUB INTERRUPT ENDPOINT */ 
+ 
+static int ahci_rh_send_irq (ohci_t * ohci, void * rh_data, int rh_len)
+{
+	int num_ports;
+	int i;
+	int ret;
+	int len;
+
+	__u8 data[8];
+
+
+	num_ports = ReadDw (&ohci->regs->rhdescriptor) & RH_NDP; 
+	if (num_ports > MAX_ROOT_PORTS) {
+	//	err ("bogus NDP=%d for OHCI usb-%s", num_ports,
+	//		ohci->ohci_dev->slot_name);
+		err ("rereads as NDP=%d",
+			ReadDw (&ohci->regs->rhdescriptor) & RH_NDP);
+		
+		return 0;
+	}
+	*(__u8 *) data = (ReadDw (&ohci->regs->rhdescriptor) & (RH_LPSC | RH_OCIC))
+		? 1: 0;
+	ret = *(__u8 *) data;
+
+	for ( i = 0; i < num_ports; i++) {
+		*(__u8 *) (data + (i + 1) / 8) |= 
+			((roothub_portstatus (ohci, i) &
+				(RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC | RH_PS_OCIC | RH_PS_PRSC))
+			    ? 1: 0) << ((i + 1) % 8);
+		ret += *(__u8 *) (data + (i + 1) / 8);
+	}
+	len = i/8 + 1;
+  
+	if (ret > 0) { 
+		memcpy(rh_data, data,
+		       min_t(unsigned int, len,
+			   min_t(unsigned int, rh_len, sizeof(data))));
+		return len;
+	}
+	
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Virtual Root Hub INTs are polled by this timer every "interval" ms */
+ 
+static void ahci_rh_int_timer_do (unsigned long ptr)
+{
+	int len; 
+
+	struct urb * urb = (struct urb *) ptr;
+	ohci_t * ohci = urb->dev->bus->hcpriv;
+
+	if (ohci->disabled)
+		return;
+
+	/* ignore timers firing during PM suspend, etc */
+
+
+	if(ohci->rh.send) { 
+		len = ahci_rh_send_irq (ohci, urb->transfer_buffer, urb->transfer_buffer_length);
+		if (len > 0) {
+			urb->actual_length = len;
+			if (urb->complete)
+				urb->complete (urb);
+		}
+	}
+ 
+	ahci_rh_init_int_timer (urb);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Root Hub INTs are polled by this timer */
+
+static int ahci_rh_init_int_timer (struct urb * urb) 
+{
+	ohci_t * ohci = urb->dev->bus->hcpriv;
+
+	ohci->rh.interval = urb->interval;
+	init_timer (&ohci->rh.rh_int_timer);
+	ohci->rh.rh_int_timer.function = ahci_rh_int_timer_do;
+	ohci->rh.rh_int_timer.data = (unsigned long) urb;
+	ohci->rh.rh_int_timer.expires = 
+			jiffies + (HZ * (urb->interval < 30? 30: urb->interval)) / 1000;
+	add_timer (&ohci->rh.rh_int_timer);
+	
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#define OK(x) 			len = (x); break
+#define WR_RH_STAT(x) 		WriteDw((x), &ohci->regs->rhdescriptor)
+#define WR_RH_PORTSTAT(x) 	WriteDw((x), &ohci->regs->portstatus[wIndex-1])
+#define RD_RH_STAT		roothub_status(ohci)
+#define RD_RH_PORTSTAT		roothub_portstatus(ohci,wIndex-1)
+
+/* request to virtual root hub */
+
+static int ahci_rh_submit_urb (struct urb * urb)
+{
+	struct usb_device * usb_dev = urb->dev;
+	ohci_t * ohci = usb_dev->bus->hcpriv;
+	unsigned int pipe = urb->pipe;
+	struct usb_ctrlrequest * cmd = (struct usb_ctrlrequest *) urb->setup_packet;
+	void * data = urb->transfer_buffer;
+	int leni = urb->transfer_buffer_length;
+	int len = 0;
+	int status = TD_CC_NOERROR;
+		
+	__u32 datab[4];
+	__u8  * data_buf = (__u8 *) datab;
+	
+ 	__u16 bmRType_bReq;
+	__u16 wValue; 
+	__u16 wIndex;
+	__u16 wLength;
+
+	if (usb_pipeint(pipe)) {
+		ohci->rh.urb =  urb;
+		ohci->rh.send = 1;
+		ohci->rh.interval = urb->interval;
+		ahci_rh_init_int_timer(urb);
+		urb->status = cc_to_error [TD_CC_NOERROR];
+		
+		return 0;
+	}
+
+	bmRType_bReq  = cmd->bRequestType | (cmd->bRequest << 8);
+	wValue        = le16_to_cpu (cmd->wValue);
+	wIndex        = le16_to_cpu (cmd->wIndex);
+	wLength       = le16_to_cpu (cmd->wLength);
+
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("(%04X %04X %04X %04X)\n",bmRType_bReq,wValue,wIndex,wLength);
+#endif
+	switch (bmRType_bReq) {
+	/* Request Destination:
+	   without flags: Device, 
+	   RH_INTERFACE: interface, 
+	   RH_ENDPOINT: endpoint,
+	   RH_CLASS means HUB here, 
+	   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here 
+	*/
+  
+		case RH_GET_STATUS: 				 		
+				*(__u16 *) data_buf = cpu_to_le16 (1); OK (2);
+		case RH_GET_STATUS | RH_INTERFACE: 	 		
+				*(__u16 *) data_buf = cpu_to_le16 (0); OK (2);
+		case RH_GET_STATUS | RH_ENDPOINT:	 		
+				*(__u16 *) data_buf = cpu_to_le16 (0); OK (2);   
+		case RH_GET_STATUS | RH_CLASS: 				
+				*(__u32 *) data_buf = cpu_to_le32 (
+					RD_RH_STAT & ~(RH_HS_CRWE | RH_HS_DRWE));
+				OK (4);
+		case RH_GET_STATUS | RH_OTHER | RH_CLASS: 	
+		 //               if (RD_RH_PORTSTAT == 0)
+				*(__u32 *) data_buf = cpu_to_le32(RD_RH_PORTSTAT);
+		//		mdelay(1);	
+			//	WR_RH_PORTSTAT(RD_RH_PORTSTAT);	
+			        OK (4);
+
+		case RH_CLEAR_FEATURE | RH_ENDPOINT:  
+			switch (wValue) {
+				case (RH_ENDPOINT_STALL): OK (0);
+			}
+			break;
+
+		case RH_CLEAR_FEATURE | RH_CLASS:
+			switch (wValue) {
+				case RH_C_HUB_LOCAL_POWER:
+					OK(0);
+				case (RH_C_HUB_OVER_CURRENT): 
+						WR_RH_STAT(RH_HS_OCIC); OK (0);
+			}
+			break;
+		
+		case RH_CLEAR_FEATURE | RH_OTHER | RH_CLASS:
+			switch (wValue) {
+				case (RH_PORT_ENABLE): 			
+						WR_RH_PORTSTAT (RH_PS_CCS ); OK (0);
+				case (RH_PORT_SUSPEND):			
+						WR_RH_PORTSTAT (RH_PS_POCI); OK (0);
+				case (RH_PORT_POWER):			
+						WR_RH_PORTSTAT (RH_PS_LSDA); OK (0);
+				case (RH_C_PORT_CONNECTION):	
+						WR_RH_PORTSTAT (RH_PS_CSC ); OK (0);
+				case (RH_C_PORT_ENABLE):		
+						WR_RH_PORTSTAT (RH_PS_PESC); OK (0);
+				case (RH_C_PORT_SUSPEND):		
+						WR_RH_PORTSTAT (RH_PS_PSSC); OK (0);
+				case (RH_C_PORT_OVER_CURRENT):	
+						WR_RH_PORTSTAT (RH_PS_OCIC); OK (0);
+				case (RH_C_PORT_RESET):			
+						WR_RH_PORTSTAT (RH_PS_PRSC); OK (0); 
+			}
+			break;
+ 
+		case RH_SET_FEATURE | RH_OTHER | RH_CLASS:
+			switch (wValue) {
+				case (RH_PORT_SUSPEND):			
+						WR_RH_PORTSTAT (RH_PS_PSS ); OK (0); 
+				case (RH_PORT_RESET): /* BUG IN HUP CODE *********/
+						if (RD_RH_PORTSTAT & RH_PS_CCS)
+						   {
+						      WR_RH_PORTSTAT (RH_PS_PRS | RH_PS_CSC);
+						//    mdelay(1000);
+						      mdelay(10);	
+					    	      WR_RH_PORTSTAT (RH_PS_PES| RH_PS_CSC);
+						      mdelay(100);
+						      WriteDw(2,&ohci->regs->hostcontrol);
+						   }
+						OK (0);
+				case (RH_PORT_POWER):			
+						WR_RH_PORTSTAT (RH_PS_PPS ); OK (0); 
+				case (RH_PORT_ENABLE): /* BUG IN HUP CODE *********/
+						if (RD_RH_PORTSTAT & RH_PS_CCS)
+						    WR_RH_PORTSTAT (RH_PS_PES );
+						OK (0);
+			}
+			break;
+
+		case RH_SET_ADDRESS: ohci->rh.devnum = wValue; OK(0);
+
+		case RH_GET_DESCRIPTOR:
+			switch ((wValue & 0xff00) >> 8) {
+				case (0x01): /* device descriptor */
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_dev_des),
+						      wLength));
+					data_buf = root_hub_dev_des; OK(len);
+				case (0x02): /* configuration descriptor */
+					len = min_t(unsigned int,
+						  leni,
+						  min_t(unsigned int,
+						      sizeof (root_hub_config_des),
+						      wLength));
+					data_buf = root_hub_config_des; OK(len);
+				case (0x03): /* string descriptors */
+					len = usb_root_hub_string (wValue & 0xff,
+						(int)(long) ohci->regs, "OHCI",
+						data, wLength);
+					if (len > 0) {
+						data_buf = data;
+						OK(min_t(int, leni, len));
+					}
+					// else fallthrough
+				default: 
+					status = TD_CC_STALL;
+			}
+			break;
+		
+		case RH_GET_DESCRIPTOR | RH_CLASS:
+		    {
+			    __u32 temp = ReadDw (&ohci->regs->rhdescriptor) ;
+
+			    data_buf [0] = 9;		// min length;
+			    data_buf [1] = 0x29;
+			    data_buf [2] = temp & RH_NDP;
+			    data_buf [3] = 0;
+			    if (temp & RH_PSM) 	/* per-port power switching? */
+				data_buf [3] |= 0x1;
+			    if (temp & RH_NOCP)	/* no overcurrent reporting? */
+				data_buf [3] |= 0x10;
+			  //  else if (temp & RH_OCPM)	/* per-port overcurrent reporting? */
+			  //	data_buf [3] |= 0x8;
+
+			    datab [1] = 0;
+			 //   data_buf [5] = (temp & RH_A_POTPGT) >> 24;
+			 //    temp = roothub_b (ohci);
+			 //   data_buf [7] = temp & RH_B_DR;
+			 //   if (data_buf [2] < 7) {
+				data_buf [8] = 0xff;
+			 //   } else {
+			//	data_buf [0] += 2;
+			//	data_buf [8] = (temp & RH_B_DR) >> 8;
+			//	data_buf [10] = data_buf [9] = 0xff;
+			//    }
+				
+			    len = min_t(unsigned int, leni,
+				      min_t(unsigned int, data_buf [0], wLength));
+			    OK (len);
+			}
+ 
+		case RH_GET_CONFIGURATION: 	*(__u8 *) data_buf = 0x01; OK (1);
+
+		case RH_SET_CONFIGURATION: /*	WR_RH_STAT (0x10000); */ OK (0);
+
+		default: 
+			dbg ("unsupported root hub command");
+			status = TD_CC_STALL;
+	}
+	
+	len = min_t(int, len, leni);
+
+#ifdef  AHCI_VERBOSE_DEBUG
+	{
+	int i;
+	for (i=0;i<len;i++)
+	  printk("%02X ",*(data_buf+i));
+	  
+	printk(" \n");  
+	}
+#endif
+	
+	if (data != data_buf)
+	    memcpy (data, data_buf, len);
+  	urb->actual_length = len;
+	urb->status = cc_to_error [status];
+	
+	urb->hcpriv = NULL;
+	usb_dec_dev_use (usb_dev);
+	urb->dev = NULL;
+	if (urb->complete)
+	    	urb->complete (urb);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int ahci_rh_unlink_urb (struct urb * urb)
+{
+	ohci_t * ohci = urb->dev->bus->hcpriv;
+ 
+	if (ohci->rh.urb == urb) {
+		ohci->rh.send = 0;
+		del_timer (&ohci->rh.rh_int_timer);
+		ohci->rh.urb = NULL;
+
+		urb->hcpriv = NULL;
+		usb_dec_dev_use(urb->dev);
+		urb->dev = NULL;
+		if (urb->transfer_flags & USB_ASYNC_UNLINK) {
+			urb->status = -ECONNRESET;
+			if (urb->complete)
+				urb->complete (urb);
+		} else
+			urb->status = -ENOENT;
+	}
+	return 0;
+}
+ 
+/*-------------------------------------------------------------------------*
+ * HC functions
+ *-------------------------------------------------------------------------*/
+
+/* reset the HC and BUS */
+
+static int hc_reset_ahci (ohci_t * ohci)
+{
+	int timeout = 30;
+//	int smm_timeout = 50; /* 0,5 sec */
+
+	WriteDw (0, &ohci->regs->intrenable);
+
+
+
+
+	mdelay(10);
+	WriteDw (OHCI_CTRL_SWRESET,  &ohci->regs->control);
+	while ((ReadDw (&ohci->regs->control) & OHCI_CTRL_SWRESET) != 0) {
+		if (--timeout == 0) {
+			err("USB HC reset timed out!");
+			return -1;
+		}	
+		mdelay (1);
+	}	 
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Start an OHCI controller, set the BUS operational
+ * enable interrupts 
+ * connect the virtual root hub */
+
+static int hc_start_ahci (ohci_t * ohci)
+{
+  	__u32 mask;
+  	unsigned int fminterval;
+  	struct usb_device  * usb_dev;
+	struct ohci_device * dev;
+	
+	ohci->disabled = 1;
+
+	/* Tell the controller where the control and bulk lists are
+	 * The lists are empty now. */
+	WriteDw (OHCI_HOST_EN, &ohci->regs->control); 
+
+	ohci->ed_start = NULL;
+	ohci->ed_tail = NULL;
+	WriteDw (0, &ohci->regs->ed_hosthead);
+   
+  	fminterval = 0x20002edf;
+	
+	WriteDw (fminterval, &ohci->regs->fminterval);
+
+	WriteDw (0x628, &ohci->regs->lsthresh);
+///	WriteDw (0x028, &ohci->regs->lsthresh);
+
+ 	/* start controller operations */
+ 	ohci->hc_control = OHCI_CTRL_OPER;
+	ohci->disabled = 0;
+ 
+ 	/* Choose the interrupts we care about now, others later on demand */
+///	mask = OHCI_INT_ACT | OHCI_FATAL_INT | OHCI_SW_INT | OHCI_TD_INT | OHCI_SOF_INT;
+	mask = OHCI_INT_ACT | OHCI_FATAL_INT | OHCI_SW_INT | OHCI_TD_INT | OHCI_SO_INT;
+
+	WriteDw ( mask, &ohci->regs->intrenable);
+
+	WriteDw ( mask, &ohci->regs->intrstatus);
+
+        WriteDw (RH_NPS+RH_LPSC,&ohci->regs->rhdescriptor);
+        WriteDw (2, &ohci->regs->hostcontrol);
+
+ 
+	/* connect the virtual root hub */
+	ohci->rh.devnum = 0;
+	usb_dev = usb_alloc_dev (NULL, ohci->bus);
+	if (!usb_dev) {
+	    ohci->disabled = 1;
+	    return -ENOMEM;
+	}
+	dev = usb_to_ahci (usb_dev);
+	ohci->bus->root_hub = usb_dev;
+	usb_connect (usb_dev);
+	if (usb_new_device (usb_dev) != 0) {
+		usb_free_dev (usb_dev); 
+		ohci->disabled = 1;
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* called only from interrupt handler */
+/*
+
+static void check_timeouts (struct ohci *ohci)
+{
+	spin_lock (&usb_ed_lock);
+	while (!list_empty (&ohci->timeout_list)) {
+		struct urb	*urb;
+
+		urb = list_entry (ohci->timeout_list.next, struct urb, urb_list);
+		if (time_after (jiffies, urb->timeout))
+			break;
+
+		list_del_init (&urb->urb_list);
+		if (urb->status != -EINPROGRESS)
+			continue;
+
+		urb->transfer_flags |= USB_TIMEOUT_KILLED | USB_ASYNC_UNLINK;
+		spin_unlock (&usb_ed_lock);
+
+		// outside the interrupt handler (in a timer...)
+		// this reference would race interrupts
+		sahci_unlink_urb (urb);
+
+		spin_lock (&usb_ed_lock);
+	}
+	spin_unlock (&usb_ed_lock);
+}
+*/
+
+/*-------------------------------------------------------------------------*/
+
+/* an interrupt happens */
+
+static void ahci_hc_interrupt (int irq, void * __ohci, struct pt_regs * r)
+{
+	ohci_t * ohci = __ohci;
+	ed_t	* ed_tp = NULL;
+	td_t	* td_tp = NULL;
+	ed_t	* ed_td;
+///	__u32	hostHead ;
+	
+	struct ohci_regs * regs = ohci->regs;
+ 	int ints; 
+
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("*** Interrupt: (%08lx)\n", ReadDw (&regs->intrstatus));
+#endif
+	if ((ints = (ReadDw (&regs->intrstatus) & ReadDw (&regs->intrenable))) == 0) {
+		return;
+	}
+
+  	if ( ints & OHCI_FATAL_INT ) {
+  		WriteDw (OHCI_FATAL_INT, &regs->intrstatus);
+  		printk("Fatal Error !!\n");
+  		hc_reset_ahci(ohci);
+	}
+
+	if ( ints & OHCI_SW_INT ) {
+		WriteDw (OHCI_SW_INT, &regs->intrstatus);
+  		printk("Software Interrupt !\n");
+  	}
+	
+	if ( ints & OHCI_SO_INT ) {
+		WriteDw (OHCI_SO_INT, &regs->intrstatus);
+  		printk("AHCI: Scheduling overrun !\n");
+	}
+
+  	if ( ints & OHCI_TD_INT ) {
+		ed_tp = ohci->ed_start;
+		if (ed_tp == NULL) {
+			return;
+		}
+  		WriteDw( ReadDw(&regs->intrenable) & ~OHCI_TD_INT, &regs->intrenable);
+///		(void)readl (&regs->intrenable); /* PCI posting flush */
+		while(ed_tp != NULL) {
+			if (ed_tp->td_head != ed_tp->td_tail) {
+				ed_td = (ed_t *)ed_tp->dma;
+				td_tp = ed_tp->td_head;
+
+				if ( !(le32_to_cpup(&td_tp->hwINFO) & TD_OWNER) ) {  //process this ED
+///				if ((ed_tp->hwHeadP & 0xFFFFFFF0) == (ed_tp->hwTailP & 0xFFFFFFF0)) {
+#ifdef  AHCI_VERBOSE_DEBUG
+					printk("*Got something in ED=%p (ED: HEAD=%08lx TAIL=%08lx)\n",ed_tp,ed_tp->hwHeadP,ed_tp->hwTailP);
+#endif
+					dl_done_list(ohci, (ed_t *)ed_tp);
+  				} 
+#ifdef  AHCI_VERBOSE_DEBUG
+				else {
+					printk("*Still something not complete: HEAD=%08lx TAIL=%08lx\n",ed_tp->hwHeadP,ed_tp->hwTailP);
+				}
+#endif
+  			}
+			ed_tp = ed_tp->ed_next;
+  		}
+		WriteDw(OHCI_TD_INT, &regs->intrstatus);
+		WriteDw( ReadDw(&regs->intrenable) | OHCI_TD_INT, &regs->intrenable);
+	}
+
+///  	if (0)	{	
+ 	if (ints & OHCI_SOF_INT) { 
+	//	unsigned int frame = le16_to_cpu (&regs->fmnumber) & 1;
+	        unsigned long frame = ReadDw(&regs->fmnumber);
+	        frame = (frame >>16) & 1;
+		WriteDw( ReadDw(&regs->intrenable) & ~OHCI_SOF_INT, &regs->intrenable);	
+		WriteDw (OHCI_SOF_INT, &regs->intrstatus);
+
+#ifdef AHCI_VERBOSE_DEBUG
+		printk("frame = %08lx %08lx ==== %08lx \n",ReadDw(&regs->fmnumber),ohci->ed_rm_list[!frame],ohci->ed_rm_list[frame]);
+#endif
+
+		if (ohci->ed_rm_list[!frame] != NULL) {
+#ifdef AHCI_VERBOSE_DEBUG
+			printk("DL DEL List \n");
+#endif
+			dl_del_list (ohci, !frame);
+		}
+
+		if (ohci->ed_rm_list[frame] != NULL) {
+			WriteDw( ReadDw(&regs->intrenable) | OHCI_SOF_INT, &regs->intrenable);
+		}
+	}
+#ifdef  AHCI_VERBOSE_DEBUG
+	printk("***** Interrupt exit\n");
+#endif
+ //	WriteDw (ints, &regs->intrstatus);
+	//writel (OHCI_INTR_MIE, &regs->intrenable);
+
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* allocate OHCI */
+
+static ohci_t * __devinit hc_alloc_ahci (void * mem_base)
+{
+	ohci_t * ohci;
+	struct usb_bus * bus;
+	struct pci_dev *dev;
+
+	ohci = (ohci_t *) kmalloc (sizeof *ohci, GFP_KERNEL);
+	if (!ohci)
+		return NULL;
+		
+	memset (ohci, 0, sizeof (ohci_t));
+	
+	dev = NULL ; // Not PCI Device 
+
+
+	ohci->disabled = 1;
+	ohci->sleeping = 0;
+	ohci->irq = -1;
+	ohci->regs = mem_base;   
+
+	ohci->ohci_dev = dev;
+//	pci_set_drvdata(dev, ohci);
+ 
+	INIT_LIST_HEAD (&ohci->ohci_hcd_list);
+	list_add (&ohci->ohci_hcd_list, &ohci_hcd_list);
+
+	INIT_LIST_HEAD (&ohci->timeout_list);
+	spin_lock_init(&usb_ed_lock);
+
+	bus = usb_alloc_bus (&sahci_device_operations);
+	if (!bus) {
+		kfree (ohci);
+		return NULL;
+	}
+
+	ohci->bus = bus;
+	bus->bus_name = "HUB"; // dev->slot_name;
+	bus->hcpriv = (void *) ohci;
+
+	return ohci;
+} 
+
+
+/*-------------------------------------------------------------------------*/
+
+/* De-allocate all resources.. */
+
+static void ahci_hc_release_ohci (ohci_t * ohci)
+{	
+//	dbg ("USB HC release ohci usb-%s", ohci->ohci_dev->slot_name);
+
+	/* disconnect all devices */    
+	if (ohci->bus->root_hub)
+		usb_disconnect (&ohci->bus->root_hub);
+
+	if (!ohci->disabled)
+		hc_reset_ahci (ohci);
+	
+	if (ohci->irq >= 0) {
+		free_irq (ohci->irq, ohci);
+		ohci->irq = -1;
+	}
+//	pci_set_drvdata(ohci->ohci_dev, NULL);
+
+	usb_deregister_bus (ohci->bus);
+	usb_free_bus (ohci->bus);
+
+	list_del (&ohci->ohci_hcd_list);
+	INIT_LIST_HEAD (&ohci->ohci_hcd_list);
+
+	ahci_mem_cleanup (ohci);
+    
+	/* unmap the IO address space */
+	iounmap (ohci->regs);
+
+//	pci_free_consistent (ohci->ohci_dev, sizeof *ohci->hcca,
+//		ohci->hcca, ohci->hcca_dma);
+	kfree (ohci);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* Increment the module usage count, start the control thread and
+ * return success. */
+
+static struct pci_driver ohci_pci_driver;
+ 
+static int __devinit
+hc_found_ahci ( int irq, void *mem_base)
+{
+	ohci_t * ohci;
+	char buf[8], *bufp = buf;
+	int ret;
+
+#ifndef __sparc__
+	sprintf(buf, "%d", irq);
+#else
+	bufp = __irq_itoa(irq);
+#endif
+         
+	ohci = hc_alloc_ahci (mem_base);
+	if (!ohci) {
+		return -ENOMEM;
+	}
+	if ((ret = ahci_mem_init (ohci)) < 0) {
+		ahci_hc_release_ohci (ohci);
+		return ret;
+	}
+
+	if (hc_reset_ahci (ohci) < 0) {
+		ahci_hc_release_ohci (ohci);
+		return -ENODEV;
+	}
+
+	usb_register_bus (ohci->bus);
+	
+	if (request_irq (irq, ahci_hc_interrupt, SA_SHIRQ,
+			ohci_pci_driver.name, ohci) != 0) {
+		err ("request interrupt %s failed", bufp);
+		ahci_hc_release_ohci (ohci);
+		return -EBUSY;
+	}
+	ohci->irq = irq;     
+
+	if (hc_start_ahci (ohci) < 0) {
+		ahci_hc_release_ohci (ohci);
+		return -EBUSY;
+	}
+
+#ifdef	DEBUG
+	ohci_dump (ohci, 1);
+#endif
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+
+
+
+/* configured so that an OHCI device is always provided */
+/* always called with process context; sleeping is OK */
+
+static int __devinit
+ahci_ahb_probe (void)
+{
+	unsigned long mem_resource, mem_len;
+	void *mem_base;
+	int irq;  	
+	
+	/* we read its hardware registers as memory */
+	irq = 0x3;    //<===== Adm5120 USB Host IRQ No.
+	mem_resource = 0x11200000;
+	mem_len = 0x84;
+	if (!request_mem_region (mem_resource, mem_len, ohci_pci_driver.name)) {
+		dbg ("controller already in use");
+	}
+
+	mem_base = ioremap_nocache (mem_resource, mem_len);
+	if (!mem_base) {
+		err("Error mapping OHCI memory");
+		return -EFAULT;
+	}
+
+	return hc_found_ahci (irq, mem_base);
+
+} 
+
+
+
+
+/*-------------------------------------------------------------------------*/
+/*
+static const struct pci_device_id __devinitdata ohci_pci_ids [] = { {
+
+	
+	vendor:		0x1022,
+	device:		0x740c,
+	subvendor:	PCI_ANY_ID,
+	subdevice:	PCI_ANY_ID,
+
+	driver_data:	OHCI_QUIRK_AMD756,
+
+} , {
+
+	
+	class: 		((PCI_CLASS_SERIAL_USB << 8) | 0x10),
+	class_mask: 	~0,
+
+	
+	vendor:		PCI_ANY_ID,
+	device:		PCI_ANY_ID,
+	subvendor:	PCI_ANY_ID,
+	subdevice:	PCI_ANY_ID,
+
+	}, {  }
+};
+*/
+/*
+MODULE_DEVICE_TABLE (pci, ohci_pci_ids);
+
+static struct pci_driver ohci_pci_driver = {
+	name:		"usb-ohci",
+	id_table:	&ahci_pci_ids [0],
+
+	probe:		ahci_pci_probe,
+	remove:		__devexit_p(ahci_pci_remove),
+
+#ifdef	CONFIG_PM
+	suspend:	ahci_pci_suspend,
+	resume:		ahci_pci_resume,
+#endif
+	
+}; */
+
+ 
+/*-------------------------------------------------------------------------*/
+
+static int __init ahci_hcd_init (void) 
+{
+	info(" Start Init AHCI_INIT\n");
+	return ahci_ahb_probe();
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void __exit ahci_hcd_cleanup (void) 
+{	
+	pci_unregister_driver (&ohci_pci_driver);
+}
+
+module_init (ahci_hcd_init);
+module_exit (ahci_hcd_cleanup);
+
+
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL");
diff -urN linux-2.4.32/drivers/usb/host/usb-shci.h linux-2.4.32-new/drivers/usb/host/usb-shci.h
--- linux-2.4.32/drivers/usb/host/usb-shci.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-new/drivers/usb/host/usb-shci.h	2006-02-01 21:53:11.000000000 +0200
@@ -0,0 +1,736 @@
+/*
+ * URB OHCI HCD (Host Controller Driver) for USB.
+ * 
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2001 David Brownell <dbrownell@users.sourceforge.net>
+ * 
+ * usb-ohci.h
+ */
+
+ 
+static int cc_to_error[16] = { 
+
+/* mapping of the OHCI CC status to error codes */ 
+	/* No  Error  */               USB_ST_NOERROR,
+	/* CRC Error  */               USB_ST_CRC,
+	/* Bit Stuff  */               USB_ST_BITSTUFF,
+	/* Data Togg  */               USB_ST_CRC,
+	/* Stall      */               USB_ST_STALL,
+	/* DevNotResp */               USB_ST_NORESPONSE,
+	/* PIDCheck   */               USB_ST_BITSTUFF,
+	/* UnExpPID   */               USB_ST_BITSTUFF,
+	/* DataOver   */               USB_ST_DATAOVERRUN,
+	/* DataUnder  */               USB_ST_DATAUNDERRUN,
+	/* reservd    */               USB_ST_NORESPONSE,
+	/* reservd    */               USB_ST_NORESPONSE,
+	/* BufferOver */               USB_ST_BUFFEROVERRUN,
+	/* BuffUnder  */               USB_ST_BUFFERUNDERRUN,
+	/* Not Access */               USB_ST_NORESPONSE,
+	/* Not Access */               USB_ST_NORESPONSE 
+};
+
+#include <linux/config.h>
+
+/* ED States */
+
+#define ED_NEW 		0x00
+#define ED_UNLINK 	0x01
+#define ED_OPER		0x02
+#define ED_DEL		0x04
+#define ED_URB_DEL  	0x08
+
+
+#define ED_TOGG		0x02
+
+/* usb_ohci_ed */
+struct ed {
+	__u32 hwINFO;
+	__u32 hwTailP;
+	__u32 hwHeadP;
+	__u32 hwNextED;
+
+	struct ed * ed_next;
+	struct ed * ed_prev;
+	__u8 int_period;
+	__u8 int_branch;		/// unused
+	__u8 int_load;
+	__u8 int_interval;		/// unused
+	__u8 state;
+	__u8 type;
+	__u16 last_iso;
+	struct ed * ed_rm_list;
+	__u8 InUse;			/// unused
+	__u8 IsLast;			/// unused
+	__u8 NeedCopy;
+	__u8 Direction;			/// unused
+///	__u32 TDHead;
+	struct td * td_head;
+	struct td * td_tail;
+        dma_addr_t dma;
+///	__u32 TD_Addr[4];
+
+} __attribute((aligned(16)));
+typedef struct ed ed_t;
+
+ 
+/* TD info field */
+#define TD_OWNER    0x80000000	
+#define TD_CC       0x00000000
+#define TD_CC_GET(td_p) ((td_p >>27) & 0x0f)
+#define TD_CC_SET(td_p, cc) (td_p) = ((td_p) & 0x0fffffff) | (((cc) & 0x0f) << 27)
+#define TD_EC       0x06000000
+#define TD_T        0x01800000
+#define TD_T_DATA0  0x01000000
+#define TD_T_DATA1  0x01800000
+#define TD_T_TOGGLE 0x00000000
+#define TD_R        0x00040000			/// ???
+#define TD_ISI      0x00003F00
+#define TD_ISI_SET(X) (((X) & 0x3F)<< 8)
+#define TD_DP       0x00600000
+#define TD_DP_SETUP 0x00000000
+#define TD_DP_IN    0x00400000
+#define TD_DP_OUT   0x00200000
+
+#define TD_FN       0x0000003F
+
+///#define TD_ISO	    0x00010000			/// ???
+///#define TD_DEL      0x00020000			/// ???
+
+/* CC Codes */
+#define TD_CC_NOERROR      0x00
+#define TD_CC_CRC          0x01
+#define TD_CC_BITSTUFFING  0x02
+#define TD_CC_DATATOGGLEM  0x03
+#define TD_CC_STALL        0x04
+#define TD_DEVNOTRESP      0x05
+#define TD_PIDCHECKFAIL    0x06
+#define TD_UNEXPECTEDPID   0x07
+#define TD_DATAOVERRUN     0x08
+#define TD_DATAUNDERRUN    0x09
+#define TD_BUFFEROVERRUN   0x0C
+#define TD_BUFFERUNDERRUN  0x0D
+#define TD_NOTACCESSED     0x0F
+
+#define TD_BUFFLEN	   0x0000FFFF
+#define TD_INTENABLE	   0x00010000
+
+
+#define TD_FLAG_LAST	0x01
+#define TD_FLAG_NOLEN	0x02
+#define TD_FLAG_ISO	0x04
+///#define TD_FLAG_REUSE	0x08
+
+#define MAXPSW 1
+
+struct td {
+	__u32 hwINFO;
+  	__u32 hwCBP;		/* Current Buffer Pointer */
+  	__u32 hwBufLen;		/* Buffer Length */
+  	__u32 hwNextTD;		/* Next TD Pointer */
+
+  	__u16 hwPSW[MAXPSW];	/// may be unused
+  	__u8  flags;
+  	__u8  index;
+  	struct ed * ed;
+  	struct td * td_next;
+  	struct urb * urb;
+
+	dma_addr_t td_dma;
+	dma_addr_t data_dma;
+	__u32 dma_buf;
+	__u8  state;
+	__u8  unused[7];
+///	__u32 unused2[2];
+} __attribute((aligned(32)));	/* normally 16, iso needs 32 */
+typedef struct td td_t;
+
+#define OHCI_ED_SKIP		(1 << 14)
+#define OHCI_ED_HIGHSPEED	(1 << 13)
+#define OHCI_ED_INT		(1 << 11)
+#define OHCI_ED_ISO		(1 << 15)
+
+  
+/*
+ * Maximum number of root hub ports.  
+ */
+#define MAX_ROOT_PORTS	15	/* maximum OHCI root hub ports */
+
+/*
+ * This is the structure of the OHCI controller's memory mapped I/O
+ * region.  This is Memory Mapped I/O.  You must use the readl() and
+ * writel() macros defined in asm/io.h to access these!!
+ */
+struct ohci_regs {
+	/* control and status registers */
+	__u32	control;		//0x00
+	__u32	intrstatus;		//0x04
+	__u32	intrenable;		//0x08
+	__u32   reserved0; 		//0x0c
+	__u32	hostcontrol;		//0x10
+	__u32	reserved1;		//0x14
+	__u32	fminterval;		//0x18
+	__u32	fmnumber;		//0x1C
+	__u32	reserved2;		//0x20
+	__u32	reserved3;		//0x24
+	__u32	reserved4;		//0x28
+	__u32	reserved5;		//0x2C
+	__u32	reserved6;		//0x30
+	__u32	reserved7;		//0x34
+	__u32	reserved8;		//0x38
+	__u32	reserved9;		//0x3C
+	__u32	reserved10;		//0x30
+	__u32	reserved11;		//0x44
+	__u32	reserved12;		//0x48
+	__u32	reserved13;		//0x4C
+	__u32	reserved14;		//0x50
+	__u32	reserved15;		//0x54
+	__u32	reserved16;		//0x58
+	__u32	reserved17;		//0x5C
+	__u32	reserved18;		//0x60
+	__u32	reserved19;		//0x64
+	__u32	reserved20;		//0x68
+	__u32	reserved21;		//0x6C
+	__u32	lsthresh;		//0x70
+	__u32	rhdescriptor;		//0x74
+	__u32	portstatus[2];		//0x78
+//	__u32	port1status;		//0x7C
+	__u32	ed_hosthead;		//0x80
+	
+} __attribute((aligned(32)));
+
+
+/* OHCI CONTROL AND STATUS REGISTER MASKS */
+
+/*
+ * HcControl (control) register masks 
+ */
+#define OHCI_CTRL_SWRESET 	(1<<3)		/* Software Reset */ 
+#define OHCI_DMA_ARB	 	(1<<2)		/* DMA arbitration */
+#define OHCI_SW_INT_REQ		(1<<1)      	/* Software Interrupt Request */
+#define OHCI_HOST_EN		(1<<0)		/* USB Host function Enable */		 
+ 
+/* 
+ * HcInterrupt 
+ */
+#define OHCI_INT_ACT	(1<<31)		/* Interrupt Active */
+#define OHCI_FATAL_INT	(1<<30)		/* Fatal system bus error occur */
+#define OHCI_SW_INT	(1<<29)		/* Software interrupt */
+#define OHCI_TD_INT	(1<<20)		/* A TD is complete */
+#define OHCI_FNO	(1<<11)		/* Frame No Overflow */
+#define OHCI_SO_INT	(1<<10)		/* Scheduling overrun */
+#define OHCI_INSMOV_INT	(1<<9)		/* Root Hub Status Change */
+#define OHCI_BAB_INT	(1<<8)		/* Babble detected */
+#define OHCI_RES_INT	(1<<5)		/* Resume Detect */
+#define OHCI_SOF_INT	(1<<4)          /* SOF TRansmitted/received */
+	  
+//***************** Host Controller **********************************
+#define OHCI_CTRL_OPER   (1<<1)         /* USB Bus State Normal Operation */
+#define OHCI_CTRL_DMA_EN (2<<1)         /* USB HOST DMA ENABLE */ 
+
+ 
+ 
+//*****************teh below item will remove after code complete *// 
+ 
+ 
+#define OHCI_CTRL_CBSR	(3 << 0)	/* control/bulk service ratio */
+#define OHCI_CTRL_PLE	(1 << 2)	/* periodic list enable */
+#define OHCI_CTRL_IE	(1 << 3)	/* isochronous enable */
+#define OHCI_CTRL_CLE	(1 << 4)	/* control list enable */
+#define OHCI_CTRL_BLE	(1 << 5)	/* bulk list enable */
+#define OHCI_CTRL_HCFS	(3 << 6)	/* host controller functional state */
+#define OHCI_CTRL_IR	(1 << 8)	/* interrupt routing */
+#define OHCI_CTRL_RWC	(1 << 9)	/* remote wakeup connected */
+#define OHCI_CTRL_RWE	(1 << 10)	/* remote wakeup enable */
+
+/* pre-shifted values for HCFS */
+#	define OHCI_USB_RESET	(0 << 6)
+#	define OHCI_USB_RESUME	(1 << 6)
+#	define OHCI_USB_OPER	(2 << 6)
+#	define OHCI_USB_SUSPEND	(3 << 6)
+
+/*
+ * HcCommandStatus (cmdstatus) register masks
+ */
+#define OHCI_HCR	(1 << 0)	/* host controller reset */
+#define OHCI_CLF  	(1 << 1)	/* control list filled */
+#define OHCI_BLF  	(1 << 2)	/* bulk list filled */
+#define OHCI_OCR  	(1 << 3)	/* ownership change request */
+#define OHCI_SOC  	(3 << 16)	/* scheduling overrun count */
+
+/*
+ * masks used with interrupt registers:
+ * HcInterruptStatus (intrstatus)
+ * HcInterruptEnable (intrenable)
+ * HcInterruptDisable (intrdisable)
+ */
+///#define OHCI_INTR_SO	(1 << 0)	/* scheduling overrun */
+///#define OHCI_INTR_WDH	(1 << 1)	/* writeback of done_head */
+///#define OHCI_INTR_SF	(1 << 2)	/* start frame */
+///#define OHCI_INTR_RD	(1 << 3)	/* resume detect */
+///#define OHCI_INTR_UE	(1 << 4)	/* unrecoverable error */
+///#define OHCI_INTR_FNO	(1 << 5)	/* frame number overflow */
+///#define OHCI_INTR_RHSC	(1 << 6)	/* root hub status change */
+///#define OHCI_INTR_OC	(1 << 30)	/* ownership change */
+///#define OHCI_INTR_MIE	(1 << 31)	/* master interrupt enable */
+
+
+
+/* Virtual Root HUB */
+struct virt_root_hub {
+	int devnum; /* Address of Root Hub endpoint */ 
+	void * urb;
+	void * int_addr;
+	int send;
+	int interval;
+	struct timer_list rh_int_timer;
+};
+
+
+/* USB HUB CONSTANTS (not OHCI-specific; see hub.h) */
+ 
+/* destination of request */
+#define RH_INTERFACE               0x01
+#define RH_ENDPOINT                0x02
+#define RH_OTHER                   0x03
+
+#define RH_CLASS                   0x20
+#define RH_VENDOR                  0x40
+
+/* Requests: bRequest << 8 | bmRequestType */
+#define RH_GET_STATUS           0x0080
+#define RH_CLEAR_FEATURE        0x0100
+#define RH_SET_FEATURE          0x0300
+#define RH_SET_ADDRESS		0x0500
+#define RH_GET_DESCRIPTOR	0x0680
+#define RH_SET_DESCRIPTOR       0x0700
+#define RH_GET_CONFIGURATION	0x0880
+#define RH_SET_CONFIGURATION	0x0900
+#define RH_GET_STATE            0x0280
+#define RH_GET_INTERFACE        0x0A80
+#define RH_SET_INTERFACE        0x0B00
+#define RH_SYNC_FRAME           0x0C80
+/* Our Vendor Specific Request */
+#define RH_SET_EP               0x2000
+
+
+/* Hub port features */
+#define RH_PORT_CONNECTION         0x00
+#define RH_PORT_ENABLE             0x01
+#define RH_PORT_SUSPEND            0x02
+#define RH_PORT_OVER_CURRENT       0x03
+#define RH_PORT_RESET              0x04
+#define RH_PORT_POWER              0x08
+#define RH_PORT_LOW_SPEED          0x09
+
+#define RH_C_PORT_CONNECTION       0x10
+#define RH_C_PORT_ENABLE           0x11
+#define RH_C_PORT_SUSPEND          0x12
+#define RH_C_PORT_OVER_CURRENT     0x13
+#define RH_C_PORT_RESET            0x14  
+
+/* Hub features */
+#define RH_C_HUB_LOCAL_POWER       0x00
+#define RH_C_HUB_OVER_CURRENT      0x01
+
+#define RH_DEVICE_REMOTE_WAKEUP    0x00
+#define RH_ENDPOINT_STALL          0x01
+
+#define RH_ACK                     0x01
+#define RH_REQ_ERR                 -1
+#define RH_NACK                    0x00
+
+
+/* OHCI ROOT HUB REGISTER MASKS */
+/* Root Hub Descriptor *//* 0x74*/
+#define	RH_NDP		(0xff << 0)		/* number of downstream ports */
+#define	RH_PSM		(1 << 8)		/* power switching mode */
+#define	RH_NPS		(1 << 9)		/* no power switching */
+#define	RH_OCPM		(1 << 10)		/* over current protection mode */
+#define	RH_NOCP		(1 << 11)		/* no over current protection */
+#define RH_PPCM	        (0xff << 16)		/* port power control mask */
+#define RH_LPS	     	(1 << 24)		/* local power status */
+#define RH_OCI	        (1 << 25)		/* over current indicator */
+#define RH_LPSC	        (1 << 26)		/* local power status change */
+#define RH_OCIC		(1 << 27)		/* over current indicator change */
+#define RH_DRWE	        (1 << 28)		/* device remote wakeup enable */
+#define RH_CRWE	        (1 << 29)		/* clear remote wakeup enable */
+
+/* Root Hub Port Status */
+#define RH_PS_CCS            0x00000001   	/* current connect status */
+#define RH_PS_PES            0x00000002   	/* port enable status*/
+#define RH_PS_PSS            0x00000004   	/* port suspend status */
+#define RH_PS_POCI           0x00000008   	/* port over current indicator */
+#define RH_PS_PRS            0x00000010  	/* port reset status */
+#define RH_PS_PPS            0x00000100   	/* port power status */
+#define RH_PS_LSDA           0x00000200    	/* low speed device attached */
+#define RH_PS_CSC            0x00010000 	/* connect status change */
+#define RH_PS_PESC           0x00020000   	/* port enable status change */
+#define RH_PS_PSSC           0x00040000    	/* port suspend status change */
+#define RH_PS_OCIC           0x00080000    	/* over current indicator change */
+#define RH_PS_PRSC           0x00100000   	/* port reset status change */
+ 
+
+/* roothub.status bits */
+#define RH_HS_LPS	     0x00000001		/* local power status */
+#define RH_HS_OCI	     0x00000002		/* over current indicator */
+#define RH_HS_DRWE	     0x00008000		/* device remote wakeup enable */
+#define RH_HS_LPSC	     0x00010000		/* local power status change */
+#define RH_HS_OCIC	     0x00020000		/* over current indicator change */
+#define RH_HS_CRWE	     0x80000000		/* clear remote wakeup enable */
+
+/* roothub.b masks */
+//#define RH_B_DR		0x0000ffff		/* device removable flags */
+//#define RH_B_PPCM	0xffff0000		/* port power control mask */
+
+/* roothub.a masks */
+//#define	RH_A_NDP	(0xff << 0)		/* number of downstream ports */
+//#define	RH_A_PSM	(1 << 8)		/* power switching mode */
+//#define	RH_A_NPS	(1 << 9)		/* no power switching */
+//#define	RH_A_DT		(1 << 10)		/* device type (mbz) */
+//#define	RH_A_OCPM	(1 << 11)		/* over current protection mode */
+//#define	RH_A_NOCP	(1 << 12)		/* no over current protection */
+//#define	RH_A_POTPGT	(0xff << 24)		/* power on to power good time */
+
+/* urb */
+typedef struct 
+{
+	ed_t * ed;
+	__u16 length;	// number of tds associated with this request
+	__u16 td_cnt;	// number of tds already serviced
+	int   state;
+	wait_queue_head_t * wait;
+	dma_addr_t dma1;
+	dma_addr_t dma2;
+///	td_t * td[0];	// list pointer to all corresponding TDs associated with this request
+
+} urb_priv_t;
+#define URB_DEL 1
+
+
+/* Hash struct used for TD/ED hashing */
+struct hash_t {
+	void		*virt;
+	dma_addr_t	dma;
+	struct hash_t	*next; // chaining for collision cases
+};
+
+/* List of TD/ED hash entries */
+struct hash_list_t {
+	struct hash_t	*head;
+	struct hash_t	*tail;
+};
+
+#define TD_HASH_SIZE    64    /* power'o'two */
+#define ED_HASH_SIZE    64    /* power'o'two */
+
+#define TD_HASH_FUNC(td_dma) ((td_dma ^ (td_dma >> 5)) % TD_HASH_SIZE)
+#define ED_HASH_FUNC(ed_dma) ((ed_dma ^ (ed_dma >> 5)) % ED_HASH_SIZE)
+
+
+/*
+ * This is the full ohci controller description
+ *
+ * Note how the "proper" USB information is just
+ * a subset of what the full implementation needs. (Linus)
+ */
+
+
+typedef struct ohci {
+//	struct ohci_hcca *hcca;		/* hcca */
+//	dma_addr_t hcca_dma;
+
+	int irq;
+	int disabled;			/* e.g. got a UE, we're hung */
+	int sleeping;
+	atomic_t resume_count;		/* defending against multiple resumes */
+	unsigned long flags;		/* for HC bugs */
+
+	struct ohci_regs * regs;	/* OHCI controller's memory */
+	struct list_head ohci_hcd_list;	/* list of all ohci_hcd */
+
+	struct ohci * next; 		// chain of ohci device contexts
+	struct list_head timeout_list;
+	// struct list_head urb_list; 	// list of all pending urbs
+	// spinlock_t urb_list_lock; 	// lock to keep consistency 
+  
+	int ohci_int_load[32];		/* load of the 32 Interrupt Chains (for load balancing)*/
+	ed_t * ed_rm_list[2];		/* lists of all endpoints to be removed */
+	ed_t * ed_bulktail;		/* last endpoint of bulk list */
+///	ed_t * ed_controltail;		/* last endpoint of control list */
+ 	ed_t * ed_isotail;		/* last endpoint of iso list */
+	int intrstatus;
+	__u32 hc_control;		/* copy of the hc control reg */
+	struct usb_bus * bus;
+	struct usb_device * dev[128];
+	struct virt_root_hub rh;
+
+	/* PCI device handle, settings, ... */
+  	struct pci_dev	*ohci_dev;
+//	u8		pci_latency;
+ 	struct pci_pool	*td_cache;
+	struct pci_pool	*dev_cache;
+	struct hash_list_t	td_hash[TD_HASH_SIZE];
+	struct hash_list_t	ed_hash[ED_HASH_SIZE];
+	ed_t  * ed_start;
+	ed_t  * ed_tail;
+
+} ohci_t;
+
+#define NUM_EDS 32 ///16		/* num of preallocated endpoint descriptors */ //we reduce to 8
+/// must be 32
+
+struct ohci_device {
+	ed_t 	ed[NUM_EDS];
+	dma_addr_t dma;
+	int ed_cnt;
+	wait_queue_head_t * wait;
+};
+
+// #define ohci_to_usb(ohci)	((ohci)->usb)
+#define usb_to_ahci(usb)	((struct ohci_device *)(usb)->hcpriv)
+
+/* hcd */
+/* endpoint */
+static int ep_link(ohci_t * ohci, ed_t * edi);
+static int ep_unlink(ohci_t * ohci, ed_t * ed);
+static ed_t * ep_add_ed_ahci(struct usb_device * usb_dev, unsigned int pipe, int interval, int load, int mem_flags);
+static void ep_rm_ed(struct usb_device * usb_dev, ed_t * ed);
+/* td */
+//static void td_fill_ahci(ohci_t * ohci, unsigned int info, dma_addr_t data, int len, urb_t * urb, int index);
+static void td_submit_urb_ahci(struct urb * urb);
+/* root hub */
+static int ahci_rh_submit_urb(struct urb * urb);
+static int ahci_rh_unlink_urb(struct urb * urb);
+static int ahci_rh_init_int_timer(struct urb * urb);
+
+/*-------------------------------------------------------------------------*/
+
+#define ALLOC_FLAGS (in_interrupt () ? GFP_ATOMIC : GFP_KERNEL)
+
+#ifdef DEBUG
+#	define OHCI_MEM_FLAGS	SLAB_POISON
+#else
+#	define OHCI_MEM_FLAGS	0
+#endif
+ 
+#ifndef CONFIG_PCI
+#	error "usb-ohci currently requires PCI-based controllers"
+	/* to support non-PCI OHCIs, you need custom bus/mem/... glue */
+#endif
+
+
+/* Recover a TD/ED using its collision chain */
+/*
+static inline void *
+dma_to_ed_td (struct hash_list_t * entry, dma_addr_t dma)
+{
+	struct hash_t * scan = entry->head;
+	while (scan && scan->dma != dma)
+		scan = scan->next;
+	if (!scan)
+		BUG();
+	return scan->virt;
+}
+
+
+static inline struct ed *
+dma_to_ed (struct ohci * hc, dma_addr_t ed_dma)
+{
+	printk(" ED DMA = %08lx\n",(long unsigned)ed_dma);
+	return (struct ed *) dma_to_ed_td(&(hc->ed_hash[ED_HASH_FUNC(ed_dma)]),
+				      ed_dma);
+}
+
+
+static inline struct td *
+dma_to_td (struct ohci * hc, dma_addr_t td_dma)
+{
+	printk(" TD DMA = %08lx\n",(long unsigned)td_dma);
+	return (struct td *) dma_to_ed_td(&(hc->td_hash[TD_HASH_FUNC(td_dma)]),
+				      td_dma);
+}
+*/
+/* Add a hash entry for a TD/ED; return true on success */
+/*
+static inline int
+hash_add_ed_td(struct hash_list_t * entry, void * virt, dma_addr_t dma)
+{
+	struct hash_t * scan;
+	
+	scan = (struct hash_t *)kmalloc(sizeof(struct hash_t), ALLOC_FLAGS);
+	if (!scan)
+		return 0;
+	
+	if (!entry->tail) {
+		entry->head = entry->tail = scan;
+	} else {
+		entry->tail->next = scan;
+		entry->tail = scan;
+	}
+	
+	scan->virt = virt;
+	scan->dma = dma;
+	scan->next = NULL;
+	return 1;
+}
+
+static inline int
+hash_add_ed (struct ohci * hc, struct ed * ed)
+{
+	return hash_add_ed_td (&(hc->ed_hash[ED_HASH_FUNC(ed->dma)]),
+			ed, ed->dma);
+}
+
+static inline int
+hash_add_td (struct ohci * hc, struct td * td)
+{
+	return hash_add_ed_td (&(hc->td_hash[TD_HASH_FUNC(td->td_dma)]),
+			td, td->td_dma);
+}
+
+
+static inline void
+hash_free_ed_td (struct hash_list_t * entry, void * virt)
+{
+	struct hash_t *scan, *prev;
+	scan = prev = entry->head;
+
+	// Find and unlink hash entry
+	while (scan && scan->virt != virt) {
+		prev = scan;
+		scan = scan->next;
+	}
+	if (scan) {
+		if (scan == entry->head) {
+			if (entry->head == entry->tail)
+				entry->head = entry->tail = NULL;
+			else
+				entry->head = scan->next;
+		} else if (scan == entry->tail) {
+			entry->tail = prev;
+			prev->next = NULL;
+		} else
+			prev->next = scan->next;
+		kfree(scan);
+	}
+}
+
+
+static inline void
+hash_free_ed (struct ohci * hc, struct ed * ed)
+{
+	hash_free_ed_td (&(hc->ed_hash[ED_HASH_FUNC(ed->dma)]), ed);
+}
+
+
+static inline void
+hash_free_td (struct ohci * hc, struct td * td)
+{
+	hash_free_ed_td (&(hc->td_hash[TD_HASH_FUNC(td->td_dma)]), td);
+}
+*/
+
+static int ahci_mem_init (struct ohci *ohci)
+{
+	ohci->td_cache = pci_pool_create ("ohci_td", ohci->ohci_dev,
+		sizeof (struct td),
+		32 /* byte alignment */,
+		0 /* no page-crossing issues */,
+		GFP_KERNEL | OHCI_MEM_FLAGS);
+
+	if (!ohci->td_cache)
+		return -ENOMEM;
+	ohci->dev_cache = pci_pool_create ("ohci_dev", ohci->ohci_dev,
+		sizeof (struct ohci_device),
+		16 /* byte alignment */,
+		0 /* no page-crossing issues */,
+		GFP_KERNEL | OHCI_MEM_FLAGS);
+
+	if (!ohci->dev_cache)
+		return -ENOMEM;
+	return 0;
+}
+
+static void ahci_mem_cleanup (struct ohci *ohci)
+{
+	if (ohci->td_cache) {
+		pci_pool_destroy (ohci->td_cache);
+		ohci->td_cache = 0;
+	}
+	if (ohci->dev_cache) {
+		pci_pool_destroy (ohci->dev_cache);
+		ohci->dev_cache = 0;
+	}
+}
+
+/* TDs ... */
+static inline struct td *
+td_alloc (struct ohci *hc, int mem_flags)
+{
+	dma_addr_t	dma;
+	struct td	*td;
+
+	td = pci_pool_alloc (hc->td_cache, mem_flags, &dma);
+	if (td) {
+		memset (td, 0, sizeof (*td));
+		td->td_dma = dma;
+		/* hash it for later reverse mapping */
+/*		
+		if (!hash_add_td (hc, td)) {
+			pci_pool_free (hc->td_cache, td, dma);
+			return NULL;
+		}
+*/
+	}
+#ifdef AHCI_VERBOSE_DEBUG
+	printk("TD ALLOC [%p]\n",td);
+#endif
+	return td;
+}
+
+static inline void
+td_free (struct ohci *hc, struct td *td)
+{
+#ifdef AHCI_VERBOSE_DEBUG
+	printk("TD FREE [%p]\n",td);
+#endif
+///	hash_free_td (hc, td);
+	pci_pool_free (hc->td_cache, td, td->td_dma);
+}
+
+
+/* DEV + EDs ... only the EDs need to be consistent */
+static inline struct ohci_device *
+dev_alloc (struct ohci *hc, int mem_flags)
+{
+	dma_addr_t		dma;
+	struct ohci_device	*dev;
+	int			i, offset;
+
+	dev = pci_pool_alloc (hc->dev_cache, mem_flags, &dma);
+#ifdef AHCI_VERBOSE_DEBUG
+	printk(" Allocate Buff %p\n",dev);
+#endif
+	if (dev) {
+		memset (dev, 0, sizeof (*dev));
+		dev->dma = dma;
+		offset = ((__u8 *)&dev->ed) - ((__u8 *)dev);
+		for (i = 0; i < NUM_EDS; i++, offset += sizeof dev->ed [0]) {
+			dev->ed [i].dma = dma + offset;
+///			(struct ohci_device *) dev->ed [i].hwNextED = &(dev->ed[i+1]); //temp
+		}
+///		(struct ohci_device *) dev->ed [NUM_EDS-1].hwNextED = NULL;
+		/* add to hashtable if used */
+	}
+	return dev;
+}
+
+static inline void
+dev_free (struct ohci *hc, struct ohci_device *dev)
+{
+#ifdef AHCI_VERBOSE_DEBUG
+	printk(" Free Buff %p\n",dev);
+#endif
+	pci_pool_free (hc->dev_cache, dev, dev->dma);
+}
+
