Index: linux-2.4.23/CREDITS
diff -c linux-2.4.23/CREDITS:1.1.1.1 linux-2.4.23/CREDITS:1.2
*** linux-2.4.23/CREDITS:1.1.1.1	Sun Nov 30 18:35:37 2003
--- linux-2.4.23/CREDITS	Sun Nov 30 21:17:12 2003
***************
*** 1225,1230 ****
--- 1225,1238 ----
  S: Linux ATA Development (LAD)
  S: Concord, CA
  
+ N: Tihomir Heidelberg
+ E: 9a4gl@9a0tcp.ampr.org
+ W: http://ham2.cc.fer.hr/9a4gl
+ D: AX.25 protocol
+ D: LinSV support in AX.25
+ D: software CRC for DMASCC driver
+ S: Zagreb, Croatia
+ 
  N: Jochen Hein
  E: jochen@jochen.org
  P: 1024/4A27F015 25 72 FB E3 85 9F DE 3B  CB 0A DA DA 40 77 05 6C
Index: linux-2.4.23/Documentation/Configure.help
diff -c linux-2.4.23/Documentation/Configure.help:1.1.1.1 linux-2.4.23/Documentation/Configure.help:1.2
*** linux-2.4.23/Documentation/Configure.help:1.1.1.1	Sun Nov 30 18:36:44 2003
--- linux-2.4.23/Documentation/Configure.help	Sun Nov 30 21:17:12 2003
***************
*** 6502,6507 ****
--- 6502,6533 ----
    slaves. If you say Y here, your Linux box will act as a DAMA server.
    If unsure, say N.
  
+ AX.25 LINSV support
+ CONFIG_AX25_LINSV
+   SuperVozelj node (short SV) is developed by Matjaz Vidmar, S53MV.
+   For details look at http://www.hamradio.si/svv-hw.html.
+ 
+   SuperVozelj node use a bit different protocol in communication
+   with other SuperVozelj nodes. It us SABM packets with INFO field 
+   to pass own callsign to neighbour node. 
+ 
+   This extension extends AX.25 kernel to support such communication.
+ 
+   This option is useful only if you plan to run SuperVozelj
+   compatible node on your linux box. One such node is LinSV
+   (Linux SuperVozelj) available at http://ham2.cc.fer.hr/9a4gl.
+   
+   If unsure, say N.
+ 
+ AX.25 use MTU 1580
+ CONFIG_AX25_MTU1580
+   On high speed interfaces, default MTU of 256 decrease performance.
+   Enable this if you want to recieve and transmit packets of length
+   up to 1580 bytes. Enabling this feature may cause problems in
+   communication with those who do not support larger packets.
+ 
+   If unsure, say N.
+ 
  Amateur Radio NET/ROM support
  CONFIG_NETROM
    NET/ROM is a network layer protocol on top of AX.25 useful for
***************
*** 6618,6623 ****
--- 6644,6663 ----
    at least version 1.27 of dmascc_cfg, as older versions will not
    work with the current driver.
  
+ Software CRC check for (DMA) SCC
+ CONFIG_DMASCC_SOFTCRC
+   If your (DMA) SCC card receives corrupted frames (because of
+   problems in DMA transfer or ...), you should say Y here to enable 
+   software CRC checking. 
+ 
+   Enabling this option, dmascc driver will use more CPU, so enable this 
+   only if you have corrupted received frames.
+ 
+   This feature does not work with Z8530 chip, if you say Y and you have
+   Z8530 chip, dmascc driver will still use hardware CRC check.
+ 
+   If unsure, say N.
+ 
  Z8530 SCC driver for AX.25
  CONFIG_SCC
    These cards are used to connect your Linux box to an amateur radio
Index: linux-2.4.23/drivers/net/hamradio/Config.in
diff -c linux-2.4.23/drivers/net/hamradio/Config.in:1.1.1.1 linux-2.4.23/drivers/net/hamradio/Config.in:1.2
*** linux-2.4.23/drivers/net/hamradio/Config.in:1.1.1.1	Sun Nov 30 18:36:04 2003
--- linux-2.4.23/drivers/net/hamradio/Config.in	Sun Nov 30 21:17:13 2003
***************
*** 6,11 ****
--- 6,14 ----
      
  if [ "$CONFIG_ISA" = "y" ]; then
  dep_tristate 'High-speed (DMA) SCC driver for AX.25' CONFIG_DMASCC $CONFIG_AX25
+ if [ "$CONFIG_DMASCC" != "n" ]; then
+    bool 'Software CRC check for (DMA) SCC' CONFIG_DMASCC_SOFTCRC $CONFIG_DMASCC
+ fi
  dep_tristate 'Z8530 SCC driver' CONFIG_SCC $CONFIG_AX25
  fi
  if [ "$CONFIG_SCC" != "n" ]; then
Index: linux-2.4.23/drivers/net/hamradio/dmascc.c
diff -c linux-2.4.23/drivers/net/hamradio/dmascc.c:1.1.1.1 linux-2.4.23/drivers/net/hamradio/dmascc.c:1.2
*** linux-2.4.23/drivers/net/hamradio/dmascc.c:1.1.1.1	Sun Nov 30 18:36:04 2003
--- linux-2.4.23/drivers/net/hamradio/dmascc.c	Sun Nov 30 21:17:13 2003
***************
*** 1,10 ****
  /*
!  * $Id: dmascc.c,v 1.27 2000/06/01 14:46:23 oe1kib Exp $
   *
   * Driver for high-speed SCC boards (those with DMA support)
   * Copyright (C) 1997-2000 Klaus Kudielka
   *
   * S5SCC/DMA support by Janko Koleznik S52HI
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
--- 1,11 ----
  /*
!  * $Id: dmascc.c,v 1.2 2003/11/30 20:17:13 root Exp $
   *
   * Driver for high-speed SCC boards (those with DMA support)
   * Copyright (C) 1997-2000 Klaus Kudielka
   *
   * S5SCC/DMA support by Janko Koleznik S52HI
+  * Software CRC check by Tihomir Heidelberg 9A4GL (2003)
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
***************
*** 48,53 ****
--- 49,99 ----
  #include <net/ax25.h>
  #include "z8530.h"
  
+ #ifdef CONFIG_DMASCC_SOFTCRC
+ static const unsigned short crc_ccitt_table[] = {
+ 	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
+ 	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
+ 	0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
+ 	0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
+ 	0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
+ 	0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
+ 	0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
+ 	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
+ 	0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
+ 	0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
+ 	0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
+ 	0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
+ 	0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
+ 	0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
+ 	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
+ 	0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
+ 	0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
+ 	0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
+ 	0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
+ 	0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
+ 	0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
+ 	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
+ 	0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
+ 	0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
+ 	0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
+ 	0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
+ 	0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
+ 	0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
+ 	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
+ 	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
+ 	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
+ 	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
+ };
+ 
+ static inline int check_crc_ccitt(const unsigned char *buf, int cnt)
+ {
+ 	unsigned int crc = 0xffff;
+ 
+ 	for (; cnt > 0; cnt--)
+ 		crc = (crc >> 8) ^ crc_ccitt_table[(crc ^ *buf++) & 0xff];
+ 	return (crc & 0xffff) == 0xf0b8;
+ }
+ #endif
  
  /* Linux 2.2 and 2.3 compatibility */
  
***************
*** 605,612 ****
  
    info->next = first;
    first = info;
!   printk("dmascc: found %s (%s) at %#3x, irq %d\n", hw[type].name,
  	 chipnames[chip], card_base, irq);
    return 0;
  }
  
--- 651,668 ----
  
    info->next = first;
    first = info;
!   printk("dmascc: found %s (%s) at %#3x, irq %d", hw[type].name,
  	 chipnames[chip], card_base, irq);
+ #ifdef CONFIG_DMASCC_SOFTCRC
+   if (chip == Z8530) {
+     printk(" (Software CRC not available for Z8530, using Hardware CRC)\n");
+   } else {
+     printk(" (Software CRC)\n");
+   }
+ #else
+   printk("(Hardware CRC)\n");
+ #endif
+ 
    return 0;
  }
  
***************
*** 760,766 ****
--- 816,826 ----
      /* Select WR7' */
      write_scc(priv, R15, SHDLCE);
      /* Auto EOM reset */
+ #ifdef CONFIG_DMASCC_SOFTCRC
+     write_scc(priv, R7, AUTOEOM | CRCCBCR);
+ #else
      write_scc(priv, R7, AUTOEOM);
+ #endif
      write_scc(priv, R15, 0);
      break;
    case Z85230:
***************
*** 787,795 ****
--- 847,863 ----
      */
      if (priv->param.dma >= 0) {
        if (priv->type == TYPE_TWIN) write_scc(priv, R7, AUTOEOM | TXFIFOE);
+ #ifdef CONFIG_DMASCC_SOFTCRC
+       else write_scc(priv, R7, AUTOEOM | CRCCBCR);
+ #else
        else write_scc(priv, R7, AUTOEOM);
+ #endif
      } else {
+ #ifdef CONFIG_DMASCC_SOFTCRC
+       write_scc(priv, R7, AUTOEOM | RXFIFOH | CRCCBCR);
+ #else
        write_scc(priv, R7, AUTOEOM | RXFIFOH);
+ #endif
      }
      write_scc(priv, R15, 0);
      break;
***************
*** 1060,1066 ****
--- 1128,1139 ----
        if (priv->rx_over == 2) priv->stats.rx_length_errors++;
        else priv->stats.rx_fifo_errors++;
        priv->rx_over = 0;
+ #ifdef CONFIG_DMASCC_SOFTCRC
+     } else if ( (priv->chip == Z8530 && rc & CRC_ERR ) ||
+                 (priv->chip != Z8530 && !check_crc_ccitt( priv->rx_buf[priv->rx_head], cb+2)) ) {
+ #else
      } else if (rc & CRC_ERR) {
+ #endif
        /* Count invalid CRC only if packet length >= minimum */
        if (cb >= 15) {
  	priv->stats.rx_errors++;
Index: linux-2.4.23/include/linux/ax25.h
diff -c linux-2.4.23/include/linux/ax25.h:1.1.1.1 linux-2.4.23/include/linux/ax25.h:1.2
*** linux-2.4.23/include/linux/ax25.h:1.1.1.1	Sun Nov 30 18:35:46 2003
--- linux-2.4.23/include/linux/ax25.h	Sun Nov 30 21:17:13 2003
***************
*** 6,12 ****
--- 6,17 ----
  #ifndef	AX25_KERNEL_H
  #define	AX25_KERNEL_H
  
+ #ifdef CONFIG_AX25_MTU1580
+ #define AX25_MTU	1580
+ #else
  #define AX25_MTU	256
+ #endif
+ 
  #define AX25_MAX_DIGIS  8
  
  #define AX25_WINDOW	1
***************
*** 21,26 ****
--- 26,40 ----
  #define AX25_PACLEN	10
  #define AX25_IAMDIGI	12
  
+ #ifdef CONFIG_AX25_LINSV
+ #define AX25_LINSV_VER	13
+ #define AX25_LINSV_EXT	14
+ #define AX25_LINSV_CALL	15
+ #define AX25_LINSV_T1S  16
+ #define AX25_LINSV_T1E  17
+ #define AX25_LINSV_UNS  18
+ #endif
+ 
  #define AX25_KILL	99
  
  #define SIOCAX25GETUID		(SIOCPROTOPRIVATE+0)
Index: linux-2.4.23/include/net/ax25.h
diff -c linux-2.4.23/include/net/ax25.h:1.1.1.1 linux-2.4.23/include/net/ax25.h:1.4
*** linux-2.4.23/include/net/ax25.h:1.1.1.1	Sun Nov 30 18:35:49 2003
--- linux-2.4.23/include/net/ax25.h	Fri Jan  9 10:56:59 2004
***************
*** 8,13 ****
--- 8,14 ----
  #define _AX25_H 
  #include <linux/config.h>
  #include <linux/ax25.h>
+ #include <linux/spinlock.h>
  
  #define	AX25_T1CLAMPLO  		1
  #define	AX25_T1CLAMPHI 			(30 * HZ)
***************
*** 123,134 ****
--- 124,142 ----
  #define	AX25_DEF_CONMODE	2			/* Connected mode allowed */
  #define	AX25_DEF_WINDOW		2			/* Window=2 */
  #define	AX25_DEF_EWINDOW	32			/* Module-128 Window=32 */
+ 
  #define	AX25_DEF_T1		(10 * HZ)		/* T1=10s */
  #define	AX25_DEF_T2		(3 * HZ)		/* T2=3s  */
  #define	AX25_DEF_T3		(300 * HZ)		/* T3=300s */
  #define	AX25_DEF_N2		10			/* N2=10 */
  #define AX25_DEF_IDLE		(0 * 60 * HZ)		/* Idle=None */
+ 
+ #ifdef CONFIG_AX25_MTU1580
+ #define AX25_DEF_PACLEN         1580			/* Paclen=1580 */
+ #else
  #define AX25_DEF_PACLEN		256			/* Paclen=256 */
+ #endif
+ 
  #define	AX25_DEF_PROTOCOL	AX25_PROTO_STD_SIMPLEX	/* Standard AX.25 */
  #define AX25_DEF_DS_TIMEOUT	(3 * 60 * HZ)		/* DAMA timeout 3 minutes */
  
***************
*** 148,154 ****
  typedef struct ax25_route {
  	struct ax25_route	*next;
  	ax25_address		callsign;
! 	struct net_device		*dev;
  	ax25_digi		*digipeat;
  	char			ip_mode;
  } ax25_route;
--- 156,162 ----
  typedef struct ax25_route {
  	struct ax25_route	*next;
  	ax25_address		callsign;
! 	struct net_device	*dev;
  	ax25_digi		*digipeat;
  	char			ip_mode;
  } ax25_route;
***************
*** 192,201 ****
--- 200,221 ----
  	unsigned char		window;
  	struct timer_list	timer;
  	struct sock		*sk;		/* Backlink to socket */
+ 	atomic_t		refcnt;
+ 	unsigned long		removed;
+ #if defined(CONFIG_AX25_LINSV)
+ 	unsigned char 		linsv_call[7];
+ 	unsigned char		linsv_ver;
+ 	unsigned char		linsv_ext;
+ 	long			linsv_t1set;
+ 	long			linsv_t1exp;
+ #endif
  } ax25_cb;
  
+ #
+ 
  /* af_ax25.c */
  extern ax25_cb *volatile ax25_list;
+ extern rwlock_t ax25_list_lock;
  extern void ax25_free_cb(ax25_cb *);
  extern void ax25_insert_socket(ax25_cb *);
  struct sock *ax25_find_listener(ax25_address *, int, struct net_device *, int);
***************
*** 209,217 ****
  extern int  ax25_create(struct socket *, int);
  extern struct sock *ax25_make_new(struct sock *, struct ax25_dev *);
  
  /* ax25_addr.c */
  extern ax25_address null_ax25_address;
! extern char *ax2asc(ax25_address *);
  extern ax25_address *asc2ax(char *);
  extern int  ax25cmp(ax25_address *, ax25_address *);
  extern int  ax25digicmp(ax25_digi *, ax25_digi *);
--- 229,248 ----
  extern int  ax25_create(struct socket *, int);
  extern struct sock *ax25_make_new(struct sock *, struct ax25_dev *);
  
+ #define ax25_cb_hold(__ax25)	atomic_inc(&((__ax25)->refcnt))
+         
+ static __inline__ void ax25_cb_put(ax25_cb *ax25)
+ {
+ 	if (ax25) {
+ 		if (atomic_dec_and_test(&ax25->refcnt)) {
+ 			ax25_free_cb(ax25);
+ 		}
+ 	}
+ }                                                                                
+ 
  /* ax25_addr.c */
  extern ax25_address null_ax25_address;
! extern char *ax2asc(char *, ax25_address *);
  extern ax25_address *asc2ax(char *);
  extern int  ax25cmp(ax25_address *, ax25_address *);
  extern int  ax25digicmp(ax25_digi *, ax25_digi *);
***************
*** 222,227 ****
--- 253,259 ----
  
  /* ax25_dev.c */
  extern ax25_dev *ax25_dev_list;
+ extern rwlock_t ax25_dev_lock;
  extern ax25_dev *ax25_dev_ax25dev(struct net_device *);
  extern ax25_dev *ax25_addr_ax25dev(ax25_address *);
  extern void ax25_dev_device_up(struct net_device *);
***************
*** 284,290 ****
  extern int  ax25_rt_ioctl(unsigned int, void *);
  extern int  ax25_rt_get_info(char *, char **, off_t, int);
  extern int  ax25_rt_autobind(ax25_cb *, ax25_address *);
! extern ax25_route *ax25_rt_find_route(ax25_address *, struct net_device *);
  extern struct sk_buff *ax25_rt_build_path(struct sk_buff *, ax25_address *, ax25_address *, ax25_digi *);
  extern void ax25_rt_free(void);
  
--- 316,322 ----
  extern int  ax25_rt_ioctl(unsigned int, void *);
  extern int  ax25_rt_get_info(char *, char **, off_t, int);
  extern int  ax25_rt_autobind(ax25_cb *, ax25_address *);
! extern ax25_route *ax25_rt_find_route(ax25_route *, ax25_address *, struct net_device *);
  extern struct sk_buff *ax25_rt_build_path(struct sk_buff *, ax25_address *, ax25_address *, ax25_digi *);
  extern void ax25_rt_free(void);
  
***************
*** 315,321 ****
  extern void ax25_return_dm(struct net_device *, ax25_address *, ax25_address *, ax25_digi *);
  extern void ax25_calculate_t1(ax25_cb *);
  extern void ax25_calculate_rtt(ax25_cb *);
! extern void ax25_disconnect(ax25_cb *, int);
  
  /* ax25_timer.c */
  extern void ax25_start_heartbeat(ax25_cb *);
--- 347,353 ----
  extern void ax25_return_dm(struct net_device *, ax25_address *, ax25_address *, ax25_digi *);
  extern void ax25_calculate_t1(ax25_cb *);
  extern void ax25_calculate_rtt(ax25_cb *);
! extern void ax25_disconnect(ax25_cb *, int, int);
  
  /* ax25_timer.c */
  extern void ax25_start_heartbeat(ax25_cb *);
Index: linux-2.4.23/net/ax25/Config.in
diff -c linux-2.4.23/net/ax25/Config.in:1.1.1.1 linux-2.4.23/net/ax25/Config.in:1.2
*** linux-2.4.23/net/ax25/Config.in:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/Config.in	Sun Nov 30 21:17:13 2003
***************
*** 17,22 ****
--- 17,24 ----
        if [ "$CONFIG_AX25" != "n" ]; then
  	 bool '    AX.25 DAMA Slave support' CONFIG_AX25_DAMA_SLAVE
  #	 bool '    AX.25 DAMA Master support' CONFIG_AX25_DAMA_MASTER
+          bool '    AX.25 LinSV support' CONFIG_AX25_LINSV
+          bool '    AX.25 use MTU 1580' CONFIG_AX25_MTU1580
  	 dep_tristate '    Amateur Radio NET/ROM protocol' CONFIG_NETROM $CONFIG_AX25
  	 dep_tristate '    Amateur Radio X.25 PLP (Rose)' CONFIG_ROSE $CONFIG_AX25
        fi
Index: linux-2.4.23/net/ax25/Makefile
diff -c linux-2.4.23/net/ax25/Makefile:1.1.1.1 linux-2.4.23/net/ax25/Makefile:1.2
*** linux-2.4.23/net/ax25/Makefile:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/Makefile	Sun Nov 30 21:17:13 2003
***************
*** 7,13 ****
  #
  # Note 2! The CFLAGS definition is now in the main makefile...
  
- 
  O_TARGET := ax25.o
  
  export-objs := af_ax25.o
--- 7,12 ----
Index: linux-2.4.23/net/ax25/af_ax25.c
diff -c linux-2.4.23/net/ax25/af_ax25.c:1.1.1.1 linux-2.4.23/net/ax25/af_ax25.c:1.4
*** linux-2.4.23/net/ax25/af_ax25.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/af_ax25.c	Fri Jan  9 10:56:59 2004
***************
*** 103,108 ****
--- 103,115 ----
   *			Arnaldo C. Melo		s/suser/capable(CAP_NET_ADMIN)/, some more cleanups
   *			Michal Ostrowski	Module initialization cleanup.
   *			Jeroen(PE1RXQ)		Use sock_orphan() on release.
+  *			Tihomir(9A4GL)		Spinlock/rwlock, ax25cb protected with refcnt,
+  *						socket locking, sock_hold/put added, unaccapted
+  *						connections fix, free write queue on destroy, 
+  *						linsv support added, mtu 1580 added, 
+  *						listen_register/release fix, incomming 
+  *						AX25 parameters fix, some protocol fixes,
+  *						sleep in ax25_connect fix, etc...
   */
  
  #include <linux/config.h>
***************
*** 135,147 ****
  #include <linux/netfilter.h>
  #include <linux/sysctl.h>
  #include <linux/init.h>
  #include <net/ip.h>
  #include <net/arp.h>
  
- 
- 
  ax25_cb *volatile ax25_list;
! 
  static struct proto_ops ax25_proto_ops;
  
  /*
--- 142,153 ----
  #include <linux/netfilter.h>
  #include <linux/sysctl.h>
  #include <linux/init.h>
+ #include <linux/spinlock.h>
  #include <net/ip.h>
  #include <net/arp.h>
  
  ax25_cb *volatile ax25_list;
! rwlock_t ax25_list_lock = RW_LOCK_UNLOCKED;
  static struct proto_ops ax25_proto_ops;
  
  /*
***************
*** 150,168 ****
   */
  void ax25_free_cb(ax25_cb *ax25)
  {
  	if (ax25->digipeat != NULL) {
  		kfree(ax25->digipeat);
  		ax25->digipeat = NULL;
  	}
! 
  	kfree(ax25);
  
  	MOD_DEC_USE_COUNT;
  }
  
  static void ax25_free_sock(struct sock *sk)
  {
! 	ax25_free_cb(sk->protinfo.ax25);
  }
  
  /*
--- 156,180 ----
   */
  void ax25_free_cb(ax25_cb *ax25)
  {
+ 	struct sock *sk = ax25->sk;
+ 	
  	if (ax25->digipeat != NULL) {
  		kfree(ax25->digipeat);
  		ax25->digipeat = NULL;
  	}
! 	
  	kfree(ax25);
  
+ 	if (sk) {
+ 		sk->protinfo.ax25 = NULL;
+ 	}
+ 		
  	MOD_DEC_USE_COUNT;
  }
  
  static void ax25_free_sock(struct sock *sk)
  {
! 	ax25_cb_put(sk->protinfo.ax25);
  }
  
  /*
***************
*** 171,197 ****
  static void ax25_remove_socket(ax25_cb *ax25)
  {
  	ax25_cb *s;
- 	unsigned long flags;
  
! 	save_flags(flags); cli();
  
  	if ((s = ax25_list) == ax25) {
! 		ax25_list = s->next;
! 		restore_flags(flags);
  		return;
  	}
  
  	while (s != NULL && s->next != NULL) {
  		if (s->next == ax25) {
! 			s->next = ax25->next;
! 			restore_flags(flags);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	restore_flags(flags);
  }
  
  /*
--- 183,212 ----
  static void ax25_remove_socket(ax25_cb *ax25)
  {
  	ax25_cb *s;
  
! 	write_lock_bh(&ax25_list_lock);
  
  	if ((s = ax25_list) == ax25) {
! 		ax25_list     = s->next;
! 		ax25->next    = NULL;
! 		ax25->removed = 1;
! 		write_unlock_bh(&ax25_list_lock);
  		return;
  	}
  
  	while (s != NULL && s->next != NULL) {
  		if (s->next == ax25) {
! 			s->next       = ax25->next;
! 			ax25->next    = NULL;
! 			ax25->removed = 1;
! 			write_unlock_bh(&ax25_list_lock);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	write_unlock_bh(&ax25_list_lock);
  }
  
  /*
***************
*** 205,216 ****
  	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
  		return;
  
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->ax25_dev == ax25_dev) {
  			s->ax25_dev = NULL;
! 			ax25_disconnect(s, ENETUNREACH);
  		}
  	}
  }
  
  /*
--- 220,235 ----
  	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
  		return;
  
+ 	write_lock_bh(&ax25_list_lock);
+ 	
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->ax25_dev == ax25_dev) {
  			s->ax25_dev = NULL;
! 			ax25_disconnect(s, ENETUNREACH, 1);
  		}
  	}
+ 	
+ 	write_unlock_bh(&ax25_list_lock);
  }
  
  /*
***************
*** 245,259 ****
   */
  void ax25_insert_socket(ax25_cb *ax25)
  {
! 	unsigned long flags;
! 
! 	save_flags(flags);
! 	cli();
  
  	ax25->next = ax25_list;
  	ax25_list  = ax25;
  
! 	restore_flags(flags);
  }
  
  /*
--- 264,275 ----
   */
  void ax25_insert_socket(ax25_cb *ax25)
  {
! 	write_lock_bh(&ax25_list_lock);
  
  	ax25->next = ax25_list;
  	ax25_list  = ax25;
  
! 	write_unlock_bh(&ax25_list_lock);
  }
  
  /*
***************
*** 262,286 ****
   */
  struct sock *ax25_find_listener(ax25_address *addr, int digi, struct net_device *dev, int type)
  {
- 	unsigned long flags;
  	ax25_cb *s;
  
! 	save_flags(flags);
! 	cli();
! 
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if ((s->iamdigi && !digi) || (!s->iamdigi && digi))
  			continue;
  		if (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 && s->sk->type == type && s->sk->state == TCP_LISTEN) {
  			/* If device is null we match any device */
  			if (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {
! 				restore_flags(flags);
! 				return s->sk;
  			}
  		}
  	}
  
- 	restore_flags(flags);
  	return NULL;
  }
  
--- 278,304 ----
   */
  struct sock *ax25_find_listener(ax25_address *addr, int digi, struct net_device *dev, int type)
  {
  	ax25_cb *s;
  
! 	read_lock_bh(&ax25_list_lock);
! 	
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if ((s->iamdigi && !digi) || (!s->iamdigi && digi))
  			continue;
  		if (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 && s->sk->type == type && s->sk->state == TCP_LISTEN) {
  			/* If device is null we match any device */
  			if (s->ax25_dev == NULL || s->ax25_dev->dev == dev) {
! 				struct sock *sk;
! 				sk = s->sk;
! 				sock_hold(sk);
! 				read_unlock_bh(&ax25_list_lock);
! 				return sk;
  			}
  		}
  	}
+ 	
+ 	read_unlock_bh(&ax25_list_lock);
  
  	return NULL;
  }
  
***************
*** 290,309 ****
  struct sock *ax25_find_socket(ax25_address *my_addr, ax25_address *dest_addr, int type)
  {
  	ax25_cb *s;
- 	unsigned long flags;
- 
- 	save_flags(flags);
- 	cli();
  
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && ax25cmp(&s->source_addr, my_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->sk->type == type) {
! 			restore_flags(flags);
! 			return s->sk;
  		}
  	}
  
! 	restore_flags(flags);
! 
  	return NULL;
  }
  
--- 308,328 ----
  struct sock *ax25_find_socket(ax25_address *my_addr, ax25_address *dest_addr, int type)
  {
  	ax25_cb *s;
  
+ 	read_lock_bh(&ax25_list_lock);
+ 	
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && ax25cmp(&s->source_addr, my_addr) == 0 && ax25cmp(&s->dest_addr, dest_addr) == 0 && s->sk->type == type) {
! 			struct sock *sk;
! 			sk = s->sk;
! 			sock_hold(sk);
! 			read_unlock_bh(&ax25_list_lock);
! 			return sk;
  		}
  	}
  
! 	read_unlock_bh(&ax25_list_lock);
! 	
  	return NULL;
  }
  
***************
*** 314,324 ****
  ax25_cb *ax25_find_cb(ax25_address *src_addr, ax25_address *dest_addr, ax25_digi *digi, struct net_device *dev)
  {
  	ax25_cb *s;
- 	unsigned long flags;
- 
- 	save_flags(flags);
- 	cli();
  
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && s->sk->type != SOCK_SEQPACKET)
  			continue;
--- 333,341 ----
  ax25_cb *ax25_find_cb(ax25_address *src_addr, ax25_address *dest_addr, ax25_digi *digi, struct net_device *dev)
  {
  	ax25_cb *s;
  
+ 	read_lock_bh(&ax25_list_lock);
+ 	
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && s->sk->type != SOCK_SEQPACKET)
  			continue;
***************
*** 334,345 ****
  				if (s->digipeat != NULL && s->digipeat->ndigi != 0)
  					continue;
  			}
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  
  	return NULL;
  }
--- 351,363 ----
  				if (s->digipeat != NULL && s->digipeat->ndigi != 0)
  					continue;
  			}
! 			ax25_cb_hold(s);
! 			read_unlock_bh(&ax25_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&ax25_list_lock);
  
  	return NULL;
  }
***************
*** 349,369 ****
   */
  struct sock *ax25_addr_match(ax25_address *addr)
  {
- 	unsigned long flags;
  	ax25_cb *s;
  
! 	save_flags(flags);
! 	cli();
! 
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 && s->sk->type == SOCK_RAW) {
! 			restore_flags(flags);
! 			return s->sk;
  		}
  	}
  
! 	restore_flags(flags);
! 
  	return NULL;
  }
  
--- 367,388 ----
   */
  struct sock *ax25_addr_match(ax25_address *addr)
  {
  	ax25_cb *s;
  
! 	read_lock_bh(&ax25_list_lock);
! 	
  	for (s = ax25_list; s != NULL; s = s->next) {
  		if (s->sk != NULL && ax25cmp(&s->source_addr, addr) == 0 && s->sk->type == SOCK_RAW) {
! 			struct sock *sk;
! 			sk = s->sk;
! 			sock_hold(sk);
! 			read_unlock_bh(&ax25_list_lock);
! 			return sk;
  		}
  	}
  
! 	read_unlock_bh(&ax25_list_lock);
! 		
  	return NULL;
  }
  
***************
*** 375,385 ****
  		if (sk->type == SOCK_RAW &&
  		    sk->protocol == proto &&
  		    atomic_read(&sk->rmem_alloc) <= sk->rcvbuf) {
! 			if ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL)
  				return;
  
! 			if (sock_queue_rcv_skb(sk, copy) != 0)
  				kfree_skb(copy);
  		}
  
  		sk = sk->next;
--- 394,406 ----
  		if (sk->type == SOCK_RAW &&
  		    sk->protocol == proto &&
  		    atomic_read(&sk->rmem_alloc) <= sk->rcvbuf) {
! 			if ((copy = skb_clone(skb, GFP_ATOMIC)) == NULL) {
  				return;
+ 			}
  
! 			if (sock_queue_rcv_skb(sk, copy) != 0) {
  				kfree_skb(copy);
+ 			}
  		}
  
  		sk = sk->next;
***************
*** 396,416 ****
   */
  static void ax25_destroy_timer(unsigned long data)
  {
! 	ax25_destroy_socket((ax25_cb *)data);
  }
  
  /*
!  *	This is called from user mode and the timers. Thus it protects itself against
!  *	interrupt users but doesn't worry about being called during work.
   *	Once it is removed from the queue no interrupt or bottom half will
   *	touch it and we are (fairly 8-) ) safe.
   */
  void ax25_destroy_socket(ax25_cb *ax25)	/* Not static as it's used by the timer */
  {
  	struct sk_buff *skb;
- 	unsigned long flags;
- 
- 	save_flags(flags); cli();
  
  	ax25_stop_heartbeat(ax25);
  	ax25_stop_t1timer(ax25);
--- 417,448 ----
   */
  static void ax25_destroy_timer(unsigned long data)
  {
! 	struct sock *sk;
! 	ax25_cb *ax25 = (ax25_cb *)data;
! 
! 	ax25_cb_put(ax25);
! 
! 	sk = ax25->sk;
! 
! 	if (sk) {
! 		sock_hold(sk);
! 		bh_lock_sock(sk);
! 		ax25_destroy_socket(ax25);
! 		bh_unlock_sock(sk);
! 		sock_put(sk);
! 	} else {
! 		ax25_destroy_socket(ax25);
! 	}
  }
  
  /*
!  *	This is called from user mode and the timers.
   *	Once it is removed from the queue no interrupt or bottom half will
   *	touch it and we are (fairly 8-) ) safe.
   */
  void ax25_destroy_socket(ax25_cb *ax25)	/* Not static as it's used by the timer */
  {
  	struct sk_buff *skb;
  
  	ax25_stop_heartbeat(ax25);
  	ax25_stop_t1timer(ax25);
***************
*** 418,456 ****
  	ax25_stop_t3timer(ax25);
  	ax25_stop_idletimer(ax25);
  
! 	ax25_remove_socket(ax25);
  	ax25_clear_queues(ax25);	/* Flush the queues */
  
  	if (ax25->sk != NULL) {
  		while ((skb = skb_dequeue(&ax25->sk->receive_queue)) != NULL) {
  			if (skb->sk != ax25->sk) {			/* A pending connection */
! 				skb->sk->dead = 1;	/* Queue the unaccepted socket for death */
! 				ax25_start_heartbeat(skb->sk->protinfo.ax25);
! 				skb->sk->protinfo.ax25->state = AX25_STATE_0;
  			}
- 
  			kfree_skb(skb);
  		}
  	}
! 
! 	if (ax25->sk != NULL) {
! 		if (atomic_read(&ax25->sk->wmem_alloc) != 0 ||
! 		    atomic_read(&ax25->sk->rmem_alloc) != 0) {
! 			/* Defer: outstanding buffers */
! 			init_timer(&ax25->timer);
! 			ax25->timer.expires  = jiffies + 10 * HZ;
! 			ax25->timer.function = ax25_destroy_timer;
! 			ax25->timer.data     = (unsigned long)ax25;
! 			add_timer(&ax25->timer);
  		} else {
! 			sk_free(ax25->sk);
  		}
  	} else {
! 		ax25_free_cb(ax25);
  	}
! 
! 	restore_flags(flags);
! }
  
  /*
   * dl1bke 960311: set parameters for existing AX.25 connections,
--- 450,530 ----
  	ax25_stop_t3timer(ax25);
  	ax25_stop_idletimer(ax25);
  
! 	if (!ax25->removed) {
! 		ax25_remove_socket(ax25);
! 	}
  	ax25_clear_queues(ax25);	/* Flush the queues */
  
  	if (ax25->sk != NULL) {
+ 	
+ 		if ( ax25->sk->state == TCP_LISTEN ) {
+ 			ax25_listen_release(&ax25->source_addr, (ax25->ax25_dev) ? ax25->ax25_dev->dev : NULL);
+ 		}
+ 
+ 		ax25->sk->state = TCP_CLOSE;
+ 		if ( ax25->sk->socket ) {
+ 			if ( ax25->sk->socket->state != SS_UNCONNECTED ) {
+ 				ax25->sk->socket->state = SS_DISCONNECTING;
+ 			}
+ 			
+ 		}
+ 		ax25->sk->state_change(ax25->sk);	
+ 		
+ 		/* empty socket receive queue */
+ 		
  		while ((skb = skb_dequeue(&ax25->sk->receive_queue)) != NULL) {
  			if (skb->sk != ax25->sk) {			/* A pending connection */
! 				ax25->sk->ack_backlog--;
! 				if (skb->sk->protinfo.ax25->state == AX25_STATE_0) {
! 					skb->sk->state = TCP_CLOSE;
! 					ax25_start_heartbeat(skb->sk->protinfo.ax25);
! 				} else {
! 					ax25_clear_queues(skb->sk->protinfo.ax25);
! 					skb->sk->protinfo.ax25->n2count = 0;
! 					switch (skb->sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {
! 						case AX25_PROTO_STD_SIMPLEX:
! 						case AX25_PROTO_STD_DUPLEX:
! 							ax25_send_control(skb->sk->protinfo.ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 							ax25_stop_t2timer(skb->sk->protinfo.ax25);
! 							ax25_stop_t3timer(skb->sk->protinfo.ax25);
! 							ax25_stop_idletimer(skb->sk->protinfo.ax25);
! 							break;
! 						case AX25_PROTO_DAMA_SLAVE:
! 							ax25_stop_t3timer(skb->sk->protinfo.ax25);
! 							ax25_stop_idletimer(skb->sk->protinfo.ax25);
! 							break;
! 					}
! 					ax25_calculate_t1(skb->sk->protinfo.ax25);
! 					ax25_start_t1timer(skb->sk->protinfo.ax25);
! 					skb->sk->protinfo.ax25->state = AX25_STATE_2;
! 					skb->sk->state                = TCP_CLOSE;
! 					skb->sk->destroy = 1;
! 				}
! 				sock_orphan(skb->sk);
  			}
  			kfree_skb(skb);
  		}
  	}
! 	
! 	if (ax25->sk != NULL) {	
! 		if(atomic_read(&ax25->sk->wmem_alloc) == 0 &&
! 		   atomic_read(&ax25->sk->rmem_alloc) == 0) {
! 			sock_put(ax25->sk);
  		} else {
! 			/*
! 			 *	Someone is using our buffers still.. defer
! 			 */
! 			init_timer(&ax25->sk->timer);
! 			ax25->sk->timer.expires = jiffies + SOCK_DESTROY_TIME;
! 			ax25->sk->timer.function = ax25_destroy_timer;
! 			ax25->sk->timer.data = (unsigned long)ax25;
! 			add_timer(&ax25->sk->timer);
! 			ax25_cb_hold(ax25);
  		}
  	} else {
! 		ax25_cb_put(ax25);
  	}
! }	
  
  /*
   * dl1bke 960311: set parameters for existing AX.25 connections,
***************
*** 488,550 ****
  			if (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)
  				ax25_dama_off(ax25);
  #endif
! 			ax25_disconnect(ax25, ENETRESET);
  			break;
  
  	  	case AX25_WINDOW:
  	  		if (ax25->modulus == AX25_MODULUS) {
! 	  			if (ax25_ctl.arg < 1 || ax25_ctl.arg > 7)
  	  				return -EINVAL;
  	  		} else {
! 	  			if (ax25_ctl.arg < 1 || ax25_ctl.arg > 63)
  	  				return -EINVAL;
  	  		}
  	  		ax25->window = ax25_ctl.arg;
  	  		break;
  
  	  	case AX25_T1:
!   			if (ax25_ctl.arg < 1)
    				return -EINVAL;
    			ax25->rtt = (ax25_ctl.arg * HZ) / 2;
    			ax25->t1  = ax25_ctl.arg * HZ;
    			break;
  
  	  	case AX25_T2:
! 	  		if (ax25_ctl.arg < 1)
  	  			return -EINVAL;
  	  		ax25->t2 = ax25_ctl.arg * HZ;
  	  		break;
  
  	  	case AX25_N2:
! 	  		if (ax25_ctl.arg < 1 || ax25_ctl.arg > 31)
  	  			return -EINVAL;
  	  		ax25->n2count = 0;
  	  		ax25->n2 = ax25_ctl.arg;
  	  		break;
  
  	  	case AX25_T3:
! 	  		if (ax25_ctl.arg < 0)
  	  			return -EINVAL;
  	  		ax25->t3 = ax25_ctl.arg * HZ;
  	  		break;
  
  	  	case AX25_IDLE:
! 	  		if (ax25_ctl.arg < 0)
  	  			return -EINVAL;
  	  		ax25->idle = ax25_ctl.arg * 60 * HZ;
  	  		break;
  
  	  	case AX25_PACLEN:
! 	  		if (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535)
  	  			return -EINVAL;
  	  		ax25->paclen = ax25_ctl.arg;
  	  		break;
  
  	  	default:
  	  		return -EINVAL;
! 	  }
  
! 	  return 0;
  }
  
  /*
--- 562,642 ----
  			if (ax25_dev->dama.slave && ax25->ax25_dev->values[AX25_VALUES_PROTOCOL] == AX25_PROTO_DAMA_SLAVE)
  				ax25_dama_off(ax25);
  #endif
! 			ax25_disconnect(ax25, ENETRESET, 1);
  			break;
  
  	  	case AX25_WINDOW:
  	  		if (ax25->modulus == AX25_MODULUS) {
! 	  			if (ax25_ctl.arg < 1 || ax25_ctl.arg > 7) {
! 	  				ax25_cb_put(ax25);
  	  				return -EINVAL;
+ 	  			}
  	  		} else {
! 	  			if (ax25_ctl.arg < 1 || ax25_ctl.arg > 63) {
! 	  				ax25_cb_put(ax25);
  	  				return -EINVAL;
+ 	  			}
  	  		}
  	  		ax25->window = ax25_ctl.arg;
  	  		break;
  
  	  	case AX25_T1:
!   			if (ax25_ctl.arg < 1) {
!   				ax25_cb_put(ax25);
    				return -EINVAL;
+   			}
    			ax25->rtt = (ax25_ctl.arg * HZ) / 2;
    			ax25->t1  = ax25_ctl.arg * HZ;
    			break;
  
  	  	case AX25_T2:
! 	  		if (ax25_ctl.arg < 1) {
! 	  			ax25_cb_put(ax25);
  	  			return -EINVAL;
+ 	  		}
  	  		ax25->t2 = ax25_ctl.arg * HZ;
  	  		break;
  
  	  	case AX25_N2:
! 	  		if (ax25_ctl.arg < 1 || ax25_ctl.arg > 31) {
! 	  			ax25_cb_put(ax25);
  	  			return -EINVAL;
+ 	  		}
  	  		ax25->n2count = 0;
  	  		ax25->n2 = ax25_ctl.arg;
  	  		break;
  
  	  	case AX25_T3:
! 	  		if (ax25_ctl.arg < 0) {
! 	  			ax25_cb_put(ax25);
  	  			return -EINVAL;
+ 	  		}
  	  		ax25->t3 = ax25_ctl.arg * HZ;
  	  		break;
  
  	  	case AX25_IDLE:
! 	  		if (ax25_ctl.arg < 0) {
! 	  			ax25_cb_put(ax25);
  	  			return -EINVAL;
+ 	  		}
  	  		ax25->idle = ax25_ctl.arg * 60 * HZ;
  	  		break;
  
  	  	case AX25_PACLEN:
! 	  		if (ax25_ctl.arg < 16 || ax25_ctl.arg > 65535) {
! 	  			ax25_cb_put(ax25);
  	  			return -EINVAL;
+ 	  		}
  	  		ax25->paclen = ax25_ctl.arg;
  	  		break;
  
  	  	default:
+ 	  		ax25_cb_put(ax25);
  	  		return -EINVAL;
! 	}
  
! 	ax25_cb_put(ax25);
! 	return 0;
  }
  
  /*
***************
*** 590,595 ****
--- 682,696 ----
  			ax25->window  = AX25_DEF_WINDOW;
  		}
  	}
+ 
+ #ifdef CONFIG_AX25_LINSV
+ 	ax25->linsv_call[0] = 0;
+ 	ax25->linsv_ver     = 2;
+ 	ax25->linsv_ext     = 0;
+ 	ax25->linsv_t1set   = 0;
+ 	ax25->linsv_t1exp   = 0;
+ #endif		                		
+ 
  }
  
  /*
***************
*** 618,626 ****
  	init_timer(&ax25->idletimer);
  
  	ax25_fillin_cb(ax25, NULL);
! 
  	ax25->state = AX25_STATE_0;
! 
  	return ax25;
  }
  
--- 719,729 ----
  	init_timer(&ax25->idletimer);
  
  	ax25_fillin_cb(ax25, NULL);
! 	atomic_set(&ax25->refcnt, 1);
! 	ax25->removed = 0;
! 	
  	ax25->state = AX25_STATE_0;
! 	
  	return ax25;
  }
  
***************
*** 639,736 ****
  	if (level != SOL_AX25)
  		return -ENOPROTOOPT;
  
! 	if (optlen < sizeof(int))
  		return -EINVAL;
  
! 	if (get_user(opt, (int *)optval))
  		return -EFAULT;
  
  	switch (optname) {
  		case AX25_WINDOW:
  			if (sk->protinfo.ax25->modulus == AX25_MODULUS) {
! 				if (opt < 1 || opt > 7)
  					return -EINVAL;
  			} else {
! 				if (opt < 1 || opt > 63)
  					return -EINVAL;
  			}
  			sk->protinfo.ax25->window = opt;
  			return 0;
  
  		case AX25_T1:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.ax25->rtt = (opt * HZ) / 2;
  			sk->protinfo.ax25->t1  = opt * HZ;
  			return 0;
  
  		case AX25_T2:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.ax25->t2 = opt * HZ;
  			return 0;
  
  		case AX25_N2:
! 			if (opt < 1 || opt > 31)
  				return -EINVAL;
  			sk->protinfo.ax25->n2 = opt;
  			return 0;
  
  		case AX25_T3:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.ax25->t3 = opt * HZ;
  			return 0;
  
  		case AX25_IDLE:
! 			if (opt < 0)
  				return -EINVAL;
  			sk->protinfo.ax25->idle = opt * 60 * HZ;
  			return 0;
  
  		case AX25_BACKOFF:
! 			if (opt < 0 || opt > 2)
  				return -EINVAL;
  			sk->protinfo.ax25->backoff = opt;
  			return 0;
  
  		case AX25_EXTSEQ:
  			sk->protinfo.ax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;
  			return 0;
  
  		case AX25_PIDINCL:
  			sk->protinfo.ax25->pidincl = opt ? 1 : 0;
  			return 0;
  
  		case AX25_IAMDIGI:
  			sk->protinfo.ax25->iamdigi = opt ? 1 : 0;
  			return 0;
  
  		case AX25_PACLEN:
! 			if (opt < 16 || opt > 65535)
  				return -EINVAL;
  			sk->protinfo.ax25->paclen = opt;
  			return 0;
  
  		case SO_BINDTODEVICE:
  			if (optlen > IFNAMSIZ) optlen=IFNAMSIZ;
! 			if (copy_from_user(devname, optval, optlen))
  				return -EFAULT;
  
  			dev = dev_get_by_name(devname);
! 			if (dev == NULL) return -ENODEV;
! 
  			if (sk->type == SOCK_SEQPACKET && 
! 			   (sock->state != SS_UNCONNECTED || sk->state == TCP_LISTEN))
  				return -EADDRNOTAVAIL;
  		
  			sk->protinfo.ax25->ax25_dev = ax25_dev_ax25dev(dev);
  			ax25_fillin_cb(sk->protinfo.ax25, sk->protinfo.ax25->ax25_dev);
  			return 0;
  
  		default:
  			return -ENOPROTOOPT;
  	}
  }
  
  static int ax25_getsockopt(struct socket *sock, int level, int optname, char *optval, int *optlen)
--- 742,926 ----
  	if (level != SOL_AX25)
  		return -ENOPROTOOPT;
  
! 	lock_sock(sk);
! 
! #ifdef CONFIG_AX25_LINSV
! 	
! 	switch (optname) {
! 		case AX25_LINSV_VER:
! 			if (get_user(opt, (int *)optval)) {
! 				release_sock(sk);
! 				return -EFAULT;
! 	               	}
! 			if (opt < 1 || opt > 2 ) {
! 				release_sock(sk);
! 				return -EINVAL;
! 			}
! 			sk->protinfo.ax25->linsv_ver = opt;
! 			release_sock(sk);
! 			return 0;
! 
! 		case AX25_LINSV_EXT:
! 			if (get_user(opt, (int *)optval)) {
! 				release_sock(sk);
! 				return -EFAULT;
! 	               	}
! 			if (opt < 1 || opt > 2 ) {
! 				release_sock(sk);
! 				return -EINVAL;
! 			}
! 			sk->protinfo.ax25->linsv_ext = opt;
! 			release_sock(sk);
! 			return 0;
! 
! 		case AX25_LINSV_CALL:
! 			copy_from_user(sk->protinfo.ax25->linsv_call, optval, 6);
! 			release_sock(sk);
! 			return 0;
! 
! 		case AX25_LINSV_T1S:	/* this options can be only read */
! 		case AX25_LINSV_T1E:
! 		case AX25_LINSV_UNS:
! 			release_sock(sk);
! 			return -EFAULT;
! 	}
! #endif
! 
! 	if (optlen < sizeof(int)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (get_user(opt, (int *)optval)) {
! 		release_sock(sk);
  		return -EFAULT;
+ 	}
  
  	switch (optname) {
  		case AX25_WINDOW:
  			if (sk->protinfo.ax25->modulus == AX25_MODULUS) {
! 				if (opt < 1 || opt > 7) {
! 					release_sock(sk);
  					return -EINVAL;
+ 				}
  			} else {
! 				if (opt < 1 || opt > 63) {
! 					release_sock(sk);
  					return -EINVAL;
+ 				}
  			}
  			sk->protinfo.ax25->window = opt;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_T1:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->rtt = (opt * HZ) / 2;
  			sk->protinfo.ax25->t1  = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_T2:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->t2 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_N2:
! 			if (opt < 1 || opt > 31) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->n2 = opt;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_T3:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->t3 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_IDLE:
! 			if (opt < 0) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->idle = opt * 60 * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_BACKOFF:
! 			if (opt < 0 || opt > 2) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->backoff = opt;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_EXTSEQ:
  			sk->protinfo.ax25->modulus = opt ? AX25_EMODULUS : AX25_MODULUS;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_PIDINCL:
  			sk->protinfo.ax25->pidincl = opt ? 1 : 0;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_IAMDIGI:
  			sk->protinfo.ax25->iamdigi = opt ? 1 : 0;
+ 			release_sock(sk);
  			return 0;
  
  		case AX25_PACLEN:
! 			if (opt < 16 || opt > 65535) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.ax25->paclen = opt;
+ 			release_sock(sk);
  			return 0;
  
  		case SO_BINDTODEVICE:
  			if (optlen > IFNAMSIZ) optlen=IFNAMSIZ;
! 			if (copy_from_user(devname, optval, optlen)) {
! 				release_sock(sk);
  				return -EFAULT;
+ 			}
  
  			dev = dev_get_by_name(devname);
! 			if (dev == NULL) {
! 				release_sock(sk);
! 				return -ENODEV;
! 			}
! 			
  			if (sk->type == SOCK_SEQPACKET && 
! 			   (sock->state != SS_UNCONNECTED || sk->state == TCP_LISTEN)) {
! 				release_sock(sk);
  				return -EADDRNOTAVAIL;
+ 			}
  		
  			sk->protinfo.ax25->ax25_dev = ax25_dev_ax25dev(dev);
  			ax25_fillin_cb(sk->protinfo.ax25, sk->protinfo.ax25->ax25_dev);
+ 			release_sock(sk);
  			return 0;
  
  		default:
+ 			release_sock(sk);
  			return -ENOPROTOOPT;
  	}
+ 	release_sock(sk);
  }
  
  static int ax25_getsockopt(struct socket *sock, int level, int optname, char *optval, int *optlen)
***************
*** 741,746 ****
--- 931,939 ----
  	void *valptr;
  	int val = 0;
  	int maxlen, length;
+ #ifdef CONFIG_AX25_LINSV
+ 	long unacked;
+ #endif
  
  	if (level != SOL_AX25)
  		return -ENOPROTOOPT;
***************
*** 751,759 ****
--- 944,1035 ----
  	if (maxlen < 1)
  		return -EFAULT;
  
+ 	lock_sock(sk);
+ 	
  	valptr = (void *) &val;
  	length = min_t(unsigned int, maxlen, sizeof(int));
  
+ #ifdef CONFIG_AX25_LINSV
+ 	switch (optname) {
+ 
+ 		case AX25_LINSV_VER:
+ 			val = sk->protinfo.ax25->linsv_ver;
+ 			if (put_user(length, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			release_sock(sk);
+                         return copy_to_user(optval, valptr, length) ? -EFAULT : 0;
+ 
+ 		case AX25_LINSV_EXT:
+ 			val = sk->protinfo.ax25->linsv_ext;
+ 			if (put_user(length, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			release_sock(sk);
+                         return copy_to_user(optval, valptr, length) ? -EFAULT : 0;
+ 
+ 		case AX25_LINSV_CALL:
+ 			if (get_user(maxlen, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			if ( maxlen != 6 ) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			release_sock(sk);
+ 			return copy_to_user(optval, sk->protinfo.ax25->linsv_call, maxlen) ? -EFAULT : 0;
+ 		
+ 		case AX25_LINSV_T1S:
+ 			if (get_user(maxlen, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			if ( maxlen != sizeof(long) ) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			release_sock(sk);
+ 			return copy_to_user(optval, &sk->protinfo.ax25->linsv_t1set, maxlen) ? -EFAULT : 0;
+ 		
+ 		case AX25_LINSV_T1E:
+ 			if (get_user(maxlen, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			if ( maxlen != sizeof(long) ) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			release_sock(sk);
+ 			return copy_to_user(optval, &sk->protinfo.ax25->linsv_t1exp, maxlen) ? -EFAULT : 0;
+ 		case AX25_LINSV_UNS:
+ 			if (get_user(maxlen, optlen)) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			if ( maxlen != sizeof(long) ) {
+ 				release_sock(sk);
+ 				return -EFAULT;
+ 			}
+ 			unacked = 0;
+ 			if ( sk->protinfo.ax25 ) {
+ 				if ( sk->protinfo.ax25->vs < sk->protinfo.ax25->va ) {
+ 					unacked = sk->protinfo.ax25->window + sk->protinfo.ax25->vs - sk->protinfo.ax25->va;
+ 				} else {
+ 					unacked = sk->protinfo.ax25->vs - sk->protinfo.ax25->va;
+ 				}
+ 				if ( atomic_read(&sk->wmem_alloc) > 0 ) {
+ 					unacked = -unacked;
+ 				}
+ 			}
+ 			release_sock(sk);
+ 			return copy_to_user(optval, &unacked, maxlen) ? -EFAULT : 0;			
+ 	}
+ #endif
+ 
  	switch (optname) {
  		case AX25_WINDOW:
  			val = sk->protinfo.ax25->window;
***************
*** 815,826 ****
  			break;
  
  		default:
  			return -ENOPROTOOPT;
  	}
  
! 	if (put_user(length, optlen))
  		return -EFAULT;
  
  	return copy_to_user(optval, valptr, length) ? -EFAULT : 0;
  }
  
--- 1091,1106 ----
  			break;
  
  		default:
+ 			release_sock(sk);
  			return -ENOPROTOOPT;
  	}
  
! 	if (put_user(length, optlen)) {
! 		release_sock(sk);
  		return -EFAULT;
+ 	}
  
+ 	release_sock(sk);
  	return copy_to_user(optval, valptr, length) ? -EFAULT : 0;
  }
  
***************
*** 828,839 ****
  {
  	struct sock *sk = sock->sk;
  
  	if (sk->type == SOCK_SEQPACKET && sk->state != TCP_LISTEN) {
  		sk->max_ack_backlog = backlog;
  		sk->state           = TCP_LISTEN;
  		return 0;
  	}
! 
  	return -EOPNOTSUPP;
  }
  
--- 1108,1125 ----
  {
  	struct sock *sk = sock->sk;
  
+ 	lock_sock(sk);
+ 
  	if (sk->type == SOCK_SEQPACKET && sk->state != TCP_LISTEN) {
  		sk->max_ack_backlog = backlog;
  		sk->state           = TCP_LISTEN;
+ 		ax25_listen_register(&sk->protinfo.ax25->source_addr, (sk->protinfo.ax25->ax25_dev) ? sk->protinfo.ax25->ax25_dev->dev : NULL );
+ 		release_sock(sk);
  		return 0;
  	}
! 	
! 	release_sock(sk);
! 	
  	return -EOPNOTSUPP;
  }
  
***************
*** 888,900 ****
  	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, 1)) == NULL)
  		return -ENOMEM;
  
  	if ((ax25 = ax25_create_cb()) == NULL) {
! 		sk_free(sk);
  		return -ENOMEM;
  	}
  
- 	sock_init_data(sock, sk);
- 
  	sk->destruct = ax25_free_sock;
  	sock->ops    = &ax25_proto_ops;
  	sk->protocol = protocol;
--- 1174,1186 ----
  	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, 1)) == NULL)
  		return -ENOMEM;
  
+ 	sock_init_data(sock, sk);
+ 	
  	if ((ax25 = ax25_create_cb()) == NULL) {
! 		sock_put(sk);
  		return -ENOMEM;
  	}
  
  	sk->destruct = ax25_free_sock;
  	sock->ops    = &ax25_proto_ops;
  	sk->protocol = protocol;
***************
*** 913,967 ****
  	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, 1)) == NULL)
  		return NULL;
  
  	if ((ax25 = ax25_create_cb()) == NULL) {
! 		sk_free(sk);
  		return NULL;
  	}
  
  	switch (osk->type) {
  		case SOCK_DGRAM:
  			break;
  		case SOCK_SEQPACKET:
  			break;
  		default:
! 			sk_free(sk);
! 			ax25_free_cb(ax25);
  			return NULL;
  	}
  
! 	sock_init_data(NULL, sk);
! 
! 	sk->destruct = ax25_free_sock;
! 	sk->type     = osk->type;
! 	sk->socket   = osk->socket;
! 	sk->priority = osk->priority;
! 	sk->protocol = osk->protocol;
! 	sk->rcvbuf   = osk->rcvbuf;
! 	sk->sndbuf   = osk->sndbuf;
! 	sk->debug    = osk->debug;
! 	sk->state    = TCP_ESTABLISHED;
! 	sk->sleep    = osk->sleep;
! 	sk->zapped   = osk->zapped;
! 
  	ax25->modulus = osk->protinfo.ax25->modulus;
- 	ax25->backoff = osk->protinfo.ax25->backoff;
  	ax25->pidincl = osk->protinfo.ax25->pidincl;
  	ax25->iamdigi = osk->protinfo.ax25->iamdigi;
- 	ax25->rtt     = osk->protinfo.ax25->rtt;
- 	ax25->t1      = osk->protinfo.ax25->t1;
- 	ax25->t2      = osk->protinfo.ax25->t2;
- 	ax25->t3      = osk->protinfo.ax25->t3;
- 	ax25->n2      = osk->protinfo.ax25->n2;
- 	ax25->idle    = osk->protinfo.ax25->idle;
- 	ax25->paclen  = osk->protinfo.ax25->paclen;
  	ax25->window  = osk->protinfo.ax25->window;
  
  	ax25->ax25_dev    = ax25_dev;
  	ax25->source_addr = osk->protinfo.ax25->source_addr;
  
  	if (osk->protinfo.ax25->digipeat != NULL) {
  		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
! 			sk_free(sk);
  			return NULL;
  		}
  
--- 1199,1258 ----
  	if ((sk = sk_alloc(PF_AX25, GFP_ATOMIC, 1)) == NULL)
  		return NULL;
  
+  	sock_init_data(NULL, sk);
+ 	
+ 	lock_sock(sk);
+ 	
  	if ((ax25 = ax25_create_cb()) == NULL) {
! 		release_sock(sk);
! 		sock_put(sk);
  		return NULL;
  	}
  
+ 	sk->destruct  = ax25_free_sock;
+ 
  	switch (osk->type) {
  		case SOCK_DGRAM:
  			break;
  		case SOCK_SEQPACKET:
  			break;
  		default:
! 			release_sock(sk);
! 			sock_put(sk);
  			return NULL;
  	}
  
! 	sk->type      = osk->type;
! 	sk->priority  = osk->priority;
! 	sk->protocol  = osk->protocol;
! 	sk->zapped    = osk->zapped;
! 	sk->state     = TCP_ESTABLISHED;
! 	sk->family    = PF_AX25;
! 	
! 	sk->sleep     = osk->sleep;
! 	sk->socket    = osk->socket;
! 	
  	ax25->modulus = osk->protinfo.ax25->modulus;
  	ax25->pidincl = osk->protinfo.ax25->pidincl;
  	ax25->iamdigi = osk->protinfo.ax25->iamdigi;
  	ax25->window  = osk->protinfo.ax25->window;
+ 	
+ 	ax25->backoff = ax25_dev->values[AX25_VALUES_BACKOFF];
+ 	ax25->rtt     = ax25_dev->values[AX25_VALUES_T1] / 2;
+ 	ax25->t1      = ax25_dev->values[AX25_VALUES_T1];
+ 	ax25->t2      = ax25_dev->values[AX25_VALUES_T2];
+ 	ax25->t3      = ax25_dev->values[AX25_VALUES_T3];
+ 	ax25->n2      = ax25_dev->values[AX25_VALUES_N2];
+ 	ax25->idle    = ax25_dev->values[AX25_VALUES_IDLE];
+ 	ax25->paclen  = ax25_dev->values[AX25_VALUES_PACLEN];
  
  	ax25->ax25_dev    = ax25_dev;
  	ax25->source_addr = osk->protinfo.ax25->source_addr;
  
  	if (osk->protinfo.ax25->digipeat != NULL) {
  		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
! 			release_sock(sk);
! 			sock_put(sk);
  			return NULL;
  		}
  
***************
*** 971,976 ****
--- 1262,1269 ----
  	sk->protinfo.ax25 = ax25;
  	ax25->sk          = sk;
  
+ 	release_sock(sk);
+ 	
  	return sk;
  }
  
***************
*** 980,1002 ****
  
  	if (sk == NULL) return 0;
  
  	if (sk->type == SOCK_SEQPACKET) {
  		switch (sk->protinfo.ax25->state) {
  			case AX25_STATE_0:
! 				ax25_disconnect(sk->protinfo.ax25, 0);
  				ax25_destroy_socket(sk->protinfo.ax25);
  				break;
  
  			case AX25_STATE_1:
  			case AX25_STATE_2:
  				ax25_send_control(sk->protinfo.ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(sk->protinfo.ax25, 0);
  				ax25_destroy_socket(sk->protinfo.ax25);
  				break;
  
  			case AX25_STATE_3:
  			case AX25_STATE_4:
- 				ax25_clear_queues(sk->protinfo.ax25);
  				sk->protinfo.ax25->n2count = 0;
  				switch (sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {
  					case AX25_PROTO_STD_SIMPLEX:
--- 1273,1300 ----
  
  	if (sk == NULL) return 0;
  
+ 	sock_orphan(sk);	
+ 
+ 	sock_hold(sk);
+ 	lock_sock(sk);
+ 	
  	if (sk->type == SOCK_SEQPACKET) {
+ 		ax25_clear_queues(sk->protinfo.ax25);
  		switch (sk->protinfo.ax25->state) {
  			case AX25_STATE_0:
! 				ax25_disconnect(sk->protinfo.ax25, 0, 0);
  				ax25_destroy_socket(sk->protinfo.ax25);
  				break;
  
  			case AX25_STATE_1:
  			case AX25_STATE_2:
  				ax25_send_control(sk->protinfo.ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(sk->protinfo.ax25, 0, 0);
  				ax25_destroy_socket(sk->protinfo.ax25);
  				break;
  
  			case AX25_STATE_3:
  			case AX25_STATE_4:
  				sk->protinfo.ax25->n2count = 0;
  				switch (sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {
  					case AX25_PROTO_STD_SIMPLEX:
***************
*** 1017,1025 ****
  				ax25_start_t1timer(sk->protinfo.ax25);
  				sk->protinfo.ax25->state = AX25_STATE_2;
  				sk->state                = TCP_CLOSE;
  				sk->shutdown            |= SEND_SHUTDOWN;
! 				sk->state_change(sk);
! 				sock_orphan(sk);
  				sk->destroy              = 1;
  				break;
  
--- 1315,1325 ----
  				ax25_start_t1timer(sk->protinfo.ax25);
  				sk->protinfo.ax25->state = AX25_STATE_2;
  				sk->state                = TCP_CLOSE;
+ 				sk->err			 = 0;
  				sk->shutdown            |= SEND_SHUTDOWN;
! 				if (!sk->dead) {
! 					sk->state_change(sk);
! 				}
  				sk->destroy              = 1;
  				break;
  
***************
*** 1029,1041 ****
  	} else {
  		sk->state     = TCP_CLOSE;
  		sk->shutdown |= SEND_SHUTDOWN;
! 		sk->state_change(sk);
! 		sock_orphan(sk);
  		ax25_destroy_socket(sk->protinfo.ax25);
  	}
  
! 	sock->sk   = NULL;	
! 	sk->socket = NULL;	/* Not used, but we should do this */
  
  	return 0;
  }
--- 1329,1345 ----
  	} else {
  		sk->state     = TCP_CLOSE;
  		sk->shutdown |= SEND_SHUTDOWN;
! 		sk->err       = 0;
! 		if (!sk->dead) {
! 			sk->state_change(sk);
! 		}
! 		sk->destroy   = 1;
  		ax25_destroy_socket(sk->protinfo.ax25);
  	}
  
! 	release_sock(sk);
! 
! 	sock_put(sk);
  
  	return 0;
  }
***************
*** 1053,1078 ****
  	ax25_address *call;
  	ax25_dev *ax25_dev = NULL;
  
! 	if (sk->zapped == 0)
  		return -EINVAL;
  
  	if (addr_len != sizeof(struct sockaddr_ax25) && 
  	    addr_len != sizeof(struct full_sockaddr_ax25)) {
  		/* support for old structure may go away some time */
  		if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    (addr_len > sizeof(struct full_sockaddr_ax25)))
  			return -EINVAL;
  
  		printk(KERN_WARNING "ax25_bind(): %s uses old (6 digipeater) socket structure.\n",
  			current->comm);
  	}
  
! 	if (addr->fsa_ax25.sax25_family != AF_AX25)
  		return -EINVAL;
  
  	call = ax25_findbyuid(current->euid);
! 	if (call == NULL && ax25_uid_policy && !capable(CAP_NET_ADMIN))
  		return -EACCES;
  
  	if (call == NULL)
  		sk->protinfo.ax25->source_addr = addr->fsa_ax25.sax25_call;
--- 1357,1392 ----
  	ax25_address *call;
  	ax25_dev *ax25_dev = NULL;
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped == 0) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	if (addr_len != sizeof(struct sockaddr_ax25) && 
  	    addr_len != sizeof(struct full_sockaddr_ax25)) {
  		/* support for old structure may go away some time */
  		if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    (addr_len > sizeof(struct full_sockaddr_ax25))) {
! 		    	release_sock(sk);
  			return -EINVAL;
+ 		}
  
  		printk(KERN_WARNING "ax25_bind(): %s uses old (6 digipeater) socket structure.\n",
  			current->comm);
  	}
  
! 	if (addr->fsa_ax25.sax25_family != AF_AX25) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	call = ax25_findbyuid(current->euid);
! 	if (call == NULL && ax25_uid_policy && !capable(CAP_NET_ADMIN)) {
! 		release_sock(sk);
  		return -EACCES;
+ 	}
  
  	if (call == NULL)
  		sk->protinfo.ax25->source_addr = addr->fsa_ax25.sax25_call;
***************
*** 1088,1098 ****
  
  	if (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {
  		if (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&
! 		    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL)
  			return -EADDRNOTAVAIL;
  	}  else {
! 		if ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL)
  			return -EADDRNOTAVAIL;
  	}
  
  	if (ax25_dev != NULL)
--- 1402,1416 ----
  
  	if (addr_len > sizeof(struct sockaddr_ax25) && addr->fsa_ax25.sax25_ndigis == 1) {
  		if (ax25cmp(&addr->fsa_digipeater[0], &null_ax25_address) != 0 &&
! 		    (ax25_dev = ax25_addr_ax25dev(&addr->fsa_digipeater[0])) == NULL) {
! 		    	release_sock(sk);
  			return -EADDRNOTAVAIL;
+ 		}
  	}  else {
! 		if ((ax25_dev = ax25_addr_ax25dev(&addr->fsa_ax25.sax25_call)) == NULL) {
! 			release_sock(sk);
  			return -EADDRNOTAVAIL;
+ 		}
  	}
  
  	if (ax25_dev != NULL)
***************
*** 1101,1138 ****
  done:
  	ax25_insert_socket(sk->protinfo.ax25);
  	sk->zapped = 0;
  	return 0;
  }
  
- /*
-  *	FIXME: nonblock behaviour looks like it may have a bug.
-  */
  static int ax25_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)
  {
  	struct sock *sk = sock->sk;
  	struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;
  	ax25_digi *digi = NULL;
  	int ct = 0, err;
! 
  	/* deal with restarts */
  	if (sock->state == SS_CONNECTING) {
  		switch (sk->state) {
  		case TCP_SYN_SENT: /* still trying */
  			return -EINPROGRESS;
  
  		case TCP_ESTABLISHED: /* connection established */
  			sock->state = SS_CONNECTED;
  			return 0;
  
  		case TCP_CLOSE: /* connection refused */
  			sock->state = SS_UNCONNECTED;
  			return -ECONNREFUSED;
  		}
  	}
  
! 	if (sk->state == TCP_ESTABLISHED && sk->type == SOCK_SEQPACKET)
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 
  	sk->state   = TCP_CLOSE;
  	sock->state = SS_UNCONNECTED;
  
--- 1419,1464 ----
  done:
  	ax25_insert_socket(sk->protinfo.ax25);
  	sk->zapped = 0;
+ 	
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
  static int ax25_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)
  {
  	struct sock *sk = sock->sk;
  	struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;
  	ax25_digi *digi = NULL;
  	int ct = 0, err;
! 	ax25_cb *ax25;
! 	
! 	lock_sock(sk);
! 	
  	/* deal with restarts */
  	if (sock->state == SS_CONNECTING) {
  		switch (sk->state) {
  		case TCP_SYN_SENT: /* still trying */
+ 			release_sock(sk);
  			return -EINPROGRESS;
  
  		case TCP_ESTABLISHED: /* connection established */
  			sock->state = SS_CONNECTED;
+ 			release_sock(sk);
  			return 0;
  
  		case TCP_CLOSE: /* connection refused */
  			sock->state = SS_UNCONNECTED;
+ 			release_sock(sk);
  			return -ECONNREFUSED;
  		}
  	}
  
! 	if (sk->state == TCP_ESTABLISHED && sk->type == SOCK_SEQPACKET) {
! 		release_sock(sk);
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 	}
! 	
  	sk->state   = TCP_CLOSE;
  	sock->state = SS_UNCONNECTED;
  
***************
*** 1148,1162 ****
  	else if (addr_len != sizeof(struct full_sockaddr_ax25)) {
  		/* support for old structure may go away some time */
  		if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    (addr_len > sizeof(struct full_sockaddr_ax25)))
  			return -EINVAL;
  
  		printk(KERN_WARNING "ax25_connect(): %s uses old (6 digipeater) socket structure.\n",
  			current->comm);
  	}
  
! 	if (fsa->fsa_ax25.sax25_family != AF_AX25)
  		return -EINVAL;
  
  	if (sk->protinfo.ax25->digipeat != NULL) {
  		kfree(sk->protinfo.ax25->digipeat);
--- 1474,1492 ----
  	else if (addr_len != sizeof(struct full_sockaddr_ax25)) {
  		/* support for old structure may go away some time */
  		if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    (addr_len > sizeof(struct full_sockaddr_ax25))) {
! 		    	release_sock(sk);
  			return -EINVAL;
+ 		}
  
  		printk(KERN_WARNING "ax25_connect(): %s uses old (6 digipeater) socket structure.\n",
  			current->comm);
  	}
  
! 	if (fsa->fsa_ax25.sax25_family != AF_AX25) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	if (sk->protinfo.ax25->digipeat != NULL) {
  		kfree(sk->protinfo.ax25->digipeat);
***************
*** 1168,1178 ****
  	 */
  	if (addr_len > sizeof(struct sockaddr_ax25) && fsa->fsa_ax25.sax25_ndigis != 0) {
  		/* Valid number of digipeaters ? */
! 		if (fsa->fsa_ax25.sax25_ndigis < 1 || fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS)
  			return -EINVAL;
  
! 		if ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL)
  			return -ENOBUFS;
  
  		digi->ndigi      = fsa->fsa_ax25.sax25_ndigis;
  		digi->lastrepeat = -1;
--- 1498,1512 ----
  	 */
  	if (addr_len > sizeof(struct sockaddr_ax25) && fsa->fsa_ax25.sax25_ndigis != 0) {
  		/* Valid number of digipeaters ? */
! 		if (fsa->fsa_ax25.sax25_ndigis < 1 || fsa->fsa_ax25.sax25_ndigis > AX25_MAX_DIGIS) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  
! 		if ((digi = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {
! 			release_sock(sk);
  			return -ENOBUFS;
+ 		}
  
  		digi->ndigi      = fsa->fsa_ax25.sax25_ndigis;
  		digi->lastrepeat = -1;
***************
*** 1198,1216 ****
  		/* check if we can remove this feature. It is broken. */
  		printk(KERN_WARNING "ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\n",
  			current->comm);
! 		if ((err = ax25_rt_autobind(sk->protinfo.ax25, &fsa->fsa_ax25.sax25_call)) < 0)
  			return err;
  		ax25_fillin_cb(sk->protinfo.ax25, sk->protinfo.ax25->ax25_dev);
  		ax25_insert_socket(sk->protinfo.ax25);
  	} else {
! 		if (sk->protinfo.ax25->ax25_dev == NULL)
  			return -EHOSTUNREACH;
  	}
  
! 	if (sk->type == SOCK_SEQPACKET && ax25_find_cb(&sk->protinfo.ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi, sk->protinfo.ax25->ax25_dev->dev) != NULL) {
! 		if (digi != NULL) kfree(digi);
  		return -EADDRINUSE;			/* Already such a connection */
  	}
  
  	sk->protinfo.ax25->dest_addr = fsa->fsa_ax25.sax25_call;
  	sk->protinfo.ax25->digipeat  = digi;
--- 1532,1560 ----
  		/* check if we can remove this feature. It is broken. */
  		printk(KERN_WARNING "ax25_connect(): %s uses autobind, please contact jreuter@yaina.de\n",
  			current->comm);
! 		if ((err = ax25_rt_autobind(sk->protinfo.ax25, &fsa->fsa_ax25.sax25_call)) < 0) {
! 			release_sock(sk);
  			return err;
+ 		}
  		ax25_fillin_cb(sk->protinfo.ax25, sk->protinfo.ax25->ax25_dev);
  		ax25_insert_socket(sk->protinfo.ax25);
  	} else {
! 		if (sk->protinfo.ax25->ax25_dev == NULL) {
! 			release_sock(sk);
  			return -EHOSTUNREACH;
+ 		}
  	}
  
! 	ax25 = NULL;
! 	if (sk->type == SOCK_SEQPACKET && (ax25 = ax25_find_cb(&sk->protinfo.ax25->source_addr, &fsa->fsa_ax25.sax25_call, digi, sk->protinfo.ax25->ax25_dev->dev)) != NULL) {
! 		if (digi != NULL) {
! 			kfree(digi);
! 		}
! 		release_sock(sk);
! 		ax25_cb_put(ax25);
  		return -EADDRINUSE;			/* Already such a connection */
  	}
+ 	ax25_cb_put(ax25);
  
  	sk->protinfo.ax25->dest_addr = fsa->fsa_ax25.sax25_call;
  	sk->protinfo.ax25->digipeat  = digi;
***************
*** 1219,1224 ****
--- 1563,1569 ----
  	if (sk->type != SOCK_SEQPACKET) {
  		sock->state = SS_CONNECTED;
  		sk->state   = TCP_ESTABLISHED;
+ 		release_sock(sk);
  		return 0;
  	}
  
***************
*** 1229,1234 ****
--- 1574,1588 ----
  	switch (sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {
  		case AX25_PROTO_STD_SIMPLEX:
  		case AX25_PROTO_STD_DUPLEX:
+ #ifdef CONFIG_AX25_LINSV
+ 			if ( sk->protinfo.ax25->linsv_ext ) {
+ 				sk->protinfo.ax25->modulus = AX25_EMODULUS;
+ 				sk->protinfo.ax25->window  = sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_EWINDOW];
+ 			} else {
+ 				sk->protinfo.ax25->modulus = AX25_MODULUS;
+ 				sk->protinfo.ax25->window  = sk->protinfo.ax25->ax25_dev->values[AX25_VALUES_WINDOW];
+ 			}
+ #endif
  			ax25_std_establish_data_link(sk->protinfo.ax25);
  			break;
  
***************
*** 1248,1278 ****
  
  	ax25_start_heartbeat(sk->protinfo.ax25);
  
! 	/* Now the loop */
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK))
  		return -EINPROGRESS;
  
! 	cli();	/* To avoid races on the sleep */
! 
! 	/* A DM or timeout will go to closed, a UA will go to ABM */
  	while (sk->state == TCP_SYN_SENT) {
- 		interruptible_sleep_on(sk->sleep);
  		if (signal_pending(current)) {
! 			sti();
  			return -ERESTARTSYS;
  		}
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
! 		/* Not in ABM, not in WAIT_UA -> failed */
! 		sti();
  		sock->state = SS_UNCONNECTED;
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	sti();
  
  	return 0;
  }
--- 1602,1641 ----
  
  	ax25_start_heartbeat(sk->protinfo.ax25);
  
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {
! 		release_sock(sk);
  		return -EINPROGRESS;
+ 	}
  
! 	/* A DM or timeout will go to closed, a UA will go to SABM */
  	while (sk->state == TCP_SYN_SENT) {
  		if (signal_pending(current)) {
! 			release_sock(sk);
  			return -ERESTARTSYS;
  		}
+ 		if ((err = sock_error(sk)) != 0) {
+ 			sock->state = SS_UNCONNECTED;
+ 			release_sock(sk);
+ 			return err;
+ 		}
+ 		
+ 		SOCK_SLEEP_PRE(sk);
+ 		if (sk->state == TCP_SYN_SENT) {
+ 			schedule();
+ 		}
+ 		SOCK_SLEEP_POST(sk);
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
! 		/* Not in SABM, not in WAIT_UA -> failed */
  		sock->state = SS_UNCONNECTED;
+ 		release_sock(sk);
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	release_sock(sk);
  
  	return 0;
  }
***************
*** 1284,1327 ****
  	struct sock *newsk;
  	struct sk_buff *skb;
  
! 	if (sock->state != SS_UNCONNECTED)
  		return -EINVAL;
  
! 	if ((sk = sock->sk) == NULL)
  		return -EINVAL;
  
! 	if (sk->type != SOCK_SEQPACKET)
  		return -EOPNOTSUPP;
  
! 	if (sk->state != TCP_LISTEN)
  		return -EINVAL;
  
  	/*
  	 *	The read queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	do {
! 		if ((skb = skb_dequeue(&sk->receive_queue)) == NULL) {
! 			if (flags & O_NONBLOCK)
! 				return -EWOULDBLOCK;
! 
! 			interruptible_sleep_on(sk->sleep);
! 			if (signal_pending(current)) 
! 				return -ERESTARTSYS;
  		}
! 	} while (skb == NULL);
  
  	newsk = skb->sk;
! 	newsk->pair = NULL;
! 	newsk->socket = newsock;
! 	newsk->sleep = &newsock->wait;
  
  	/* Now attach up the new socket */
! 	kfree_skb(skb);
! 	sk->ack_backlog--;
  	newsock->sk    = newsk;
  	newsock->state = SS_CONNECTED;
  
  	return 0;
  }
  
--- 1647,1720 ----
  	struct sock *newsk;
  	struct sk_buff *skb;
  
! 	sk = sock->sk;
! 
! 	if (sk == NULL) {
  		return -EINVAL;
+ 	}
+ 	
+ 	lock_sock(sk);
  
! 	if (sock->state != SS_UNCONNECTED) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (sk->type != SOCK_SEQPACKET) {
! 		release_sock(sk);
  		return -EOPNOTSUPP;
+ 	}
  
! 	if (sk->state != TCP_LISTEN) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	/*
  	 *	The read queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	for (;;) {
! 		skb = skb_dequeue(&sk->receive_queue);
! 		if (skb) {
! 			break;
! 		}
! 		if (flags & O_NONBLOCK) {
! 			release_sock(sk);
! 			return -EWOULDBLOCK;
  		}
! 		if (signal_pending(current)) {
! 			release_sock(sk);
! 			return -ERESTARTSYS;
! 		}
! 		
! 		SOCK_SLEEP_PRE(sk);
! 		if (!skb_peek(&sk->receive_queue)) {
! 			schedule();
! 		}
! 		SOCK_SLEEP_POST(sk);
! 	}
! 	
! 	sk->ack_backlog--;
! 	
! 	release_sock(sk);
  
  	newsk = skb->sk;
! 	kfree_skb(skb);
! 	
! 	lock_sock(newsk);
  
+ 	newsk->socket   = newsock;
+ 	newsk->sleep    = &newsock->wait;
+ 	newsk->destruct = ax25_free_sock;
+ 		
  	/* Now attach up the new socket */
! 	
  	newsock->sk    = newsk;
  	newsock->state = SS_CONNECTED;
  
+ 	release_sock(newsk);
+ 	
  	return 0;
  }
  
***************
*** 1331,1339 ****
  	struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;
  	unsigned char ndigi, i;
  
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  
  		fsa->fsa_ax25.sax25_family = AF_AX25;
  		fsa->fsa_ax25.sax25_call   = sk->protinfo.ax25->dest_addr;
--- 1724,1736 ----
  	struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;
  	unsigned char ndigi, i;
  
+ 	lock_sock(sk);
+ 	
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  
  		fsa->fsa_ax25.sax25_family = AF_AX25;
  		fsa->fsa_ax25.sax25_call   = sk->protinfo.ax25->dest_addr;
***************
*** 1356,1361 ****
--- 1753,1761 ----
  		}
  	}
  	*uaddr_len = sizeof (struct full_sockaddr_ax25);
+ 	
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
***************
*** 1373,1395 ****
  	int lv;
  	int addr_len = msg->msg_namelen;
  
! 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR))
  		return -EINVAL;
  
! 	if (sk->zapped)
  		return -EADDRNOTAVAIL;
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
  		send_sig(SIGPIPE, current, 0);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.ax25->ax25_dev == NULL)
  		return -ENETUNREACH;
  
  	if (usax != NULL) {
! 		if (usax->sax25_family != AF_AX25)
  			return -EINVAL;
  
  		if (addr_len == sizeof(struct sockaddr_ax25)) {
  			printk(KERN_WARNING "ax25_sendmsg(): %s uses obsolete socket structure\n",
--- 1773,1805 ----
  	int lv;
  	int addr_len = msg->msg_namelen;
  
! 	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR)) {
  		return -EINVAL;
+ 	}
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped) {
! 		release_sock(sk);
  		return -EADDRNOTAVAIL;
+ 	}
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
+ 		release_sock(sk);
  		send_sig(SIGPIPE, current, 0);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.ax25->ax25_dev == NULL) {
! 		release_sock(sk);
  		return -ENETUNREACH;
+ 	}
  
  	if (usax != NULL) {
! 		if (usax->sax25_family != AF_AX25) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  
  		if (addr_len == sizeof(struct sockaddr_ax25)) {
  			printk(KERN_WARNING "ax25_sendmsg(): %s uses obsolete socket structure\n",
***************
*** 1398,1405 ****
  		else if (addr_len != sizeof(struct full_sockaddr_ax25)) {
  			/* support for old structure may go away some time */
  			if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    	    (addr_len > sizeof(struct full_sockaddr_ax25)))
  		    		return -EINVAL;
  
  			printk(KERN_WARNING "ax25_sendmsg(): %s uses old (6 digipeater) socket structure.\n",
  				current->comm);
--- 1808,1817 ----
  		else if (addr_len != sizeof(struct full_sockaddr_ax25)) {
  			/* support for old structure may go away some time */
  			if ((addr_len < sizeof(struct sockaddr_ax25) + sizeof(ax25_address) * 6) ||
! 		    	    (addr_len > sizeof(struct full_sockaddr_ax25))) {
! 		    	    	release_sock(sk);
  		    		return -EINVAL;
+ 		    	}
  
  			printk(KERN_WARNING "ax25_sendmsg(): %s uses old (6 digipeater) socket structure.\n",
  				current->comm);
***************
*** 1410,1417 ****
  			struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;
  
  			/* Valid number of digipeaters ? */
! 			if (usax->sax25_ndigis < 1 || usax->sax25_ndigis > AX25_MAX_DIGIS)
  				return -EINVAL;
  
  			dtmp.ndigi      = usax->sax25_ndigis;
  
--- 1822,1831 ----
  			struct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)usax;
  
  			/* Valid number of digipeaters ? */
! 			if (usax->sax25_ndigis < 1 || usax->sax25_ndigis > AX25_MAX_DIGIS) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  
  			dtmp.ndigi      = usax->sax25_ndigis;
  
***************
*** 1425,1432 ****
  		}
  
  		sax = *usax;
! 		if (sk->type == SOCK_SEQPACKET && ax25cmp(&sk->protinfo.ax25->dest_addr, &sax.sax25_call) != 0)
  			return -EISCONN;
  		if (usax->sax25_ndigis == 0)
  			dp = NULL;
  		else
--- 1839,1848 ----
  		}
  
  		sax = *usax;
! 		if (sk->type == SOCK_SEQPACKET && ax25cmp(&sk->protinfo.ax25->dest_addr, &sax.sax25_call) != 0) {
! 			release_sock(sk);
  			return -EISCONN;
+ 		}
  		if (usax->sax25_ndigis == 0)
  			dp = NULL;
  		else
***************
*** 1437,1464 ****
  		 *	it has become closed (not started closed) and is VC
  		 *	we ought to SIGPIPE, EPIPE
  		 */
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  		sax.sax25_family = AF_AX25;
  		sax.sax25_call   = sk->protinfo.ax25->dest_addr;
  		dp = sk->protinfo.ax25->digipeat;
  	}
  
- 	SOCK_DEBUG(sk, "AX.25: sendto: Addresses built.\n");
- 
- 	/* Build a packet */
- 	SOCK_DEBUG(sk, "AX.25: sendto: building packet.\n");
- 
  	/* Assume the worst case */
  	size = len + 3 + ax25_addr_size(dp) + AX25_BPQ_HEADER_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)
  		return err;
  
  	skb_reserve(skb, size - len);
  
- 	SOCK_DEBUG(sk, "AX.25: Appending user data\n");
- 
  	/* User data follows immediately after the AX.25 data */
  	memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
  	skb->nh.raw = skb->data;
--- 1853,1877 ----
  		 *	it has become closed (not started closed) and is VC
  		 *	we ought to SIGPIPE, EPIPE
  		 */
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  		sax.sax25_family = AF_AX25;
  		sax.sax25_call   = sk->protinfo.ax25->dest_addr;
  		dp = sk->protinfo.ax25->digipeat;
  	}
  
  	/* Assume the worst case */
  	size = len + 3 + ax25_addr_size(dp) + AX25_BPQ_HEADER_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL) {
! 		release_sock(sk);
  		return err;
+ 	}
  
  	skb_reserve(skb, size - len);
  
  	/* User data follows immediately after the AX.25 data */
  	memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
  	skb->nh.raw = skb->data;
***************
*** 1469,1512 ****
  		*asmptr = sk->protocol;
  	}
  
- 	SOCK_DEBUG(sk, "AX.25: Transmitting buffer\n");
- 
  	if (sk->type == SOCK_SEQPACKET) {
  		/* Connected mode sockets go via the LAPB machine */
  		if (sk->state != TCP_ESTABLISHED) {
  			kfree_skb(skb);
  			return -ENOTCONN;
  		}
  
  		ax25_output(sk->protinfo.ax25, sk->protinfo.ax25->paclen, skb);	/* Shove it onto the queue and kick */
! 
  		return len;
  	} else {
  		asmptr = skb_push(skb, 1 + ax25_addr_size(dp));
  
- 		SOCK_DEBUG(sk, "Building AX.25 Header (dp=%p).\n", dp);
- 
- 		if (dp != NULL)
- 			SOCK_DEBUG(sk, "Num digipeaters=%d\n", dp->ndigi);
- 
  		/* Build an AX.25 header */
  		asmptr += (lv = ax25_addr_build(asmptr, &sk->protinfo.ax25->source_addr, &sax.sax25_call, dp, AX25_COMMAND, AX25_MODULUS));
  
- 		SOCK_DEBUG(sk, "Built header (%d bytes)\n",lv);
- 
  		skb->h.raw = asmptr;
  
- 		SOCK_DEBUG(sk, "base=%p pos=%p\n", skb->data, asmptr);
- 
  		*asmptr = AX25_UI;
  
  		/* Datagram frames go straight out of the door as UI */
  		skb->dev      = sk->protinfo.ax25->ax25_dev->dev;
  
  		ax25_queue_xmit(skb);
! 
  		return len;
  	}
  }
  
  static int ax25_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags, struct scm_cookie *scm)
--- 1882,1916 ----
  		*asmptr = sk->protocol;
  	}
  
  	if (sk->type == SOCK_SEQPACKET) {
  		/* Connected mode sockets go via the LAPB machine */
  		if (sk->state != TCP_ESTABLISHED) {
  			kfree_skb(skb);
+ 			release_sock(sk);
  			return -ENOTCONN;
  		}
  
  		ax25_output(sk->protinfo.ax25, sk->protinfo.ax25->paclen, skb);	/* Shove it onto the queue and kick */
! 		release_sock(sk);
  		return len;
  	} else {
  		asmptr = skb_push(skb, 1 + ax25_addr_size(dp));
  
  		/* Build an AX.25 header */
  		asmptr += (lv = ax25_addr_build(asmptr, &sk->protinfo.ax25->source_addr, &sax.sax25_call, dp, AX25_COMMAND, AX25_MODULUS));
  
  		skb->h.raw = asmptr;
  
  		*asmptr = AX25_UI;
  
  		/* Datagram frames go straight out of the door as UI */
  		skb->dev      = sk->protinfo.ax25->ax25_dev->dev;
  
  		ax25_queue_xmit(skb);
! 		release_sock(sk);
  		return len;
  	}
+ 	release_sock(sk);
  }
  
  static int ax25_recvmsg(struct socket *sock, struct msghdr *msg, int size, int flags, struct scm_cookie *scm)
***************
*** 1516,1531 ****
  	struct sk_buff *skb;
  	int er;
  
  	/*
  	 * 	This works for seqpacket too. The receiver has ordered the
  	 *	queue for us! We do one quick check first though
  	 */
! 	if (sk->type == SOCK_SEQPACKET && sk->state != TCP_ESTABLISHED)
  		return -ENOTCONN;
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)
  		return er;
  
  	if (!sk->protinfo.ax25->pidincl)
  		skb_pull(skb, 1);		/* Remove PID */
--- 1920,1941 ----
  	struct sk_buff *skb;
  	int er;
  
+ 	lock_sock(sk);
+ 	
  	/*
  	 * 	This works for seqpacket too. The receiver has ordered the
  	 *	queue for us! We do one quick check first though
  	 */
! 	if (sk->type == SOCK_SEQPACKET && sk->state != TCP_ESTABLISHED) {
! 		release_sock(sk);
  		return -ENOTCONN;
+ 	}
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
! 		release_sock(sk);
  		return er;
+ 	}
  
  	if (!sk->protinfo.ax25->pidincl)
  		skb_pull(skb, 1);		/* Remove PID */
***************
*** 1566,1590 ****
  
  	skb_free_datagram(sk, skb);
  
  	return copied;
  }
  
- static int ax25_shutdown(struct socket *sk, int how)
- {
- 	/* FIXME - generate DM and RNR states */
- 	return -EOPNOTSUPP;
- }
- 
  static int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
  {
  	struct sock *sk = sock->sk;
! 
  	switch (cmd) {
  		case TIOCOUTQ: {
  			long amount;
  			amount = sk->sndbuf - atomic_read(&sk->wmem_alloc);
! 			if (amount < 0)
  				amount = 0;
  			return put_user(amount, (int *)arg);
  		}
  
--- 1976,1999 ----
  
  	skb_free_datagram(sk, skb);
  
+ 	release_sock(sk);
+ 	
  	return copied;
  }
  
  static int ax25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
  {
  	struct sock *sk = sock->sk;
! 	
  	switch (cmd) {
  		case TIOCOUTQ: {
  			long amount;
+ 			lock_sock(sk);
  			amount = sk->sndbuf - atomic_read(&sk->wmem_alloc);
! 			if (amount < 0) {
  				amount = 0;
+ 			}
+ 			release_sock(sk);
  			return put_user(amount, (int *)arg);
  		}
  
***************
*** 1592,1606 ****
  			struct sk_buff *skb;
  			long amount = 0L;
  			/* These two are safe on a single CPU system as only user tasks fiddle here */
! 			if ((skb = skb_peek(&sk->receive_queue)) != NULL)
  				amount = skb->len;
  			return put_user(amount, (int *)arg);
  		}
  
  		case SIOCGSTAMP:
  			if (sk != NULL) {
! 				if (sk->stamp.tv_sec == 0)
  					return -ENOENT;
  				return copy_to_user((void *)arg, &sk->stamp, sizeof(struct timeval)) ? -EFAULT : 0;
  	 		}
  			return -EINVAL;
--- 2001,2017 ----
  			struct sk_buff *skb;
  			long amount = 0L;
  			/* These two are safe on a single CPU system as only user tasks fiddle here */
! 			if ((skb = skb_peek(&sk->receive_queue)) != NULL) {
  				amount = skb->len;
+ 			}
  			return put_user(amount, (int *)arg);
  		}
  
  		case SIOCGSTAMP:
  			if (sk != NULL) {
! 				if (sk->stamp.tv_sec == 0) {
  					return -ENOENT;
+ 				}
  				return copy_to_user((void *)arg, &sk->stamp, sizeof(struct timeval)) ? -EFAULT : 0;
  	 		}
  			return -EINVAL;
***************
*** 1609,1627 ****
  		case SIOCAX25DELUID:	/* Delete a uid from the uid/call map table */
  		case SIOCAX25GETUID: {
  			struct sockaddr_ax25 sax25;
! 			if (copy_from_user(&sax25, (void *)arg, sizeof(sax25)))
  				return -EFAULT;
  			return ax25_uid_ioctl(cmd, &sax25);
  		}
  
  		case SIOCAX25NOUID: {	/* Set the default policy (default/bar) */
  			long amount;
! 			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
! 			if (get_user(amount, (long *)arg))
  				return -EFAULT;
! 			if (amount > AX25_NOUID_BLOCK)
  				return -EINVAL;
  			ax25_uid_policy = amount;
  			return 0;
  		}
--- 2020,2042 ----
  		case SIOCAX25DELUID:	/* Delete a uid from the uid/call map table */
  		case SIOCAX25GETUID: {
  			struct sockaddr_ax25 sax25;
! 			if (copy_from_user(&sax25, (void *)arg, sizeof(sax25))) {
  				return -EFAULT;
+ 			}
  			return ax25_uid_ioctl(cmd, &sax25);
  		}
  
  		case SIOCAX25NOUID: {	/* Set the default policy (default/bar) */
  			long amount;
! 			if (!capable(CAP_NET_ADMIN)) {
  				return -EPERM;
! 			}
! 			if (get_user(amount, (long *)arg)) {
  				return -EFAULT;
! 			}
! 			if (amount > AX25_NOUID_BLOCK) {
  				return -EINVAL;
+ 			}
  			ax25_uid_policy = amount;
  			return 0;
  		}
***************
*** 1629,1667 ****
  		case SIOCADDRT:
  		case SIOCDELRT:
  		case SIOCAX25OPTRT:
! 			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
  			return ax25_rt_ioctl(cmd, (void *)arg);
  
  		case SIOCAX25CTLCON:
! 			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
  			return ax25_ctl_ioctl(cmd, (void *)arg);
  
  		case SIOCAX25GETINFO: 
  		case SIOCAX25GETINFOOLD: {
  			struct ax25_info_struct ax25_info;
! 
! 			ax25_info.t1        = sk->protinfo.ax25->t1   / HZ;
! 			ax25_info.t2        = sk->protinfo.ax25->t2   / HZ;
! 			ax25_info.t3        = sk->protinfo.ax25->t3   / HZ;
! 			ax25_info.idle      = sk->protinfo.ax25->idle / (60 * HZ);
! 			ax25_info.n2        = sk->protinfo.ax25->n2;
! 			ax25_info.t1timer   = ax25_display_timer(&sk->protinfo.ax25->t1timer)   / HZ;
! 			ax25_info.t2timer   = ax25_display_timer(&sk->protinfo.ax25->t2timer)   / HZ;
! 			ax25_info.t3timer   = ax25_display_timer(&sk->protinfo.ax25->t3timer)   / HZ;
! 			ax25_info.idletimer = ax25_display_timer(&sk->protinfo.ax25->idletimer) / (60 * HZ);
! 			ax25_info.n2count   = sk->protinfo.ax25->n2count;
! 			ax25_info.state     = sk->protinfo.ax25->state;
! 			ax25_info.rcv_q     = atomic_read(&sk->rmem_alloc);
! 			ax25_info.snd_q     = atomic_read(&sk->wmem_alloc);
! 			ax25_info.vs        = sk->protinfo.ax25->vs;
! 			ax25_info.vr        = sk->protinfo.ax25->vr;
! 			ax25_info.va        = sk->protinfo.ax25->va;
! 			ax25_info.vs_max    = sk->protinfo.ax25->vs; /* reserved */
! 			ax25_info.paclen    = sk->protinfo.ax25->paclen;
! 			ax25_info.window    = sk->protinfo.ax25->window;
! 
  			/* old structure? */
  			if (cmd == SIOCAX25GETINFOOLD) {
  				static int warned = 0;
--- 2044,2087 ----
  		case SIOCADDRT:
  		case SIOCDELRT:
  		case SIOCAX25OPTRT:
! 			if (!capable(CAP_NET_ADMIN)) {
  				return -EPERM;
+ 			}
  			return ax25_rt_ioctl(cmd, (void *)arg);
  
  		case SIOCAX25CTLCON:
! 			if (!capable(CAP_NET_ADMIN)) {
  				return -EPERM;
+ 			}
  			return ax25_ctl_ioctl(cmd, (void *)arg);
  
  		case SIOCAX25GETINFO: 
  		case SIOCAX25GETINFOOLD: {
  			struct ax25_info_struct ax25_info;
! 			memset(&ax25_info, 0, sizeof(struct ax25_info_struct));
! 			if (sk) {
! 				lock_sock(sk);
! 				ax25_info.t1        = sk->protinfo.ax25->t1   / HZ;
! 				ax25_info.t2        = sk->protinfo.ax25->t2   / HZ;
! 				ax25_info.t3        = sk->protinfo.ax25->t3   / HZ;
! 				ax25_info.idle      = sk->protinfo.ax25->idle / (60 * HZ);
! 				ax25_info.n2        = sk->protinfo.ax25->n2;
! 				ax25_info.t1timer   = ax25_display_timer(&sk->protinfo.ax25->t1timer)   / HZ;
! 				ax25_info.t2timer   = ax25_display_timer(&sk->protinfo.ax25->t2timer)   / HZ;
! 				ax25_info.t3timer   = ax25_display_timer(&sk->protinfo.ax25->t3timer)   / HZ;
! 				ax25_info.idletimer = ax25_display_timer(&sk->protinfo.ax25->idletimer) / (60 * HZ);
! 				ax25_info.n2count   = sk->protinfo.ax25->n2count;
! 				ax25_info.state     = sk->protinfo.ax25->state;
! 				ax25_info.rcv_q     = atomic_read(&sk->rmem_alloc);
! 				ax25_info.snd_q     = atomic_read(&sk->wmem_alloc);
! 				ax25_info.vs        = sk->protinfo.ax25->vs;
! 				ax25_info.vr        = sk->protinfo.ax25->vr;
! 				ax25_info.va        = sk->protinfo.ax25->va;
! 				ax25_info.vs_max    = sk->protinfo.ax25->vs; /* reserved */
! 				ax25_info.paclen    = sk->protinfo.ax25->paclen;
! 				ax25_info.window    = sk->protinfo.ax25->window;
! 				release_sock(sk);
! 			}
  			/* old structure? */
  			if (cmd == SIOCAX25GETINFOOLD) {
  				static int warned = 0;
***************
*** 1671,1681 ****
  					warned=1;
  				}
  
! 				if (copy_to_user((void *)arg, &ax25_info, sizeof(struct ax25_info_struct_depreciated)))
  					return -EFAULT;
  			} else {
! 				if (copy_to_user((void *)arg, &ax25_info, sizeof(struct ax25_info_struct)))
  					return -EINVAL;
  			} 
  			return 0;
  		}
--- 2091,2103 ----
  					warned=1;
  				}
  
! 				if (copy_to_user((void *)arg, &ax25_info, sizeof(struct ax25_info_struct_depreciated))) {
  					return -EFAULT;
+ 				}
  			} else {
! 				if (copy_to_user((void *)arg, &ax25_info, sizeof(struct ax25_info_struct))) {
  					return -EINVAL;
+ 				}
  			} 
  			return 0;
  		}
***************
*** 1683,1692 ****
  		case SIOCAX25ADDFWD:
  		case SIOCAX25DELFWD: {
  			struct ax25_fwd_struct ax25_fwd;
! 			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
! 			if (copy_from_user(&ax25_fwd, (void *)arg, sizeof(ax25_fwd)))
  				return -EFAULT;
  			return ax25_fwd_ioctl(cmd, &ax25_fwd);
  		}
  
--- 2105,2116 ----
  		case SIOCAX25ADDFWD:
  		case SIOCAX25DELFWD: {
  			struct ax25_fwd_struct ax25_fwd;
! 			if (!capable(CAP_NET_ADMIN)) {
  				return -EPERM;
! 			}
! 			if (copy_from_user(&ax25_fwd, (void *)arg, sizeof(ax25_fwd))) {
  				return -EFAULT;
+ 			}
  			return ax25_fwd_ioctl(cmd, &ax25_fwd);
  		}
  
***************
*** 1707,1724 ****
  	}
  
  	/*NOTREACHED*/
  	return 0;
  }
  
  static int ax25_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_cb *ax25;
  	int k;
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	cli();
  
  	/*
  	 * New format:
--- 2131,2150 ----
  	}
  
  	/*NOTREACHED*/
+ 	
  	return 0;
  }
  
  static int ax25_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_cb *ax25;
+ 	char buf[11];
  	int k;
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	read_lock_bh(&ax25_list_lock);
  
  	/*
  	 * New format:
***************
*** 1729,1742 ****
  		len += sprintf(buffer+len, "%8.8lx %s %s%s ", 
  				(long) ax25, 
  				ax25->ax25_dev == NULL? "???" : ax25->ax25_dev->dev->name,
! 				ax2asc(&ax25->source_addr),
  				ax25->iamdigi? "*":"");
  
! 		len += sprintf(buffer+len, "%s", ax2asc(&ax25->dest_addr));
  				
  		for (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {
  			len += sprintf(buffer+len, ",%s%s",
! 					ax2asc(&ax25->digipeat->calls[k]),
  					ax25->digipeat->repeated[k]? "*":"");
  		}
  		
--- 2155,2168 ----
  		len += sprintf(buffer+len, "%8.8lx %s %s%s ", 
  				(long) ax25, 
  				ax25->ax25_dev == NULL? "???" : ax25->ax25_dev->dev->name,
! 				ax2asc(buf, &ax25->source_addr),
  				ax25->iamdigi? "*":"");
  
! 		len += sprintf(buffer+len, "%s", ax2asc(buf, &ax25->dest_addr));
  				
  		for (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {
  			len += sprintf(buffer+len, ",%s%s",
! 					ax2asc(buf, &ax25->digipeat->calls[k]),
  					ax25->digipeat->repeated[k]? "*":"");
  		}
  		
***************
*** 1761,1767 ****
  		} else {
  			len += sprintf(buffer + len, " * * *\n");
  		}
! 
  		pos = begin + len;
  
  		if (pos < offset) {
--- 2187,2193 ----
  		} else {
  			len += sprintf(buffer + len, " * * *\n");
  		}
! 		
  		pos = begin + len;
  
  		if (pos < offset) {
***************
*** 1773,1779 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 2199,2205 ----
  			break;
  	}
  
! 	read_unlock_bh(&ax25_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1788,1794 ****
  	create:		ax25_create,
  };
  
! static struct proto_ops SOCKOPS_WRAPPED(ax25_proto_ops) = {
  	family:		PF_AX25,
  
  	release:	ax25_release,
--- 2214,2220 ----
  	create:		ax25_create,
  };
  
! static struct proto_ops ax25_proto_ops = {
  	family:		PF_AX25,
  
  	release:	ax25_release,
***************
*** 1800,1806 ****
  	poll:		datagram_poll,
  	ioctl:		ax25_ioctl,
  	listen:		ax25_listen,
! 	shutdown:	ax25_shutdown,
  	setsockopt:	ax25_setsockopt,
  	getsockopt:	ax25_getsockopt,
  	sendmsg:	ax25_sendmsg,
--- 2226,2232 ----
  	poll:		datagram_poll,
  	ioctl:		ax25_ioctl,
  	listen:		ax25_listen,
! 	shutdown:	sock_no_shutdown,
  	setsockopt:	ax25_setsockopt,
  	getsockopt:	ax25_getsockopt,
  	sendmsg:	ax25_sendmsg,
***************
*** 1809,1817 ****
  	sendpage:	sock_no_sendpage,
  };
  
- #include <linux/smp_lock.h>
- SOCKOPS_WRAP(ax25_proto, PF_AX25);
- 
  /*
   *	Called by socket.c on kernel start up
   */
--- 2235,2240 ----
***************
*** 1841,1849 ****
--- 2264,2281 ----
  EXPORT_SYMBOL(asc2ax);
  EXPORT_SYMBOL(null_ax25_address);
  EXPORT_SYMBOL(ax25_display_timer);
+ EXPORT_SYMBOL(ax25_free_cb);
  
  static char banner[] __initdata = KERN_INFO "NET4: G4KLX/GW4PTS AX.25 for Linux. Version 0.37 for Linux NET4.0\n";
  
+ #ifdef CONFIG_AX25_LINSV
+ static char linsv_banner[] __initdata = KERN_INFO "NET4: 9A4GL AX.25 LinSV V0.51 support for Linux.\n";
+ #endif
+ 
+ #ifdef CONFIG_AX25_MTU1580
+ static char mtu1580_banner[] __initdata = KERN_INFO "NET4: 9A4GL AX.25 MTU is 1580\n";
+ #endif
+ 
  static int __init ax25_init(void)
  {
  	sock_register(&ax25_family_ops);
***************
*** 1856,1861 ****
--- 2288,2302 ----
  	proc_net_create("ax25_calls", 0, ax25_uid_get_info);
  
  	printk(banner);
+ 
+ #ifdef CONFIG_AX25_LINSV
+ 	printk(linsv_banner);
+ #endif
+ 
+ #ifdef CONFIG_AX25_MTU1580
+ 	printk(mtu1580_banner);
+ #endif
+ 
  	return 0;
  }
  module_init(ax25_init);
Index: linux-2.4.23/net/ax25/ax25_addr.c
diff -c linux-2.4.23/net/ax25/ax25_addr.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_addr.c:1.2
*** linux-2.4.23/net/ax25/ax25_addr.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_addr.c	Sun Nov 30 21:17:13 2003
***************
*** 17,22 ****
--- 17,23 ----
   *
   *	History
   *	AX.25 036	Jonathan(G4KLX)	Split from ax25_subr.c.
+  *			Tihomir(9A4GL)  ax2asc static variable removed
   */
  
  #include <linux/errno.h>
***************
*** 49,57 ****
  /*
   *	ax25 -> ascii conversion
   */
! char *ax2asc(ax25_address *a)
  {
- 	static char buf[11];
  	char c, *s;
  	int n;
  
--- 50,57 ----
  /*
   *	ax25 -> ascii conversion
   */
! char *ax2asc(char *buf, ax25_address *a)
  {
  	char c, *s;
  	int n;
  
Index: linux-2.4.23/net/ax25/ax25_dev.c
diff -c linux-2.4.23/net/ax25/ax25_dev.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_dev.c:1.2
*** linux-2.4.23/net/ax25/ax25_dev.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_dev.c	Sun Nov 30 21:17:13 2003
***************
*** 14,19 ****
--- 14,20 ----
   *
   *	History
   *	AX.25 036	Jonathan(G4KLX)	Split from ax25_route.c.
+  *			Tihomir(9A4GL)	Protecting list with spinlock/rwlock.
   */
  
  #include <linux/config.h>
***************
*** 39,55 ****
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <linux/init.h>
  
  ax25_dev *ax25_dev_list;
  
  ax25_dev *ax25_dev_ax25dev(struct net_device *dev)
  {
  	ax25_dev *ax25_dev;
  
! 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)
! 		if (ax25_dev->dev == dev)
  			return ax25_dev;
  
  	return NULL;
  }
  
--- 40,65 ----
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <linux/init.h>
+ #include <linux/spinlock.h>
  
  ax25_dev *ax25_dev_list;
+ rwlock_t ax25_dev_lock = RW_LOCK_UNLOCKED;
  
  ax25_dev *ax25_dev_ax25dev(struct net_device *dev)
  {
  	ax25_dev *ax25_dev;
  
! 	read_lock(&ax25_dev_lock);
! 	
! 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next) {
! 		if (ax25_dev->dev == dev) {
! 			read_unlock(&ax25_dev_lock);
  			return ax25_dev;
+ 		}
+ 	}
  
+ 	read_unlock(&ax25_dev_lock);
+ 	
  	return NULL;
  }
  
***************
*** 57,66 ****
  {
  	ax25_dev *ax25_dev;
  
! 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)
! 		if (ax25cmp(addr, (ax25_address *)ax25_dev->dev->dev_addr) == 0)
  			return ax25_dev;
  
  	return NULL;
  }
  
--- 67,83 ----
  {
  	ax25_dev *ax25_dev;
  
! 	read_lock(&ax25_dev_lock);
! 	
! 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next) {
! 		if (ax25cmp(addr, (ax25_address *)ax25_dev->dev->dev_addr) == 0) {
! 			read_unlock(&ax25_dev_lock);
  			return ax25_dev;
+ 		}
+ 	}
  
+ 	read_unlock(&ax25_dev_lock);
+ 	
  	return NULL;
  }
  
***************
*** 71,77 ****
  void ax25_dev_device_up(struct net_device *dev)
  {
  	ax25_dev *ax25_dev;
- 	unsigned long flags;
  
  	if ((ax25_dev = kmalloc(sizeof(*ax25_dev), GFP_ATOMIC)) == NULL) {
  		printk(KERN_ERR "AX.25: ax25_dev_device_up - out of memory\n");
--- 88,93 ----
***************
*** 100,109 ****
  	ax25_dev->values[AX25_VALUES_PROTOCOL]  = AX25_DEF_PROTOCOL;
  	ax25_dev->values[AX25_VALUES_DS_TIMEOUT]= AX25_DEF_DS_TIMEOUT;
  
! 	save_flags(flags); cli();
  	ax25_dev->next = ax25_dev_list;
  	ax25_dev_list  = ax25_dev;
! 	restore_flags(flags);
  
  	ax25_register_sysctl();
  }
--- 116,127 ----
  	ax25_dev->values[AX25_VALUES_PROTOCOL]  = AX25_DEF_PROTOCOL;
  	ax25_dev->values[AX25_VALUES_DS_TIMEOUT]= AX25_DEF_DS_TIMEOUT;
  
! 	write_lock(&ax25_dev_lock);
! 	
  	ax25_dev->next = ax25_dev_list;
  	ax25_dev_list  = ax25_dev;
! 	
! 	write_unlock(&ax25_dev_lock);
  
  	ax25_register_sysctl();
  }
***************
*** 111,129 ****
  void ax25_dev_device_down(struct net_device *dev)
  {
  	ax25_dev *s, *ax25_dev;
- 	unsigned long flags;
  
  	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
  		return;
  
  	ax25_unregister_sysctl();
  
- 	save_flags(flags); cli();
- 
  #ifdef CONFIG_AX25_DAMA_SLAVE
  	ax25_ds_del_timer(ax25_dev);
  #endif
  
  	/*
  	 *	Remove any packet forwarding that points to this device.
  	 */
--- 129,146 ----
  void ax25_dev_device_down(struct net_device *dev)
  {
  	ax25_dev *s, *ax25_dev;
  
  	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
  		return;
  
  	ax25_unregister_sysctl();
  
  #ifdef CONFIG_AX25_DAMA_SLAVE
  	ax25_ds_del_timer(ax25_dev);
  #endif
  
+ 	write_lock(&ax25_dev_lock);
+ 	
  	/*
  	 *	Remove any packet forwarding that points to this device.
  	 */
***************
*** 133,139 ****
  
  	if ((s = ax25_dev_list) == ax25_dev) {
  		ax25_dev_list = s->next;
! 		restore_flags(flags);
  		kfree(ax25_dev);
  		ax25_register_sysctl();
  		return;
--- 150,156 ----
  
  	if ((s = ax25_dev_list) == ax25_dev) {
  		ax25_dev_list = s->next;
! 		write_unlock(&ax25_dev_lock);
  		kfree(ax25_dev);
  		ax25_register_sysctl();
  		return;
***************
*** 142,148 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == ax25_dev) {
  			s->next = ax25_dev->next;
! 			restore_flags(flags);
  			kfree(ax25_dev);
  			ax25_register_sysctl();
  			return;
--- 159,165 ----
  	while (s != NULL && s->next != NULL) {
  		if (s->next == ax25_dev) {
  			s->next = ax25_dev->next;
! 			write_unlock(&ax25_dev_lock);
  			kfree(ax25_dev);
  			ax25_register_sysctl();
  			return;
***************
*** 151,157 ****
  		s = s->next;
  	}
  
! 	restore_flags(flags);
  	ax25_register_sysctl();
  }
  
--- 168,175 ----
  		s = s->next;
  	}
  
! 	write_unlock(&ax25_dev_lock);
! 	
  	ax25_register_sysctl();
  }
  
***************
*** 202,213 ****
   */
  void __exit ax25_dev_free(void)
  {
! 	ax25_dev *s, *ax25_dev = ax25_dev_list;
  
  	while (ax25_dev != NULL) {
  		s        = ax25_dev;
  		ax25_dev = ax25_dev->next;
- 
  		kfree(s);
  	}
  }
--- 220,236 ----
   */
  void __exit ax25_dev_free(void)
  {
! 	ax25_dev *s, *ax25_dev;
! 	
! 	write_lock(&ax25_dev_lock);
! 	
! 	ax25_dev = ax25_dev_list;
  
  	while (ax25_dev != NULL) {
  		s        = ax25_dev;
  		ax25_dev = ax25_dev->next;
  		kfree(s);
  	}
+ 	
+ 	write_unlock(&ax25_dev_lock);
  }
Index: linux-2.4.23/net/ax25/ax25_ds_in.c
diff -c linux-2.4.23/net/ax25/ax25_ds_in.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_ds_in.c:1.4
*** linux-2.4.23/net/ax25/ax25_ds_in.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_ds_in.c	Fri Jan  9 10:56:59 2004
***************
*** 79,88 ****
  			ax25->state   = AX25_STATE_3;
  			ax25->n2count = 0;
  			if (ax25->sk != NULL) {
  				ax25->sk->state = TCP_ESTABLISHED;
  				/* For WAIT_SABM connections we will produce an accept ready socket here */
! 				if (!ax25->sk->dead)
  					ax25->sk->state_change(ax25->sk);
  			}
  			ax25_dama_on(ax25);
  
--- 79,91 ----
  			ax25->state   = AX25_STATE_3;
  			ax25->n2count = 0;
  			if (ax25->sk != NULL) {
+ 				bh_lock_sock(ax25->sk);
  				ax25->sk->state = TCP_ESTABLISHED;
  				/* For WAIT_SABM connections we will produce an accept ready socket here */
! 				if (!ax25->sk->dead) {
  					ax25->sk->state_change(ax25->sk);
+ 				}
+ 				bh_unlock_sock(ax25->sk);
  			}
  			ax25_dama_on(ax25);
  
***************
*** 94,100 ****
  			break;
  
  		case AX25_DM:
! 			if (pf) ax25_disconnect(ax25, ECONNREFUSED);
  			break;
  
  		default:
--- 97,103 ----
  			break;
  
  		case AX25_DM:
! 			if (pf) ax25_disconnect(ax25, ECONNREFUSED, 1);
  			break;
  
  		default:
***************
*** 122,135 ****
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_DM:
  		case AX25_UA:
  			if (pf) {
  				ax25_dama_off(ax25);
! 				ax25_disconnect(ax25, 0);
  			}
  			break;
  
--- 125,138 ----
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, 0, 1);
  			break;
  
  		case AX25_DM:
  		case AX25_UA:
  			if (pf) {
  				ax25_dama_off(ax25);
! 				ax25_disconnect(ax25, 0, 1);
  			}
  			break;
  
***************
*** 184,195 ****
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_DM:
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, ECONNRESET);
  			break;
  
  		case AX25_RR:
--- 187,198 ----
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, 0, 1);
  			break;
  
  		case AX25_DM:
  			ax25_dama_off(ax25);
! 			ax25_disconnect(ax25, ECONNRESET, 1);
  			break;
  
  		case AX25_RR:
Index: linux-2.4.23/net/ax25/ax25_ds_subr.c
diff -c linux-2.4.23/net/ax25/ax25_ds_subr.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_ds_subr.c:1.2
*** linux-2.4.23/net/ax25/ax25_ds_subr.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_ds_subr.c	Sun Nov 30 21:17:14 2003
***************
*** 42,47 ****
--- 42,48 ----
  #include <linux/fcntl.h>
  #include <linux/mm.h>
  #include <linux/interrupt.h>
+ #include <linux/spinlock.h>
  
  void ax25_ds_nr_error_recovery(ax25_cb *ax25)
  {
***************
*** 85,98 ****
  		ax25_kick(ax25);
  	}
  
! 	if (ax25->state == AX25_STATE_1 || ax25->state == AX25_STATE_2 || skb_peek(&ax25->ack_queue) != NULL)
  		ax25_ds_t1_timeout(ax25);
! 	else
  		ax25->n2count = 0;
! 
  	ax25_start_t3timer(ax25);
  	ax25_ds_set_timer(ax25->ax25_dev);
  
  	for (ax25o = ax25_list; ax25o != NULL; ax25o = ax25o->next) {
  		if (ax25o == ax25)
  			continue;
--- 86,102 ----
  		ax25_kick(ax25);
  	}
  
! 	if (ax25->state == AX25_STATE_1 || ax25->state == AX25_STATE_2 || skb_peek(&ax25->ack_queue) != NULL) {
  		ax25_ds_t1_timeout(ax25);
! 	} else {
  		ax25->n2count = 0;
! 	}
! 	
  	ax25_start_t3timer(ax25);
  	ax25_ds_set_timer(ax25->ax25_dev);
  
+ 	read_lock_bh(&ax25_list_lock);
+ 	
  	for (ax25o = ax25_list; ax25o != NULL; ax25o = ax25o->next) {
  		if (ax25o == ax25)
  			continue;
***************
*** 109,123 ****
  			ax25_requeue_frames(ax25o);
  			ax25_kick(ax25o);
  		}
! 
! 		if (ax25o->state == AX25_STATE_1 || ax25o->state == AX25_STATE_2 || skb_peek(&ax25o->ack_queue) != NULL)
  			ax25_ds_t1_timeout(ax25o);
! 
  		/* do not start T3 for listening sockets (tnx DD8NE) */
  
  		if (ax25o->state != AX25_STATE_0)
  			ax25_start_t3timer(ax25o);
  	}
  }
  
  void ax25_ds_establish_data_link(ax25_cb *ax25)
--- 113,130 ----
  			ax25_requeue_frames(ax25o);
  			ax25_kick(ax25o);
  		}
! 		
! 		if (ax25o->state == AX25_STATE_1 || ax25o->state == AX25_STATE_2 || skb_peek(&ax25o->ack_queue) != NULL) {
  			ax25_ds_t1_timeout(ax25o);
! 		}
! 		
  		/* do not start T3 for listening sockets (tnx DD8NE) */
  
  		if (ax25o->state != AX25_STATE_0)
  			ax25_start_t3timer(ax25o);
  	}
+ 	
+ 	read_unlock_bh(&ax25_list_lock);
  }
  
  void ax25_ds_establish_data_link(ax25_cb *ax25)
***************
*** 171,181 ****
  static int ax25_check_dama_slave(ax25_dev *ax25_dev)
  {
  	ax25_cb *ax25;
  
! 	for (ax25 = ax25_list; ax25 != NULL ; ax25 = ax25->next)
! 		if (ax25->ax25_dev == ax25_dev && (ax25->condition & AX25_COND_DAMA_MODE) && ax25->state > AX25_STATE_1)
  			return 1;
! 
  	return 0;
  }
  
--- 178,196 ----
  static int ax25_check_dama_slave(ax25_dev *ax25_dev)
  {
  	ax25_cb *ax25;
+ 	unsigned long flags;
  
! 	read_lock_bh(&ax25_list_lock);
! 	
! 	for (ax25 = ax25_list; ax25 != NULL ; ax25 = ax25->next) {
! 		if (ax25->ax25_dev == ax25_dev && (ax25->condition & AX25_COND_DAMA_MODE) && ax25->state > AX25_STATE_1) {
! 			read_unlock_bh(&ax25_list_lock);
  			return 1;
! 		}
! 	}
! 	
! 	read_unlock_bh(&ax25_list_lock);
! 	
  	return 0;
  }
  
Index: linux-2.4.23/net/ax25/ax25_ds_timer.c
diff -c linux-2.4.23/net/ax25/ax25_ds_timer.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_ds_timer.c:1.4
*** linux-2.4.23/net/ax25/ax25_ds_timer.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_ds_timer.c	Fri Jan  9 10:56:59 2004
***************
*** 13,18 ****
--- 13,19 ----
   *	AX.25 036	Jonathan(G4KLX)	Cloned from ax25_timer.c.
   *			Joerg(DL1BKE)	Added DAMA Slave Timeout timer
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Unaccepted connection fix, spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 35,40 ****
--- 36,42 ----
  #include <linux/fcntl.h>
  #include <linux/mm.h>
  #include <linux/interrupt.h>
+ #include <linux/spinlock.h>
  
  static void ax25_ds_timeout(unsigned long);
  
***************
*** 88,101 ****
  		return;
  	}
  	
  	for (ax25=ax25_list; ax25 != NULL; ax25 = ax25->next) {
  		if (ax25->ax25_dev != ax25_dev || !(ax25->condition & AX25_COND_DAMA_MODE))
  			continue;
  
  		ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 		ax25_disconnect(ax25, ETIMEDOUT);
  	}
  	
  	ax25_dev_dama_off(ax25_dev);
  }
  
--- 90,107 ----
  		return;
  	}
  	
+ 	read_lock(&ax25_list_lock);
+ 	
  	for (ax25=ax25_list; ax25 != NULL; ax25 = ax25->next) {
  		if (ax25->ax25_dev != ax25_dev || !(ax25->condition & AX25_COND_DAMA_MODE))
  			continue;
  
  		ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 		ax25_disconnect(ax25, ETIMEDOUT, 1);
  	}
  	
+ 	read_unlock(&ax25_list_lock);
+ 	
  	ax25_dev_dama_off(ax25_dev);
  }
  
***************
*** 106,113 ****
  		case AX25_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (ax25->sk == NULL || ax25->sk->destroy || (ax25->sk->state == TCP_LISTEN && ax25->sk->dead)) {
! 				ax25_destroy_socket(ax25);
  				return;
  			}
  			break;
--- 112,128 ----
  		case AX25_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (ax25->sk == NULL || ax25->sk->destroy || (ax25->sk->state == TCP_CLOSE && ax25->sk->dead)) {
! 				struct sock *sk = ax25->sk;
! 				if (sk) {
! 					sock_hold(sk);
! 					bh_lock_sock(sk);
! 					ax25_destroy_socket(ax25);
! 					bh_unlock_sock(sk);
! 					sock_put(sk);
! 				} else {
! 					ax25_destroy_socket(ax25);
! 				}
  				return;
  			}
  			break;
***************
*** 138,144 ****
  {
  	ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
  	ax25_dama_off(ax25);
! 	ax25_disconnect(ax25, ETIMEDOUT);
  }
  
  /* dl1bke 960228: close the connection when IDLE expires.
--- 153,159 ----
  {
  	ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
  	ax25_dama_off(ax25);
! 	ax25_disconnect(ax25, ETIMEDOUT, 1);
  }
  
  /* dl1bke 960228: close the connection when IDLE expires.
***************
*** 157,168 ****
  	ax25_stop_t3timer(ax25);
  
  	if (ax25->sk != NULL) {
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = 0;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead)
  			ax25->sk->state_change(ax25->sk);
! 		ax25->sk->dead      = 1;
  	}
  }
  
--- 172,185 ----
  	ax25_stop_t3timer(ax25);
  
  	if (ax25->sk != NULL) {
+ 		bh_lock_sock(ax25->sk);
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = 0;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead) {
  			ax25->sk->state_change(ax25->sk);
! 		}
! 		bh_unlock_sock(ax25->sk);
  	}
  }
  
***************
*** 181,187 ****
  		case AX25_STATE_1: 
  			if (ax25->n2count == ax25->n2) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ETIMEDOUT);
  					return;
  				} else {
  					ax25->modulus = AX25_MODULUS;
--- 198,204 ----
  		case AX25_STATE_1: 
  			if (ax25->n2count == ax25->n2) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ETIMEDOUT, 1);
  					return;
  				} else {
  					ax25->modulus = AX25_MODULUS;
***************
*** 201,207 ****
  		case AX25_STATE_2:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(ax25, ETIMEDOUT);
  				return;
  			} else {
  				ax25->n2count++;
--- 218,224 ----
  		case AX25_STATE_2:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(ax25, ETIMEDOUT, 1);
  				return;
  			} else {
  				ax25->n2count++;
***************
*** 211,217 ****
  		case AX25_STATE_3:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);
! 				ax25_disconnect(ax25, ETIMEDOUT);
  				return;
  			} else {
  				ax25->n2count++;
--- 228,234 ----
  		case AX25_STATE_3:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);
! 				ax25_disconnect(ax25, ETIMEDOUT, 1);
  				return;
  			} else {
  				ax25->n2count++;
Index: linux-2.4.23/net/ax25/ax25_iface.c
diff -c linux-2.4.23/net/ax25/ax25_iface.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_iface.c:1.2
*** linux-2.4.23/net/ax25/ax25_iface.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_iface.c	Sun Nov 30 21:17:14 2003
***************
*** 11,16 ****
--- 11,17 ----
   *
   *	History
   *	AX.25 036	Jonathan(G4KLX)	Split from ax25_timer.c.
+  *			Tihomir(9A4GL)	Protecting lists with spinlock/rw_lock...
   */
  
  #include <linux/config.h>
***************
*** 34,39 ****
--- 35,41 ----
  #include <linux/fcntl.h>
  #include <linux/mm.h>
  #include <linux/interrupt.h>
+ #include <linux/spinlock.h>
  
  static struct protocol_struct {
  	struct protocol_struct *next;
***************
*** 41,61 ****
  	int (*func)(struct sk_buff *, ax25_cb *);
  } *protocol_list;
  
  static struct linkfail_struct {
  	struct linkfail_struct *next;
  	void (*func)(ax25_cb *, int);
  } *linkfail_list;
  
  static struct listen_struct {
  	struct listen_struct *next;
  	ax25_address  callsign;
  	struct net_device *dev;
  } *listen_list;
  
  int ax25_protocol_register(unsigned int pid, int (*func)(struct sk_buff *, ax25_cb *))
  {
  	struct protocol_struct *protocol;
- 	unsigned long flags;
  
  	if (pid == AX25_P_TEXT || pid == AX25_P_SEGMENT)
  		return 0;
--- 43,68 ----
  	int (*func)(struct sk_buff *, ax25_cb *);
  } *protocol_list;
  
+ static rwlock_t protocol_list_lock = RW_LOCK_UNLOCKED;
+ 
  static struct linkfail_struct {
  	struct linkfail_struct *next;
  	void (*func)(ax25_cb *, int);
  } *linkfail_list;
  
+ static rwlock_t linkfail_list_lock = RW_LOCK_UNLOCKED;
+ 
  static struct listen_struct {
  	struct listen_struct *next;
  	ax25_address  callsign;
  	struct net_device *dev;
  } *listen_list;
  
+ static rwlock_t listen_list_lock = RW_LOCK_UNLOCKED;
+ 
  int ax25_protocol_register(unsigned int pid, int (*func)(struct sk_buff *, ax25_cb *))
  {
  	struct protocol_struct *protocol;
  
  	if (pid == AX25_P_TEXT || pid == AX25_P_SEGMENT)
  		return 0;
***************
*** 69,99 ****
  	protocol->pid  = pid;
  	protocol->func = func;
  
! 	save_flags(flags);
! 	cli();
! 
  	protocol->next = protocol_list;
  	protocol_list  = protocol;
  
! 	restore_flags(flags);
  
  	return 1;
  }
  
  void ax25_protocol_release(unsigned int pid)
  {
! 	struct protocol_struct *s, *protocol = protocol_list;
! 	unsigned long flags;
  
! 	if (protocol == NULL)
  		return;
  
- 	save_flags(flags);
- 	cli();
  
  	if (protocol->pid == pid) {
  		protocol_list = protocol->next;
! 		restore_flags(flags);
  		kfree(protocol);
  		return;
  	}
--- 76,108 ----
  	protocol->pid  = pid;
  	protocol->func = func;
  
! 	write_lock(&protocol_list_lock);
! 	
  	protocol->next = protocol_list;
  	protocol_list  = protocol;
  
! 	write_unlock(&protocol_list_lock);
  
  	return 1;
  }
  
  void ax25_protocol_release(unsigned int pid)
  {
! 	struct protocol_struct *s, *protocol;
  
! 	write_lock(&protocol_list_lock);
! 	
! 	protocol = protocol_list;
! 	
! 	if (protocol == NULL) {
! 		write_unlock(&protocol_list_lock);
  		return;
+ 	}
  
  
  	if (protocol->pid == pid) {
  		protocol_list = protocol->next;
! 		write_unlock(&protocol_list_lock);
  		kfree(protocol);
  		return;
  	}
***************
*** 102,108 ****
  		if (protocol->next->pid == pid) {
  			s = protocol->next;
  			protocol->next = protocol->next->next;
! 			restore_flags(flags);
  			kfree(s);
  			return;
  		}
--- 111,117 ----
  		if (protocol->next->pid == pid) {
  			s = protocol->next;
  			protocol->next = protocol->next->next;
! 			write_unlock(&protocol_list_lock);
  			kfree(s);
  			return;
  		}
***************
*** 110,153 ****
  		protocol = protocol->next;
  	}
  
! 	restore_flags(flags);
  }
  
  int ax25_linkfail_register(void (*func)(ax25_cb *, int))
  {
  	struct linkfail_struct *linkfail;
- 	unsigned long flags;
  
  	if ((linkfail = kmalloc(sizeof(*linkfail), GFP_ATOMIC)) == NULL)
  		return 0;
  
  	linkfail->func = func;
  
! 	save_flags(flags);
! 	cli();
! 
  	linkfail->next = linkfail_list;
  	linkfail_list  = linkfail;
  
! 	restore_flags(flags);
  
  	return 1;
  }
  
  void ax25_linkfail_release(void (*func)(ax25_cb *, int))
  {
! 	struct linkfail_struct *s, *linkfail = linkfail_list;
! 	unsigned long flags;
  
! 	if (linkfail == NULL)
  		return;
  
- 	save_flags(flags);
- 	cli();
  
  	if (linkfail->func == func) {
  		linkfail_list = linkfail->next;
! 		restore_flags(flags);
  		kfree(linkfail);
  		return;
  	}
--- 119,163 ----
  		protocol = protocol->next;
  	}
  
! 	write_unlock(&protocol_list_lock);
  }
  
  int ax25_linkfail_register(void (*func)(ax25_cb *, int))
  {
  	struct linkfail_struct *linkfail;
  
  	if ((linkfail = kmalloc(sizeof(*linkfail), GFP_ATOMIC)) == NULL)
  		return 0;
  
  	linkfail->func = func;
  
! 	write_lock(&linkfail_list_lock);
! 	
  	linkfail->next = linkfail_list;
  	linkfail_list  = linkfail;
  
! 	write_unlock(&linkfail_list_lock);
  
  	return 1;
  }
  
  void ax25_linkfail_release(void (*func)(ax25_cb *, int))
  {
! 	struct linkfail_struct *s, *linkfail;
  
! 	write_lock(&linkfail_list_lock);
! 	
! 	linkfail = linkfail_list;
! 	
! 	if (linkfail == NULL) {
! 		write_unlock(&linkfail_list_lock);
  		return;
+ 	}
  
  
  	if (linkfail->func == func) {
  		linkfail_list = linkfail->next;
! 		write_unlock(&linkfail_list_lock);
  		kfree(linkfail);
  		return;
  	}
***************
*** 156,162 ****
  		if (linkfail->next->func == func) {
  			s = linkfail->next;
  			linkfail->next = linkfail->next->next;
! 			restore_flags(flags);
  			kfree(s);
  			return;
  		}
--- 166,172 ----
  		if (linkfail->next->func == func) {
  			s = linkfail->next;
  			linkfail->next = linkfail->next->next;
! 			write_unlock(&linkfail_list_lock);
  			kfree(s);
  			return;
  		}
***************
*** 164,176 ****
  		linkfail = linkfail->next;
  	}
  
! 	restore_flags(flags);
  }
  
  int ax25_listen_register(ax25_address *callsign, struct net_device *dev)
  {
  	struct listen_struct *listen;
- 	unsigned long flags;
  
  	if (ax25_listen_mine(callsign, dev))
  		return 0;
--- 174,185 ----
  		linkfail = linkfail->next;
  	}
  
! 	write_unlock(&linkfail_list_lock);
  }
  
  int ax25_listen_register(ax25_address *callsign, struct net_device *dev)
  {
  	struct listen_struct *listen;
  
  	if (ax25_listen_mine(callsign, dev))
  		return 0;
***************
*** 181,211 ****
  	listen->callsign = *callsign;
  	listen->dev      = dev;
  
! 	save_flags(flags);
! 	cli();
  
  	listen->next = listen_list;
  	listen_list  = listen;
  
! 	restore_flags(flags);
  
  	return 1;
  }
  
  void ax25_listen_release(ax25_address *callsign, struct net_device *dev)
  {
! 	struct listen_struct *s, *listen = listen_list;
! 	unsigned long flags;
  
! 	if (listen == NULL)
  		return;
  
- 	save_flags(flags);
- 	cli();
  
  	if (ax25cmp(&listen->callsign, callsign) == 0 && listen->dev == dev) {
  		listen_list = listen->next;
! 		restore_flags(flags);
  		kfree(listen);
  		return;
  	}
--- 190,222 ----
  	listen->callsign = *callsign;
  	listen->dev      = dev;
  
! 	write_lock(&listen_list_lock);
  
  	listen->next = listen_list;
  	listen_list  = listen;
  
! 	write_unlock(&listen_list_lock);
  
  	return 1;
  }
  
  void ax25_listen_release(ax25_address *callsign, struct net_device *dev)
  {
! 	struct listen_struct *s, *listen;
  
! 	write_lock(&listen_list_lock);
! 	
! 	listen = listen_list;
! 		
! 	if (listen == NULL) {
! 		write_unlock(&listen_list_lock);
  		return;
+ 	}
  
  
  	if (ax25cmp(&listen->callsign, callsign) == 0 && listen->dev == dev) {
  		listen_list = listen->next;
! 		write_unlock(&listen_list_lock);
  		kfree(listen);
  		return;
  	}
***************
*** 214,220 ****
  		if (ax25cmp(&listen->next->callsign, callsign) == 0 && listen->next->dev == dev) {
  			s = listen->next;
  			listen->next = listen->next->next;
! 			restore_flags(flags);
  			kfree(s);
  			return;
  		}
--- 225,231 ----
  		if (ax25cmp(&listen->next->callsign, callsign) == 0 && listen->next->dev == dev) {
  			s = listen->next;
  			listen->next = listen->next->next;
! 			write_unlock(&listen_list_lock);
  			kfree(s);
  			return;
  		}
***************
*** 222,238 ****
  		listen = listen->next;
  	}
  
! 	restore_flags(flags);
  }
  
  int (*ax25_protocol_function(unsigned int pid))(struct sk_buff *, ax25_cb *)
  {
  	struct protocol_struct *protocol;
  
! 	for (protocol = protocol_list; protocol != NULL; protocol = protocol->next)
! 		if (protocol->pid == pid)
! 			return protocol->func;
  
  	return NULL;
  }
  
--- 233,258 ----
  		listen = listen->next;
  	}
  
! 	write_unlock(&listen_list_lock);
  }
  
  int (*ax25_protocol_function(unsigned int pid))(struct sk_buff *, ax25_cb *)
  {
  	struct protocol_struct *protocol;
+ 	
+ 	read_lock(&protocol_list_lock);
  
! 	for (protocol = protocol_list; protocol != NULL; protocol = protocol->next) {
! 		if (protocol->pid == pid) {
! 			int (*func)(struct sk_buff *, ax25_cb *);
! 			func = protocol->func;
! 			read_unlock(&protocol_list_lock);
! 			return func;
! 		}
! 	}
  
+ 	read_unlock(&protocol_list_lock);
+ 	
  	return NULL;
  }
  
***************
*** 240,249 ****
  {
  	struct listen_struct *listen;
  
! 	for (listen = listen_list; listen != NULL; listen = listen->next)
! 		if (ax25cmp(&listen->callsign, callsign) == 0 && (listen->dev == dev || listen->dev == NULL))
  			return 1;
  
  	return 0;
  }
  
--- 260,276 ----
  {
  	struct listen_struct *listen;
  
! 	read_lock(&listen_list_lock);
! 	
! 	for (listen = listen_list; listen != NULL; listen = listen->next) {
! 		if (ax25cmp(&listen->callsign, callsign) == 0 && (listen->dev == dev || listen->dev == NULL)) {
! 			read_unlock(&listen_list_lock);
  			return 1;
+ 		}
+ 	}
  
+ 	read_unlock(&listen_list_lock);
+ 	
  	return 0;
  }
  
***************
*** 251,268 ****
  {
  	struct linkfail_struct *linkfail;
  
  	for (linkfail = linkfail_list; linkfail != NULL; linkfail = linkfail->next)
  		(linkfail->func)(ax25, reason);
  }
  
  int ax25_protocol_is_registered(unsigned int pid)
  {
  	struct protocol_struct *protocol;
  
! 	for (protocol = protocol_list; protocol != NULL; protocol = protocol->next)
! 		if (protocol->pid == pid)
  			return 1;
  
  	return 0;
  }
  
--- 278,306 ----
  {
  	struct linkfail_struct *linkfail;
  
+ 	read_lock(&linkfail_list_lock);
+ 	
  	for (linkfail = linkfail_list; linkfail != NULL; linkfail = linkfail->next)
  		(linkfail->func)(ax25, reason);
+ 	
+ 	read_unlock(&linkfail_list_lock);
  }
  
  int ax25_protocol_is_registered(unsigned int pid)
  {
  	struct protocol_struct *protocol;
  
! 	read_lock(&protocol_list_lock);
! 	
! 	for (protocol = protocol_list; protocol != NULL; protocol = protocol->next) {
! 		if (protocol->pid == pid) {
! 			read_unlock(&protocol_list_lock);
  			return 1;
+ 		}
+ 	}
  
+ 	read_unlock(&protocol_list_lock);
+ 	
  	return 0;
  }
  
Index: linux-2.4.23/net/ax25/ax25_in.c
diff -c linux-2.4.23/net/ax25/ax25_in.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_in.c:1.4
*** linux-2.4.23/net/ax25/ax25_in.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_in.c	Fri Jan  9 10:56:59 2004
***************
*** 37,42 ****
--- 37,43 ----
   *			Joerg(DL1BKE)	Fixed DAMA Slave.
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
   *			Thomas(DL9SAU)  Fixed missing initialization of skb->protocol.
+  *			Tihomir(9A4GL)	Spinlocking....
   */
  
  #include <linux/config.h>
***************
*** 71,77 ****
  static int ax25_rx_fragment(ax25_cb *ax25, struct sk_buff *skb)
  {
  	struct sk_buff *skbn, *skbo;
! 
  	if (ax25->fragno != 0) {
  		if (!(*skb->data & AX25_SEG_FIRST)) {
  			if ((ax25->fragno - 1) == (*skb->data & AX25_SEG_REM)) {
--- 72,78 ----
  static int ax25_rx_fragment(ax25_cb *ax25, struct sk_buff *skb)
  {
  	struct sk_buff *skbn, *skbo;
! 	
  	if (ax25->fragno != 0) {
  		if (!(*skb->data & AX25_SEG_FIRST)) {
  			if ((ax25->fragno - 1) == (*skb->data & AX25_SEG_REM)) {
***************
*** 79,84 ****
--- 80,86 ----
  				ax25->fragno = *skb->data & AX25_SEG_REM;
  				skb_pull(skb, 1);	/* skip fragno */
  				ax25->fraglen += skb->len;
+ 				
  				skb_queue_tail(&ax25->frag_queue, skb);
  
  				/* Last fragment received ? */
***************
*** 273,280 ****
  	if ((*skb->data & ~0x10) == AX25_UI && dp.lastrepeat + 1 == dp.ndigi) {
  		skb->h.raw = skb->data + 2;		/* skip control and pid */
  
! 		if ((raw = ax25_addr_match(&dest)) != NULL)
  			ax25_send_to_raw(raw, skb, skb->data[1]);
  
  		if (!mine && ax25cmp(&dest, (ax25_address *)dev->broadcast) != 0) {
  			kfree_skb(skb);
--- 275,284 ----
  	if ((*skb->data & ~0x10) == AX25_UI && dp.lastrepeat + 1 == dp.ndigi) {
  		skb->h.raw = skb->data + 2;		/* skip control and pid */
  
! 		if ((raw = ax25_addr_match(&dest)) != NULL) {
  			ax25_send_to_raw(raw, skb, skb->data[1]);
+ 			sock_put(raw);
+ 		}
  
  		if (!mine && ax25cmp(&dest, (ax25_address *)dev->broadcast) != 0) {
  			kfree_skb(skb);
***************
*** 307,312 ****
--- 311,317 ----
  			case AX25_P_TEXT:
  				/* Now find a suitable dgram socket */
  				if ((sk = ax25_find_socket(&dest, &src, SOCK_DGRAM)) != NULL) {
+ 					bh_lock_sock(sk);
  					if (atomic_read(&sk->rmem_alloc) >= sk->rcvbuf) {
  						kfree_skb(skb);
  					} else {
***************
*** 314,322 ****
  						 *	Remove the control and PID.
  						 */
  						skb_pull(skb, 2);
! 						if (sock_queue_rcv_skb(sk, skb) != 0)
  							kfree_skb(skb);
  					}
  				} else {
  					kfree_skb(skb);
  				}
--- 319,330 ----
  						 *	Remove the control and PID.
  						 */
  						skb_pull(skb, 2);
! 						if (sock_queue_rcv_skb(sk, skb) != 0) {
  							kfree_skb(skb);
+ 						}
  					}
+ 					bh_unlock_sock(sk);
+ 					sock_put(sk);
  				} else {
  					kfree_skb(skb);
  				}
***************
*** 355,360 ****
--- 363,369 ----
  		if (ax25_process_rx_frame(ax25, skb, type, dama) == 0)
  			kfree_skb(skb);
  
+ 		ax25_cb_put(ax25);
  		return 0;
  	}
  
***************
*** 385,401 ****
  		if (sk->ack_backlog == sk->max_ack_backlog || (make = ax25_make_new(sk, ax25_dev)) == NULL) {
  			if (mine) ax25_return_dm(dev, &src, &dest, &dp);
  			kfree_skb(skb);
  			return 0;
  		}
  
  		ax25 = make->protinfo.ax25;
  		skb_set_owner_r(skb, make);
  		skb_queue_head(&sk->receive_queue, skb);
! 
  		make->state = TCP_ESTABLISHED;
- 		make->pair  = sk;
  
  		sk->ack_backlog++;
  	} else {
  		if (!mine) {
  			kfree_skb(skb);
--- 394,414 ----
  		if (sk->ack_backlog == sk->max_ack_backlog || (make = ax25_make_new(sk, ax25_dev)) == NULL) {
  			if (mine) ax25_return_dm(dev, &src, &dest, &dp);
  			kfree_skb(skb);
+ 			sock_put(sk);
  			return 0;
  		}
  
  		ax25 = make->protinfo.ax25;
  		skb_set_owner_r(skb, make);
+ 		
  		skb_queue_head(&sk->receive_queue, skb);
! 		
  		make->state = TCP_ESTABLISHED;
  
  		sk->ack_backlog++;
+ 		
+ 		sock_put(sk); /* ax25_find_listener called sock_hold on this socket */
+ 		
  	} else {
  		if (!mine) {
  			kfree_skb(skb);
***************
*** 414,426 ****
  	ax25->source_addr = dest;
  	ax25->dest_addr   = src;
  
  	/*
  	 *	Sort out any digipeated paths.
  	 */
  	if (dp.ndigi && !ax25->digipeat &&
  	    (ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
  		kfree_skb(skb);
! 		ax25_destroy_socket(ax25);
  		return 0;
  	}
  
--- 427,457 ----
  	ax25->source_addr = dest;
  	ax25->dest_addr   = src;
  
+ #ifdef CONFIG_AX25_LINSV
+ 	if ( skb->len == 8 ) { /* we have SABM packet with INFO filed */
+ 		if ( skb->data[1] == 0xF0 ) { /* SV SABM have allways PID 0xF0 */
+ 			ax25->linsv_ver = 1;
+ 			memcpy(ax25->linsv_call, skb->data + 2, 6);
+ 		}
+ 	}
+ #endif
+ 
  	/*
  	 *	Sort out any digipeated paths.
  	 */
  	if (dp.ndigi && !ax25->digipeat &&
  	    (ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
+ 		struct sock *sk = ax25->sk;
  		kfree_skb(skb);
! 		if (sk) {
! 			sock_hold(sk);
! 			bh_lock_sock(sk);
! 			ax25_destroy_socket(ax25);
! 			bh_unlock_sock(sk);
! 			sock_put(sk);
! 		} else {
! 			ax25_destroy_socket(ax25);
! 		}
  		return 0;
  	}
  
***************
*** 437,445 ****
--- 468,482 ----
  	if ((*skb->data & ~AX25_PF) == AX25_SABME) {
  		ax25->modulus = AX25_EMODULUS;
  		ax25->window  = ax25_dev->values[AX25_VALUES_EWINDOW];
+ #ifdef CONFIG_AX25_LINSV
+ 		ax25->linsv_ext = 1;
+ #endif
  	} else {
  		ax25->modulus = AX25_MODULUS;
  		ax25->window  = ax25_dev->values[AX25_VALUES_WINDOW];
+ #ifdef CONFIG_AX25_LINSV
+ 		ax25->linsv_ext = 0;
+ #endif
  	}
  
  	ax25_send_control(ax25, AX25_UA, AX25_POLLON, AX25_RESPONSE);
***************
*** 458,465 ****
  	ax25_start_idletimer(ax25);
  
  	if (sk != NULL) {
! 		if (!sk->dead)
  			sk->data_ready(sk, skb->len);
  	} else {
  		kfree_skb(skb);
  	}
--- 495,503 ----
  	ax25_start_idletimer(ax25);
  
  	if (sk != NULL) {
! 		if (!sk->dead) {
  			sk->data_ready(sk, skb->len);
+ 		}
  	} else {
  		kfree_skb(skb);
  	}
Index: linux-2.4.23/net/ax25/ax25_ip.c
diff -c linux-2.4.23/net/ax25/ax25_ip.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_ip.c:1.2
*** linux-2.4.23/net/ax25/ax25_ip.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_ip.c	Sun Nov 30 21:17:14 2003
***************
*** 112,119 ****
  	unsigned char *bp  = skb->data;
  	struct net_device *dev;
  	ax25_address *src, *dst;
! 	ax25_route *route;
  	ax25_dev *ax25_dev;
  
  	dst = (ax25_address *)(bp + 1);
  	src = (ax25_address *)(bp + 8);
--- 112,120 ----
  	unsigned char *bp  = skb->data;
  	struct net_device *dev;
  	ax25_address *src, *dst;
! 	ax25_route _route, *route = &_route;
  	ax25_dev *ax25_dev;
+ 	ax25_cb *ax25;
  
  	dst = (ax25_address *)(bp + 1);
  	src = (ax25_address *)(bp + 8);
***************
*** 121,127 ****
    	if (arp_find(bp + 1, skb))
    		return 1;
  
! 	route    = ax25_rt_find_route(dst, NULL);
  	dev      = route->dev;
  
  	if (dev == NULL)
--- 122,128 ----
    	if (arp_find(bp + 1, skb))
    		return 1;
  
! 	route    = ax25_rt_find_route(route, dst, NULL);
  	dev      = route->dev;
  
  	if (dev == NULL)
***************
*** 173,180 ****
  			skb_pull(ourskb, AX25_HEADER_LEN - 1);	/* Keep PID */
  			ourskb->nh.raw = ourskb->data;
  
! 			ax25_send_frame(ourskb, ax25_dev->values[AX25_VALUES_PACLEN], &src_c, 
  &dst_c, route->digipeat, dev);
  
  			return 1;
  		}
--- 174,182 ----
  			skb_pull(ourskb, AX25_HEADER_LEN - 1);	/* Keep PID */
  			ourskb->nh.raw = ourskb->data;
  
! 			ax25 = ax25_send_frame(ourskb, ax25_dev->values[AX25_VALUES_PACLEN], &src_c, 
  &dst_c, route->digipeat, dev);
+ 			ax25_cb_put(ax25);
  
  			return 1;
  		}
Index: linux-2.4.23/net/ax25/ax25_out.c
diff -c linux-2.4.23/net/ax25/ax25_out.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_out.c:1.4
*** linux-2.4.23/net/ax25/ax25_out.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_out.c	Fri Jan  9 10:56:59 2004
***************
*** 32,37 ****
--- 32,38 ----
   *					again (this behaviour is _required_).
   *			Joerg(DL1BKE)	ax25_check_iframes_acked() returns a 
   *					value now (for DAMA n2count handling)
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/config.h>
***************
*** 81,91 ****
  		return ax25;		/* It already existed */
  	}
  
! 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
  		return NULL;
  
! 	if ((ax25 = ax25_create_cb()) == NULL)
  		return NULL;
  
  	ax25_fillin_cb(ax25, ax25_dev);
  
--- 82,94 ----
  		return ax25;		/* It already existed */
  	}
  
! 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) {
  		return NULL;
+ 	}
  
! 	if ((ax25 = ax25_create_cb()) == NULL) {
  		return NULL;
+ 	}
  
  	ax25_fillin_cb(ax25, ax25_dev);
  
***************
*** 94,100 ****
  
  	if (digi != NULL) {
  		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
! 			ax25_free_cb(ax25);
  			return NULL;
  		}
  		memcpy(ax25->digipeat, digi, sizeof(ax25_digi));
--- 97,103 ----
  
  	if (digi != NULL) {
  		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
! 			ax25_cb_put(ax25);
  			return NULL;
  		}
  		memcpy(ax25->digipeat, digi, sizeof(ax25_digi));
***************
*** 124,129 ****
--- 127,134 ----
  
  	ax25_output(ax25, paclen, skb);
  
+ 	ax25_cb_hold(ax25);
+ 	
  	return ax25;			/* We had to create it */
  }
  
***************
*** 138,144 ****
  	struct sk_buff *skbn;
  	unsigned char *p;
  	int frontlen, len, fragno, ka9qfrag, first = 1;
- 	unsigned long flags;
  
  	if ((skb->len - 1) > paclen) {
  		if (*skb->data == AX25_P_TEXT) {
--- 143,148 ----
***************
*** 155,165 ****
  		frontlen = skb_headroom(skb);	/* Address space + CTRL */
  
  		while (skb->len > 0) {
- 			save_flags(flags); 
- 			cli();
  
  			if ((skbn = alloc_skb(paclen + 2 + frontlen, GFP_ATOMIC)) == NULL) {
- 				restore_flags(flags);
  				printk(KERN_CRIT "AX.25: ax25_output - out of memory\n");
  				return;
  			}
--- 159,166 ----
***************
*** 167,174 ****
  			if (skb->sk != NULL)
  				skb_set_owner_w(skbn, skb->sk);
  			
- 			restore_flags(flags);
- 			
  			len = (paclen > skb->len) ? skb->len : paclen;
  
  			if (ka9qfrag == 1) {
--- 168,173 ----
***************
*** 258,278 ****
  	struct sk_buff *skb, *skbn;
  	int last = 1;
  	unsigned short start, end, next;
! 
! 	if (ax25->state != AX25_STATE_3 && ax25->state != AX25_STATE_4)
  		return;
  
! 	if (ax25->condition & AX25_COND_PEER_RX_BUSY)
  		return;
  
! 	if (skb_peek(&ax25->write_queue) == NULL)
  		return;
  
  	start = (skb_peek(&ax25->ack_queue) == NULL) ? ax25->va : ax25->vs;
  	end   = (ax25->va + ax25->window) % ax25->modulus;
! 
! 	if (start == end)
  		return;
  
  	ax25->vs = start;
  
--- 257,281 ----
  	struct sk_buff *skb, *skbn;
  	int last = 1;
  	unsigned short start, end, next;
! 	
! 	if (ax25->state != AX25_STATE_3 && ax25->state != AX25_STATE_4) {
  		return;
+ 	}
  
! 	if (ax25->condition & AX25_COND_PEER_RX_BUSY) {
  		return;
+ 	}
  
! 	if (skb_peek(&ax25->write_queue) == NULL) {
  		return;
+ 	}
  
  	start = (skb_peek(&ax25->ack_queue) == NULL) ? ax25->va : ax25->vs;
  	end   = (ax25->va + ax25->window) % ax25->modulus;
! 	
! 	if (start == end) {
  		return;
+ 	}
  
  	ax25->vs = start;
  
***************
*** 285,293 ****
--- 288,302 ----
  	/*
  	 * Dequeue the frame and copy it.
  	 */
+ 
  	skb  = skb_dequeue(&ax25->write_queue);
  
+ 	if ( skb == NULL ) {
+ 		return;
+ 	}
+ 	
  	do {
+ 		
  		if ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {
  			skb_queue_head(&ax25->write_queue, skb);
  			break;
***************
*** 323,329 ****
  		 * Requeue the original data frame.
  		 */
  		skb_queue_tail(&ax25->ack_queue, skb);
! 
  	} while (!last && (skb = skb_dequeue(&ax25->write_queue)) != NULL);
  
  	ax25->condition &= ~AX25_COND_ACK_PENDING;
--- 332,338 ----
  		 * Requeue the original data frame.
  		 */
  		skb_queue_tail(&ax25->ack_queue, skb);
! 		
  	} while (!last && (skb = skb_dequeue(&ax25->write_queue)) != NULL);
  
  	ax25->condition &= ~AX25_COND_ACK_PENDING;
***************
*** 333,338 ****
--- 342,348 ----
  		ax25_calculate_t1(ax25);
  		ax25_start_t1timer(ax25);
  	}
+ 	
  }
  
  void ax25_transmit_buffer(ax25_cb *ax25, struct sk_buff *skb, int type)
***************
*** 342,353 ****
  	int headroom;
  
  	if (ax25->ax25_dev == NULL) {
! 		ax25_disconnect(ax25, ENETUNREACH);
  		return;
  	}
  
  	headroom = ax25_addr_size(ax25->digipeat);
! 
  	if (skb_headroom(skb) < headroom) {
  		if ((skbn = skb_realloc_headroom(skb, headroom)) == NULL) {
  			printk(KERN_CRIT "AX.25: ax25_transmit_buffer - out of memory\n");
--- 352,363 ----
  	int headroom;
  
  	if (ax25->ax25_dev == NULL) {
! 		ax25_disconnect(ax25, ENETUNREACH, 1);
  		return;
  	}
  
  	headroom = ax25_addr_size(ax25->digipeat);
! 	
  	if (skb_headroom(skb) < headroom) {
  		if ((skbn = skb_realloc_headroom(skb, headroom)) == NULL) {
  			printk(KERN_CRIT "AX.25: ax25_transmit_buffer - out of memory\n");
***************
*** 363,369 ****
  	}
  
  	ptr = skb_push(skb, headroom);
! 
  	ax25_addr_build(ptr, &ax25->source_addr, &ax25->dest_addr, ax25->digipeat, type, ax25->modulus);
  
  	skb->dev = ax25->ax25_dev->dev;
--- 373,379 ----
  	}
  
  	ptr = skb_push(skb, headroom);
! 	
  	ax25_addr_build(ptr, &ax25->source_addr, &ax25->dest_addr, ax25->digipeat, type, ax25->modulus);
  
  	skb->dev = ax25->ax25_dev->dev;
Index: linux-2.4.23/net/ax25/ax25_route.c
diff -c linux-2.4.23/net/ax25/ax25_route.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_route.c:1.2
*** linux-2.4.23/net/ax25/ax25_route.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_route.c	Sun Nov 30 21:17:14 2003
***************
*** 39,44 ****
--- 39,45 ----
   *	AX.25 035	Frederic(F1OAT)	Support for pseudo-digipeating.
   *			Jonathan(G4KLX)	Support for packet forwarding.
   *			Arnaldo C. Melo s/suser/capable/
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 63,70 ****
--- 64,73 ----
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <linux/init.h>
+ #include <linux/spinlock.h>
  
  static ax25_route *ax25_route_list;
+ static rwlock_t ax25_route_lock = RW_LOCK_UNLOCKED;
  
  static ax25_route *ax25_find_route(ax25_address *, struct net_device *);
  
***************
*** 86,92 ****
  
  void ax25_rt_device_down(struct net_device *dev)
  {
! 	ax25_route *s, *t, *ax25_rt = ax25_route_list;
  	
  	while (ax25_rt != NULL) {
  		s       = ax25_rt;
--- 89,99 ----
  
  void ax25_rt_device_down(struct net_device *dev)
  {
! 	ax25_route *s, *t, *ax25_rt;
! 	
! 	write_lock(&ax25_route_lock);
! 	
! 	ax25_rt = ax25_route_list;
  	
  	while (ax25_rt != NULL) {
  		s       = ax25_rt;
***************
*** 111,127 ****
  			}
  		}
  	}
  }
  
  int ax25_rt_ioctl(unsigned int cmd, void *arg)
  {
- 	unsigned long flags;
  	ax25_route *s, *t, *ax25_rt;
  	struct ax25_routes_struct route;
  	struct ax25_route_opt_struct rt_option;
  	ax25_dev *ax25_dev;
  	int i;
! 
  	switch (cmd) {
  		case SIOCADDRT:
  			if (copy_from_user(&route, arg, sizeof(route)))
--- 118,135 ----
  			}
  		}
  	}
+ 	
+ 	write_unlock(&ax25_route_lock);
  }
  
  int ax25_rt_ioctl(unsigned int cmd, void *arg)
  {
  	ax25_route *s, *t, *ax25_rt;
  	struct ax25_routes_struct route;
  	struct ax25_route_opt_struct rt_option;
  	ax25_dev *ax25_dev;
  	int i;
! 	
  	switch (cmd) {
  		case SIOCADDRT:
  			if (copy_from_user(&route, arg, sizeof(route)))
***************
*** 130,135 ****
--- 138,144 ----
  				return -EINVAL;
  			if (route.digi_count > AX25_MAX_DIGIS)
  				return -EINVAL;
+ 			write_lock(&ax25_route_lock);
  			for (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {
  				if (ax25cmp(&ax25_rt->callsign, &route.dest_addr) == 0 && ax25_rt->dev == ax25_dev->dev) {
  					if (ax25_rt->digipeat != NULL) {
***************
*** 137,144 ****
  						ax25_rt->digipeat = NULL;
  					}
  					if (route.digi_count != 0) {
! 						if ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL)
  							return -ENOMEM;
  						ax25_rt->digipeat->lastrepeat = -1;
  						ax25_rt->digipeat->ndigi      = route.digi_count;
  						for (i = 0; i < route.digi_count; i++) {
--- 146,155 ----
  						ax25_rt->digipeat = NULL;
  					}
  					if (route.digi_count != 0) {
! 						if ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
! 							write_unlock(&ax25_route_lock);
  							return -ENOMEM;
+ 						}
  						ax25_rt->digipeat->lastrepeat = -1;
  						ax25_rt->digipeat->ndigi      = route.digi_count;
  						for (i = 0; i < route.digi_count; i++) {
***************
*** 146,156 ****
  							ax25_rt->digipeat->calls[i]    = route.digi_addr[i];
  						}
  					}
  					return 0;
  				}
  			}
! 			if ((ax25_rt = kmalloc(sizeof(ax25_route), GFP_ATOMIC)) == NULL)
  				return -ENOMEM;
  			ax25_rt->callsign     = route.dest_addr;
  			ax25_rt->dev          = ax25_dev->dev;
  			ax25_rt->digipeat     = NULL;
--- 157,170 ----
  							ax25_rt->digipeat->calls[i]    = route.digi_addr[i];
  						}
  					}
+ 					write_unlock(&ax25_route_lock);
  					return 0;
  				}
  			}
! 			if ((ax25_rt = kmalloc(sizeof(ax25_route), GFP_ATOMIC)) == NULL) {
! 				write_unlock(&ax25_route_lock);
  				return -ENOMEM;
+ 			}
  			ax25_rt->callsign     = route.dest_addr;
  			ax25_rt->dev          = ax25_dev->dev;
  			ax25_rt->digipeat     = NULL;
***************
*** 158,163 ****
--- 172,178 ----
  			if (route.digi_count != 0) {
  				if ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
  					kfree(ax25_rt);
+ 					write_unlock(&ax25_route_lock);
  					return -ENOMEM;
  				}
  				ax25_rt->digipeat->lastrepeat = -1;
***************
*** 167,176 ****
  					ax25_rt->digipeat->calls[i]    = route.digi_addr[i];
  				}
  			}
- 			save_flags(flags); cli();
  			ax25_rt->next   = ax25_route_list;
  			ax25_route_list = ax25_rt;
! 			restore_flags(flags);
  			break;
  
  		case SIOCDELRT:
--- 182,190 ----
  					ax25_rt->digipeat->calls[i]    = route.digi_addr[i];
  				}
  			}
  			ax25_rt->next   = ax25_route_list;
  			ax25_route_list = ax25_rt;
! 			write_unlock(&ax25_route_lock);
  			break;
  
  		case SIOCDELRT:
***************
*** 178,183 ****
--- 192,198 ----
  				return -EFAULT;
  			if ((ax25_dev = ax25_addr_ax25dev(&route.port_addr)) == NULL)
  				return -EINVAL;
+ 			write_lock(&ax25_route_lock);
  			ax25_rt = ax25_route_list;
  			while (ax25_rt != NULL) {
  				s       = ax25_rt;
***************
*** 201,206 ****
--- 216,222 ----
  					}
  				}
  			}
+ 			write_unlock(&ax25_route_lock);
  			break;
  
  		case SIOCAX25OPTRT:
***************
*** 208,213 ****
--- 224,230 ----
  				return -EFAULT;
  			if ((ax25_dev = ax25_addr_ax25dev(&rt_option.port_addr)) == NULL)
  				return -EINVAL;
+ 			write_lock(&ax25_route_lock);	
  			for (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {
  				if (ax25_rt->dev == ax25_dev->dev && ax25cmp(&rt_option.dest_addr, &ax25_rt->callsign) == 0) {
  					switch (rt_option.cmd) {
***************
*** 219,232 ****
--- 236,252 ----
  									ax25_rt->ip_mode = rt_option.arg;
  									break;
  								default:
+ 									write_unlock(&ax25_route_lock);
  									return -EINVAL;
  							}
  							break;
  						default:
+ 							write_unlock(&ax25_route_lock);
  							return -EINVAL;
  					}
  				}
  			}
+ 			write_unlock(&ax25_route_lock);
  			break;
  
  		default:
***************
*** 239,251 ****
  int ax25_rt_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_route *ax25_rt;
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	char *callsign;
  	int i;
    
! 	cli();
  
  	len += sprintf(buffer, "callsign  dev  mode digipeaters\n");
  
--- 259,272 ----
  int ax25_rt_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_route *ax25_rt;
+ 	char buf[11];
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	char *callsign;
  	int i;
    
! 	read_lock(&ax25_route_lock);
  
  	len += sprintf(buffer, "callsign  dev  mode digipeaters\n");
  
***************
*** 253,259 ****
  		if (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0)
  			callsign = "default";
  		else
! 			callsign = ax2asc(&ax25_rt->callsign);
  		len += sprintf(buffer + len, "%-9s %-4s",
  			callsign,
  			ax25_rt->dev ? ax25_rt->dev->name : "???");
--- 274,280 ----
  		if (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0)
  			callsign = "default";
  		else
! 			callsign = ax2asc(buf, &ax25_rt->callsign);
  		len += sprintf(buffer + len, "%-9s %-4s",
  			callsign,
  			ax25_rt->dev ? ax25_rt->dev->name : "???");
***************
*** 272,278 ****
  
  		if (ax25_rt->digipeat != NULL)
  			for (i = 0; i < ax25_rt->digipeat->ndigi; i++)
! 				len += sprintf(buffer + len, " %s", ax2asc(&ax25_rt->digipeat->calls[i]));
  
  		len += sprintf(buffer + len, "\n");
  
--- 293,299 ----
  
  		if (ax25_rt->digipeat != NULL)
  			for (i = 0; i < ax25_rt->digipeat->ndigi; i++)
! 				len += sprintf(buffer + len, " %s", ax2asc(buf, &ax25_rt->digipeat->calls[i]));
  
  		len += sprintf(buffer + len, "\n");
  
***************
*** 287,293 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 308,314 ----
  			break;
  	}
  
! 	read_unlock(&ax25_route_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 305,310 ****
--- 326,333 ----
  	ax25_route *ax25_spe_rt = NULL;
  	ax25_route *ax25_def_rt = NULL;
  	ax25_route *ax25_rt;
+ 	
+ 	read_lock(&ax25_route_lock);
  
  	/*
  	 *	Bind to the physical interface we heard them on, or the default
***************
*** 324,329 ****
--- 347,354 ----
  		}
  	}
  
+ 	read_unlock(&ax25_route_lock);
+ 	
  	if (ax25_spe_rt != NULL)
  		return ax25_spe_rt;
  
***************
*** 356,378 ****
  	ax25_route *ax25_rt;
  	ax25_address *call;
  
! 	if ((ax25_rt = ax25_find_route(addr, NULL)) == NULL)
  		return -EHOSTUNREACH;
  
! 	if ((ax25->ax25_dev = ax25_dev_ax25dev(ax25_rt->dev)) == NULL)
  		return -EHOSTUNREACH;
  
  	if ((call = ax25_findbyuid(current->euid)) == NULL) {
! 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))
  			return -EPERM;
  		call = (ax25_address *)ax25->ax25_dev->dev->dev_addr;
  	}
  
  	ax25->source_addr = *call;
  
  	if (ax25_rt->digipeat != NULL) {
! 		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL)
  			return -ENOMEM;
  		memcpy(ax25->digipeat, ax25_rt->digipeat, sizeof(ax25_digi));
  		ax25_adjust_path(addr, ax25->digipeat);
  	}
--- 381,407 ----
  	ax25_route *ax25_rt;
  	ax25_address *call;
  
! 	if ((ax25_rt = ax25_find_route(addr, NULL)) == NULL) {
  		return -EHOSTUNREACH;
+ 	}
  
! 	if ((ax25->ax25_dev = ax25_dev_ax25dev(ax25_rt->dev)) == NULL) {
  		return -EHOSTUNREACH;
+ 	}
  
  	if ((call = ax25_findbyuid(current->euid)) == NULL) {
! 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {
  			return -EPERM;
+ 		}
  		call = (ax25_address *)ax25->ax25_dev->dev->dev_addr;
  	}
  
  	ax25->source_addr = *call;
  
  	if (ax25_rt->digipeat != NULL) {
! 		if ((ax25->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
  			return -ENOMEM;
+ 		}
  		memcpy(ax25->digipeat, ax25_rt->digipeat, sizeof(ax25_digi));
  		ax25_adjust_path(addr, ax25->digipeat);
  	}
***************
*** 387,407 ****
   *	dl1bke 960117: build digipeater path
   *	dl1bke 960301: use the default route if it exists
   */
! ax25_route *ax25_rt_find_route(ax25_address *addr, struct net_device *dev)
  {
- 	static ax25_route route;
  	ax25_route *ax25_rt;
  
! 	if ((ax25_rt = ax25_find_route(addr, dev)) == NULL) {
! 		route.next     = NULL;
! 		route.callsign = *addr;
! 		route.dev      = dev;
! 		route.digipeat = NULL;
! 		route.ip_mode  = ' ';
! 		return &route;
! 	}
  
! 	return ax25_rt;
  }
  
  struct sk_buff *ax25_rt_build_path(struct sk_buff *skb, ax25_address *src, ax25_address *dest, ax25_digi *digi)
--- 416,435 ----
   *	dl1bke 960117: build digipeater path
   *	dl1bke 960301: use the default route if it exists
   */
! ax25_route *ax25_rt_find_route(ax25_route *route, ax25_address *addr, struct net_device *dev)
  {
  	ax25_route *ax25_rt;
  
! 	if ( (ax25_rt = ax25_find_route(addr, dev)) )
! 		return ax25_rt;
! 		
! 	route->next     = NULL;
! 	route->callsign = *addr;
! 	route->dev      = dev;
! 	route->digipeat = NULL;
! 	route->ip_mode  = ' ';
  
! 	return route;
  }
  
  struct sk_buff *ax25_rt_build_path(struct sk_buff *skb, ax25_address *src, ax25_address *dest, ax25_digi *digi)
***************
*** 438,444 ****
   */
  void __exit ax25_rt_free(void)
  {
! 	ax25_route *s, *ax25_rt = ax25_route_list;
  
  	while (ax25_rt != NULL) {
  		s       = ax25_rt;
--- 466,476 ----
   */
  void __exit ax25_rt_free(void)
  {
! 	ax25_route *s, *ax25_rt;
! 	
! 	write_lock(&ax25_route_lock);
! 	
! 	ax25_rt = ax25_route_list;
  
  	while (ax25_rt != NULL) {
  		s       = ax25_rt;
***************
*** 449,452 ****
--- 481,486 ----
  
  		kfree(s);
  	}
+ 	
+ 	write_unlock(&ax25_route_lock);
  }
Index: linux-2.4.23/net/ax25/ax25_std_in.c
diff -c linux-2.4.23/net/ax25/ax25_std_in.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_std_in.c:1.4
*** linux-2.4.23/net/ax25/ax25_std_in.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_std_in.c	Fri Jan  9 10:56:59 2004
***************
*** 35,40 ****
--- 35,43 ----
   *	AX.25 035	Hans(PE1AYX)	Fixed interface to IP layer.
   *	AX.25 036	Jonathan(G4KLX)	Cloned from ax25_in.c.
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Respond always to I without pf (state3 and 4).
+  *					In state4 if RNR there were situations
+  *					with no T1/T3 timers running, fixed.
   */
  
  #include <linux/errno.h>
***************
*** 95,104 ****
  				ax25->state   = AX25_STATE_3;
  				ax25->n2count = 0;
  				if (ax25->sk != NULL) {
  					ax25->sk->state = TCP_ESTABLISHED;
  					/* For WAIT_SABM connections we will produce an accept ready socket here */
! 					if (!ax25->sk->dead)
  						ax25->sk->state_change(ax25->sk);
  				}
  			}
  			break;
--- 98,110 ----
  				ax25->state   = AX25_STATE_3;
  				ax25->n2count = 0;
  				if (ax25->sk != NULL) {
+ 					bh_lock_sock(ax25->sk);
  					ax25->sk->state = TCP_ESTABLISHED;
  					/* For WAIT_SABM connections we will produce an accept ready socket here */
! 					if (!ax25->sk->dead) {
  						ax25->sk->state_change(ax25->sk);
+ 					}
+ 					bh_unlock_sock(ax25->sk);
  				}
  			}
  			break;
***************
*** 106,112 ****
  		case AX25_DM:
  			if (pf) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ECONNREFUSED);
  				} else {
  					ax25->modulus = AX25_MODULUS;
  					ax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];
--- 112,118 ----
  		case AX25_DM:
  			if (pf) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ECONNREFUSED, 1);
  				} else {
  					ax25->modulus = AX25_MODULUS;
  					ax25->window  = ax25->ax25_dev->values[AX25_VALUES_WINDOW];
***************
*** 136,147 ****
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_DM:
  		case AX25_UA:
! 			if (pf) ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_I:
--- 142,155 ----
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0, 1);
  			break;
  
  		case AX25_DM:
  		case AX25_UA:
! 			if (pf) {
! 				ax25_disconnect(ax25, 0, 1);
! 			}
  			break;
  
  		case AX25_I:
***************
*** 191,201 ****
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_DM:
! 			ax25_disconnect(ax25, ECONNRESET);
  			break;
  
  		case AX25_RR:
--- 199,209 ----
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0, 1);
  			break;
  
  		case AX25_DM:
! 			ax25_disconnect(ax25, ECONNRESET, 1);
  			break;
  
  		case AX25_RR:
***************
*** 242,248 ****
  				ax25_check_iframes_acked(ax25, nr);
  			}
  			if (ax25->condition & AX25_COND_OWN_RX_BUSY) {
! 				if (pf) ax25_std_enquiry_response(ax25);
  				break;
  			}
  			if (ns == ax25->vr) {
--- 250,263 ----
  				ax25_check_iframes_acked(ax25, nr);
  			}
  			if (ax25->condition & AX25_COND_OWN_RX_BUSY) {
! 				if (pf) {
! 					ax25_std_enquiry_response(ax25);
! 				} else {
! 					if (!(ax25->condition & AX25_COND_ACK_PENDING)) {
! 						ax25->condition |= AX25_COND_ACK_PENDING;
! 						ax25_start_t2timer(ax25);
! 					}
! 				}
  				break;
  			}
  			if (ns == ax25->vr) {
***************
*** 261,267 ****
  				}
  			} else {
  				if (ax25->condition & AX25_COND_REJECT) {
! 					if (pf) ax25_std_enquiry_response(ax25);
  				} else {
  					ax25->condition |= AX25_COND_REJECT;
  					ax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);
--- 276,289 ----
  				}
  			} else {
  				if (ax25->condition & AX25_COND_REJECT) {
! 					if (pf) {
! 						ax25_std_enquiry_response(ax25);
! 					} else {
! 						if (!(ax25->condition & AX25_COND_ACK_PENDING)) {
! 							ax25->condition |= AX25_COND_ACK_PENDING;
! 							ax25_start_t2timer(ax25);
! 						}
! 					}
  				} else {
  					ax25->condition |= AX25_COND_REJECT;
  					ax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);
***************
*** 318,328 ****
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0);
  			break;
  
  		case AX25_DM:
! 			ax25_disconnect(ax25, ECONNRESET);
  			break;
  
  		case AX25_RR:
--- 340,350 ----
  
  		case AX25_DISC:
  			ax25_send_control(ax25, AX25_UA, pf, AX25_RESPONSE);
! 			ax25_disconnect(ax25, 0, 1);
  			break;
  
  		case AX25_DM:
! 			ax25_disconnect(ax25, ECONNRESET, 1);
  			break;
  
  		case AX25_RR:
***************
*** 336,343 ****
  				ax25->n2count = 0;
  				if (ax25_validate_nr(ax25, nr)) {
  					ax25_frames_acked(ax25, nr);
  					if (ax25->vs == ax25->va) {
- 						ax25_start_t3timer(ax25);
  						ax25->state   = AX25_STATE_3;
  					} else {
  						ax25_requeue_frames(ax25);
--- 358,365 ----
  				ax25->n2count = 0;
  				if (ax25_validate_nr(ax25, nr)) {
  					ax25_frames_acked(ax25, nr);
+ 					ax25_start_t3timer(ax25);
  					if (ax25->vs == ax25->va) {
  						ax25->state   = AX25_STATE_3;
  					} else {
  						ax25_requeue_frames(ax25);
***************
*** 365,372 ****
  				ax25->n2count = 0;
  				if (ax25_validate_nr(ax25, nr)) {
  					ax25_frames_acked(ax25, nr);
  					if (ax25->vs == ax25->va) {
- 						ax25_start_t3timer(ax25);
  						ax25->state   = AX25_STATE_3;
  					} else {
  						ax25_requeue_frames(ax25);
--- 387,394 ----
  				ax25->n2count = 0;
  				if (ax25_validate_nr(ax25, nr)) {
  					ax25_frames_acked(ax25, nr);
+ 					ax25_start_t3timer(ax25);
  					if (ax25->vs == ax25->va) {
  						ax25->state   = AX25_STATE_3;
  					} else {
  						ax25_requeue_frames(ax25);
***************
*** 396,402 ****
  			}
  			ax25_frames_acked(ax25, nr);
  			if (ax25->condition & AX25_COND_OWN_RX_BUSY) {
! 				if (pf) ax25_std_enquiry_response(ax25);
  				break;
  			}
  			if (ns == ax25->vr) {
--- 418,431 ----
  			}
  			ax25_frames_acked(ax25, nr);
  			if (ax25->condition & AX25_COND_OWN_RX_BUSY) {
! 				if (pf) {
! 					ax25_std_enquiry_response(ax25);
! 				} else {
! 					if (!(ax25->condition & AX25_COND_ACK_PENDING)) {
! 						ax25->condition |= AX25_COND_ACK_PENDING;
! 						ax25_start_t2timer(ax25);
! 					}
! 				}
  				break;
  			}
  			if (ns == ax25->vr) {
***************
*** 415,421 ****
  				}
  			} else {
  				if (ax25->condition & AX25_COND_REJECT) {
! 					if (pf) ax25_std_enquiry_response(ax25);
  				} else {
  					ax25->condition |= AX25_COND_REJECT;
  					ax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);
--- 444,457 ----
  				}
  			} else {
  				if (ax25->condition & AX25_COND_REJECT) {
! 					if (pf) {
! 						ax25_std_enquiry_response(ax25);
! 					} else {
! 						if (!(ax25->condition & AX25_COND_ACK_PENDING)) {
! 							ax25->condition |= AX25_COND_ACK_PENDING;
! 							ax25_start_t2timer(ax25);
! 						}
! 					}
  				} else {
  					ax25->condition |= AX25_COND_REJECT;
  					ax25_send_control(ax25, AX25_REJ, pf, AX25_RESPONSE);
Index: linux-2.4.23/net/ax25/ax25_std_timer.c
diff -c linux-2.4.23/net/ax25/ax25_std_timer.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_std_timer.c:1.5
*** linux-2.4.23/net/ax25/ax25_std_timer.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_std_timer.c	Fri Jan  9 10:56:59 2004
***************
*** 20,25 ****
--- 20,26 ----
   *	AX.25 035	Frederic(F1OAT)	Support for pseudo-digipeating.
   *	AX.25 036	Jonathan(G4KLX)	Split from ax25_timer.c.
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Unaccepted connection fix, socket locking.
   */
  
  #include <linux/errno.h>
***************
*** 50,57 ****
  		case AX25_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (ax25->sk == NULL || ax25->sk->destroy || (ax25->sk->state == TCP_LISTEN && ax25->sk->dead)) {
! 				ax25_destroy_socket(ax25);
  				return;
  			}
  			break;
--- 51,76 ----
  		case AX25_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (ax25->sk == NULL || ax25->sk->destroy || (ax25->sk->state == TCP_CLOSE && ax25->sk->dead)) {
! 				struct sock *sk = ax25->sk;
! 				if (sk) {
! 					sk->state = TCP_CLOSE;
! 					if (!sk->dead) {
! 						if (sk->socket) {
! 							if ( sk->socket->state != SS_UNCONNECTED) {
! 								sk->socket->state = SS_DISCONNECTING;
! 							}
! 						}
! 						sk->state_change(sk);
! 					}
! 					sock_hold(sk);
! 					bh_lock_sock(sk);
! 					ax25_destroy_socket(ax25);
! 					bh_unlock_sock(sk);
! 					sock_put(sk);
! 				} else {
! 					ax25_destroy_socket(ax25);
! 				}
  				return;
  			}
  			break;
***************
*** 104,115 ****
  	ax25_stop_t3timer(ax25);
  
  	if (ax25->sk != NULL) {
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = 0;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead)
  			ax25->sk->state_change(ax25->sk);
! 		ax25->sk->dead      = 1;
  	}
  }
  
--- 123,136 ----
  	ax25_stop_t3timer(ax25);
  
  	if (ax25->sk != NULL) {
+ 		bh_lock_sock(ax25->sk);
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = 0;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead) {
  			ax25->sk->state_change(ax25->sk);
! 		}
! 		bh_unlock_sock(ax25->sk);
  	}
  }
  
***************
*** 119,125 ****
  		case AX25_STATE_1: 
  			if (ax25->n2count == ax25->n2) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ETIMEDOUT);
  					return;
  				} else {
  					ax25->modulus = AX25_MODULUS;
--- 140,146 ----
  		case AX25_STATE_1: 
  			if (ax25->n2count == ax25->n2) {
  				if (ax25->modulus == AX25_MODULUS) {
! 					ax25_disconnect(ax25, ETIMEDOUT, 1);
  					return;
  				} else {
  					ax25->modulus = AX25_MODULUS;
***************
*** 139,145 ****
  		case AX25_STATE_2:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(ax25, ETIMEDOUT);
  				return;
  			} else {
  				ax25->n2count++;
--- 160,166 ----
  		case AX25_STATE_2:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
! 				ax25_disconnect(ax25, ETIMEDOUT, 1);
  				return;
  			} else {
  				ax25->n2count++;
***************
*** 156,162 ****
  		case AX25_STATE_4:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);
! 				ax25_disconnect(ax25, ETIMEDOUT);
  				return;
  			} else {
  				ax25->n2count++;
--- 177,183 ----
  		case AX25_STATE_4:
  			if (ax25->n2count == ax25->n2) {
  				ax25_send_control(ax25, AX25_DM, AX25_POLLON, AX25_RESPONSE);
! 				ax25_disconnect(ax25, ETIMEDOUT, 1);
  				return;
  			} else {
  				ax25->n2count++;
Index: linux-2.4.23/net/ax25/ax25_subr.c
diff -c linux-2.4.23/net/ax25/ax25_subr.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_subr.c:1.4
*** linux-2.4.23/net/ax25/ax25_subr.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_subr.c	Fri Jan  9 10:56:59 2004
***************
*** 31,36 ****
--- 31,41 ----
   *					enqueued buffers of a socket..
   *	AX.25 035	Frederic(F1OAT)	Support for pseudo-digipeating.
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Spinlocking, linsv support.
+  *					In ax25_calculate_t1 if retry>29 and backoff=2
+  *					then t becomes negative and connection end in
+  *					billions years future, fixed.
+  *					ax25_disconnect locks socket.
   */
  
  #include <linux/errno.h>
***************
*** 53,61 ****
--- 58,68 ----
  #include <linux/fcntl.h>
  #include <linux/mm.h>
  #include <linux/interrupt.h>
+ #include <linux/spinlock.h>
  
  /*
   *	This routine purges all the queues of frames.
+  *	No need to lock queues
   */
  void ax25_clear_queues(ax25_cb *ax25)
  {
***************
*** 80,87 ****
  	if (ax25->va != nr) {
  		while (skb_peek(&ax25->ack_queue) != NULL && ax25->va != nr) {
  		        skb = skb_dequeue(&ax25->ack_queue);
! 			kfree_skb(skb);
! 			ax25->va = (ax25->va + 1) % ax25->modulus;
  		}
  	}
  }
--- 87,96 ----
  	if (ax25->va != nr) {
  		while (skb_peek(&ax25->ack_queue) != NULL && ax25->va != nr) {
  		        skb = skb_dequeue(&ax25->ack_queue);
! 			if (skb) {
! 				kfree_skb(skb);
! 				ax25->va = (ax25->va + 1) % ax25->modulus;
! 			}
  		}
  	}
  }
***************
*** 89,105 ****
  void ax25_requeue_frames(ax25_cb *ax25)
  {
          struct sk_buff *skb, *skb_prev = NULL;
! 
  	/*
  	 * Requeue all the un-ack-ed frames on the output queue to be picked
  	 * up by ax25_kick called from the timer. This arrangement handles the
  	 * possibility of an empty output queue.
  	 */
  	while ((skb = skb_dequeue(&ax25->ack_queue)) != NULL) {
! 		if (skb_prev == NULL)
  			skb_queue_head(&ax25->write_queue, skb);
! 		else
  			skb_append(skb_prev, skb);
  		skb_prev = skb;
  	}
  }
--- 98,115 ----
  void ax25_requeue_frames(ax25_cb *ax25)
  {
          struct sk_buff *skb, *skb_prev = NULL;
! 	
  	/*
  	 * Requeue all the un-ack-ed frames on the output queue to be picked
  	 * up by ax25_kick called from the timer. This arrangement handles the
  	 * possibility of an empty output queue.
  	 */
  	while ((skb = skb_dequeue(&ax25->ack_queue)) != NULL) {
! 		if (skb_prev == NULL) {
  			skb_queue_head(&ax25->write_queue, skb);
! 		} else {
  			skb_append(skb_prev, skb);
+ 		}
  		skb_prev = skb;
  	}
  }
***************
*** 133,139 ****
  
  	frame = skb->data;
  	*ns = *nr = *pf = 0;
! 
  	if (ax25->modulus == AX25_MODULUS) {
  		if ((frame[0] & AX25_S) == 0) {
  			frametype = AX25_I;			/* I frame - carries NR/NS/PF */
--- 143,149 ----
  
  	frame = skb->data;
  	*ns = *nr = *pf = 0;
! 	
  	if (ax25->modulus == AX25_MODULUS) {
  		if ((frame[0] & AX25_S) == 0) {
  			frametype = AX25_I;			/* I frame - carries NR/NS/PF */
***************
*** 181,188 ****
  	struct sk_buff *skb;
  	unsigned char  *dptr;
  
! 	if ((skb = alloc_skb(AX25_BPQ_HEADER_LEN + ax25_addr_size(ax25->digipeat) + 2, GFP_ATOMIC)) == NULL)
  		return;
  
  	skb_reserve(skb, AX25_BPQ_HEADER_LEN + ax25_addr_size(ax25->digipeat));
  
--- 191,211 ----
  	struct sk_buff *skb;
  	unsigned char  *dptr;
  
! #ifdef CONFIG_AX25_LINSV
! 	if (ax25->linsv_call[0] && ( frametype == AX25_SABM || frametype == AX25_SABME ) ) {
! 		if ((skb = alloc_skb(AX25_BPQ_HEADER_LEN + 7 + ax25_addr_size(ax25->digipeat) + 2, GFP_ATOMIC)) == NULL) {
! 			return;
! 		}
! 	} else {
! 		if ((skb = alloc_skb(AX25_BPQ_HEADER_LEN + ax25_addr_size(ax25->digipeat) + 2, GFP_ATOMIC)) == NULL) {
! 			return;
! 		}
! 	}
! #else
! 	if ((skb = alloc_skb(AX25_BPQ_HEADER_LEN + ax25_addr_size(ax25->digipeat) + 2, GFP_ATOMIC)) == NULL) {
  		return;
+ 	}
+ #endif
  
  	skb_reserve(skb, AX25_BPQ_HEADER_LEN + ax25_addr_size(ax25->digipeat));
  
***************
*** 208,213 ****
--- 231,243 ----
  		}
  	}
  
+ #ifdef CONFIG_AX25_LINSV
+ 	if (ax25->linsv_ver == 1 && ( frametype == AX25_SABM || frametype == AX25_SABME ) ) {
+ 		dptr = skb_put(skb, 7);
+ 		dptr[0] = 0xF0; 	/* PID of SABM frame */
+ 		memcpy(dptr+1, ax25->linsv_call, 6);
+ 	}
+ #endif
  	ax25_transmit_buffer(ax25, skb, type);
  }
  
***************
*** 264,272 ****
  			break;
  
  		case 2:
! 			for (n = 0; n < ax25->n2count; n++)
  				t *= 2;
- 			if (t > 8) t = 8;
  			break;
  	}
  
--- 294,301 ----
  			break;
  
  		case 2:
! 			for (n = 0; n < ax25->n2count && n < 2; n++)
  				t *= 2;
  			break;
  	}
  
***************
*** 291,297 ****
  		ax25->rtt = AX25_T1CLAMPHI;
  }
  
! void ax25_disconnect(ax25_cb *ax25, int reason)
  {
  	ax25_clear_queues(ax25);
  
--- 320,326 ----
  		ax25->rtt = AX25_T1CLAMPHI;
  }
  
! void ax25_disconnect(ax25_cb *ax25, int reason, int lock)
  {
  	ax25_clear_queues(ax25);
  
***************
*** 305,315 ****
  	ax25_link_failed(ax25, reason);
  
  	if (ax25->sk != NULL) {
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = reason;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead)
  			ax25->sk->state_change(ax25->sk);
! 		ax25->sk->dead      = 1;
  	}
  }
--- 334,363 ----
  	ax25_link_failed(ax25, reason);
  
  	if (ax25->sk != NULL) {
+ 		if (lock) { 
+ 			if (in_softirq()) {
+ 				bh_lock_sock(ax25->sk);
+ 			} else {
+ 				lock_sock(ax25->sk);
+ 			}
+ 		}
  		ax25->sk->state     = TCP_CLOSE;
  		ax25->sk->err       = reason;
  		ax25->sk->shutdown |= SEND_SHUTDOWN;
! 		if (!ax25->sk->dead) {
! 			if ( ax25->sk->socket ) {
! 				if ( ax25->sk->socket->state != SS_UNCONNECTED ) {
! 					ax25->sk->socket->state = SS_DISCONNECTING;
! 				}
! 			}
  			ax25->sk->state_change(ax25->sk);
! 		}
! 		if (lock) { 
! 			if (in_softirq()) {
! 				bh_unlock_sock(ax25->sk);
! 			} else {
! 				release_sock(ax25->sk);
! 			}
! 		}
  	}
  }
Index: linux-2.4.23/net/ax25/ax25_timer.c
diff -c linux-2.4.23/net/ax25/ax25_timer.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_timer.c:1.2
*** linux-2.4.23/net/ax25/ax25_timer.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_timer.c	Sun Nov 30 21:17:14 2003
***************
*** 23,28 ****
--- 23,30 ----
   *					standard AX.25 mode.
   *	AX.25 037	Jonathan(G4KLX)	New timer architecture.
   *                      Tomi(OH2BNS)    Fixed heartbeat expiry (check ax25_dev).
+  *			Tihomir(9A4GL)	Linsv support, timer holds reference to
+  *					ax25cb to avoif freeing before expirity.
   */
  
  #include <linux/config.h>
***************
*** 55,107 ****
  
  void ax25_start_heartbeat(ax25_cb *ax25)
  {
! 	del_timer(&ax25->timer);
  
  	ax25->timer.data     = (unsigned long)ax25;
  	ax25->timer.function = &ax25_heartbeat_expiry;
! 	ax25->timer.expires  = jiffies + 5 * HZ;
  
  	add_timer(&ax25->timer);
  }
  
  void ax25_start_t1timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t1timer);
  
  	ax25->t1timer.data     = (unsigned long)ax25;
  	ax25->t1timer.function = &ax25_t1timer_expiry;
  	ax25->t1timer.expires  = jiffies + ax25->t1;
  
  	add_timer(&ax25->t1timer);
  }
  
  void ax25_start_t2timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t2timer);
  
  	ax25->t2timer.data     = (unsigned long)ax25;
  	ax25->t2timer.function = &ax25_t2timer_expiry;
  	ax25->t2timer.expires  = jiffies + ax25->t2;
  
  	add_timer(&ax25->t2timer);
  }
  
  void ax25_start_t3timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t3timer);
  
  	if (ax25->t3 > 0) {
  		ax25->t3timer.data     = (unsigned long)ax25;
  		ax25->t3timer.function = &ax25_t3timer_expiry;
  		ax25->t3timer.expires  = jiffies + ax25->t3;
! 
  		add_timer(&ax25->t3timer);
  	}
  }
  
  void ax25_start_idletimer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->idletimer);
  
  	if (ax25->idle > 0) {
  		ax25->idletimer.data     = (unsigned long)ax25;
--- 57,127 ----
  
  void ax25_start_heartbeat(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->timer)) {
! 		ax25_cb_put(ax25);
! 	}
  
  	ax25->timer.data     = (unsigned long)ax25;
  	ax25->timer.function = &ax25_heartbeat_expiry;
! 	ax25->timer.expires  = jiffies + 1 * HZ;
  
  	add_timer(&ax25->timer);
+ 	ax25_cb_hold(ax25);
  }
  
  void ax25_start_t1timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t1timer)) {
! 		ax25_cb_put(ax25);
! 	}
  
  	ax25->t1timer.data     = (unsigned long)ax25;
  	ax25->t1timer.function = &ax25_t1timer_expiry;
  	ax25->t1timer.expires  = jiffies + ax25->t1;
  
  	add_timer(&ax25->t1timer);
+ 	ax25_cb_hold(ax25);
+ 	
+ #ifdef CONFIG_AX25_LINSV
+ 	ax25->linsv_t1set++;
+ #endif
  }
  
  void ax25_start_t2timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t2timer)) {
! 		ax25_cb_put(ax25);
! 	}
  
  	ax25->t2timer.data     = (unsigned long)ax25;
  	ax25->t2timer.function = &ax25_t2timer_expiry;
  	ax25->t2timer.expires  = jiffies + ax25->t2;
  
  	add_timer(&ax25->t2timer);
+ 	ax25_cb_hold(ax25);
  }
  
  void ax25_start_t3timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t3timer)) {
! 		ax25_cb_put(ax25);
! 	}
  
  	if (ax25->t3 > 0) {
  		ax25->t3timer.data     = (unsigned long)ax25;
  		ax25->t3timer.function = &ax25_t3timer_expiry;
  		ax25->t3timer.expires  = jiffies + ax25->t3;
! 		
  		add_timer(&ax25->t3timer);
+ 		ax25_cb_hold(ax25);
  	}
  }
  
  void ax25_start_idletimer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->idletimer)) {
! 		ax25_cb_put(ax25);
! 	}
  
  	if (ax25->idle > 0) {
  		ax25->idletimer.data     = (unsigned long)ax25;
***************
*** 109,140 ****
  		ax25->idletimer.expires  = jiffies + ax25->idle;
  
  		add_timer(&ax25->idletimer);
  	}
  }
  
  void ax25_stop_heartbeat(ax25_cb *ax25)
  {
! 	del_timer(&ax25->timer);
  }
  
  void ax25_stop_t1timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t1timer);
  }
  
  void ax25_stop_t2timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t2timer);
  }
  
  void ax25_stop_t3timer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->t3timer);
  }
  
  void ax25_stop_idletimer(ax25_cb *ax25)
  {
! 	del_timer(&ax25->idletimer);
  }
  
  int ax25_t1timer_running(ax25_cb *ax25)
--- 129,171 ----
  		ax25->idletimer.expires  = jiffies + ax25->idle;
  
  		add_timer(&ax25->idletimer);
+ 		ax25_cb_hold(ax25);
  	}
  }
  
  void ax25_stop_heartbeat(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->timer)) {
! 		ax25_cb_put(ax25);
! 	}
  }
  
  void ax25_stop_t1timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t1timer)) {
! 		ax25_cb_put(ax25);
! 	}
  }
  
  void ax25_stop_t2timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t2timer)) {
! 		ax25_cb_put(ax25);
! 	}
  }
  
  void ax25_stop_t3timer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->t3timer)) {
! 		ax25_cb_put(ax25);
! 	}
  }
  
  void ax25_stop_idletimer(ax25_cb *ax25)
  {
! 	if (del_timer(&ax25->idletimer)) {
! 		ax25_cb_put(ax25);
! 	}
  }
  
  int ax25_t1timer_running(ax25_cb *ax25)
***************
*** 173,178 ****
--- 204,210 ----
  			break;
  #endif
  	}
+ 	ax25_cb_put(ax25);
  }
  
  static void ax25_t1timer_expiry(unsigned long param)
***************
*** 192,197 ****
--- 224,235 ----
  			break;
  #endif
  	}
+ 	
+ #ifdef CONFIG_AX25_LINSV
+ 	ax25->linsv_t1exp++;
+ #endif
+ 
+ 	ax25_cb_put(ax25);        
  }
  
  static void ax25_t2timer_expiry(unsigned long param)
***************
*** 211,216 ****
--- 249,255 ----
  			break;
  #endif
  	}
+ 	ax25_cb_put(ax25);
  }
  
  static void ax25_t3timer_expiry(unsigned long param)
***************
*** 232,237 ****
--- 271,277 ----
  			break;
  #endif
  	}
+ 	ax25_cb_put(ax25);
  }
  
  static void ax25_idletimer_expiry(unsigned long param)
***************
*** 253,256 ****
--- 293,297 ----
  			break;
  #endif
  	}
+ 	ax25_cb_put(ax25);
  }
Index: linux-2.4.23/net/ax25/ax25_uid.c
diff -c linux-2.4.23/net/ax25/ax25_uid.c:1.1.1.1 linux-2.4.23/net/ax25/ax25_uid.c:1.2
*** linux-2.4.23/net/ax25/ax25_uid.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/ax25_uid.c	Sun Nov 30 21:17:14 2003
***************
*** 11,16 ****
--- 11,17 ----
   *
   *	History
   *	AX.25 036	Jonathan(G4KLX)	Split from af_ax25.c.
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 39,44 ****
--- 40,46 ----
  #include <linux/stat.h>
  #include <linux/netfilter.h>
  #include <linux/sysctl.h>
+ #include <linux/spinlock.h>
  #include <net/ip.h>
  #include <net/arp.h>
  
***************
*** 47,78 ****
   */
  
  static ax25_uid_assoc *ax25_uid_list;
! 
  int ax25_uid_policy = 0;
  
  ax25_address *ax25_findbyuid(uid_t uid)
  {
  	ax25_uid_assoc *ax25_uid;
  
  	for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 		if (ax25_uid->uid == uid)
! 			return &ax25_uid->call;
  	}
  
  	return NULL;
  }
  
  int ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)
  {
  	ax25_uid_assoc *s, *ax25_uid;
- 	unsigned long flags;
  
  	switch (cmd) {
  		case SIOCAX25GETUID:
  			for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 				if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0)
! 					return ax25_uid->uid;
  			}
  			return -ENOENT;
  
  		case SIOCAX25ADDUID:
--- 49,93 ----
   */
  
  static ax25_uid_assoc *ax25_uid_list;
! static rwlock_t ax25_uid_lock = RW_LOCK_UNLOCKED;
  int ax25_uid_policy = 0;
  
  ax25_address *ax25_findbyuid(uid_t uid)
  {
  	ax25_uid_assoc *ax25_uid;
+ 	
+ 	read_lock_bh(&ax25_uid_lock);
  
  	for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 		if (ax25_uid->uid == uid) {
! 			ax25_address *call;
! 			call = &ax25_uid->call;
! 			read_unlock_bh(&ax25_uid_lock);
! 			return call;
! 		}
  	}
  
+ 	read_unlock_bh(&ax25_uid_lock);
+ 	
  	return NULL;
  }
  
  int ax25_uid_ioctl(int cmd, struct sockaddr_ax25 *sax)
  {
  	ax25_uid_assoc *s, *ax25_uid;
  
  	switch (cmd) {
  		case SIOCAX25GETUID:
+ 			read_lock_bh(&ax25_uid_lock);
  			for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 				if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {
! 					uid_t uid;
! 					uid = ax25_uid->uid;
! 					read_unlock_bh(&ax25_uid_lock);
! 					return uid;
! 				}
  			}
+ 			read_unlock_bh(&ax25_uid_lock);
  			return -ENOENT;
  
  		case SIOCAX25ADDUID:
***************
*** 86,123 ****
  				return -ENOMEM;
  			ax25_uid->uid  = sax->sax25_uid;
  			ax25_uid->call = sax->sax25_call;
! 			save_flags(flags); cli();
  			ax25_uid->next = ax25_uid_list;
  			ax25_uid_list  = ax25_uid;
! 			restore_flags(flags);
  			return 0;
  
  		case SIOCAX25DELUID:
  			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
  			for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 				if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0)
  					break;
  			}
! 			if (ax25_uid == NULL)
  				return -ENOENT;
! 			save_flags(flags); cli();
  			if ((s = ax25_uid_list) == ax25_uid) {
  				ax25_uid_list = s->next;
! 				restore_flags(flags);
  				kfree(ax25_uid);
  				return 0;
  			}
  			while (s != NULL && s->next != NULL) {
  				if (s->next == ax25_uid) {
  					s->next = ax25_uid->next;
! 					restore_flags(flags);
  					kfree(ax25_uid);
  					return 0;
  				}
  				s = s->next;
  			}
! 			restore_flags(flags);
  			return -ENOENT;
  
  		default:
--- 101,145 ----
  				return -ENOMEM;
  			ax25_uid->uid  = sax->sax25_uid;
  			ax25_uid->call = sax->sax25_call;
! 			write_lock_bh(&ax25_uid_lock);
  			ax25_uid->next = ax25_uid_list;
  			ax25_uid_list  = ax25_uid;
! 			write_unlock_bh(&ax25_uid_lock);
  			return 0;
  
  		case SIOCAX25DELUID:
  			if (!capable(CAP_NET_ADMIN))
  				return -EPERM;
+ 			
+ 			write_lock_bh(&ax25_uid_lock);
  			for (ax25_uid = ax25_uid_list; ax25_uid != NULL; ax25_uid = ax25_uid->next) {
! 				if (ax25cmp(&sax->sax25_call, &ax25_uid->call) == 0) {
! 					write_unlock_bh(&ax25_uid_lock);
  					break;
+ 				}
  			}
! 			
! 			if (ax25_uid == NULL) {
! 				write_unlock_bh(&ax25_uid_lock);
  				return -ENOENT;
! 			}
! 			
  			if ((s = ax25_uid_list) == ax25_uid) {
  				ax25_uid_list = s->next;
! 				write_unlock_bh(&ax25_uid_lock);
  				kfree(ax25_uid);
  				return 0;
  			}
  			while (s != NULL && s->next != NULL) {
  				if (s->next == ax25_uid) {
  					s->next = ax25_uid->next;
! 					write_unlock_bh(&ax25_uid_lock);
  					kfree(ax25_uid);
  					return 0;
  				}
  				s = s->next;
  			}
! 			write_unlock_bh(&ax25_uid_lock);
  			return -ENOENT;
  
  		default:
***************
*** 130,145 ****
  int ax25_uid_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_uid_assoc *pt;
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  
! 	cli();
  
  	len += sprintf(buffer, "Policy: %d\n", ax25_uid_policy);
  
  	for (pt = ax25_uid_list; pt != NULL; pt = pt->next) {
! 		len += sprintf(buffer + len, "%6d %s\n", pt->uid, ax2asc(&pt->call));
  
  		pos = begin + len;
  
--- 152,168 ----
  int ax25_uid_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	ax25_uid_assoc *pt;
+ 	char buf[11];
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  
! 	read_lock_bh(&ax25_uid_lock);
  
  	len += sprintf(buffer, "Policy: %d\n", ax25_uid_policy);
  
  	for (pt = ax25_uid_list; pt != NULL; pt = pt->next) {
! 		len += sprintf(buffer + len, "%6d %s\n", pt->uid, ax2asc(buf, &pt->call));
  
  		pos = begin + len;
  
***************
*** 152,158 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= offset - begin;
--- 175,181 ----
  			break;
  	}
  
! 	read_unlock_bh(&ax25_uid_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= offset - begin;
***************
*** 167,173 ****
   */
  void __exit ax25_uid_free(void)
  {
! 	ax25_uid_assoc *s, *ax25_uid = ax25_uid_list;
  
  	while (ax25_uid != NULL) {
  		s        = ax25_uid;
--- 190,200 ----
   */
  void __exit ax25_uid_free(void)
  {
! 	ax25_uid_assoc *s, *ax25_uid;
! 	
! 	write_lock_bh(&ax25_uid_lock);
! 	
! 	ax25_uid = ax25_uid_list;
  
  	while (ax25_uid != NULL) {
  		s        = ax25_uid;
***************
*** 175,178 ****
--- 202,207 ----
  
  		kfree(s);
  	}
+ 	
+ 	write_unlock_bh(&ax25_uid_lock);
  }
Index: linux-2.4.23/net/ax25/sysctl_net_ax25.c
diff -c linux-2.4.23/net/ax25/sysctl_net_ax25.c:1.1.1.1 linux-2.4.23/net/ax25/sysctl_net_ax25.c:1.2
*** linux-2.4.23/net/ax25/sysctl_net_ax25.c:1.1.1.1	Sun Nov 30 18:35:58 2003
--- linux-2.4.23/net/ax25/sysctl_net_ax25.c	Sun Nov 30 21:17:14 2003
***************
*** 21,27 ****
--- 21,31 ----
  static int min_t3[] = {0},		max_t3[] = {3600 * HZ};
  static int min_idle[] = {0},		max_idle[] = {65535 * HZ};
  static int min_n2[] = {1},		max_n2[] = {31};
+ #ifdef CONFIG_AX25_MTU1580
+ static int min_paclen[] = {1},		max_paclen[] = {1500};
+ #else
  static int min_paclen[] = {1},		max_paclen[] = {512};
+ #endif
  static int min_proto[] = {0},		max_proto[] = {3};
  static int min_ds_timeout[] = {0},	max_ds_timeout[] = {65535 * HZ};
  
***************
*** 105,115 ****
  	ax25_dev *ax25_dev;
  	int n, k;
  
  	for (ax25_table_size = sizeof(ctl_table), ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)
  		ax25_table_size += sizeof(ctl_table);
  
! 	if ((ax25_table = kmalloc(ax25_table_size, GFP_ATOMIC)) == NULL)
  		return;
  
  	memset(ax25_table, 0x00, ax25_table_size);
  
--- 109,123 ----
  	ax25_dev *ax25_dev;
  	int n, k;
  
+ 	read_lock(&ax25_dev_lock);
+ 	
  	for (ax25_table_size = sizeof(ctl_table), ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)
  		ax25_table_size += sizeof(ctl_table);
  
! 	if ((ax25_table = kmalloc(ax25_table_size, GFP_ATOMIC)) == NULL) {
! 		read_unlock(&ax25_dev_lock);
  		return;
+ 	}
  
  	memset(ax25_table, 0x00, ax25_table_size);
  
***************
*** 119,124 ****
--- 127,133 ----
  			while (n--)
  				kfree(ax25_table[n].child);
  			kfree(ax25_table);
+ 			read_unlock(&ax25_dev_lock);
  			return;
  		}
  		memcpy(child, ax25_param_table, sizeof(ax25_param_table));
***************
*** 145,162 ****
--- 154,176 ----
  		n++;
  	}
  
+ 	read_unlock(&ax25_dev_lock);
+ 	
  	ax25_dir_table[0].child = ax25_table;
  
  	ax25_table_header = register_sysctl_table(ax25_root_table, 1);
+ 
  }
  
  void ax25_unregister_sysctl(void)
  {
  	ctl_table *p;
+ 
  	unregister_sysctl_table(ax25_table_header);
  
  	ax25_dir_table[0].child = NULL;
  	for (p = ax25_table; p->ctl_name; p++)
  		kfree(p->child);
  	kfree(ax25_table);
+ 
  }
Index: linux-2.4.23/net/netrom/af_netrom.c
diff -c linux-2.4.23/net/netrom/af_netrom.c:1.1.1.1 linux-2.4.23/net/netrom/af_netrom.c:1.3
*** linux-2.4.23/net/netrom/af_netrom.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/af_netrom.c	Fri Jan  9 10:56:59 2004
***************
*** 34,39 ****
--- 34,44 ----
   *			Jeroen(PE1RXQ)	Use sock_orphan() on release.
   *			Tomi(OH2BNS)	Better frame type checking.
   *					Device refcnt fixes.
+  *			Tihomir(9A4GL)	Spinlock list protection, socket locking,
+  *					sock_hold/put instead sk_free, sock_orphan
+  *					for unaccepted sockets, sleep with interrupts
+  *					disabled fixed.
+  *					nr control block was not dealocated, fixed.
   */
  
  #include <linux/config.h>
***************
*** 67,72 ****
--- 72,78 ----
  #include <net/ip.h>
  #include <net/arp.h>
  #include <linux/init.h>
+ #include <linux/spinlock.h>
  
  int nr_ndevs = 4;
  
***************
*** 85,101 ****
  static unsigned short circuit = 0x101;
  
  static struct sock *volatile nr_list;
  
  static struct proto_ops nr_proto_ops;
  
  static void nr_free_sock(struct sock *sk)
  {
! 	sk_free(sk);
  
  	MOD_DEC_USE_COUNT;
  }
  
! static struct sock *nr_alloc_sock(void)
  {
  	struct sock *sk;
  	nr_cb *nr;
--- 91,110 ----
  static unsigned short circuit = 0x101;
  
  static struct sock *volatile nr_list;
+ rwlock_t nr_list_lock = RW_LOCK_UNLOCKED;
  
  static struct proto_ops nr_proto_ops;
  
  static void nr_free_sock(struct sock *sk)
  {
! 	kfree(sk->protinfo.nr);
! 	sk->protinfo.nr = NULL;
! 	sock_put(sk);
  
  	MOD_DEC_USE_COUNT;
  }
  
! static struct sock *nr_alloc_sock(struct socket *sock)
  {
  	struct sock *sk;
  	nr_cb *nr;
***************
*** 103,110 ****
  	if ((sk = sk_alloc(PF_NETROM, GFP_ATOMIC, 1)) == NULL)
  		return NULL;
  
  	if ((nr = kmalloc(sizeof(*nr), GFP_ATOMIC)) == NULL) {
! 		sk_free(sk);
  		return NULL;
  	}
  
--- 112,121 ----
  	if ((sk = sk_alloc(PF_NETROM, GFP_ATOMIC, 1)) == NULL)
  		return NULL;
  
+ 	sock_init_data(sock, sk);
+ 	
  	if ((nr = kmalloc(sizeof(*nr), GFP_ATOMIC)) == NULL) {
! 		sock_put(sk);
  		return NULL;
  	}
  
***************
*** 124,137 ****
  static void nr_remove_socket(struct sock *sk)
  {
  	struct sock *s;
- 	unsigned long flags;
  
! 	save_flags(flags); cli();
  
  	if ((s = nr_list) == sk) {
  		nr_list = s->next;
  		dev_put(sk->protinfo.nr->device);
! 		restore_flags(flags);
  		return;
  	}
  
--- 135,147 ----
  static void nr_remove_socket(struct sock *sk)
  {
  	struct sock *s;
  
! 	write_lock_bh(&nr_list_lock);
  
  	if ((s = nr_list) == sk) {
  		nr_list = s->next;
  		dev_put(sk->protinfo.nr->device);
! 		write_unlock_bh(&nr_list_lock);
  		return;
  	}
  
***************
*** 139,152 ****
  		if (s->next == sk) {
  			s->next = sk->next;
  			dev_put(sk->protinfo.nr->device);
! 			restore_flags(flags);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	restore_flags(flags);
  }
  
  /*
--- 149,162 ----
  		if (s->next == sk) {
  			s->next = sk->next;
  			dev_put(sk->protinfo.nr->device);
! 			write_unlock_bh(&nr_list_lock);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	write_unlock_bh(&nr_list_lock);
  }
  
  /*
***************
*** 156,165 ****
--- 166,179 ----
  {
  	struct sock *s;
  
+ 	write_lock_bh(&nr_list_lock);
+ 	
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (s->protinfo.nr->device == dev)
  			nr_disconnect(s, ENETUNREACH);
  	}
+ 	
+ 	write_unlock_bh(&nr_list_lock);
  }
  
  /*
***************
*** 183,196 ****
   */
  static void nr_insert_socket(struct sock *sk)
  {
! 	unsigned long flags;
! 
! 	save_flags(flags); cli();
  
  	sk->next = nr_list;
  	nr_list  = sk;
  
! 	restore_flags(flags);
  }
  
  /*
--- 197,208 ----
   */
  static void nr_insert_socket(struct sock *sk)
  {
! 	write_lock_bh(&nr_list_lock);
  
  	sk->next = nr_list;
  	nr_list  = sk;
  
! 	write_unlock_bh(&nr_list_lock);
  }
  
  /*
***************
*** 199,218 ****
   */
  static struct sock *nr_find_listener(ax25_address *addr)
  {
- 	unsigned long flags;
  	struct sock *s;
  
! 	save_flags(flags);
! 	cli();
! 
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (ax25cmp(&s->protinfo.nr->source_addr, addr) == 0 && s->state == TCP_LISTEN) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  	return NULL;
  }
  
--- 211,230 ----
   */
  static struct sock *nr_find_listener(ax25_address *addr)
  {
  	struct sock *s;
  
! 	read_lock_bh(&nr_list_lock);
! 	
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (ax25cmp(&s->protinfo.nr->source_addr, addr) == 0 && s->state == TCP_LISTEN) {
! 			sock_hold(s);
! 			read_unlock_bh(&nr_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&nr_list_lock);
! 	
  	return NULL;
  }
  
***************
*** 222,240 ****
  static struct sock *nr_find_socket(unsigned char index, unsigned char id)
  {
  	struct sock *s;
- 	unsigned long flags;
- 
- 	save_flags(flags);
- 	cli();
  
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (s->protinfo.nr->my_index == index && s->protinfo.nr->my_id == id) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  
  	return NULL;
  }
--- 234,251 ----
  static struct sock *nr_find_socket(unsigned char index, unsigned char id)
  {
  	struct sock *s;
  
+ 	read_lock_bh(&nr_list_lock);
+ 	
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (s->protinfo.nr->my_index == index && s->protinfo.nr->my_id == id) {
! 			sock_hold(s);
! 			read_unlock_bh(&nr_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&nr_list_lock);
  
  	return NULL;
  }
***************
*** 245,263 ****
  static struct sock *nr_find_peer(unsigned char index, unsigned char id, ax25_address *dest)
  {
  	struct sock *s;
- 	unsigned long flags;
- 
- 	save_flags(flags);
- 	cli();
  
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (s->protinfo.nr->your_index == index && s->protinfo.nr->your_id == id && ax25cmp(&s->protinfo.nr->dest_addr, dest) == 0) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  
  	return NULL;
  }
--- 256,273 ----
  static struct sock *nr_find_peer(unsigned char index, unsigned char id, ax25_address *dest)
  {
  	struct sock *s;
  
+ 	read_lock_bh(&nr_list_lock);
+ 	
  	for (s = nr_list; s != NULL; s = s->next) {
  		if (s->protinfo.nr->your_index == index && s->protinfo.nr->your_id == id && ax25cmp(&s->protinfo.nr->dest_addr, dest) == 0) {
! 			sock_hold(s);
! 			read_unlock_bh(&nr_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&nr_list_lock);
  
  	return NULL;
  }
***************
*** 269,282 ****
  {
  	unsigned short id = circuit;
  	unsigned char i, j;
  
  	for (;;) {
  		i = id / 256;
  		j = id % 256;
  
! 		if (i != 0 && j != 0)
! 			if (nr_find_socket(i, j) == NULL)
  				break;
  
  		id++;
  	}
--- 279,297 ----
  {
  	unsigned short id = circuit;
  	unsigned char i, j;
+ 	struct sock *sk;
  
  	for (;;) {
  		i = id / 256;
  		j = id % 256;
  
! 		if (i != 0 && j != 0) {
! 			sk = nr_find_socket(i, j);
! 			if (sk == NULL) {
  				break;
+ 			}
+ 			sock_put(sk);
+ 		}
  
  		id++;
  	}
***************
*** 294,300 ****
   */
  static void nr_destroy_timer(unsigned long data)
  {
! 	nr_destroy_socket((struct sock *)data);
  }
  
  /*
--- 309,320 ----
   */
  static void nr_destroy_timer(unsigned long data)
  {
! 	struct sock *sk = (struct sock *)data;
! 	sock_hold(sk);
! 	bh_lock_sock(sk);	
! 	nr_destroy_socket(sk);
! 	bh_unlock_sock(sk);
! 	sock_put(sk);
  }
  
  /*
***************
*** 306,314 ****
  void nr_destroy_socket(struct sock *sk)	/* Not static as it's used by the timer */
  {
  	struct sk_buff *skb;
- 	unsigned long flags;
- 
- 	save_flags(flags); cli();
  
  	nr_stop_heartbeat(sk);
  	nr_stop_t1timer(sk);
--- 326,331 ----
***************
*** 321,346 ****
  
  	while ((skb = skb_dequeue(&sk->receive_queue)) != NULL) {
  		if (skb->sk != sk) {			/* A pending connection */
- 			skb->sk->dead = 1;	/* Queue the unaccepted socket for death */
  			nr_start_heartbeat(skb->sk);
  			skb->sk->protinfo.nr->state = NR_STATE_0;
  		}
  
  		kfree_skb(skb);
  	}
  
! 	if (atomic_read(&sk->wmem_alloc) != 0 || atomic_read(&sk->rmem_alloc) != 0) {
! 		/* Defer: outstanding buffers */
  		init_timer(&sk->timer);
! 		sk->timer.expires  = jiffies + 10 * HZ;
  		sk->timer.function = nr_destroy_timer;
  		sk->timer.data     = (unsigned long)sk;
  		add_timer(&sk->timer);
- 	} else {
- 		nr_free_sock(sk);
  	}
- 
- 	restore_flags(flags);
  }
  
  /*
--- 338,373 ----
  
  	while ((skb = skb_dequeue(&sk->receive_queue)) != NULL) {
  		if (skb->sk != sk) {			/* A pending connection */
  			nr_start_heartbeat(skb->sk);
  			skb->sk->protinfo.nr->state = NR_STATE_0;
+ 			skb->sk->state              = TCP_CLOSE;
+ 			sock_orphan(skb->sk);
  		}
  
  		kfree_skb(skb);
  	}
  
! 	sk->state = TCP_CLOSE;
! 	if ( sk->socket ) {
! 		if ( sk->socket->state != SS_UNCONNECTED ) {
! 			sk->socket->state = SS_DISCONNECTING;
! 		}
! 	}
! 	sk->state_change(sk);
! 	
! 	if (atomic_read(&sk->wmem_alloc) == 0 &&
! 	    atomic_read(&sk->rmem_alloc) == 0) {
! 	    	nr_free_sock(sk);
! 	} else {
! 		/*
! 		 *	Someone is using our buffers still.. defer
! 		 */
  		init_timer(&sk->timer);
! 		sk->timer.expires  = jiffies + SOCK_DESTROY_TIME;
  		sk->timer.function = nr_destroy_timer;
  		sk->timer.data     = (unsigned long)sk;
  		add_timer(&sk->timer);
  	}
  }
  
  /*
***************
*** 353,402 ****
  {
  	struct sock *sk = sock->sk;
  	int opt;
  
! 	if (level != SOL_NETROM)
  		return -ENOPROTOOPT;
  
! 	if (optlen < sizeof(int))
  		return -EINVAL;
  
! 	if (get_user(opt, (int *)optval))
  		return -EFAULT;
  
  	switch (optname) {
  		case NETROM_T1:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.nr->t1 = opt * HZ;
  			return 0;
  
  		case NETROM_T2:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.nr->t2 = opt * HZ;
  			return 0;
  
  		case NETROM_N2:
! 			if (opt < 1 || opt > 31)
  				return -EINVAL;
  			sk->protinfo.nr->n2 = opt;
  			return 0;
  
  		case NETROM_T4:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.nr->t4 = opt * HZ;
  			return 0;
  
  		case NETROM_IDLE:
! 			if (opt < 0)
  				return -EINVAL;
  			sk->protinfo.nr->idle = opt * 60 * HZ;
  			return 0;
  
  		default:
  			return -ENOPROTOOPT;
  	}
  }
  
  static int nr_getsockopt(struct socket *sock, int level, int optname,
--- 380,454 ----
  {
  	struct sock *sk = sock->sk;
  	int opt;
+ 	
+ 	lock_sock(sk);
  
! 	if (level != SOL_NETROM) {
! 		release_sock(sk);
  		return -ENOPROTOOPT;
+ 	}
  
! 	if (optlen < sizeof(int)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (get_user(opt, (int *)optval)) {
! 		release_sock(sk);
  		return -EFAULT;
+ 	}
  
  	switch (optname) {
  		case NETROM_T1:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.nr->t1 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case NETROM_T2:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.nr->t2 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case NETROM_N2:
! 			if (opt < 1 || opt > 31) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.nr->n2 = opt;
+ 			release_sock(sk);
  			return 0;
  
  		case NETROM_T4:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.nr->t4 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case NETROM_IDLE:
! 			if (opt < 0) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.nr->idle = opt * 60 * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		default:
+ 			release_sock(sk);
  			return -ENOPROTOOPT;
  	}
+ 	release_sock(sk);
  }
  
  static int nr_getsockopt(struct socket *sock, int level, int optname,
***************
*** 415,420 ****
--- 467,474 ----
  	if (len < 0)
  		return -EINVAL;
  		
+ 	lock_sock(sk);
+ 	
  	switch (optname) {
  		case NETROM_T1:
  			val = sk->protinfo.nr->t1 / HZ;
***************
*** 442,449 ****
  
  	len = min_t(unsigned int, len, sizeof(int));
  
! 	if (put_user(len, optlen))
  		return -EFAULT;
  
  	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
  }
--- 496,506 ----
  
  	len = min_t(unsigned int, len, sizeof(int));
  
! 	release_sock(sk);
! 	
! 	if (put_user(len, optlen)) {
  		return -EFAULT;
+ 	}
  
  	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
  }
***************
*** 452,464 ****
--- 509,526 ----
  {
  	struct sock *sk = sock->sk;
  
+ 	lock_sock(sk);
+ 	
  	if (sk->state != TCP_LISTEN) {
  		memset(&sk->protinfo.nr->user_addr, '\0', AX25_ADDR_LEN);
  		sk->max_ack_backlog = backlog;
  		sk->state           = TCP_LISTEN;
+ 		release_sock(sk);
  		return 0;
  	}
  
+ 	release_sock(sk);
+ 	
  	return -EOPNOTSUPP;
  }
  
***************
*** 470,482 ****
  	if (sock->type != SOCK_SEQPACKET || protocol != 0)
  		return -ESOCKTNOSUPPORT;
  
! 	if ((sk = nr_alloc_sock()) == NULL)
  		return -ENOMEM;
  
  	nr = sk->protinfo.nr;
  
- 	sock_init_data(sock, sk);
- 
  	sock->ops    = &nr_proto_ops;
  	sk->protocol = protocol;
  
--- 532,542 ----
  	if (sock->type != SOCK_SEQPACKET || protocol != 0)
  		return -ESOCKTNOSUPPORT;
  
! 	if ((sk = nr_alloc_sock(sock)) == NULL)
  		return -ENOMEM;
  
  	nr = sk->protinfo.nr;
  
  	sock->ops    = &nr_proto_ops;
  	sk->protocol = protocol;
  
***************
*** 510,532 ****
  	if (osk->type != SOCK_SEQPACKET)
  		return NULL;
  
! 	if ((sk = nr_alloc_sock()) == NULL)
  		return NULL;
  
  	nr = sk->protinfo.nr;
  
- 	sock_init_data(NULL, sk);
- 
  	sk->type     = osk->type;
- 	sk->socket   = osk->socket;
  	sk->priority = osk->priority;
  	sk->protocol = osk->protocol;
- 	sk->rcvbuf   = osk->rcvbuf;
- 	sk->sndbuf   = osk->sndbuf;
- 	sk->debug    = osk->debug;
  	sk->state    = TCP_ESTABLISHED;
- 	sk->sleep    = osk->sleep;
  	sk->zapped   = osk->zapped;
  
  	skb_queue_head_init(&nr->ack_queue);
  	skb_queue_head_init(&nr->reseq_queue);
--- 570,587 ----
  	if (osk->type != SOCK_SEQPACKET)
  		return NULL;
  
! 	if ((sk = nr_alloc_sock(NULL)) == NULL)
  		return NULL;
  
  	nr = sk->protinfo.nr;
  
  	sk->type     = osk->type;
  	sk->priority = osk->priority;
  	sk->protocol = osk->protocol;
  	sk->state    = TCP_ESTABLISHED;
  	sk->zapped   = osk->zapped;
+ 	sk->sleep    = osk->sleep;
+ 	sk->socket   = osk->socket;
  
  	skb_queue_head_init(&nr->ack_queue);
  	skb_queue_head_init(&nr->reseq_queue);
***************
*** 556,561 ****
--- 611,621 ----
  
  	if (sk == NULL) return 0;
  
+ 	sock_orphan(sk);
+ 	sock_hold(sk);
+ 	local_bh_disable();
+ 	bh_lock_sock(sk);
+ 	
  	switch (sk->protinfo.nr->state) {
  
  		case NR_STATE_0:
***************
*** 576,593 ****
  			sk->protinfo.nr->state   = NR_STATE_2;
  			sk->state                = TCP_CLOSE;
  			sk->shutdown            |= SEND_SHUTDOWN;
! 			sk->state_change(sk);
! 			sock_orphan(sk);
  			sk->destroy              = 1;
  			break;
  
  		default:
- 			sk->socket = NULL;
  			break;
  	}
  
! 	sock->sk   = NULL;	
! 
  	return 0;
  }
  
--- 636,655 ----
  			sk->protinfo.nr->state   = NR_STATE_2;
  			sk->state                = TCP_CLOSE;
  			sk->shutdown            |= SEND_SHUTDOWN;
! 			if (!sk->dead) {
! 				sk->state_change(sk);
! 			}
  			sk->destroy              = 1;
  			break;
  
  		default:
  			break;
  	}
  
! 	bh_unlock_sock(sk);
! 	local_bh_enable();
! 	sock_put(sk);
! 	
  	return 0;
  }
  
***************
*** 598,618 ****
  	struct net_device *dev;
  	ax25_address *user, *source;
  
! 	if (sk->zapped == 0)
  		return -EINVAL;
  
! 	if (addr_len < sizeof(struct sockaddr_ax25) || addr_len > sizeof(struct
! full_sockaddr_ax25))
  		return -EINVAL;
  
! 	if (addr_len < (addr->fsa_ax25.sax25_ndigis * sizeof(ax25_address) + sizeof(struct sockaddr_ax25)))
  		return -EINVAL;
  
! 	if (addr->fsa_ax25.sax25_family != AF_NETROM)
  		return -EINVAL;
  
  	if ((dev = nr_dev_get(&addr->fsa_ax25.sax25_call)) == NULL) {
  		SOCK_DEBUG(sk, "NET/ROM: bind failed: invalid node callsign\n");
  		return -EADDRNOTAVAIL;
  	}
  
--- 660,690 ----
  	struct net_device *dev;
  	ax25_address *user, *source;
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped == 0) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr_len < sizeof(struct sockaddr_ax25) || addr_len > sizeof(struct full_sockaddr_ax25)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr_len < (addr->fsa_ax25.sax25_ndigis * sizeof(ax25_address) + sizeof(struct sockaddr_ax25))) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr->fsa_ax25.sax25_family != AF_NETROM) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	if ((dev = nr_dev_get(&addr->fsa_ax25.sax25_call)) == NULL) {
  		SOCK_DEBUG(sk, "NET/ROM: bind failed: invalid node callsign\n");
+ 		release_sock(sk);
  		return -EADDRNOTAVAIL;
  	}
  
***************
*** 622,627 ****
--- 694,700 ----
  	if (addr->fsa_ax25.sax25_ndigis == 1) {
  		if (!capable(CAP_NET_BIND_SERVICE)) {
  			dev_put(dev);
+ 			release_sock(sk);
  			return -EACCES;
  		}
  		sk->protinfo.nr->user_addr   = addr->fsa_digipeater[0];
***************
*** 632,637 ****
--- 705,711 ----
  		if ((user = ax25_findbyuid(current->euid)) == NULL) {
  			if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {
  				dev_put(dev);
+ 				release_sock(sk);
  				return -EPERM;
  			}
  			user = source;
***************
*** 646,695 ****
  
  	sk->zapped = 0;
  	SOCK_DEBUG(sk, "NET/ROM: socket is bound\n");
  	return 0;
  }
  
  static int nr_connect(struct socket *sock, struct sockaddr *uaddr,
! 	int addr_len, int flags)
! {
  	struct sock *sk = sock->sk;
  	struct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;
  	ax25_address *user, *source = NULL;
  	struct net_device *dev;
  
  	if (sk->state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {
  		sock->state = SS_CONNECTED;
  		return 0;	/* Connect completed during a ERESTARTSYS event */
  	}
  
  	if (sk->state == TCP_CLOSE && sock->state == SS_CONNECTING) {
  		sock->state = SS_UNCONNECTED;
  		return -ECONNREFUSED;
  	}
  
! 	if (sk->state == TCP_ESTABLISHED)
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 
  	sk->state   = TCP_CLOSE;	
  	sock->state = SS_UNCONNECTED;
  
! 	if (addr_len != sizeof(struct sockaddr_ax25) && addr_len != sizeof(struct full_sockaddr_ax25))
  		return -EINVAL;
! 
! 	if (addr->sax25_family != AF_NETROM)
  		return -EINVAL;
  
  	if (sk->zapped) {	/* Must bind first - autobinding in this may or may not work */
  		sk->zapped = 0;
  
! 		if ((dev = nr_dev_first()) == NULL)
  			return -ENETUNREACH;
! 
  		source = (ax25_address *)dev->dev_addr;
  
  		if ((user = ax25_findbyuid(current->euid)) == NULL) {
  			if (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {
  				dev_put(dev);
  				return -EPERM;
  			}
  			user = source;
--- 720,786 ----
  
  	sk->zapped = 0;
  	SOCK_DEBUG(sk, "NET/ROM: socket is bound\n");
+ 	
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
  static int nr_connect(struct socket *sock, struct sockaddr *uaddr,
! 	int addr_len, int flags) {
! 	
  	struct sock *sk = sock->sk;
  	struct sockaddr_ax25 *addr = (struct sockaddr_ax25 *)uaddr;
  	ax25_address *user, *source = NULL;
  	struct net_device *dev;
+ 	int err;
  
+ 	lock_sock(sk);
+ 	
  	if (sk->state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {
  		sock->state = SS_CONNECTED;
+ 		release_sock(sk);
  		return 0;	/* Connect completed during a ERESTARTSYS event */
  	}
  
  	if (sk->state == TCP_CLOSE && sock->state == SS_CONNECTING) {
  		sock->state = SS_UNCONNECTED;
+ 		release_sock(sk);
  		return -ECONNREFUSED;
  	}
  
! 	if (sk->state == TCP_ESTABLISHED) {
! 		release_sock(sk);
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 	}
! 	
  	sk->state   = TCP_CLOSE;	
  	sock->state = SS_UNCONNECTED;
  
! 	if (addr_len != sizeof(struct sockaddr_ax25) && addr_len != sizeof(struct full_sockaddr_ax25)) {
! 		release_sock(sk);
  		return -EINVAL;
! 	}
! 	
! 	if (addr->sax25_family != AF_NETROM) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	if (sk->zapped) {	/* Must bind first - autobinding in this may or may not work */
  		sk->zapped = 0;
  
! 		if ((dev = nr_dev_first()) == NULL) {
! 			release_sock(sk);
  			return -ENETUNREACH;
! 		}
! 		
  		source = (ax25_address *)dev->dev_addr;
  
  		if ((user = ax25_findbyuid(current->euid)) == NULL) {
  			if (ax25_uid_policy && !capable(CAP_NET_ADMIN)) {
  				dev_put(dev);
+ 				release_sock(sk);
  				return -EPERM;
  			}
  			user = source;
***************
*** 722,753 ****
  	nr_start_heartbeat(sk);
  
  	/* Now the loop */
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK))
  		return -EINPROGRESS;
  		
- 	cli();	/* To avoid races on the sleep */
- 
  	/*
  	 * A Connect Ack with Choke or timeout or failed routing will go to closed.
  	 */
  	while (sk->state == TCP_SYN_SENT) {
- 		interruptible_sleep_on(sk->sleep);
  		if (signal_pending(current)) {
! 			sti();
  			return -ERESTARTSYS;
  		}
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
- 		sti();
  		sock->state = SS_UNCONNECTED;
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	sti();
! 
  	return 0;
  }
  
--- 813,854 ----
  	nr_start_heartbeat(sk);
  
  	/* Now the loop */
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {
! 		release_sock(sk);
  		return -EINPROGRESS;
+ 	}
  		
  	/*
  	 * A Connect Ack with Choke or timeout or failed routing will go to closed.
  	 */
  	while (sk->state == TCP_SYN_SENT) {
  		if (signal_pending(current)) {
! 			release_sock(sk);
  			return -ERESTARTSYS;
  		}
+ 		if ((err = sock_error(sk)) != 0) {
+ 			sock->state = SS_UNCONNECTED;
+ 			release_sock(sk);
+ 			return err;
+ 		}
+ 		
+ 		SOCK_SLEEP_PRE(sk);
+ 		if (sk->state == TCP_SYN_SENT) {
+ 			schedule();
+ 		}
+ 		SOCK_SLEEP_POST(sk);
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
  		sock->state = SS_UNCONNECTED;
+ 		release_sock(sk);
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	release_sock(sk);
! 	
  	return 0;
  }
  
***************
*** 756,813 ****
  	struct sock *sk;
  	struct sock *newsk;
  	struct sk_buff *skb;
! 
! 	if ((sk = sock->sk) == NULL)
  		return -EINVAL;
  
! 	if (sk->type != SOCK_SEQPACKET)
  		return -EOPNOTSUPP;
  
! 	if (sk->state != TCP_LISTEN)
  		return -EINVAL;
  
  	/*
  	 *	The write queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	do {
! 		cli();
! 		if ((skb = skb_dequeue(&sk->receive_queue)) == NULL) {
! 			if (flags & O_NONBLOCK) {
! 				sti();
! 				return -EWOULDBLOCK;
! 			}
! 			interruptible_sleep_on(sk->sleep);
! 			if (signal_pending(current)) {
! 				sti();
! 				return -ERESTARTSYS;
! 			}
  		}
! 	} while (skb == NULL);
  
  	newsk = skb->sk;
- 	newsk->pair = NULL;
  	newsk->socket = newsock;
! 	newsk->sleep = &newsock->wait;
! 	sti();
  
  	/* Now attach up the new socket */
  	kfree_skb(skb);
  	sk->ack_backlog--;
  	newsock->sk = newsk;
  
  	return 0;
  }
  
  static int nr_getname(struct socket *sock, struct sockaddr *uaddr,
! 	int *uaddr_len, int peer)
! {
  	struct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;
  	struct sock *sk = sock->sk;
  
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  		sax->fsa_ax25.sax25_family = AF_NETROM;
  		sax->fsa_ax25.sax25_ndigis = 1;
  		sax->fsa_ax25.sax25_call   = sk->protinfo.nr->user_addr;
--- 857,933 ----
  	struct sock *sk;
  	struct sock *newsk;
  	struct sk_buff *skb;
! 	
! 	sk = sock->sk;
! 	
! 	if (sk == NULL) {
  		return -EINVAL;
+ 	}
  
! 	lock_sock(sk);
! 	
! 	if (sk->type != SOCK_SEQPACKET) {
! 		release_sock(sk);
  		return -EOPNOTSUPP;
+ 	}
  
! 	if (sk->state != TCP_LISTEN) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	/*
  	 *	The write queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	for (;;) {
! 		skb = skb_dequeue(&sk->receive_queue);
! 		if (skb) {
! 			break;
! 		}
! 		if (flags & O_NONBLOCK) {
! 			release_sock(sk);
! 			return -EWOULDBLOCK;
! 		}
! 		if (signal_pending(current)) {
! 			release_sock(sk);
! 			return -ERESTARTSYS;
! 		}
! 		
! 		SOCK_SLEEP_PRE(sk);
! 		if (!skb_peek(&sk->receive_queue)) {
! 			schedule();
  		}
! 		SOCK_SLEEP_POST(sk);
! 	}
  
  	newsk = skb->sk;
  	newsk->socket = newsock;
! 	newsk->sleep  = &newsock->wait;
  
  	/* Now attach up the new socket */
  	kfree_skb(skb);
  	sk->ack_backlog--;
  	newsock->sk = newsk;
  
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
  static int nr_getname(struct socket *sock, struct sockaddr *uaddr,
! 	int *uaddr_len, int peer) {
! 	
  	struct full_sockaddr_ax25 *sax = (struct full_sockaddr_ax25 *)uaddr;
  	struct sock *sk = sock->sk;
  
+ 	lock_sock(sk);
+ 	
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  		sax->fsa_ax25.sax25_family = AF_NETROM;
  		sax->fsa_ax25.sax25_ndigis = 1;
  		sax->fsa_ax25.sax25_call   = sk->protinfo.nr->user_addr;
***************
*** 820,825 ****
--- 940,947 ----
  		*uaddr_len = sizeof(struct sockaddr_ax25);
  	}
  
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
***************
*** 831,837 ****
  	unsigned short circuit_index, circuit_id;
  	unsigned short peer_circuit_index, peer_circuit_id;
  	unsigned short frametype, flags, window, timeout;
! 
  	skb->sk = NULL;		/* Initially we don't know who it's for */
  
  	/*
--- 953,959 ----
  	unsigned short circuit_index, circuit_id;
  	unsigned short peer_circuit_index, peer_circuit_id;
  	unsigned short frametype, flags, window, timeout;
! 	
  	skb->sk = NULL;		/* Initially we don't know who it's for */
  
  	/*
***************
*** 909,914 ****
--- 1031,1038 ----
  		else
  			sk->protinfo.nr->bpqext = 0;
  
+ 		sock_put(sk);
+ 		
  		return nr_process_rx_frame(sk, skb);
  	}
  
***************
*** 938,943 ****
--- 1062,1070 ----
  
  	if (sk == NULL || sk->ack_backlog == sk->max_ack_backlog || (make = nr_make_new(sk)) == NULL) {
  		nr_transmit_refusal(skb, 0);
+ 		if (sk) {
+ 			sock_put(sk);
+ 		}
  		return 0;
  	}
  
***************
*** 984,990 ****
  	make->protinfo.nr->vl        = 0;
  	make->protinfo.nr->state     = NR_STATE_3;
  	sk->ack_backlog++;
- 	make->pair = sk;
  
  	dev_hold(make->protinfo.nr->device);
  
--- 1111,1116 ----
***************
*** 998,1003 ****
--- 1124,1131 ----
  	if (!sk->dead)
  		sk->data_ready(sk, skb->len);
  
+ 	sock_put(sk);
+ 	
  	return 1;
  }
  
***************
*** 1014,1041 ****
  	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR))
  		return -EINVAL;
  
! 	if (sk->zapped)
  		return -EADDRNOTAVAIL;
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
  		send_sig(SIGPIPE, current, 0);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.nr->device == NULL)
  		return -ENETUNREACH;
  
  	if (usax) {
! 		if (msg->msg_namelen < sizeof(sax))
  			return -EINVAL;
  		sax = *usax;
! 		if (ax25cmp(&sk->protinfo.nr->dest_addr, &sax.sax25_call) != 0)
  			return -EISCONN;
! 		if (sax.sax25_family != AF_NETROM)
  			return -EINVAL;
  	} else {
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  		sax.sax25_family = AF_NETROM;
  		sax.sax25_call   = sk->protinfo.nr->dest_addr;
  	}
--- 1142,1184 ----
  	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR))
  		return -EINVAL;
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped) {
! 		release_sock(sk);
  		return -EADDRNOTAVAIL;
+ 	}
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
+ 		release_sock(sk);
  		send_sig(SIGPIPE, current, 0);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.nr->device == NULL) {
! 		release_sock(sk);
  		return -ENETUNREACH;
+ 	}
  
  	if (usax) {
! 		if (msg->msg_namelen < sizeof(sax)) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  		sax = *usax;
! 		if (ax25cmp(&sk->protinfo.nr->dest_addr, &sax.sax25_call) != 0) {
! 			release_sock(sk);
  			return -EISCONN;
! 		}
! 		if (sax.sax25_family != AF_NETROM) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  	} else {
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  		sax.sax25_family = AF_NETROM;
  		sax.sax25_call   = sk->protinfo.nr->dest_addr;
  	}
***************
*** 1046,1053 ****
  	SOCK_DEBUG(sk, "NET/ROM: sendto: building packet.\n");
  	size = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + NR_NETWORK_LEN + NR_TRANSPORT_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)
  		return err;
  
  	skb_reserve(skb, size - len);
  
--- 1189,1198 ----
  	SOCK_DEBUG(sk, "NET/ROM: sendto: building packet.\n");
  	size = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + NR_NETWORK_LEN + NR_TRANSPORT_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL) {
! 		release_sock(sk);
  		return err;
+ 	}
  
  	skb_reserve(skb, size - len);
  
***************
*** 1082,1092 ****
--- 1227,1240 ----
  
  	if (sk->state != TCP_ESTABLISHED) {
  		kfree_skb(skb);
+ 		release_sock(sk);
  		return -ENOTCONN;
  	}
  
  	nr_output(sk, skb);	/* Shove it onto the queue */
  
+ 	release_sock(sk);
+ 	
  	return len;
  }
  
***************
*** 1104,1115 ****
  	 * us! We do one quick check first though
  	 */
  
! 	if (sk->state != TCP_ESTABLISHED)
  		return -ENOTCONN;
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)
  		return er;
  
  	skb->h.raw = skb->data;
  	copied     = skb->len;
--- 1252,1269 ----
  	 * us! We do one quick check first though
  	 */
  
! 	lock_sock(sk);
! 	
! 	if (sk->state != TCP_ESTABLISHED) {
! 		release_sock(sk);
  		return -ENOTCONN;
+ 	}
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
! 		release_sock(sk);
  		return er;
+ 	}
  
  	skb->h.raw = skb->data;
  	copied     = skb->len;
***************
*** 1130,1135 ****
--- 1284,1291 ----
  
  	skb_free_datagram(sk, skb);
  
+ 	release_sock(sk);
+ 	
  	return copied;
  }
  
***************
*** 1150,1158 ****
  		case TIOCINQ: {
  			struct sk_buff *skb;
  			long amount = 0L;
! 			/* These two are safe on a single CPU system as only user tasks fiddle here */
! 			if ((skb = skb_peek(&sk->receive_queue)) != NULL)
  				amount = skb->len;
  			return put_user(amount, (int *)arg);
  		}
  
--- 1306,1316 ----
  		case TIOCINQ: {
  			struct sk_buff *skb;
  			long amount = 0L;
! 			lock_sock(sk);
! 			if ((skb = skb_peek(&sk->receive_queue)) != NULL) {
  				amount = skb->len;
+ 			}
+ 			release_sock(sk);
  			return put_user(amount, (int *)arg);
  		}
  
***************
*** 1195,1205 ****
  	struct sock *s;
  	struct net_device *dev;
  	const char *devname;
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	cli();
  
  	len += sprintf(buffer, "user_addr dest_node src_node  dev    my  your  st  vs  vr  va    t1     t2     t4      idle   n2  wnd Snd-Q Rcv-Q inode\n");
  
--- 1353,1364 ----
  	struct sock *s;
  	struct net_device *dev;
  	const char *devname;
+ 	char buf[11];
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	read_lock_bh(&nr_list_lock);
  
  	len += sprintf(buffer, "user_addr dest_node src_node  dev    my  your  st  vs  vr  va    t1     t2     t4      idle   n2  wnd Snd-Q Rcv-Q inode\n");
  
***************
*** 1210,1220 ****
  			devname = dev->name;
  
  		len += sprintf(buffer + len, "%-9s ",
! 			ax2asc(&s->protinfo.nr->user_addr));
  		len += sprintf(buffer + len, "%-9s ",
! 			ax2asc(&s->protinfo.nr->dest_addr));
  		len += sprintf(buffer + len, "%-9s %-3s  %02X/%02X %02X/%02X %2d %3d %3d %3d %3lu/%03lu %2lu/%02lu %3lu/%03lu %3lu/%03lu %2d/%02d %3d %5d %5d %ld\n",
! 			ax2asc(&s->protinfo.nr->source_addr),
  			devname,
  			s->protinfo.nr->my_index,
  			s->protinfo.nr->my_id,
--- 1369,1379 ----
  			devname = dev->name;
  
  		len += sprintf(buffer + len, "%-9s ",
! 			ax2asc(buf, &s->protinfo.nr->user_addr));
  		len += sprintf(buffer + len, "%-9s ",
! 			ax2asc(buf, &s->protinfo.nr->dest_addr));
  		len += sprintf(buffer + len, "%-9s %-3s  %02X/%02X %02X/%02X %2d %3d %3d %3d %3lu/%03lu %2lu/%02lu %3lu/%03lu %3lu/%03lu %2d/%02d %3d %5d %5d %ld\n",
! 			ax2asc(buf, &s->protinfo.nr->source_addr),
  			devname,
  			s->protinfo.nr->my_index,
  			s->protinfo.nr->my_id,
***************
*** 1250,1256 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 1409,1415 ----
  			break;
  	}
  
! 	read_unlock_bh(&nr_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1265,1271 ****
  	create:		nr_create,
  };
  
! static struct proto_ops SOCKOPS_WRAPPED(nr_proto_ops) = {
  	family:		PF_NETROM,
  
  	release:	nr_release,
--- 1424,1430 ----
  	create:		nr_create,
  };
  
! static struct proto_ops nr_proto_ops = {
  	family:		PF_NETROM,
  
  	release:	nr_release,
***************
*** 1286,1294 ****
  	sendpage:	sock_no_sendpage,
  };
  
- #include <linux/smp_lock.h>
- SOCKOPS_WRAP(nr_proto, PF_NETROM);
- 
  static struct notifier_block nr_dev_notifier = {
  	notifier_call:	nr_device_event,
  };
--- 1445,1450 ----
Index: linux-2.4.23/net/netrom/nr_in.c
diff -c linux-2.4.23/net/netrom/nr_in.c:1.1.1.1 linux-2.4.23/net/netrom/nr_in.c:1.2
*** linux-2.4.23/net/netrom/nr_in.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_in.c	Sun Nov 30 21:17:14 2003
***************
*** 22,27 ****
--- 22,28 ----
   *					INFOACK handling, removed reconnect on error.
   *	NET/ROM 006	Jonathan(G4KLX)	Hdrincl removal changes.
   *	NET/ROM 007	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 46,51 ****
--- 47,53 ----
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <net/netrom.h>
+ #include <linux/spinlock.h>
  
  static int nr_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)
  {
***************
*** 65,72 ****
  		sk->protinfo.nr->fraglen += skb->len;
  		skb_queue_tail(&sk->protinfo.nr->frag_queue, skb);
  
! 		if ((skbn = alloc_skb(sk->protinfo.nr->fraglen, GFP_ATOMIC)) == NULL)
  			return 1;
  
  		skbn->h.raw = skbn->data;
  
--- 67,75 ----
  		sk->protinfo.nr->fraglen += skb->len;
  		skb_queue_tail(&sk->protinfo.nr->frag_queue, skb);
  
! 		if ((skbn = alloc_skb(sk->protinfo.nr->fraglen, GFP_ATOMIC)) == NULL) {
  			return 1;
+ 		}
  
  		skbn->h.raw = skbn->data;
  
***************
*** 74,80 ****
  			memcpy(skb_put(skbn, skbo->len), skbo->data, skbo->len);
  			kfree_skb(skbo);
  		}
! 
  		sk->protinfo.nr->fraglen = 0;		
  	}
  
--- 77,83 ----
  			memcpy(skb_put(skbn, skbo->len), skbo->data, skbo->len);
  			kfree_skb(skbo);
  		}
! 		
  		sk->protinfo.nr->fraglen = 0;		
  	}
  
***************
*** 231,236 ****
--- 234,240 ----
  				}
  			}
  			queued = 1;
+ 			
  			skb_queue_head(&sk->protinfo.nr->reseq_queue, skb);
  			if (sk->protinfo.nr->condition & NR_COND_OWN_RX_BUSY)
  				break;
Index: linux-2.4.23/net/netrom/nr_loopback.c
diff -c linux-2.4.23/net/netrom/nr_loopback.c:1.1.1.1 linux-2.4.23/net/netrom/nr_loopback.c:1.2
*** linux-2.4.23/net/netrom/nr_loopback.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_loopback.c	Sun Nov 30 21:17:14 2003
***************
*** 12,17 ****
--- 12,18 ----
   *	History
   *	NET/ROM 007	Tomi(OH2BNS)	Created this file.
   *                                      Small change in nr_loopback_queue().
+  *			Tihomir(9A4GL)	Spinlocking...
   *
   */
  
***************
*** 22,27 ****
--- 23,29 ----
  #include <linux/skbuff.h>
  #include <net/netrom.h>
  #include <linux/init.h>
+ #include <linux/spinlock.h>
  
  static struct sk_buff_head loopback_queue;
  static struct timer_list loopback_timer;
Index: linux-2.4.23/net/netrom/nr_out.c
diff -c linux-2.4.23/net/netrom/nr_out.c:1.1.1.1 linux-2.4.23/net/netrom/nr_out.c:1.2
*** linux-2.4.23/net/netrom/nr_out.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_out.c	Sun Nov 30 21:17:14 2003
***************
*** 14,19 ****
--- 14,20 ----
   *	NET/ROM 003	Jonathan(G4KLX)	Added NET/ROM fragmentation.
   *			Darryl(G7LED)	Fixed NAK, to give out correct reponse.
   *	NET/ROM 007	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 37,42 ****
--- 38,44 ----
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <net/netrom.h>
+ #include <linux/spinlock.h>
  
  /*
   *	This is where all NET/ROM frames pass, except for IP-over-NET/ROM which
***************
*** 73,79 ****
  
  			if (skb->len > 0)
  				skbn->data[4] |= NR_MORE_FLAG;
! 
  			skb_queue_tail(&sk->write_queue, skbn); /* Throw it on the queue */
  		}
  
--- 75,81 ----
  
  			if (skb->len > 0)
  				skbn->data[4] |= NR_MORE_FLAG;
! 				
  			skb_queue_tail(&sk->write_queue, skbn); /* Throw it on the queue */
  		}
  
***************
*** 109,117 ****
  {
  	struct sk_buff *skb, *skbn;
  
! 	if ((skb = skb_peek(&sk->protinfo.nr->ack_queue)) == NULL)
  		return;
! 
  	if ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL)
  		return;
  
--- 111,120 ----
  {
  	struct sk_buff *skb, *skbn;
  
! 	if ((skb = skb_peek(&sk->protinfo.nr->ack_queue)) == NULL) {
  		return;
! 	}
! 	
  	if ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL)
  		return;
  
***************
*** 140,149 ****
  	if (sk->protinfo.nr->condition & NR_COND_PEER_RX_BUSY)
  		return;
  
! 	if (skb_peek(&sk->write_queue) == NULL)
  		return;
! 
  	start = (skb_peek(&sk->protinfo.nr->ack_queue) == NULL) ? sk->protinfo.nr->va : sk->protinfo.nr->vs;
  	end   = (sk->protinfo.nr->va + sk->protinfo.nr->window) % NR_MODULUS;
  
  	if (start == end)
--- 143,154 ----
  	if (sk->protinfo.nr->condition & NR_COND_PEER_RX_BUSY)
  		return;
  
! 	if (skb_peek(&sk->write_queue) == NULL) {
  		return;
! 	}
! 	
  	start = (skb_peek(&sk->protinfo.nr->ack_queue) == NULL) ? sk->protinfo.nr->va : sk->protinfo.nr->vs;
+ 
  	end   = (sk->protinfo.nr->va + sk->protinfo.nr->window) % NR_MODULUS;
  
  	if (start == end)
***************
*** 160,166 ****
  	 * Dequeue the frame and copy it.
  	 */
  	skb  = skb_dequeue(&sk->write_queue);
! 
  	do {
  		if ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {
  			skb_queue_head(&sk->write_queue, skb);
--- 165,175 ----
  	 * Dequeue the frame and copy it.
  	 */
  	skb  = skb_dequeue(&sk->write_queue);
! 	
! 	if ( skb == NULL ) {
! 		return;
! 	}
! 	
  	do {
  		if ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {
  			skb_queue_head(&sk->write_queue, skb);
***************
*** 182,188 ****
  		skb_queue_tail(&sk->protinfo.nr->ack_queue, skb);
  
  	} while (sk->protinfo.nr->vs != end && (skb = skb_dequeue(&sk->write_queue)) != NULL);
! 
  	sk->protinfo.nr->vl         = sk->protinfo.nr->vr;
  	sk->protinfo.nr->condition &= ~NR_COND_ACK_PENDING;
  
--- 191,197 ----
  		skb_queue_tail(&sk->protinfo.nr->ack_queue, skb);
  
  	} while (sk->protinfo.nr->vs != end && (skb = skb_dequeue(&sk->write_queue)) != NULL);
! 	
  	sk->protinfo.nr->vl         = sk->protinfo.nr->vr;
  	sk->protinfo.nr->condition &= ~NR_COND_ACK_PENDING;
  
***************
*** 247,254 ****
  	if (sk->protinfo.nr->condition & NR_COND_OWN_RX_BUSY) {
  		frametype |= NR_CHOKE_FLAG;
  	} else {
! 		if (skb_peek(&sk->protinfo.nr->reseq_queue) != NULL)
  			frametype |= NR_NAK_FLAG;
  	}
  
  	nr_write_internal(sk, frametype);
--- 256,264 ----
  	if (sk->protinfo.nr->condition & NR_COND_OWN_RX_BUSY) {
  		frametype |= NR_CHOKE_FLAG;
  	} else {
! 		if (skb_peek(&sk->protinfo.nr->reseq_queue) != NULL) {
  			frametype |= NR_NAK_FLAG;
+ 		}
  	}
  
  	nr_write_internal(sk, frametype);
Index: linux-2.4.23/net/netrom/nr_route.c
diff -c linux-2.4.23/net/netrom/nr_route.c:1.1.1.1 linux-2.4.23/net/netrom/nr_route.c:1.2
*** linux-2.4.23/net/netrom/nr_route.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_route.c	Sun Nov 30 21:17:14 2003
***************
*** 20,25 ****
--- 20,26 ----
   *	NET/ROM 006	Jonathan(G4KLX)	Added the setting of digipeated neighbours.
   *			Tomi(OH2BNS)	Routing quality and link failure changes.
   *					Device refcnt fixes.
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 53,59 ****
--- 54,62 ----
  static unsigned int nr_neigh_no = 1;
  
  static struct nr_node  *nr_node_list;
+ rwlock_t nr_node_list_lock = RW_LOCK_UNLOCKED;
  static struct nr_neigh *nr_neigh_list;
+ rwlock_t nr_neigh_list_lock = RW_LOCK_UNLOCKED;
  
  static void nr_remove_neigh(struct nr_neigh *);
  
***************
*** 68,74 ****
  	struct nr_neigh *nr_neigh;
  	struct nr_route nr_route;
  	struct net_device *tdev;
- 	unsigned long flags;
  	int i, found;
  
  	/* Can't add routes to ourself */
--- 71,76 ----
***************
*** 77,90 ****
  		return -EINVAL;
  	}
  
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next)
! 		if (ax25cmp(nr, &nr_node->callsign) == 0)
  			break;
! 
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next)
! 		if (ax25cmp(ax25, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev)
  			break;
! 
  	/*
  	 * The L2 link to a neighbour has failed in the past
  	 * and now a frame comes from this neighbour. We assume
--- 79,99 ----
  		return -EINVAL;
  	}
  
! 	write_lock_bh(&nr_node_list_lock);
! 	write_lock_bh(&nr_neigh_list_lock);
! 	
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
! 		if (ax25cmp(nr, &nr_node->callsign) == 0) {
  			break;
! 		}
! 	}
! 	
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
! 		if (ax25cmp(ax25, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev) {
  			break;
! 		}
! 	}
! 	
  	/*
  	 * The L2 link to a neighbour has failed in the past
  	 * and now a frame comes from this neighbour. We assume
***************
*** 101,115 ****
  						node->which = i;
  	}
  
  	if (nr_neigh != NULL)
  		nr_neigh->failed = 0;
  
! 	if (quality == 0 && nr_neigh != NULL && nr_node != NULL)
  		return 0;
  
  	if (nr_neigh == NULL) {
! 		if ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL)
  			return -ENOMEM;
  
  		nr_neigh->callsign = *ax25;
  		nr_neigh->digipeat = NULL;
--- 110,131 ----
  						node->which = i;
  	}
  
+ 	
  	if (nr_neigh != NULL)
  		nr_neigh->failed = 0;
  
! 	if (quality == 0 && nr_neigh != NULL && nr_node != NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		write_unlock_bh(&nr_node_list_lock);
  		return 0;
+ 	}
  
  	if (nr_neigh == NULL) {
! 		if ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL) {
! 			write_unlock_bh(&nr_neigh_list_lock);
! 			write_unlock_bh(&nr_node_list_lock);
  			return -ENOMEM;
+ 		}
  
  		nr_neigh->callsign = *ax25;
  		nr_neigh->digipeat = NULL;
***************
*** 124,129 ****
--- 140,147 ----
  		if (ax25_digi != NULL && ax25_digi->ndigi > 0) {
  			if ((nr_neigh->digipeat = kmalloc(sizeof(*ax25_digi), GFP_KERNEL)) == NULL) {
  				kfree(nr_neigh);
+ 				write_unlock_bh(&nr_neigh_list_lock);
+ 				write_unlock_bh(&nr_node_list_lock);
  				return -ENOMEM;
  			}
  			memcpy(nr_neigh->digipeat, ax25_digi, sizeof(ax25_digi));
***************
*** 131,151 ****
  
  		dev_hold(nr_neigh->dev);
  
- 		save_flags(flags);
- 		cli();
- 
  		nr_neigh->next = nr_neigh_list;
  		nr_neigh_list  = nr_neigh;
- 
- 		restore_flags(flags);
  	}
  
  	if (quality != 0 && ax25cmp(nr, ax25) == 0 && !nr_neigh->locked)
  		nr_neigh->quality = quality;
  
  	if (nr_node == NULL) {
! 		if ((nr_node = kmalloc(sizeof(*nr_node), GFP_ATOMIC)) == NULL)
  			return -ENOMEM;
  
  		nr_node->callsign = *nr;
  		strcpy(nr_node->mnemonic, mnemonic);
--- 149,167 ----
  
  		dev_hold(nr_neigh->dev);
  
  		nr_neigh->next = nr_neigh_list;
  		nr_neigh_list  = nr_neigh;
  	}
  
  	if (quality != 0 && ax25cmp(nr, ax25) == 0 && !nr_neigh->locked)
  		nr_neigh->quality = quality;
  
  	if (nr_node == NULL) {
! 		if ((nr_node = kmalloc(sizeof(*nr_node), GFP_ATOMIC)) == NULL) {
! 			write_unlock_bh(&nr_neigh_list_lock);
! 			write_unlock_bh(&nr_node_list_lock);
  			return -ENOMEM;
+ 		}
  
  		nr_node->callsign = *nr;
  		strcpy(nr_node->mnemonic, mnemonic);
***************
*** 157,171 ****
  		nr_node->routes[0].obs_count = obs_count;
  		nr_node->routes[0].neighbour = nr_neigh;
  
- 		save_flags(flags);
- 		cli();
- 
  		nr_node->next = nr_node_list;
  		nr_node_list  = nr_node;
  
- 		restore_flags(flags);
- 
  		nr_neigh->count++;
  
  		return 0;
  	}
--- 173,185 ----
  		nr_node->routes[0].obs_count = obs_count;
  		nr_node->routes[0].neighbour = nr_neigh;
  
  		nr_node->next = nr_node_list;
  		nr_node_list  = nr_node;
  
  		nr_neigh->count++;
+ 		
+ 		write_unlock_bh(&nr_neigh_list_lock);
+ 		write_unlock_bh(&nr_node_list_lock);
  
  		return 0;
  	}
***************
*** 201,207 ****
  				nr_node->routes[2].neighbour->count--;
  
  				if (nr_node->routes[2].neighbour->count == 0 && !nr_node->routes[2].neighbour->locked)
! 					nr_remove_neigh(nr_node->routes[2].neighbour);
  
  				nr_node->routes[2].quality   = quality;
  				nr_node->routes[2].obs_count = obs_count;
--- 215,221 ----
  				nr_node->routes[2].neighbour->count--;
  
  				if (nr_node->routes[2].neighbour->count == 0 && !nr_node->routes[2].neighbour->locked)
! 					nr_remove_neigh(nr_node->routes[2].neighbour); /* both list locked, can call */
  
  				nr_node->routes[2].quality   = quality;
  				nr_node->routes[2].obs_count = obs_count;
***************
*** 258,277 ****
  		}
  	}
  
  	return 0;
  }
  
  static void nr_remove_node(struct nr_node *nr_node)
  {
  	struct nr_node *s;
- 	unsigned long flags;
- 
- 	save_flags(flags);
- 	cli();
  
  	if ((s = nr_node_list) == nr_node) {
  		nr_node_list = nr_node->next;
- 		restore_flags(flags);
  		kfree(nr_node);
  		return;
  	}
--- 272,292 ----
  		}
  	}
  
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
+ 	
  	return 0;
  }
  
+ /*
+  *	This must be called with nr_node_list locked !!
+  */
  static void nr_remove_node(struct nr_node *nr_node)
  {
  	struct nr_node *s;
  
  	if ((s = nr_node_list) == nr_node) {
  		nr_node_list = nr_node->next;
  		kfree(nr_node);
  		return;
  	}
***************
*** 279,306 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == nr_node) {
  			s->next = nr_node->next;
- 			restore_flags(flags);
  			kfree(nr_node);
  			return;
  		}
  
  		s = s->next;
  	}
- 
- 	restore_flags(flags);
  }
  
  static void nr_remove_neigh(struct nr_neigh *nr_neigh)
  {
  	struct nr_neigh *s;
- 	unsigned long flags;
  	
- 	save_flags(flags);
- 	cli();
- 
  	if ((s = nr_neigh_list) == nr_neigh) {
  		nr_neigh_list = nr_neigh->next;
- 		restore_flags(flags);
  		dev_put(nr_neigh->dev);
  		if (nr_neigh->digipeat != NULL)
  			kfree(nr_neigh->digipeat);
--- 294,316 ----
  	while (s != NULL && s->next != NULL) {
  		if (s->next == nr_node) {
  			s->next = nr_node->next;
  			kfree(nr_node);
  			return;
  		}
  
  		s = s->next;
  	}
  }
  
+ /*
+  *	This must be called with nr_neigh_list locked !!
+  */
  static void nr_remove_neigh(struct nr_neigh *nr_neigh)
  {
  	struct nr_neigh *s;
  	
  	if ((s = nr_neigh_list) == nr_neigh) {
  		nr_neigh_list = nr_neigh->next;
  		dev_put(nr_neigh->dev);
  		if (nr_neigh->digipeat != NULL)
  			kfree(nr_neigh->digipeat);
***************
*** 311,317 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == nr_neigh) {
  			s->next = nr_neigh->next;
- 			restore_flags(flags);
  			dev_put(nr_neigh->dev);
  			if (nr_neigh->digipeat != NULL)
  				kfree(nr_neigh->digipeat);
--- 321,326 ----
***************
*** 321,328 ****
  
  		s = s->next;
  	}
- 
- 	restore_flags(flags);
  }
  
  /*
--- 330,335 ----
***************
*** 335,363 ****
  	struct nr_neigh *nr_neigh;
  	int i;
  
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next)
! 		if (ax25cmp(callsign, &nr_node->callsign) == 0)
  			break;
! 
! 	if (nr_node == NULL) return -EINVAL;
! 
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next)
! 		if (ax25cmp(neighbour, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev)
  			break;
  
! 	if (nr_neigh == NULL) return -EINVAL;
! 
  	for (i = 0; i < nr_node->count; i++) {
  		if (nr_node->routes[i].neighbour == nr_neigh) {
  			nr_neigh->count--;
  
  			if (nr_neigh->count == 0 && !nr_neigh->locked)
! 				nr_remove_neigh(nr_neigh);
  
  			nr_node->count--;
  
  			if (nr_node->count == 0) {
! 				nr_remove_node(nr_node);
  			} else {
  				switch (i) {
  					case 0:
--- 342,385 ----
  	struct nr_neigh *nr_neigh;
  	int i;
  
! 	write_lock_bh(&nr_node_list_lock);
! 	write_lock_bh(&nr_neigh_list_lock);
! 	                
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
! 		if (ax25cmp(callsign, &nr_node->callsign) == 0) {
  			break;
! 		}
! 	}
! 	
! 	if (nr_node == NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		write_unlock_bh(&nr_node_list_lock);
! 		return -EINVAL;
! 	}
! 	
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
! 		if (ax25cmp(neighbour, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev) {
  			break;
+ 		}
+ 	}
  
! 	if (nr_neigh == NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		write_unlock_bh(&nr_node_list_lock);
! 		return -EINVAL;
! 	}
! 	
  	for (i = 0; i < nr_node->count; i++) {
  		if (nr_node->routes[i].neighbour == nr_neigh) {
  			nr_neigh->count--;
  
  			if (nr_neigh->count == 0 && !nr_neigh->locked)
! 				nr_remove_neigh(nr_neigh); /* nr_neigh_list is locked -> can call */
  
  			nr_node->count--;
  
  			if (nr_node->count == 0) {
! 				nr_remove_node(nr_node); /* nr_node_list is locked -> can call */
  			} else {
  				switch (i) {
  					case 0:
***************
*** 373,378 ****
--- 395,403 ----
  		}
  	}
  
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
+ 
  	return -EINVAL;
  }
  
***************
*** 382,399 ****
  static int nr_add_neigh(ax25_address *callsign, ax25_digi *ax25_digi, struct net_device *dev, unsigned int quality)
  {
  	struct nr_neigh *nr_neigh;
- 	unsigned long flags;
  
  	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
  		if (ax25cmp(callsign, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev) {
  			nr_neigh->quality = quality;
  			nr_neigh->locked  = 1;
  			return 0;
  		}
  	}
! 
! 	if ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL)
  		return -ENOMEM;
  
  	nr_neigh->callsign = *callsign;
  	nr_neigh->digipeat = NULL;
--- 407,428 ----
  static int nr_add_neigh(ax25_address *callsign, ax25_digi *ax25_digi, struct net_device *dev, unsigned int quality)
  {
  	struct nr_neigh *nr_neigh;
  
+ 	write_lock_bh(&nr_neigh_list_lock);
+ 	
  	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
  		if (ax25cmp(callsign, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev) {
  			nr_neigh->quality = quality;
  			nr_neigh->locked  = 1;
+ 			write_unlock_bh(&nr_neigh_list_lock);
  			return 0;
  		}
  	}
! 	
! 	if ((nr_neigh = kmalloc(sizeof(*nr_neigh), GFP_ATOMIC)) == NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
  		return -ENOMEM;
+ 	}
  
  	nr_neigh->callsign = *callsign;
  	nr_neigh->digipeat = NULL;
***************
*** 408,413 ****
--- 437,443 ----
  	if (ax25_digi != NULL && ax25_digi->ndigi > 0) {
  		if ((nr_neigh->digipeat = kmalloc(sizeof(*ax25_digi), GFP_KERNEL)) == NULL) {
  			kfree(nr_neigh);
+ 			write_unlock_bh(&nr_neigh_list_lock);
  			return -ENOMEM;
  		}
  		memcpy(nr_neigh->digipeat, ax25_digi, sizeof(ax25_digi));
***************
*** 415,427 ****
  
  	dev_hold(nr_neigh->dev);
  
- 	save_flags(flags);
- 	cli();
- 
  	nr_neigh->next = nr_neigh_list;
  	nr_neigh_list  = nr_neigh;
  
! 	restore_flags(flags);
  
  	return 0;	
  }
--- 445,454 ----
  
  	dev_hold(nr_neigh->dev);
  
  	nr_neigh->next = nr_neigh_list;
  	nr_neigh_list  = nr_neigh;
  
! 	write_unlock_bh(&nr_neigh_list_lock);
  
  	return 0;	
  }
***************
*** 434,451 ****
  {
  	struct nr_neigh *nr_neigh;
  
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next)
! 		if (ax25cmp(callsign, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev)
  			break;
  
! 	if (nr_neigh == NULL) return -EINVAL;
! 
  	nr_neigh->quality = quality;
  	nr_neigh->locked  = 0;
  
! 	if (nr_neigh->count == 0)
! 		nr_remove_neigh(nr_neigh);
  
  	return 0;
  }
  
--- 461,488 ----
  {
  	struct nr_neigh *nr_neigh;
  
! 	write_lock_bh(&nr_neigh_list_lock);
! 	
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
! 		if (ax25cmp(callsign, &nr_neigh->callsign) == 0 && nr_neigh->dev == dev) {
  			break;
+ 		}
+ 	}
  
! 	if (nr_neigh == NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		return -EINVAL;
! 	}
! 	
  	nr_neigh->quality = quality;
  	nr_neigh->locked  = 0;
  
! 	if (nr_neigh->count == 0) {
! 		nr_remove_neigh(nr_neigh); /* nr_neigh_list locked -> call ok */
! 	}
  
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	
  	return 0;
  }
  
***************
*** 460,467 ****
  	struct nr_node  *s, *nr_node;
  	int i;
  
! 	nr_node = nr_node_list;
  
  	while (nr_node != NULL) {
  		s       = nr_node;
  		nr_node = nr_node->next;
--- 497,507 ----
  	struct nr_node  *s, *nr_node;
  	int i;
  
! 	write_lock_bh(&nr_node_list_lock);
! 	write_lock_bh(&nr_neigh_list_lock);
  
+ 	nr_node = nr_node_list;
+ 	
  	while (nr_node != NULL) {
  		s       = nr_node;
  		nr_node = nr_node->next;
***************
*** 478,484 ****
  				nr_neigh->count--;
  
  				if (nr_neigh->count == 0 && !nr_neigh->locked)
! 					nr_remove_neigh(nr_neigh);
  
  				s->count--;
  
--- 518,524 ----
  				nr_neigh->count--;
  
  				if (nr_neigh->count == 0 && !nr_neigh->locked)
! 					nr_remove_neigh(nr_neigh); /* nr_neigh_list locked -> call ok */
  
  				s->count--;
  
***************
*** 500,508 ****
  		}
  
  		if (s->count <= 0)
! 			nr_remove_node(s);
  	}
  
  	return 0;
  }
  
--- 540,551 ----
  		}
  
  		if (s->count <= 0)
! 			nr_remove_node(s); /* nr_node_list locked, call ok */
  	}
  
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
+ 	
  	return 0;
  }
  
***************
*** 515,527 ****
  	struct nr_node  *t, *nr_node;
  	int i;
  
  	while (nr_neigh != NULL) {
  		s        = nr_neigh;
  		nr_neigh = nr_neigh->next;
  
  		if (s->dev == dev) {
  			nr_node = nr_node_list;
! 
  			while (nr_node != NULL) {
  				t       = nr_node;
  				nr_node = nr_node->next;
--- 558,573 ----
  	struct nr_node  *t, *nr_node;
  	int i;
  
+ 	write_lock_bh(&nr_node_list_lock);
+ 	write_lock_bh(&nr_neigh_list_lock);
+ 
  	while (nr_neigh != NULL) {
  		s        = nr_neigh;
  		nr_neigh = nr_neigh->next;
  
  		if (s->dev == dev) {
  			nr_node = nr_node_list;
! 			
  			while (nr_node != NULL) {
  				t       = nr_node;
  				nr_node = nr_node->next;
***************
*** 542,553 ****
  				}
  
  				if (t->count <= 0)
! 					nr_remove_node(t);
  			}
  
! 			nr_remove_neigh(s);
  		}
  	}
  }
  
  /*
--- 588,602 ----
  				}
  
  				if (t->count <= 0)
! 					nr_remove_node(t); /* nr_node_list locked, call ok */
  			}
  
! 			nr_remove_neigh(s); /* nr_neigh_list locked, call ok */
  		}
  	}
+ 	
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
  }
  
  /*
***************
*** 708,727 ****
  {
  	struct nr_neigh *nr_neigh;
  	struct nr_node  *nr_node;
! 
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next)
! 		if (nr_neigh->ax25 == ax25)
  			break;
  
! 	if (nr_neigh == NULL) return;
! 
  	nr_neigh->ax25 = NULL;
  
! 	if (++nr_neigh->failed < sysctl_netrom_link_fails_count) return;
! 
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next)
! 		if (nr_node->which < nr_node->count && nr_node->routes[nr_node->which].neighbour == nr_neigh)
  			nr_node->which++;
  }
  
  /*
--- 757,795 ----
  {
  	struct nr_neigh *nr_neigh;
  	struct nr_node  *nr_node;
! 	
! 	write_lock_bh(&nr_node_list_lock);
! 	write_lock_bh(&nr_neigh_list_lock);
! 	
! 	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
! 		if (nr_neigh->ax25 == ax25) {
  			break;
+ 		}
+ 	}
  
! 	if (nr_neigh == NULL) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		write_unlock_bh(&nr_node_list_lock);
! 		return;
! 	}
! 	
  	nr_neigh->ax25 = NULL;
  
! 	if (++nr_neigh->failed < sysctl_netrom_link_fails_count) {
! 		write_unlock_bh(&nr_neigh_list_lock);
! 		write_unlock_bh(&nr_node_list_lock);
! 		return;
! 	}
! 	
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
! 		if (nr_node->which < nr_node->count && nr_node->routes[nr_node->which].neighbour == nr_neigh) {
  			nr_node->which++;
+ 		}
+ 	}
+ 	
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
+ 
  }
  
  /*
***************
*** 736,742 ****
  	struct net_device *dev;
  	unsigned char *dptr;
  
- 
  	nr_src  = (ax25_address *)(skb->data + 0);
  	nr_dest = (ax25_address *)(skb->data + 7);
  
--- 804,809 ----
***************
*** 763,785 ****
  	if (--skb->data[14] == 0)
  		return 0;
  
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next)
! 		if (ax25cmp(nr_dest, &nr_node->callsign) == 0)
  			break;
  
! 	if (nr_node == NULL || nr_node->which >= nr_node->count)
  		return 0;
  
  	nr_neigh = nr_node->routes[nr_node->which].neighbour;
! 
! 	if ((dev = nr_dev_first()) == NULL)
  		return 0;
  
  	dptr  = skb_push(skb, 1);
  	*dptr = AX25_P_NETROM;
  
  	nr_neigh->ax25 = ax25_send_frame(skb, 256, (ax25_address *)dev->dev_addr, &nr_neigh->callsign, nr_neigh->digipeat, nr_neigh->dev);
  
  	dev_put(dev);
  
  	return (nr_neigh->ax25 != NULL);
--- 830,863 ----
  	if (--skb->data[14] == 0)
  		return 0;
  
! 	read_lock_bh(&nr_node_list_lock);
! 	
! 	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
! 		if (ax25cmp(nr_dest, &nr_node->callsign) == 0) {
  			break;
+ 		}
+ 	}
  
! 	if (nr_node == NULL || nr_node->which >= nr_node->count) {
! 		read_unlock_bh(&nr_node_list_lock);
  		return 0;
+ 	}
  
  	nr_neigh = nr_node->routes[nr_node->which].neighbour;
! 	
! 	read_unlock_bh(&nr_node_list_lock);
! 	
! 	if ((dev = nr_dev_first()) == NULL) {
  		return 0;
+ 	}
  
  	dptr  = skb_push(skb, 1);
  	*dptr = AX25_P_NETROM;
  
  	nr_neigh->ax25 = ax25_send_frame(skb, 256, (ax25_address *)dev->dev_addr, &nr_neigh->callsign, nr_neigh->digipeat, nr_neigh->dev);
  
+ 	ax25_cb_put(nr_neigh->ax25);
+ 	
  	dev_put(dev);
  
  	return (nr_neigh->ax25 != NULL);
***************
*** 788,805 ****
  int nr_nodes_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct nr_node *nr_node;
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
! 
! 	cli();
  
  	len += sprintf(buffer, "callsign  mnemonic w n qual obs neigh qual obs neigh qual obs neigh\n");
  
  	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
  		len += sprintf(buffer + len, "%-9s %-7s  %d %d",
! 			ax2asc(&nr_node->callsign),
  			(nr_node->mnemonic[0] == '\0') ? "*" : nr_node->mnemonic,
  			nr_node->which + 1,
  			nr_node->count);			
--- 866,884 ----
  int nr_nodes_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct nr_node *nr_node;
+ 	char buf[11];
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
! 	
! 	read_lock_bh(&nr_node_list_lock);
  
  	len += sprintf(buffer, "callsign  mnemonic w n qual obs neigh qual obs neigh qual obs neigh\n");
  
  	for (nr_node = nr_node_list; nr_node != NULL; nr_node = nr_node->next) {
  		len += sprintf(buffer + len, "%-9s %-7s  %d %d",
! 			ax2asc(buf, &nr_node->callsign),
  			(nr_node->mnemonic[0] == '\0') ? "*" : nr_node->mnemonic,
  			nr_node->which + 1,
  			nr_node->count);			
***************
*** 824,830 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 903,909 ----
  			break;
  	}
  
! 	read_unlock_bh(&nr_node_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 841,855 ****
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
  
! 	cli();
  
  	len += sprintf(buffer, "addr  callsign  dev  qual lock count failed digipeaters\n");
  
  	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
  		len += sprintf(buffer + len, "%05d %-9s %-4s  %3d    %d   %3d    %3d",
  			nr_neigh->number,
! 			ax2asc(&nr_neigh->callsign),
  			nr_neigh->dev ? nr_neigh->dev->name : "???",
  			nr_neigh->quality,
  			nr_neigh->locked,
--- 920,935 ----
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
+ 	char buf[11];
  
! 	read_lock_bh(&nr_neigh_list_lock);
  
  	len += sprintf(buffer, "addr  callsign  dev  qual lock count failed digipeaters\n");
  
  	for (nr_neigh = nr_neigh_list; nr_neigh != NULL; nr_neigh = nr_neigh->next) {
  		len += sprintf(buffer + len, "%05d %-9s %-4s  %3d    %d   %3d    %3d",
  			nr_neigh->number,
! 			ax2asc(buf, &nr_neigh->callsign),
  			nr_neigh->dev ? nr_neigh->dev->name : "???",
  			nr_neigh->quality,
  			nr_neigh->locked,
***************
*** 858,864 ****
  
  		if (nr_neigh->digipeat != NULL) {
  			for (i = 0; i < nr_neigh->digipeat->ndigi; i++)
! 				len += sprintf(buffer + len, " %s", ax2asc(&nr_neigh->digipeat->calls[i]));
  		}
  
  		len += sprintf(buffer + len, "\n");
--- 938,944 ----
  
  		if (nr_neigh->digipeat != NULL) {
  			for (i = 0; i < nr_neigh->digipeat->ndigi; i++)
! 				len += sprintf(buffer + len, " %s", ax2asc(buf, &nr_neigh->digipeat->calls[i]));
  		}
  
  		len += sprintf(buffer + len, "\n");
***************
*** 874,880 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 954,960 ----
  			break;
  	}
  
! 	read_unlock_bh(&nr_neigh_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 889,908 ****
   */
  void __exit nr_rt_free(void)
  {
! 	struct nr_neigh *s, *nr_neigh = nr_neigh_list;
! 	struct nr_node  *t, *nr_node  = nr_node_list;
  
  	while (nr_node != NULL) {
  		t       = nr_node;
  		nr_node = nr_node->next;
  
! 		nr_remove_node(t);
  	}
  
  	while (nr_neigh != NULL) {
  		s        = nr_neigh;
  		nr_neigh = nr_neigh->next;
  
! 		nr_remove_neigh(s);
  	}
  }
--- 969,998 ----
   */
  void __exit nr_rt_free(void)
  {
! 	struct nr_neigh *s, *nr_neigh;
! 	struct nr_node  *t, *nr_node;
! 	
! 	write_lock_bh(&nr_node_list_lock);
! 	write_lock_bh(&nr_neigh_list_lock);
! 
! 	nr_neigh = nr_neigh_list;
! 	nr_node  = nr_node_list;
  
  	while (nr_node != NULL) {
  		t       = nr_node;
  		nr_node = nr_node->next;
  
! 		nr_remove_node(t); /* nr_node_list locked, call ok */
  	}
  
  	while (nr_neigh != NULL) {
  		s        = nr_neigh;
  		nr_neigh = nr_neigh->next;
  
! 		nr_remove_neigh(s); /* nr_neigh_list locked, call ok */
  	}
+ 
+ 	write_unlock_bh(&nr_neigh_list_lock);
+ 	write_unlock_bh(&nr_node_list_lock);
+ 
  }
Index: linux-2.4.23/net/netrom/nr_subr.c
diff -c linux-2.4.23/net/netrom/nr_subr.c:1.1.1.1 linux-2.4.23/net/netrom/nr_subr.c:1.2
*** linux-2.4.23/net/netrom/nr_subr.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_subr.c	Sun Nov 30 21:17:14 2003
***************
*** 13,18 ****
--- 13,19 ----
   *	NET/ROM 001	Jonathan(G4KLX)	Cloned from ax25_subr.c
   *	NET/ROM	003	Jonathan(G4KLX)	Added G8BPQ NET/ROM extensions.
   *	NET/ROM 007	Jonathan(G4KLX)	New timer architecture.
+  *			Tihomir(9A4GL)	Spinlocking...
   */
  
  #include <linux/errno.h>
***************
*** 36,50 ****
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <net/netrom.h>
  
  /*
   *	This routine purges all of the queues of frames.
   */
  void nr_clear_queues(struct sock *sk)
  {
! 	skb_queue_purge(&sk->write_queue);
  	skb_queue_purge(&sk->protinfo.nr->ack_queue);
! 	skb_queue_purge(&sk->protinfo.nr->reseq_queue);
  	skb_queue_purge(&sk->protinfo.nr->frag_queue);
  }
  
--- 37,52 ----
  #include <linux/mm.h>
  #include <linux/interrupt.h>
  #include <net/netrom.h>
+ #include <linux/spinlock.h>
  
  /*
   *	This routine purges all of the queues of frames.
   */
  void nr_clear_queues(struct sock *sk)
  {
! 	skb_queue_purge(&sk->write_queue);	
  	skb_queue_purge(&sk->protinfo.nr->ack_queue);
! 	skb_queue_purge(&sk->protinfo.nr->reseq_queue);	
  	skb_queue_purge(&sk->protinfo.nr->frag_queue);
  }
  
***************
*** 63,70 ****
  	if (sk->protinfo.nr->va != nr) {
  		while (skb_peek(&sk->protinfo.nr->ack_queue) != NULL && sk->protinfo.nr->va != nr) {
  		        skb = skb_dequeue(&sk->protinfo.nr->ack_queue);
! 			kfree_skb(skb);
! 			sk->protinfo.nr->va = (sk->protinfo.nr->va + 1) % NR_MODULUS;
  		}
  	}
  }
--- 65,74 ----
  	if (sk->protinfo.nr->va != nr) {
  		while (skb_peek(&sk->protinfo.nr->ack_queue) != NULL && sk->protinfo.nr->va != nr) {
  		        skb = skb_dequeue(&sk->protinfo.nr->ack_queue);
! 		        if (skb) {
! 				kfree_skb(skb);
! 				sk->protinfo.nr->va = (sk->protinfo.nr->va + 1) % NR_MODULUS;
! 			}
  		}
  	}
  }
***************
*** 79,88 ****
  	struct sk_buff *skb, *skb_prev = NULL;
  
  	while ((skb = skb_dequeue(&sk->protinfo.nr->ack_queue)) != NULL) {
! 		if (skb_prev == NULL)
  			skb_queue_head(&sk->write_queue, skb);
! 		else
  			skb_append(skb_prev, skb);
  		skb_prev = skb;
  	}
  }
--- 83,93 ----
  	struct sk_buff *skb, *skb_prev = NULL;
  
  	while ((skb = skb_dequeue(&sk->protinfo.nr->ack_queue)) != NULL) {
! 		if (skb_prev == NULL) {
  			skb_queue_head(&sk->write_queue, skb);
! 		} else {
  			skb_append(skb_prev, skb);
+ 		}
  		skb_prev = skb;
  	}
  }
***************
*** 281,288 ****
  	sk->err       = reason;
  	sk->shutdown |= SEND_SHUTDOWN;
  
! 	if (!sk->dead)
  		sk->state_change(sk);
! 
! 	sk->dead = 1;
  }
--- 286,297 ----
  	sk->err       = reason;
  	sk->shutdown |= SEND_SHUTDOWN;
  
! 	if (!sk->dead) {
! 		if ( sk->socket ) {
! 			if ( sk->socket->state != SS_UNCONNECTED ) {
! 				sk->socket->state = SS_DISCONNECTING;
! 			}
! 		}
  		sk->state_change(sk);
! 	}
  }
Index: linux-2.4.23/net/netrom/nr_timer.c
diff -c linux-2.4.23/net/netrom/nr_timer.c:1.1.1.1 linux-2.4.23/net/netrom/nr_timer.c:1.2
*** linux-2.4.23/net/netrom/nr_timer.c:1.1.1.1	Sun Nov 30 18:35:59 2003
--- linux-2.4.23/net/netrom/nr_timer.c	Sun Nov 30 21:17:14 2003
***************
*** 13,18 ****
--- 13,19 ----
   *	NET/ROM 001	Jonathan(G4KLX)	Cloned from ax25_timer.c
   *	NET/ROM 007	Jonathan(G4KLX)	New timer architecture.
   *					Implemented idle timer.
+  *			Tihomir(9A4GL)	Spinlocking... Unaccepted connections fix.
   */
  
  #include <linux/errno.h>
***************
*** 139,149 ****
  		case NR_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (sk->destroy || (sk->state == TCP_LISTEN && sk->dead)) {
  				nr_destroy_socket(sk);
  				return;
  			}
! 			break;
  
  		case NR_STATE_3:
  			/*
--- 140,154 ----
  		case NR_STATE_0:
  			/* Magic here: If we listen() and a new link dies before it
  			   is accepted() it isn't 'dead' so doesn't get removed. */
! 			if (sk->destroy || (sk->state == TCP_CLOSE && sk->dead)) {
! 				sock_hold(sk);
! 				bh_lock_sock(sk);
  				nr_destroy_socket(sk);
+ 				bh_unlock_sock(sk);
+ 				sock_put(sk);
  				return;
  			}
! 
  
  		case NR_STATE_3:
  			/*
***************
*** 200,207 ****
  
  	if (!sk->dead)
  		sk->state_change(sk);
- 
- 	sk->dead = 1;
  }
  
  static void nr_t1timer_expiry(unsigned long param)
--- 205,210 ----
Index: linux-2.4.23/net/rose/af_rose.c
diff -c linux-2.4.23/net/rose/af_rose.c:1.1.1.1 linux-2.4.23/net/rose/af_rose.c:1.2
*** linux-2.4.23/net/rose/af_rose.c:1.1.1.1	Sun Nov 30 18:36:00 2003
--- linux-2.4.23/net/rose/af_rose.c	Sun Nov 30 21:17:14 2003
***************
*** 61,66 ****
--- 61,67 ----
  #include <linux/proc_fs.h>
  #include <net/ip.h>
  #include <net/arp.h>
+ #include <linux/spinlock.h>
  
  int rose_ndevs = 10;
  
***************
*** 76,81 ****
--- 77,83 ----
  int sysctl_rose_window_size             = ROSE_DEFAULT_WINDOW_SIZE;
  
  static struct sock *rose_list;
+ rwlock_t rose_list_lock = RW_LOCK_UNLOCKED;
  
  static struct proto_ops rose_proto_ops;
  
***************
*** 144,150 ****
  
  static void rose_free_sock(struct sock *sk)
  {
! 	sk_free(sk);
  
  	MOD_DEC_USE_COUNT;
  }
--- 146,152 ----
  
  static void rose_free_sock(struct sock *sk)
  {
! 	sock_put(sk);
  
  	MOD_DEC_USE_COUNT;
  }
***************
*** 158,164 ****
  		return NULL;
  
  	if ((rose = kmalloc(sizeof(*rose), GFP_ATOMIC)) == NULL) {
! 		sk_free(sk);
  		return NULL;
  	}
  
--- 160,166 ----
  		return NULL;
  
  	if ((rose = kmalloc(sizeof(*rose), GFP_ATOMIC)) == NULL) {
! 		sock_put(sk);
  		return NULL;
  	}
  
***************
*** 178,204 ****
  static void rose_remove_socket(struct sock *sk)
  {
  	struct sock *s;
- 	unsigned long flags;
- 
- 	save_flags(flags); cli();
  
  	if ((s = rose_list) == sk) {
  		rose_list = s->next;
! 		restore_flags(flags);
  		return;
  	}
  
  	while (s != NULL && s->next != NULL) {
  		if (s->next == sk) {
  			s->next = sk->next;
! 			restore_flags(flags);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	restore_flags(flags);
  }
  
  /*
--- 180,205 ----
  static void rose_remove_socket(struct sock *sk)
  {
  	struct sock *s;
  
+ 	write_lock_bh(&rose_list_lock);
+ 	
  	if ((s = rose_list) == sk) {
  		rose_list = s->next;
! 		write_unlock_bh(&rose_list_lock);
  		return;
  	}
  
  	while (s != NULL && s->next != NULL) {
  		if (s->next == sk) {
  			s->next = sk->next;
! 			write_unlock_bh(&rose_list_lock);
  			return;
  		}
  
  		s = s->next;
  	}
  
! 	write_unlock_bh(&rose_list_lock);
  }
  
  /*
***************
*** 209,214 ****
--- 210,217 ----
  {
  	struct sock *s;
  
+ 	write_lock_bh(&rose_list_lock);
+ 	
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (s->protinfo.rose->neighbour == neigh) {
  			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
***************
*** 216,221 ****
--- 219,226 ----
  			s->protinfo.rose->neighbour = NULL;
  		}
  	}
+ 	
+ 	write_unlock_bh(&rose_list_lock);
  }
  
  /*
***************
*** 225,230 ****
--- 230,237 ----
  {
  	struct sock *s;
  	
+ 	write_lock_bh(&rose_list_lock);
+ 	
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (s->protinfo.rose->device == dev) {
  			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
***************
*** 233,238 ****
--- 240,247 ----
  			s->protinfo.rose->device = NULL;
  		}
  	}
+ 	
+ 	write_unlock_bh(&rose_list_lock);
  }
  
  /*
***************
*** 263,276 ****
   */
  static void rose_insert_socket(struct sock *sk)
  {
! 	unsigned long flags;
! 
! 	save_flags(flags); cli();
! 
  	sk->next  = rose_list;
  	rose_list = sk;
  
! 	restore_flags(flags);
  }
  
  /*
--- 272,283 ----
   */
  static void rose_insert_socket(struct sock *sk)
  {
! 	write_lock_bh(&rose_list_lock);
! 	
  	sk->next  = rose_list;
  	rose_list = sk;
  
! 	write_unlock_bh(&rose_list_lock);
  }
  
  /*
***************
*** 279,304 ****
   */
  static struct sock *rose_find_listener(rose_address *addr, ax25_address *call)
  {
- 	unsigned long flags;
  	struct sock *s;
  
! 	save_flags(flags); cli();
! 
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (rosecmp(&s->protinfo.rose->source_addr, addr) == 0 && ax25cmp(&s->protinfo.rose->source_call, call) == 0 && s->protinfo.rose->source_ndigis == 0 && s->state == TCP_LISTEN) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (rosecmp(&s->protinfo.rose->source_addr, addr) == 0 && ax25cmp(&s->protinfo.rose->source_call, &null_ax25_address) == 0 && s->state == TCP_LISTEN) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  	return NULL;
  }
  
--- 286,311 ----
   */
  static struct sock *rose_find_listener(rose_address *addr, ax25_address *call)
  {
  	struct sock *s;
  
! 	read_lock_bh(&rose_list_lock);
! 	
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (rosecmp(&s->protinfo.rose->source_addr, addr) == 0 && ax25cmp(&s->protinfo.rose->source_call, call) == 0 && s->protinfo.rose->source_ndigis == 0 && s->state == TCP_LISTEN) {
! 			read_unlock_bh(&rose_list_lock);
  			return s;
  		}
  	}
  
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (rosecmp(&s->protinfo.rose->source_addr, addr) == 0 && ax25cmp(&s->protinfo.rose->source_call, &null_ax25_address) == 0 && s->state == TCP_LISTEN) {
! 			read_unlock_bh(&rose_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&rose_list_lock);
! 	
  	return NULL;
  }
  
***************
*** 308,325 ****
  struct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)
  {
  	struct sock *s;
- 	unsigned long flags;
- 
- 	save_flags(flags); cli();
  
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (s->protinfo.rose->lci == lci && s->protinfo.rose->neighbour == neigh) {
! 			restore_flags(flags);
  			return s;
  		}
  	}
  
! 	restore_flags(flags);
  
  	return NULL;
  }
--- 315,331 ----
  struct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)
  {
  	struct sock *s;
  
+ 	read_lock_bh(&rose_list_lock);
+ 	
  	for (s = rose_list; s != NULL; s = s->next) {
  		if (s->protinfo.rose->lci == lci && s->protinfo.rose->neighbour == neigh) {
! 			read_unlock_bh(&rose_list_lock);
  			return s;
  		}
  	}
  
! 	read_unlock_bh(&rose_list_lock);
  
  	return NULL;
  }
***************
*** 366,374 ****
  void rose_destroy_socket(struct sock *sk)	/* Not static as it's used by the timer */
  {
  	struct sk_buff *skb;
- 	unsigned long flags;
- 
- 	save_flags(flags); cli();
  
  	rose_stop_heartbeat(sk);
  	rose_stop_idletimer(sk);
--- 372,377 ----
***************
*** 390,404 ****
  	if (atomic_read(&sk->wmem_alloc) != 0 || atomic_read(&sk->rmem_alloc) != 0) {
  		/* Defer: outstanding buffers */
  		init_timer(&sk->timer);
! 		sk->timer.expires  = jiffies + 10 * HZ;
  		sk->timer.function = rose_destroy_timer;
  		sk->timer.data     = (unsigned long)sk;
  		add_timer(&sk->timer);
  	} else {
  		rose_free_sock(sk);
  	}
- 
- 	restore_flags(flags);
  }
  
  /*
--- 393,405 ----
  	if (atomic_read(&sk->wmem_alloc) != 0 || atomic_read(&sk->rmem_alloc) != 0) {
  		/* Defer: outstanding buffers */
  		init_timer(&sk->timer);
! 		sk->timer.expires  = jiffies + SOCK_DESTROY_TIME;
  		sk->timer.function = rose_destroy_timer;
  		sk->timer.data     = (unsigned long)sk;
  		add_timer(&sk->timer);
  	} else {
  		rose_free_sock(sk);
  	}
  }
  
  /*
***************
*** 412,466 ****
  	struct sock *sk = sock->sk;
  	int opt;
  
! 	if (level != SOL_ROSE)
  		return -ENOPROTOOPT;
  
! 	if (optlen < sizeof(int))
  		return -EINVAL;
  
! 	if (get_user(opt, (int *)optval))
  		return -EFAULT;
  
  	switch (optname) {
  		case ROSE_DEFER:
  			sk->protinfo.rose->defer = opt ? 1 : 0;
  			return 0;
  
  		case ROSE_T1:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.rose->t1 = opt * HZ;
  			return 0;
  
  		case ROSE_T2:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.rose->t2 = opt * HZ;
  			return 0;
  
  		case ROSE_T3:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.rose->t3 = opt * HZ;
  			return 0;
  
  		case ROSE_HOLDBACK:
! 			if (opt < 1)
  				return -EINVAL;
  			sk->protinfo.rose->hb = opt * HZ;
  			return 0;
  
  		case ROSE_IDLE:
! 			if (opt < 0)
  				return -EINVAL;
  			sk->protinfo.rose->idle = opt * 60 * HZ;
  			return 0;
  
  		case ROSE_QBITINCL:
  			sk->protinfo.rose->qbitincl = opt ? 1 : 0;
  			return 0;
  
  		default:
  			return -ENOPROTOOPT;
  	}
  }
--- 413,493 ----
  	struct sock *sk = sock->sk;
  	int opt;
  
! 	lock_sock(sk);
! 	
! 	if (level != SOL_ROSE) {
! 		release_sock(sk);
  		return -ENOPROTOOPT;
+ 	}
  
! 	if (optlen < sizeof(int)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (get_user(opt, (int *)optval)) {
! 		release_sock(sk);
  		return -EFAULT;
+ 	}
  
  	switch (optname) {
  		case ROSE_DEFER:
  			sk->protinfo.rose->defer = opt ? 1 : 0;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_T1:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.rose->t1 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_T2:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.rose->t2 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_T3:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.rose->t3 = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_HOLDBACK:
! 			if (opt < 1) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.rose->hb = opt * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_IDLE:
! 			if (opt < 0) {
! 				release_sock(sk);
  				return -EINVAL;
+ 			}
  			sk->protinfo.rose->idle = opt * 60 * HZ;
+ 			release_sock(sk);
  			return 0;
  
  		case ROSE_QBITINCL:
  			sk->protinfo.rose->qbitincl = opt ? 1 : 0;
+ 			release_sock(sk);
  			return 0;
  
  		default:
+ 			release_sock(sk);
  			return -ENOPROTOOPT;
  	}
  }
***************
*** 481,486 ****
--- 508,515 ----
  	if (len < 0)
  		return -EINVAL;
  			
+ 	lock_sock(sk);
+ 	
  	switch (optname) {
  		case ROSE_DEFER:
  			val = sk->protinfo.rose->defer;
***************
*** 511,524 ****
  			break;
  
  		default:
  			return -ENOPROTOOPT;
  	}
  
  	len = min_t(unsigned int, len, sizeof(int));
  
! 	if (put_user(len, optlen))
  		return -EFAULT;
  
  	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
  }
  
--- 540,557 ----
  			break;
  
  		default:
+ 			release_sock(sk);
  			return -ENOPROTOOPT;
  	}
  
  	len = min_t(unsigned int, len, sizeof(int));
  
! 	if (put_user(len, optlen)) {
! 		release_sock(sk);
  		return -EFAULT;
+ 	}
  
+ 	release_sock(sk);
  	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
  }
  
***************
*** 526,531 ****
--- 559,566 ----
  {
  	struct sock *sk = sock->sk;
  
+ 	lock_sock(sk);
+ 	
  	if (sk->state != TCP_LISTEN) {
  		sk->protinfo.rose->dest_ndigis = 0;
  		memset(&sk->protinfo.rose->dest_addr, '\0', ROSE_ADDR_LEN);
***************
*** 533,541 ****
  		memset(sk->protinfo.rose->dest_digis, '\0', AX25_ADDR_LEN*ROSE_MAX_DIGIS);
  		sk->max_ack_backlog = backlog;
  		sk->state           = TCP_LISTEN;
  		return 0;
  	}
! 
  	return -EOPNOTSUPP;
  }
  
--- 568,578 ----
  		memset(sk->protinfo.rose->dest_digis, '\0', AX25_ADDR_LEN*ROSE_MAX_DIGIS);
  		sk->max_ack_backlog = backlog;
  		sk->state           = TCP_LISTEN;
+ 		release_sock(sk);
  		return 0;
  	}
! 	
! 	release_sock(sk);
  	return -EOPNOTSUPP;
  }
  
***************
*** 591,596 ****
--- 628,635 ----
  	rose = sk->protinfo.rose;
  
  	sock_init_data(NULL, sk);
+ 	
+ 	lock_sock(sk);
  
  	skb_queue_head_init(&rose->ack_queue);
  #ifdef M_BIT
***************
*** 622,627 ****
--- 661,668 ----
  	rose->device   = osk->protinfo.rose->device;
  	rose->qbitincl = osk->protinfo.rose->qbitincl;
  
+ 	release_sock(sk);
+ 	
  	return sk;
  }
  
***************
*** 631,636 ****
--- 672,682 ----
  
  	if (sk == NULL) return 0;
  
+ 	sock_orphan(sk);
+ 	
+ 	sock_hold(sk);
+ 	lock_sock(sk);
+ 	
  	switch (sk->protinfo.rose->state) {
  
  		case ROSE_STATE_0:
***************
*** 656,672 ****
  			sk->state                = TCP_CLOSE;
  			sk->shutdown            |= SEND_SHUTDOWN;
  			sk->state_change(sk);
- 			sock_orphan(sk);
  			sk->destroy              = 1;
  			break;
  
  		default:
- 			sk->socket = NULL;
  			break;
  	}
  
! 	sock->sk = NULL;	
! 
  	return 0;
  }
  
--- 702,717 ----
  			sk->state                = TCP_CLOSE;
  			sk->shutdown            |= SEND_SHUTDOWN;
  			sk->state_change(sk);
  			sk->destroy              = 1;
  			break;
  
  		default:
  			break;
  	}
  
! 	release_sock(sk);
! 	sock_put(sk);
! 		
  	return 0;
  }
  
***************
*** 678,708 ****
  	ax25_address *user, *source;
  	int n;
  
! 	if (sk->zapped == 0)
  		return -EINVAL;
  
! 	if (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))
  		return -EINVAL;
  
! 	if (addr->srose_family != AF_ROSE)
  		return -EINVAL;
  
! 	if (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)
  		return -EINVAL;
  
! 	if (addr->srose_ndigis > ROSE_MAX_DIGIS)
  		return -EINVAL;
  
  	if ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {
  		SOCK_DEBUG(sk, "ROSE: bind failed: invalid address\n");
  		return -EADDRNOTAVAIL;
  	}
  
  	source = &addr->srose_call;
  
  	if ((user = ax25_findbyuid(current->euid)) == NULL) {
! 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))
  			return -EACCES;
  		user = source;
  	}
  
--- 723,768 ----
  	ax25_address *user, *source;
  	int n;
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped == 0) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr->srose_family != AF_ROSE) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr->srose_ndigis > ROSE_MAX_DIGIS) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	if ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {
  		SOCK_DEBUG(sk, "ROSE: bind failed: invalid address\n");
+ 		release_sock(sk);
  		return -EADDRNOTAVAIL;
  	}
  
  	source = &addr->srose_call;
  
  	if ((user = ax25_findbyuid(current->euid)) == NULL) {
! 		if (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {
! 			release_sock(sk);
  			return -EACCES;
+ 		}
  		user = source;
  	}
  
***************
*** 724,730 ****
  	rose_insert_socket(sk);
  
  	sk->zapped = 0;
! 	SOCK_DEBUG(sk, "ROSE: socket is bound\n");
  	return 0;
  }
  
--- 784,792 ----
  	rose_insert_socket(sk);
  
  	sk->zapped = 0;
! 	
! 	release_sock(sk);	
! 	
  	return 0;
  }
  
***************
*** 735,788 ****
  	unsigned char cause, diagnostic;
  	ax25_address *user;
  	struct net_device *dev;
! 	int n;
  
  	if (sk->state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {
  		sock->state = SS_CONNECTED;
  		return 0;	/* Connect completed during a ERESTARTSYS event */
  	}
  
  	if (sk->state == TCP_CLOSE && sock->state == SS_CONNECTING) {
  		sock->state = SS_UNCONNECTED;
  		return -ECONNREFUSED;
  	}
  
! 	if (sk->state == TCP_ESTABLISHED)
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 
  	sk->state   = TCP_CLOSE;
  	sock->state = SS_UNCONNECTED;
  
! 	if (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))
  		return -EINVAL;
  
! 	if (addr->srose_family != AF_ROSE)
  		return -EINVAL;
  
! 	if (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)
  		return -EINVAL;
  
! 	if (addr->srose_ndigis > ROSE_MAX_DIGIS)
  		return -EINVAL;
  
  	/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */
! 	if ((sk->protinfo.rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)
  		return -EINVAL;
  
! 	if ((sk->protinfo.rose->neighbour = rose_get_neigh(&addr->srose_addr, &cause, &diagnostic)) == NULL)
  		return -ENETUNREACH;
  
! 	if ((sk->protinfo.rose->lci = rose_new_lci(sk->protinfo.rose->neighbour)) == 0)
  		return -ENETUNREACH;
  
  	if (sk->zapped) {	/* Must bind first - autobinding in this may or may not work */
  		sk->zapped = 0;
  
! 		if ((dev = rose_dev_first()) == NULL)
  			return -ENETUNREACH;
  
! 		if ((user = ax25_findbyuid(current->euid)) == NULL)
  			return -EINVAL;
  
  		memcpy(&sk->protinfo.rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);
  		sk->protinfo.rose->source_call = *user;
--- 797,874 ----
  	unsigned char cause, diagnostic;
  	ax25_address *user;
  	struct net_device *dev;
! 	int n, err;
  
+ 	lock_sock(sk);
+ 	
  	if (sk->state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {
  		sock->state = SS_CONNECTED;
+ 		release_sock(sk);
  		return 0;	/* Connect completed during a ERESTARTSYS event */
  	}
  
  	if (sk->state == TCP_CLOSE && sock->state == SS_CONNECTING) {
  		sock->state = SS_UNCONNECTED;
+ 		release_sock(sk);
  		return -ECONNREFUSED;
  	}
  
! 	if (sk->state == TCP_ESTABLISHED) {
! 		release_sock(sk);
  		return -EISCONN;	/* No reconnect on a seqpacket socket */
! 	}
! 	
  	sk->state   = TCP_CLOSE;
  	sock->state = SS_UNCONNECTED;
  
! 	if (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose)) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr->srose_family != AF_ROSE) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if (addr->srose_ndigis > ROSE_MAX_DIGIS) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */
! 	if ((sk->protinfo.rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
! 	if ((sk->protinfo.rose->neighbour = rose_get_neigh(&addr->srose_addr, &cause, &diagnostic)) == NULL) {
! 		release_sock(sk);
  		return -ENETUNREACH;
+ 	}
  
! 	if ((sk->protinfo.rose->lci = rose_new_lci(sk->protinfo.rose->neighbour)) == 0) {
! 		release_sock(sk);
  		return -ENETUNREACH;
+ 	}
  
  	if (sk->zapped) {	/* Must bind first - autobinding in this may or may not work */
  		sk->zapped = 0;
  
! 		if ((dev = rose_dev_first()) == NULL) {
! 			release_sock(sk);
  			return -ENETUNREACH;
+ 		}
  
! 		if ((user = ax25_findbyuid(current->euid)) == NULL) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  
  		memcpy(&sk->protinfo.rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);
  		sk->protinfo.rose->source_call = *user;
***************
*** 819,850 ****
  	rose_start_t1timer(sk);
  
  	/* Now the loop */
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK))
  		return -EINPROGRESS;
! 
! 	cli();	/* To avoid races on the sleep */
  
  	/*
  	 * A Connect Ack with Choke or timeout or failed routing will go to closed.
  	 */
  	while (sk->state == TCP_SYN_SENT) {
- 		interruptible_sleep_on(sk->sleep);
  		if (signal_pending(current)) {
! 			sti();
  			return -ERESTARTSYS;
  		}
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
- 		sti();
  		sock->state = SS_UNCONNECTED;
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	sti();
! 
  	return 0;
  }
  
--- 905,946 ----
  	rose_start_t1timer(sk);
  
  	/* Now the loop */
! 	if (sk->state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {
! 		release_sock(sk);
  		return -EINPROGRESS;
! 	}
  
  	/*
  	 * A Connect Ack with Choke or timeout or failed routing will go to closed.
  	 */
  	while (sk->state == TCP_SYN_SENT) {
  		if (signal_pending(current)) {
! 			release_sock(sk);
  			return -ERESTARTSYS;
  		}
+ 		if ((err = sock_error(sk)) != 0) {
+ 			sock->state = SS_UNCONNECTED;
+ 			release_sock(sk);
+ 			return err;
+ 		}
+ 		
+ 		SOCK_SLEEP_PRE(sk);
+ 		if (sk->state == TCP_SYN_SENT) {
+ 			schedule();
+ 		}
+ 		SOCK_SLEEP_POST(sk);
  	}
  
  	if (sk->state != TCP_ESTABLISHED) {
  		sock->state = SS_UNCONNECTED;
+ 		release_sock(sk);
  		return sock_error(sk);	/* Always set at this point */
  	}
  
  	sock->state = SS_CONNECTED;
  
! 	release_sock(sk);
! 	
  	return 0;
  }
  
***************
*** 857,892 ****
  	if ((sk = sock->sk) == NULL)
  		return -EINVAL;
  
! 	if (sk->type != SOCK_SEQPACKET)
  		return -EOPNOTSUPP;
  
! 	if (sk->state != TCP_LISTEN)
  		return -EINVAL;
  
  	/*
  	 *	The write queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	do {
! 		cli();
! 		if ((skb = skb_dequeue(&sk->receive_queue)) == NULL) {
! 			if (flags & O_NONBLOCK) {
! 				sti();
! 				return -EWOULDBLOCK;
! 			}
! 			interruptible_sleep_on(sk->sleep);
! 			if (signal_pending(current)) {
! 				sti();
! 				return -ERESTARTSYS;
! 			}
  		}
! 	} while (skb == NULL);
  
  	newsk = skb->sk;
  	newsk->pair = NULL;
  	newsk->socket = newsock;
  	newsk->sleep = &newsock->wait;
- 	sti();
  
  	/* Now attach up the new socket */
  	skb->sk = NULL;
--- 953,999 ----
  	if ((sk = sock->sk) == NULL)
  		return -EINVAL;
  
! 	lock_sock(sk);
! 	
! 	if (sk->type != SOCK_SEQPACKET) {
! 		release_sock(sk);
  		return -EOPNOTSUPP;
+ 	}
  
! 	if (sk->state != TCP_LISTEN) {
! 		release_sock(sk);
  		return -EINVAL;
+ 	}
  
  	/*
  	 *	The write queue this time is holding sockets ready to use
  	 *	hooked into the SABM we saved
  	 */
! 	for (;;) {
! 		skb = skb_dequeue(&sk->receive_queue);
! 		if (skb) {
! 			break;
! 		}
! 		
! 		if (flags & O_NONBLOCK) {
! 			release_sock(sk);
! 			return -EWOULDBLOCK;
! 		}
! 		if (signal_pending(current)) {
! 			release_sock(sk);
! 			return -ERESTARTSYS;
! 		}
! 		SOCK_SLEEP_PRE(sk);
! 		if (!skb_peek(&sk->receive_queue)) {
! 			schedule();
  		}
! 		SOCK_SLEEP_POST(sk);
! 	}
  
  	newsk = skb->sk;
  	newsk->pair = NULL;
  	newsk->socket = newsock;
  	newsk->sleep = &newsock->wait;
  
  	/* Now attach up the new socket */
  	skb->sk = NULL;
***************
*** 894,899 ****
--- 1001,1008 ----
  	sk->ack_backlog--;
  	newsock->sk = newsk;
  
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
***************
*** 904,912 ****
  	struct sock *sk = sock->sk;
  	int n;
  
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  		srose->srose_family = AF_ROSE;
  		srose->srose_addr   = sk->protinfo.rose->dest_addr;
  		srose->srose_call   = sk->protinfo.rose->dest_call;
--- 1013,1025 ----
  	struct sock *sk = sock->sk;
  	int n;
  
+ 	lock_sock(sk);
+ 	
  	if (peer != 0) {
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  		srose->srose_family = AF_ROSE;
  		srose->srose_addr   = sk->protinfo.rose->dest_addr;
  		srose->srose_call   = sk->protinfo.rose->dest_call;
***************
*** 923,928 ****
--- 1036,1044 ----
  	}
  
  	*uaddr_len = sizeof(struct full_sockaddr_rose);
+ 	
+ 	release_sock(sk);
+ 	
  	return 0;
  }
  
***************
*** 1019,1055 ****
  	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR))
  		return -EINVAL;
  
! 	if (sk->zapped)
  		return -EADDRNOTAVAIL;
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
  		send_sig(SIGPIPE, current, 0);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.rose->neighbour == NULL || sk->protinfo.rose->device == NULL)
  		return -ENETUNREACH;
  
  	if (usrose != NULL) {
! 		if (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))
  			return -EINVAL;
  		memset(&srose, 0, sizeof(struct full_sockaddr_rose));
  		memcpy(&srose, usrose, msg->msg_namelen);
  		if (rosecmp(&sk->protinfo.rose->dest_addr, &srose.srose_addr) != 0 ||
! 		    ax25cmp(&sk->protinfo.rose->dest_call, &srose.srose_call) != 0)
  			return -EISCONN;
! 		if (srose.srose_ndigis != sk->protinfo.rose->dest_ndigis)
  			return -EISCONN;
  		if (srose.srose_ndigis == sk->protinfo.rose->dest_ndigis) {
  			for (n = 0 ; n < srose.srose_ndigis ; n++)
! 				if (ax25cmp(&sk->protinfo.rose->dest_digis[n], &srose.srose_digis[n]) != 0)
  					return -EISCONN;
  		}
! 		if (srose.srose_family != AF_ROSE)
  			return -EINVAL;
  	} else {
! 		if (sk->state != TCP_ESTABLISHED)
  			return -ENOTCONN;
  
  		srose.srose_family = AF_ROSE;
  		srose.srose_addr   = sk->protinfo.rose->dest_addr;
--- 1135,1190 ----
  	if (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR))
  		return -EINVAL;
  
! 	lock_sock(sk);
! 	
! 	if (sk->zapped) {
! 		release_sock(sk);
  		return -EADDRNOTAVAIL;
+ 	}
  
  	if (sk->shutdown & SEND_SHUTDOWN) {
  		send_sig(SIGPIPE, current, 0);
+ 		release_sock(sk);
  		return -EPIPE;
  	}
  
! 	if (sk->protinfo.rose->neighbour == NULL || sk->protinfo.rose->device == NULL) {
! 		release_sock(sk);
  		return -ENETUNREACH;
+ 	}
  
  	if (usrose != NULL) {
! 		if (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose)) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  		memset(&srose, 0, sizeof(struct full_sockaddr_rose));
  		memcpy(&srose, usrose, msg->msg_namelen);
  		if (rosecmp(&sk->protinfo.rose->dest_addr, &srose.srose_addr) != 0 ||
! 		    ax25cmp(&sk->protinfo.rose->dest_call, &srose.srose_call) != 0) {
! 		    	release_sock(sk);
  			return -EISCONN;
! 		}
! 		if (srose.srose_ndigis != sk->protinfo.rose->dest_ndigis) {
! 			release_sock(sk);
  			return -EISCONN;
+ 		}
  		if (srose.srose_ndigis == sk->protinfo.rose->dest_ndigis) {
  			for (n = 0 ; n < srose.srose_ndigis ; n++)
! 				if (ax25cmp(&sk->protinfo.rose->dest_digis[n], &srose.srose_digis[n]) != 0) {
! 					release_sock(sk);
  					return -EISCONN;
+ 				}
  		}
! 		if (srose.srose_family != AF_ROSE) {
! 			release_sock(sk);
  			return -EINVAL;
+ 		}
  	} else {
! 		if (sk->state != TCP_ESTABLISHED) {
! 			release_sock(sk);
  			return -ENOTCONN;
+ 		}
  
  		srose.srose_family = AF_ROSE;
  		srose.srose_addr   = sk->protinfo.rose->dest_addr;
***************
*** 1065,1072 ****
  	SOCK_DEBUG(sk, "ROSE: sendto: building packet.\n");
  	size = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)
  		return err;
  
  	skb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);
  
--- 1200,1209 ----
  	SOCK_DEBUG(sk, "ROSE: sendto: building packet.\n");
  	size = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;
  
! 	if ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL) {
! 		release_sock(sk);
  		return err;
+ 	}
  
  	skb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);
  
***************
*** 1109,1114 ****
--- 1246,1252 ----
  	
  	if (sk->state != TCP_ESTABLISHED) {
  		kfree_skb(skb);
+ 		release_sock(sk);
  		return -ENOTCONN;
  	}
  
***************
*** 1163,1168 ****
--- 1301,1308 ----
  
  	rose_kick(sk);
  
+ 	release_sock(sk);
+ 	
  	return len;
  }
  
***************
*** 1177,1192 ****
  	struct sk_buff *skb;
  	int n, er;
  
  	/*
  	 * This works for seqpacket too. The receiver has ordered the queue for
  	 * us! We do one quick check first though
  	 */
! 	if (sk->state != TCP_ESTABLISHED)
  		return -ENOTCONN;
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)
  		return er;
  
  	qbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;
  
--- 1317,1338 ----
  	struct sk_buff *skb;
  	int n, er;
  
+ 	lock_sock(sk);
+ 	
  	/*
  	 * This works for seqpacket too. The receiver has ordered the queue for
  	 * us! We do one quick check first though
  	 */
! 	if (sk->state != TCP_ESTABLISHED) {
! 		release_sock(sk);
  		return -ENOTCONN;
+ 	}
  
  	/* Now we can treat all alike */
! 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
! 		release_sock(sk);
  		return er;
+ 	}
  
  	qbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;
  
***************
*** 1228,1233 ****
--- 1374,1381 ----
  
  	skb_free_datagram(sk, skb);
  
+ 	release_sock(sk);
+ 	
  	return copied;
  }
  
***************
*** 1239,1247 ****
--- 1387,1397 ----
  	switch (cmd) {
  		case TIOCOUTQ: {
  			long amount;
+ 			lock_sock(sk);
  			amount = sk->sndbuf - atomic_read(&sk->wmem_alloc);
  			if (amount < 0)
  				amount = 0;
+ 			release_sock(sk);
  			return put_user(amount, (unsigned int *)arg);
  		}
  
***************
*** 1282,1289 ****
--- 1432,1441 ----
  
  		case SIOCRSGCAUSE: {
  			struct rose_cause_struct rose_cause;
+ 			lock_sock(sk);
  			rose_cause.cause      = sk->protinfo.rose->cause;
  			rose_cause.diagnostic = sk->protinfo.rose->diagnostic;
+ 			release_sock(sk);
  			return copy_to_user((void *)arg, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;
  		}
  
***************
*** 1291,1298 ****
--- 1443,1452 ----
  			struct rose_cause_struct rose_cause;
  			if (copy_from_user(&rose_cause, (void *)arg, sizeof(struct rose_cause_struct)))
  				return -EFAULT;
+ 			lock_sock(sk);
  			sk->protinfo.rose->cause      = rose_cause.cause;
  			sk->protinfo.rose->diagnostic = rose_cause.diagnostic;
+ 			release_sock(sk);
  			return 0;
  		}
  
***************
*** 1310,1315 ****
--- 1464,1470 ----
  			return copy_to_user((void *)arg, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;
  
  		case SIOCRSACCEPT:
+ 			lock_sock(sk);
  			if (sk->protinfo.rose->state == ROSE_STATE_5) {
  				rose_write_internal(sk, ROSE_CALL_ACCEPTED);
  				rose_start_idletimer(sk);
***************
*** 1320,1325 ****
--- 1475,1481 ----
  				sk->protinfo.rose->vl        = 0;
  				sk->protinfo.rose->state     = ROSE_STATE_3;
  			}
+ 			release_sock(sk);
  			return 0;
  
  		default:
***************
*** 1335,1346 ****
  	struct sock *s;
  	struct net_device *dev;
  	const char *devname, *callsign;
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	cli();
! 
  	len += sprintf(buffer, "dest_addr  dest_call src_addr   src_call  dev   lci neigh st vs vr va   t  t1  t2  t3  hb    idle Snd-Q Rcv-Q inode\n");
  
  	for (s = rose_list; s != NULL; s = s->next) {
--- 1491,1503 ----
  	struct sock *s;
  	struct net_device *dev;
  	const char *devname, *callsign;
+ 	char buf[11];
  	int len = 0;
  	off_t pos = 0;
  	off_t begin = 0;
  
! 	read_lock_bh(&rose_list_lock);
! 	
  	len += sprintf(buffer, "dest_addr  dest_call src_addr   src_call  dev   lci neigh st vs vr va   t  t1  t2  t3  hb    idle Snd-Q Rcv-Q inode\n");
  
  	for (s = rose_list; s != NULL; s = s->next) {
***************
*** 1351,1362 ****
  
  		len += sprintf(buffer + len, "%-10s %-9s ",
  			rose2asc(&s->protinfo.rose->dest_addr),
! 			ax2asc(&s->protinfo.rose->dest_call));
  
  		if (ax25cmp(&s->protinfo.rose->source_call, &null_ax25_address) == 0)
  			callsign = "??????-?";
  		else
! 			callsign = ax2asc(&s->protinfo.rose->source_call);
  
  		len += sprintf(buffer + len, "%-10s %-9s %-5s %3.3X %05d  %d  %d  %d  %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\n",
  			rose2asc(&s->protinfo.rose->source_addr),
--- 1508,1519 ----
  
  		len += sprintf(buffer + len, "%-10s %-9s ",
  			rose2asc(&s->protinfo.rose->dest_addr),
! 			ax2asc(buf, &s->protinfo.rose->dest_call));
  
  		if (ax25cmp(&s->protinfo.rose->source_call, &null_ax25_address) == 0)
  			callsign = "??????-?";
  		else
! 			callsign = ax2asc(buf, &s->protinfo.rose->source_call);
  
  		len += sprintf(buffer + len, "%-10s %-9s %-5s %3.3X %05d  %d  %d  %d  %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\n",
  			rose2asc(&s->protinfo.rose->source_addr),
***************
*** 1390,1396 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 1547,1553 ----
  			break;
  	}
  
! 	read_unlock_bh(&rose_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1405,1411 ****
  	create:		rose_create,
  };
  
! static struct proto_ops SOCKOPS_WRAPPED(rose_proto_ops) = {
  	family:		PF_ROSE,
  
  	release:	rose_release,
--- 1562,1568 ----
  	create:		rose_create,
  };
  
! static struct proto_ops rose_proto_ops = {
  	family:		PF_ROSE,
  
  	release:	rose_release,
***************
*** 1426,1434 ****
  	sendpage:	sock_no_sendpage,
  };
  
- #include <linux/smp_lock.h>
- SOCKOPS_WRAP(rose_proto, PF_ROSE);
- 
  static struct notifier_block rose_dev_notifier = {
  	notifier_call:	rose_device_event,
  };
--- 1583,1588 ----
Index: linux-2.4.23/net/rose/rose_link.c
diff -c linux-2.4.23/net/rose/rose_link.c:1.1.1.1 linux-2.4.23/net/rose/rose_link.c:1.2
*** linux-2.4.23/net/rose/rose_link.c:1.1.1.1	Sun Nov 30 18:36:00 2003
--- linux-2.4.23/net/rose/rose_link.c	Sun Nov 30 21:17:14 2003
***************
*** 113,118 ****
--- 113,121 ----
  
  	neigh->ax25 = ax25_send_frame(skb, 260, rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);
  
+ 	/* TODO: call ax25_cb_put when reference is not needed any more */
+ 	ax25_cb_put(neigh->ax25);
+ 
  	return (neigh->ax25 != NULL);
  }
  
***************
*** 124,138 ****
  static int rose_link_up(struct rose_neigh *neigh)
  {
  	ax25_address *rose_call;
  
! 	if (ax25cmp(&rose_callsign, &null_ax25_address) == 0)
  		rose_call = (ax25_address *)neigh->dev->dev_addr;
! 	else
  		rose_call = &rose_callsign;
  
  	neigh->ax25 = ax25_find_cb(rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);
  
! 	return (neigh->ax25 != NULL);
  }
  
  /*
--- 127,146 ----
  static int rose_link_up(struct rose_neigh *neigh)
  {
  	ax25_address *rose_call;
+ 	int ret;
  
! 	if (ax25cmp(&rose_callsign, &null_ax25_address) == 0) {
  		rose_call = (ax25_address *)neigh->dev->dev_addr;
! 	} else {
  		rose_call = &rose_callsign;
+ 	}
  
  	neigh->ax25 = ax25_find_cb(rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);
  
!         ret = (neigh->ax25 != NULL);
!         ax25_cb_put(neigh->ax25);
!         
! 	return ret;
  }
  
  /*
Index: linux-2.4.23/net/rose/rose_route.c
diff -c linux-2.4.23/net/rose/rose_route.c:1.1.1.1 linux-2.4.23/net/rose/rose_route.c:1.2
*** linux-2.4.23/net/rose/rose_route.c:1.1.1.1	Sun Nov 30 18:36:00 2003
--- linux-2.4.23/net/rose/rose_route.c	Sun Nov 30 21:17:14 2003
***************
*** 47,58 ****
--- 47,62 ----
  #include <linux/netfilter.h>
  #include <linux/init.h>
  #include <net/rose.h>
+ #include <linux/spinlock.h>
  
  static unsigned int rose_neigh_no = 1;
  
  static struct rose_node  *rose_node_list;
+ rwlock_t rose_node_list_lock = RW_LOCK_UNLOCKED;
  static struct rose_neigh *rose_neigh_list;
+ rwlock_t rose_neigh_list_lock = RW_LOCK_UNLOCKED;
  static struct rose_route *rose_route_list;
+ rwlock_t rose_route_list_lock = RW_LOCK_UNLOCKED;
  
  struct rose_neigh *rose_loopback_neigh;
  
***************
*** 66,88 ****
  {
  	struct rose_node  *rose_node, *rose_tmpn, *rose_tmpp;
  	struct rose_neigh *rose_neigh;
- 	unsigned long flags;
  	int i;
  
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next)
! 		if ((rose_node->mask == rose_route->mask) && (rosecmpm(&rose_route->address, &rose_node->address, rose_route->mask) == 0))
  			break;
  
! 	if (rose_node != NULL && rose_node->loopback)
  		return -EINVAL;
  
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next)
! 		if (ax25cmp(&rose_route->neighbour, &rose_neigh->callsign) == 0 && rose_neigh->dev == dev)
  			break;
  
  	if (rose_neigh == NULL) {
! 		if ((rose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC)) == NULL)
  			return -ENOMEM;
  
  		rose_neigh->callsign  = rose_route->neighbour;
  		rose_neigh->digipeat  = NULL;
--- 70,104 ----
  {
  	struct rose_node  *rose_node, *rose_tmpn, *rose_tmpp;
  	struct rose_neigh *rose_neigh;
  	int i;
  
! 	write_lock_bh(&rose_node_list_lock);
! 		
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next) {
! 		if ((rose_node->mask == rose_route->mask) && (rosecmpm(&rose_route->address, &rose_node->address, rose_route->mask) == 0)) {
  			break;
+ 		}
+ 	}
  
! 	if (rose_node != NULL && rose_node->loopback) {
! 		write_unlock_bh(&rose_node_list_lock);
  		return -EINVAL;
+ 	}
  
! 	write_lock_bh(&rose_neigh_list_lock);
! 	
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
! 		if (ax25cmp(&rose_route->neighbour, &rose_neigh->callsign) == 0 && rose_neigh->dev == dev) {
  			break;
+ 		}
+ 	}
  
  	if (rose_neigh == NULL) {
! 		if ((rose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC)) == NULL) {
! 			write_unlock_bh(&rose_neigh_list_lock);
! 			write_unlock_bh(&rose_node_list_lock);
  			return -ENOMEM;
+ 		}
  
  		rose_neigh->callsign  = rose_route->neighbour;
  		rose_neigh->digipeat  = NULL;
***************
*** 103,108 ****
--- 119,126 ----
  		if (rose_route->ndigis != 0) {
  			if ((rose_neigh->digipeat = kmalloc(sizeof(ax25_digi), GFP_KERNEL)) == NULL) {
  				kfree(rose_neigh);
+ 				write_unlock_bh(&rose_neigh_list_lock);
+ 				write_unlock_bh(&rose_node_list_lock);
  				return -ENOMEM;
  			}
  
***************
*** 115,124 ****
  			}
  		}
  
- 		save_flags(flags); cli();
  		rose_neigh->next = rose_neigh_list;
  		rose_neigh_list  = rose_neigh;
- 		restore_flags(flags);
  	}
  
  	/*
--- 133,140 ----
***************
*** 142,149 ****
  		}
  
  		/* create new node */
! 		if ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL)
  			return -ENOMEM;
  
  		rose_node->address      = rose_route->address;
  		rose_node->mask         = rose_route->mask;
--- 158,168 ----
  		}
  
  		/* create new node */
! 		if ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {
! 			write_unlock_bh(&rose_neigh_list_lock);	
! 			write_unlock_bh(&rose_node_list_lock);
  			return -ENOMEM;
+ 		}
  
  		rose_node->address      = rose_route->address;
  		rose_node->mask         = rose_route->mask;
***************
*** 151,158 ****
  		rose_node->loopback     = 0;
  		rose_node->neighbour[0] = rose_neigh;
  
- 		save_flags(flags); cli();
- 
  		if (rose_tmpn == NULL) {
  			if (rose_tmpp == NULL) {	/* Empty list */
  				rose_node_list  = rose_node;
--- 170,175 ----
***************
*** 171,180 ****
  			}
  		}
  
- 		restore_flags(flags);
- 
  		rose_neigh->count++;
  
  		return 0;
  	}
  
--- 188,198 ----
  			}
  		}
  
  		rose_neigh->count++;
  
+ 		write_unlock_bh(&rose_neigh_list_lock);	
+ 		write_unlock_bh(&rose_node_list_lock);
+ 		
  		return 0;
  	}
  
***************
*** 185,204 ****
  		rose_neigh->count++;
  	}
  
  	return 0;
  }
  
  static void rose_remove_node(struct rose_node *rose_node)
  {
  	struct rose_node *s;
- 	unsigned long flags;
- 	
- 	save_flags(flags);
- 	cli();
  
  	if ((s = rose_node_list) == rose_node) {
  		rose_node_list = rose_node->next;
- 		restore_flags(flags);
  		kfree(rose_node);
  		return;
  	}
--- 203,223 ----
  		rose_neigh->count++;
  	}
  
+ 	write_unlock_bh(&rose_neigh_list_lock);	
+ 	write_unlock_bh(&rose_node_list_lock);
+ 	
  	return 0;
  }
  
+ /*
+  *	rose_node_list_lock must be locked !
+  */
  static void rose_remove_node(struct rose_node *rose_node)
  {
  	struct rose_node *s;
  
  	if ((s = rose_node_list) == rose_node) {
  		rose_node_list = rose_node->next;
  		kfree(rose_node);
  		return;
  	}
***************
*** 206,239 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == rose_node) {
  			s->next = rose_node->next;
- 			restore_flags(flags);
  			kfree(rose_node);
  			return;
  		}
  
  		s = s->next;
  	}
- 
- 	restore_flags(flags);
  }
  
  static void rose_remove_neigh(struct rose_neigh *rose_neigh)
  {
  	struct rose_neigh *s;
- 	unsigned long flags;
  
  	rose_stop_ftimer(rose_neigh);
  	rose_stop_t0timer(rose_neigh);
  
  	skb_queue_purge(&rose_neigh->queue);
  
- 	save_flags(flags); cli();
- 
  	if ((s = rose_neigh_list) == rose_neigh) {
  		rose_neigh_list = rose_neigh->next;
! 		restore_flags(flags);
! 		if (rose_neigh->digipeat != NULL)
  			kfree(rose_neigh->digipeat);
  		kfree(rose_neigh);
  		return;
  	}
--- 225,255 ----
  	while (s != NULL && s->next != NULL) {
  		if (s->next == rose_node) {
  			s->next = rose_node->next;
  			kfree(rose_node);
  			return;
  		}
  
  		s = s->next;
  	}
  }
  
+ /*
+  * 	rose_neigh_list_lock must be locked !
+  */
  static void rose_remove_neigh(struct rose_neigh *rose_neigh)
  {
  	struct rose_neigh *s;
  
  	rose_stop_ftimer(rose_neigh);
  	rose_stop_t0timer(rose_neigh);
  
  	skb_queue_purge(&rose_neigh->queue);
  
  	if ((s = rose_neigh_list) == rose_neigh) {
  		rose_neigh_list = rose_neigh->next;
! 		if (rose_neigh->digipeat != NULL) {
  			kfree(rose_neigh->digipeat);
+ 		}
  		kfree(rose_neigh);
  		return;
  	}
***************
*** 241,275 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == rose_neigh) {
  			s->next = rose_neigh->next;
! 			restore_flags(flags);
! 			if (rose_neigh->digipeat != NULL)
  				kfree(rose_neigh->digipeat);
  			kfree(rose_neigh);
  			return;
  		}
  
  		s = s->next;
  	}
- 
- 	restore_flags(flags);
  }
  
  static void rose_remove_route(struct rose_route *rose_route)
  {
  	struct rose_route *s;
- 	unsigned long flags;
  
! 	if (rose_route->neigh1 != NULL)
  		rose_route->neigh1->use--;
  
! 	if (rose_route->neigh2 != NULL)
  		rose_route->neigh2->use--;
! 
! 	save_flags(flags); cli();
! 
  	if ((s = rose_route_list) == rose_route) {
  		rose_route_list = rose_route->next;
- 		restore_flags(flags);
  		kfree(rose_route);
  		return;
  	}
--- 257,290 ----
  	while (s != NULL && s->next != NULL) {
  		if (s->next == rose_neigh) {
  			s->next = rose_neigh->next;
! 			if (rose_neigh->digipeat != NULL) {
  				kfree(rose_neigh->digipeat);
+ 			}
  			kfree(rose_neigh);
  			return;
  		}
  
  		s = s->next;
  	}
  }
  
+ /*
+  * 	rose_route_list_lock must be locked !
+  */
  static void rose_remove_route(struct rose_route *rose_route)
  {
  	struct rose_route *s;
  
! 	if (rose_route->neigh1 != NULL) {
  		rose_route->neigh1->use--;
+ 	}
  
! 	if (rose_route->neigh2 != NULL) {
  		rose_route->neigh2->use--;
! 	}
! 	
  	if ((s = rose_route_list) == rose_route) {
  		rose_route_list = rose_route->next;
  		kfree(rose_route);
  		return;
  	}
***************
*** 277,291 ****
  	while (s != NULL && s->next != NULL) {
  		if (s->next == rose_route) {
  			s->next = rose_route->next;
- 			restore_flags(flags);
  			kfree(rose_route);
  			return;
  		}
  
  		s = s->next;
  	}
- 
- 	restore_flags(flags);
  }
  
  /*
--- 292,303 ----
***************
*** 298,323 ****
  	struct rose_neigh *rose_neigh;
  	int i;
  
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next)
! 		if ((rose_node->mask == rose_route->mask) && (rosecmpm(&rose_route->address, &rose_node->address, rose_route->mask) == 0))
  			break;
  
! 	if (rose_node == NULL) return -EINVAL;
! 
! 	if (rose_node->loopback) return -EINVAL;
  
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next)
! 		if (ax25cmp(&rose_route->neighbour, &rose_neigh->callsign) == 0 && rose_neigh->dev == dev)
  			break;
  
! 	if (rose_neigh == NULL) return -EINVAL;
! 
  	for (i = 0; i < rose_node->count; i++) {
  		if (rose_node->neighbour[i] == rose_neigh) {
  			rose_neigh->count--;
  
! 			if (rose_neigh->count == 0 && rose_neigh->use == 0)
  				rose_remove_neigh(rose_neigh);
  
  			rose_node->count--;
  
--- 310,354 ----
  	struct rose_neigh *rose_neigh;
  	int i;
  
! 	write_lock_bh(&rose_node_list_lock);
! 	
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next) {
! 		if ((rose_node->mask == rose_route->mask) && (rosecmpm(&rose_route->address, &rose_node->address, rose_route->mask) == 0)) {
  			break;
+ 		}
+ 	}
  
! 	if (rose_node == NULL) {
! 		write_unlock_bh(&rose_node_list_lock);
! 		return -EINVAL;
! 	}
  
! 	if (rose_node->loopback) {
! 		write_unlock_bh(&rose_node_list_lock);
! 		return -EINVAL;
! 	}
! 	
! 	write_lock_bh(&rose_neigh_list_lock);
! 	
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
! 		if (ax25cmp(&rose_route->neighbour, &rose_neigh->callsign) == 0 && rose_neigh->dev == dev) {
  			break;
+ 		}
+ 	}
  
! 	if (rose_neigh == NULL) {
! 		write_unlock_bh(&rose_neigh_list_lock);
! 		write_unlock_bh(&rose_node_list_lock);
! 		return -EINVAL;
! 	}
! 	
  	for (i = 0; i < rose_node->count; i++) {
  		if (rose_node->neighbour[i] == rose_neigh) {
  			rose_neigh->count--;
  
! 			if (rose_neigh->count == 0 && rose_neigh->use == 0) {
  				rose_remove_neigh(rose_neigh);
+ 			}
  
  			rose_node->count--;
  
***************
*** 333,343 ****
  						break;
  				}
  			}
! 
  			return 0;
  		}
  	}
  
  	return -EINVAL;
  }
  
--- 364,378 ----
  						break;
  				}
  			}
! 			write_unlock_bh(&rose_neigh_list_lock);
! 			write_unlock_bh(&rose_node_list_lock);
  			return 0;
  		}
  	}
  
+ 	write_unlock_bh(&rose_neigh_list_lock);
+ 	write_unlock_bh(&rose_node_list_lock);
+ 	
  	return -EINVAL;
  }
  
***************
*** 346,355 ****
   */
  int rose_add_loopback_neigh(void)
  {
! 	unsigned long flags;
! 
! 	if ((rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_ATOMIC)) == NULL)
  		return -ENOMEM;
  
  	rose_loopback_neigh->callsign  = null_ax25_address;
  	rose_loopback_neigh->digipeat  = NULL;
--- 381,389 ----
   */
  int rose_add_loopback_neigh(void)
  {
! 	if ((rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_ATOMIC)) == NULL) {
  		return -ENOMEM;
+ 	}
  
  	rose_loopback_neigh->callsign  = null_ax25_address;
  	rose_loopback_neigh->digipeat  = NULL;
***************
*** 367,377 ****
  	init_timer(&rose_loopback_neigh->ftimer);
  	init_timer(&rose_loopback_neigh->t0timer);
  
! 	save_flags(flags); cli();
  	rose_loopback_neigh->next = rose_neigh_list;
  	rose_neigh_list           = rose_loopback_neigh;
! 	restore_flags(flags);
! 
  	return 0;
  }
  
--- 401,411 ----
  	init_timer(&rose_loopback_neigh->ftimer);
  	init_timer(&rose_loopback_neigh->t0timer);
  
! 	write_lock_bh(&rose_neigh_list_lock);
  	rose_loopback_neigh->next = rose_neigh_list;
  	rose_neigh_list           = rose_loopback_neigh;
! 	write_unlock_bh(&rose_neigh_list_lock);
! 	
  	return 0;
  }
  
***************
*** 381,396 ****
  int rose_add_loopback_node(rose_address *address)
  {
  	struct rose_node *rose_node;
- 	unsigned long flags;
  
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next)
! 		if ((rose_node->mask == 10) && (rosecmpm(address, &rose_node->address, 10) == 0) && rose_node->loopback)
  			break;
  
! 	if (rose_node != NULL) return 0;
  	
! 	if ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL)
  		return -ENOMEM;
  
  	rose_node->address      = *address;
  	rose_node->mask         = 10;
--- 415,438 ----
  int rose_add_loopback_node(rose_address *address)
  {
  	struct rose_node *rose_node;
  
! 	write_lock_bh(&rose_node_list_lock);
! 	
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next) {
! 		if ((rose_node->mask == 10) && (rosecmpm(address, &rose_node->address, 10) == 0) && rose_node->loopback) {
  			break;
+ 		}
+ 	}
  
! 	if (rose_node != NULL) {
! 		write_unlock_bh(&rose_node_list_lock);
! 		return 0;
! 	}
  	
! 	if ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {
! 		write_unlock_bh(&rose_node_list_lock);
  		return -ENOMEM;
+ 	}
  
  	rose_node->address      = *address;
  	rose_node->mask         = 10;
***************
*** 399,408 ****
  	rose_node->neighbour[0] = rose_loopback_neigh;
  
  	/* Insert at the head of list. Address is always mask=10 */
! 	save_flags(flags); cli();
  	rose_node->next = rose_node_list;
  	rose_node_list  = rose_node;
! 	restore_flags(flags);
  
  	rose_loopback_neigh->count++;
  
--- 441,451 ----
  	rose_node->neighbour[0] = rose_loopback_neigh;
  
  	/* Insert at the head of list. Address is always mask=10 */
! 	
  	rose_node->next = rose_node_list;
  	rose_node_list  = rose_node;
! 	
! 	write_unlock_bh(&rose_node_list_lock);
  
  	rose_loopback_neigh->count++;
  
***************
*** 416,430 ****
  {
  	struct rose_node *rose_node;
  
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next)
! 		if ((rose_node->mask == 10) && (rosecmpm(address, &rose_node->address, 10) == 0) && rose_node->loopback)
  			break;
! 
! 	if (rose_node == NULL) return;
! 
  	rose_remove_node(rose_node);
  
  	rose_loopback_neigh->count--;
  }
  
  /*
--- 459,482 ----
  {
  	struct rose_node *rose_node;
  
! 	write_lock_bh(&rose_node_list_lock);
! 	
! 	for (rose_node = rose_node_list; rose_node != NULL; rose_node = rose_node->next) {
! 		if ((rose_node->mask == 10) && (rosecmpm(address, &rose_node->address, 10) == 0) && rose_node->loopback) {
  			break;
! 		}
! 	}
! 	
! 	if (rose_node == NULL) {
! 		write_unlock_bh(&rose_node_list_lock);
! 		return;
! 	}
! 	
  	rose_remove_node(rose_node);
  
  	rose_loopback_neigh->count--;
+ 	
+ 	write_unlock_bh(&rose_node_list_lock);
  }
  
  /*
***************
*** 432,448 ****
   */
  void rose_rt_device_down(struct net_device *dev)
  {
! 	struct rose_neigh *s, *rose_neigh = rose_neigh_list;
  	struct rose_node  *t, *rose_node;
  	int i;
  
  	while (rose_neigh != NULL) {
  		s          = rose_neigh;
  		rose_neigh = rose_neigh->next;
  
! 		if (s->dev == dev) {
  			rose_node = rose_node_list;
- 
  			while (rose_node != NULL) {
  				t         = rose_node;
  				rose_node = rose_node->next;
--- 484,504 ----
   */
  void rose_rt_device_down(struct net_device *dev)
  {
! 	struct rose_neigh *s, *rose_neigh;
  	struct rose_node  *t, *rose_node;
  	int i;
  
+ 	write_lock_bh(&rose_neigh_list_lock);
+ 
+ 	rose_neigh = rose_neigh_list;
+ 	
  	while (rose_neigh != NULL) {
  		s          = rose_neigh;
  		rose_neigh = rose_neigh->next;
  
! 		if (s->dev == dev) {		
! 			write_lock_bh(&rose_node_list_lock);
  			rose_node = rose_node_list;
  			while (rose_node != NULL) {
  				t         = rose_node;
  				rose_node = rose_node->next;
***************
*** 462,474 ****
  					}
  				}
  
! 				if (t->count <= 0)
  					rose_remove_node(t);
  			}
! 
  			rose_remove_neigh(s);
  		}
  	}
  }
  
  /*
--- 518,532 ----
  					}
  				}
  
! 				if (t->count <= 0) {
  					rose_remove_node(t);
+ 				}
  			}
! 			write_unlock_bh(&rose_node_list_lock);
  			rose_remove_neigh(s);
  		}
  	}
+ 	write_unlock_bh(&rose_neigh_list_lock);
  }
  
  /*
***************
*** 476,490 ****
   */
  void rose_route_device_down(struct net_device *dev)
  {
! 	struct rose_route *s, *rose_route = rose_route_list;
  
  	while (rose_route != NULL) {
  		s          = rose_route;
  		rose_route = rose_route->next;
  
! 		if (s->neigh1->dev == dev || s->neigh2->dev == dev)
  			rose_remove_route(s);
  	}
  }
  
  /*
--- 534,554 ----
   */
  void rose_route_device_down(struct net_device *dev)
  {
! 	struct rose_route *s, *rose_route;
  
+ 	write_lock_bh(&rose_route_list_lock);
+ 	
+ 	rose_route = rose_route_list;
+ 	
  	while (rose_route != NULL) {
  		s          = rose_route;
  		rose_route = rose_route->next;
  
! 		if (s->neigh1->dev == dev || s->neigh2->dev == dev) {
  			rose_remove_route(s);
+ 		}
  	}
+ 	write_unlock_bh(&rose_route_list_lock);
  }
  
  /*
***************
*** 494,507 ****
   */
  static int rose_clear_routes(void)
  {
! 	struct rose_neigh *s, *rose_neigh = rose_neigh_list;
! 	struct rose_node  *t, *rose_node  = rose_node_list;
  
  	while (rose_node != NULL) {
  		t         = rose_node;
  		rose_node = rose_node->next;
! 		if (!t->loopback)
  			rose_remove_node(t);
  	}
  
  	while (rose_neigh != NULL) {
--- 558,578 ----
   */
  static int rose_clear_routes(void)
  {
! 	struct rose_neigh *s, *rose_neigh;
! 	struct rose_node  *t, *rose_node;
  
+ 	write_lock_bh(&rose_node_list_lock);
+ 	write_lock_bh(&rose_neigh_list_lock);
+ 	
+ 	rose_neigh = rose_neigh_list;
+ 	rose_node  = rose_node_list;
+ 	
  	while (rose_node != NULL) {
  		t         = rose_node;
  		rose_node = rose_node->next;
! 		if (!t->loopback) {
  			rose_remove_node(t);
+ 		}
  	}
  
  	while (rose_neigh != NULL) {
***************
*** 513,519 ****
  			rose_remove_neigh(s);
  		}
  	}
! 
  	return 0;
  }
  
--- 584,593 ----
  			rose_remove_neigh(s);
  		}
  	}
! 	
! 	write_unlock_bh(&rose_neigh_list_lock);
! 	write_unlock_bh(&rose_node_list_lock);
! 	
  	return 0;
  }
  
***************
*** 531,536 ****
--- 605,611 ----
  		return dev;
  
  	dev_put(dev);
+ 
  	return NULL;
  }
  
***************
*** 542,551 ****
  	struct net_device *dev, *first = NULL;
  
  	read_lock(&dev_base_lock);
  	for (dev = dev_base; dev != NULL; dev = dev->next) {
! 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)
! 			if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
  				first = dev;
  	}
  	read_unlock(&dev_base_lock);
  
--- 617,629 ----
  	struct net_device *dev, *first = NULL;
  
  	read_lock(&dev_base_lock);
+ 
  	for (dev = dev_base; dev != NULL; dev = dev->next) {
! 		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE) {
! 			if (first == NULL || strncmp(dev->name, first->name, 3) < 0) {
  				first = dev;
+ 			}
+ 		}
  	}
  	read_unlock(&dev_base_lock);
  
***************
*** 576,587 ****
--- 654,667 ----
  	struct net_device *dev;
  
  	read_lock(&dev_base_lock);
+ 
  	for (dev = dev_base; dev != NULL; dev = dev->next) {
  		if ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0)
  			goto out;
  	}
  out:
  	read_unlock(&dev_base_lock);
+ 
  	return dev != NULL;
  }
  
***************
*** 592,602 ****
  {
  	struct rose_route *rose_route;
  
! 	for (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next)
  		if ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||
! 		    (rose_route->neigh2 == neigh && rose_route->lci2 == lci))
  			return rose_route;
  
  	return NULL;
  }
  
--- 672,688 ----
  {
  	struct rose_route *rose_route;
  
! 	read_lock_bh(&rose_route_list_lock);
! 	
! 	for (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next) {
  		if ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||
! 		    (rose_route->neigh2 == neigh && rose_route->lci2 == lci)) {
  			return rose_route;
+ 		}
+ 	}
  
+ 	read_unlock_bh(&rose_route_list_lock);
+ 	
  	return NULL;
  }
  
***************
*** 609,626 ****
  	int failed = 0;
  	int i;
  
  	for (node = rose_node_list; node != NULL; node = node->next) {
  		if (rosecmpm(addr, &node->address, node->mask) == 0) {
  			for (i = 0; i < node->count; i++) {
  				if (!rose_ftimer_running(node->neighbour[i])) {
! 					return node->neighbour[i]; }
! 				else
  					failed = 1;
  			}
  			break;
  		}
  	}
  
  	if (failed) {
  		*cause      = ROSE_OUT_OF_ORDER;
  		*diagnostic = 0;
--- 695,717 ----
  	int failed = 0;
  	int i;
  
+ 	read_lock_bh(&rose_node_list_lock);
+ 	
  	for (node = rose_node_list; node != NULL; node = node->next) {
  		if (rosecmpm(addr, &node->address, node->mask) == 0) {
  			for (i = 0; i < node->count; i++) {
  				if (!rose_ftimer_running(node->neighbour[i])) {
! 					return node->neighbour[i]; 
! 				} else {
  					failed = 1;
+ 				}
  			}
  			break;
  		}
  	}
  
+ 	read_unlock_bh(&rose_node_list_lock);
+ 	
  	if (failed) {
  		*cause      = ROSE_OUT_OF_ORDER;
  		*diagnostic = 0;
***************
*** 628,634 ****
  		*cause      = ROSE_NOT_OBTAINABLE;
  		*diagnostic = 0;
  	}
! 
  	return NULL;
  }
  
--- 719,725 ----
  		*cause      = ROSE_NOT_OBTAINABLE;
  		*diagnostic = 0;
  	}
! 	
  	return NULL;
  }
  
***************
*** 654,661 ****
  			}
  			if (rose_route.mask > 10) /* Mask can't be more than 10 digits */
  				return -EINVAL;
! 
  			err = rose_add_node(&rose_route, dev);
  			dev_put(dev);
  			return err;
  
--- 745,753 ----
  			}
  			if (rose_route.mask > 10) /* Mask can't be more than 10 digits */
  				return -EINVAL;
! 			write_lock_bh(&rose_node_list_lock);
  			err = rose_add_node(&rose_route, dev);
+ 			write_unlock_bh(&rose_node_list_lock);
  			dev_put(dev);
  			return err;
  
***************
*** 664,675 ****
--- 756,770 ----
  				return -EFAULT;
  			if ((dev = rose_ax25_dev_get(rose_route.device)) == NULL)
  				return -EINVAL;
+ 			write_lock_bh(&rose_node_list_lock);
  			err = rose_del_node(&rose_route, dev);
+ 			write_unlock_bh(&rose_node_list_lock);
  			dev_put(dev);
  			return err;
  				
  
  		case SIOCRSCLRRT:
+ 			// this one locks inside
  			return rose_clear_routes();
  
  		default:
***************
*** 690,695 ****
--- 785,792 ----
  
  	skb_queue_purge(&rose_neigh->queue);
  
+ 	write_lock_bh(&rose_route_list_lock);
+ 	
  	rose_route = rose_route_list;
  
  	while (rose_route != NULL) {
***************
*** 716,721 ****
--- 813,820 ----
  
  		rose_route = rose_route->next;
  	}
+ 	
+ 	write_unlock_bh(&rose_route_list_lock);
  }
  
  /*
***************
*** 727,742 ****
  {
  	struct rose_neigh *rose_neigh;
  
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next)
! 		if (rose_neigh->ax25 == ax25)
  			break;
  
! 	if (rose_neigh == NULL) return;
! 
  	rose_neigh->ax25 = NULL;
  
! 	rose_del_route_by_neigh(rose_neigh);
! 	rose_kill_by_neigh(rose_neigh);
  }
  
  /*
--- 826,850 ----
  {
  	struct rose_neigh *rose_neigh;
  
! 	read_lock_bh(&rose_neigh_list_lock);
! 	
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
! 		if (rose_neigh->ax25 == ax25) {
  			break;
+ 		}
+ 	}
  
! 	if (rose_neigh == NULL) {
! 		read_unlock_bh(&rose_neigh_list_lock);
! 		return;
! 	}
! 	
  	rose_neigh->ax25 = NULL;
  
! 	read_unlock_bh(&rose_neigh_list_lock);
! 	
! 	rose_del_route_by_neigh(rose_neigh); // this one locks route
! 	rose_kill_by_neigh(rose_neigh); // no lock need, it kills rose connections
  }
  
  /*
***************
*** 747,758 ****
  {
  	struct rose_neigh *rose_neigh;
  
  	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
  		if (rose_neigh->dev == dev) {
! 			rose_del_route_by_neigh(rose_neigh);
! 			rose_kill_by_neigh(rose_neigh);
  		}
  	}
  }
  
  /*
--- 855,871 ----
  {
  	struct rose_neigh *rose_neigh;
  
+ 	read_lock_bh(&rose_neigh_list_lock);
+ 	
  	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
  		if (rose_neigh->dev == dev) {
! 			rose_del_route_by_neigh(rose_neigh); // this one locks route
! 			rose_kill_by_neigh(rose_neigh); // no lock need, it kill rose connections
  		}
  	}
+ 	
+ 	read_unlock_bh(&rose_neigh_list_lock);
+ 
  }
  
  /*
***************
*** 769,776 ****
  	unsigned int lci, new_lci;
  	unsigned char cause, diagnostic;
  	struct net_device *dev;
- 	unsigned long flags;
  	int len;
  
  #if 0
  	if (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)
--- 882,889 ----
  	unsigned int lci, new_lci;
  	unsigned char cause, diagnostic;
  	struct net_device *dev;
  	int len;
+ 	char buf[11];
  
  #if 0
  	if (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)
***************
*** 782,793 ****
  	src_addr  = (rose_address *)(skb->data + 9);
  	dest_addr = (rose_address *)(skb->data + 4);
  
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next)
! 		if (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 && ax25->ax25_dev->dev == rose_neigh->dev)
  			break;
  
  	if (rose_neigh == NULL) {
! 		printk("rose_route : unknown neighbour or device %s\n", ax2asc(&ax25->dest_addr));
  		return 0;
  	}
  
--- 895,912 ----
  	src_addr  = (rose_address *)(skb->data + 9);
  	dest_addr = (rose_address *)(skb->data + 4);
  
! 	read_lock_bh(&rose_neigh_list_lock);
! 	
! 	for (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {
! 		if (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 && ax25->ax25_dev->dev == rose_neigh->dev) {
  			break;
+ 		}
+ 	}
  
+ 	read_unlock_bh(&rose_neigh_list_lock);
+ 	
  	if (rose_neigh == NULL) {
! 		printk("rose_route : unknown neighbour or device %s\n", ax2asc(buf, &ax25->dest_addr));
  		return 0;
  	}
  
***************
*** 846,851 ****
--- 965,971 ----
  		return 0;
  	}
  
+ 	write_lock_bh(&rose_route_list_lock);	
  	/*
  	 *	Route it to the next in line if we have an entry for it.
  	 */
***************
*** 860,871 ****
  				skb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;
  				skb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;
  				rose_transmit_link(skb, rose_route->neigh2);
! 				if (frametype == ROSE_CLEAR_CONFIRMATION)
  					rose_remove_route(rose_route);
  				return 1;
  			} else {
! 				if (frametype == ROSE_CLEAR_CONFIRMATION)
  					rose_remove_route(rose_route);
  				return 0;
  			}
  		}
--- 980,995 ----
  				skb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;
  				skb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;
  				rose_transmit_link(skb, rose_route->neigh2);
! 				if (frametype == ROSE_CLEAR_CONFIRMATION) {
  					rose_remove_route(rose_route);
+ 				}
+ 				write_unlock_bh(&rose_route_list_lock);
  				return 1;
  			} else {
! 				if (frametype == ROSE_CLEAR_CONFIRMATION) {
  					rose_remove_route(rose_route);
+ 				}
+ 				write_unlock_bh(&rose_route_list_lock);
  				return 0;
  			}
  		}
***************
*** 879,894 ****
  				skb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;
  				skb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;
  				rose_transmit_link(skb, rose_route->neigh1);
! 				if (frametype == ROSE_CLEAR_CONFIRMATION)
  					rose_remove_route(rose_route);
  				return 1;
  			} else {
! 				if (frametype == ROSE_CLEAR_CONFIRMATION)
  					rose_remove_route(rose_route);
  				return 0;
  			}
  		}
  	}
  
  	/*
  	 *	We know that:
--- 1003,1023 ----
  				skb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;
  				skb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;
  				rose_transmit_link(skb, rose_route->neigh1);
! 				if (frametype == ROSE_CLEAR_CONFIRMATION) {
  					rose_remove_route(rose_route);
+ 				}
+ 				write_unlock_bh(&rose_route_list_lock);
  				return 1;
  			} else {
! 				if (frametype == ROSE_CLEAR_CONFIRMATION) {
  					rose_remove_route(rose_route);
+ 				}
+ 				write_unlock_bh(&rose_route_list_lock);
  				return 0;
  			}
  		}
  	}
+ 	write_unlock_bh(&rose_route_list_lock);
  
  	/*
  	 *	We know that:
***************
*** 908,913 ****
--- 1037,1043 ----
  		return 0;
  	}
  
+ 	read_lock_bh(&rose_route_list_lock);
  	/*
  	 *	Check for routing loops.
  	 */
***************
*** 917,925 ****
--- 1047,1057 ----
  		    ax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&
  		    ax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {
  			rose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);
+ 			read_unlock_bh(&rose_route_list_lock);
  			return 0;
  		}
  	}
+ 	read_unlock_bh(&rose_route_list_lock);
  
  	if ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic)) == NULL) {
  		rose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);
***************
*** 949,958 ****
  	rose_route->neigh1->use++;
  	rose_route->neigh2->use++;
  
! 	save_flags(flags); cli();
  	rose_route->next = rose_route_list;
  	rose_route_list  = rose_route;
! 	restore_flags(flags);
  
  	skb->data[0] &= 0xF0;
  	skb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;
--- 1081,1090 ----
  	rose_route->neigh1->use++;
  	rose_route->neigh2->use++;
  
! 	write_lock_bh(&rose_route_list_lock);
  	rose_route->next = rose_route_list;
  	rose_route_list  = rose_route;
! 	write_unlock_bh(&rose_route_list_lock);
  
  	skb->data[0] &= 0xF0;
  	skb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;
***************
*** 971,977 ****
  	off_t begin = 0;
  	int i;
  
! 	cli();
  
  	len += sprintf(buffer, "address    mask n neigh neigh neigh\n");
  
--- 1103,1109 ----
  	off_t begin = 0;
  	int i;
  
! 	read_lock_bh(&rose_node_list_lock);
  
  	len += sprintf(buffer, "address    mask n neigh neigh neigh\n");
  
***************
*** 1004,1010 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 1136,1142 ----
  			break;
  	}
  
! 	read_unlock_bh(&rose_node_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1017,1028 ****
  int rose_neigh_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct rose_neigh *rose_neigh;
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
  
! 	cli();
  
  	len += sprintf(buffer, "addr  callsign  dev  count use mode restart  t0  tf digipeaters\n");
  
--- 1149,1161 ----
  int rose_neigh_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct rose_neigh *rose_neigh;
+ 	char buf[11];
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  	int i;
  
! 	read_lock_bh(&rose_neigh_list_lock);
  
  	len += sprintf(buffer, "addr  callsign  dev  count use mode restart  t0  tf digipeaters\n");
  
***************
*** 1030,1036 ****
  		/* if (!rose_neigh->loopback) { */
  			len += sprintf(buffer + len, "%05d %-9s %-4s   %3d %3d  %3s     %3s %3lu %3lu",
  				rose_neigh->number,
! 				(rose_neigh->loopback) ? "RSLOOP-0" : ax2asc(&rose_neigh->callsign),
  				rose_neigh->dev ? rose_neigh->dev->name : "???",
  				rose_neigh->count,
  				rose_neigh->use,
--- 1163,1169 ----
  		/* if (!rose_neigh->loopback) { */
  			len += sprintf(buffer + len, "%05d %-9s %-4s   %3d %3d  %3s     %3s %3lu %3lu",
  				rose_neigh->number,
! 				(rose_neigh->loopback) ? "RSLOOP-0" : ax2asc(buf, &rose_neigh->callsign),
  				rose_neigh->dev ? rose_neigh->dev->name : "???",
  				rose_neigh->count,
  				rose_neigh->use,
***************
*** 1041,1047 ****
  
  			if (rose_neigh->digipeat != NULL) {
  				for (i = 0; i < rose_neigh->digipeat->ndigi; i++)
! 					len += sprintf(buffer + len, " %s", ax2asc(&rose_neigh->digipeat->calls[i]));
  			}
  
  			len += sprintf(buffer + len, "\n");
--- 1174,1180 ----
  
  			if (rose_neigh->digipeat != NULL) {
  				for (i = 0; i < rose_neigh->digipeat->ndigi; i++)
! 					len += sprintf(buffer + len, " %s", ax2asc(buf, &rose_neigh->digipeat->calls[i]));
  			}
  
  			len += sprintf(buffer + len, "\n");
***************
*** 1058,1064 ****
  		/* } */
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 1191,1197 ----
  		/* } */
  	}
  
! 	read_unlock_bh(&rose_neigh_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1071,1081 ****
  int rose_routes_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct rose_route *rose_route;
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  
! 	cli();
  
  	len += sprintf(buffer, "lci  address     callsign   neigh  <-> lci  address     callsign   neigh\n");
  
--- 1204,1215 ----
  int rose_routes_get_info(char *buffer, char **start, off_t offset, int length)
  {
  	struct rose_route *rose_route;
+ 	char buf[11];
  	int len     = 0;
  	off_t pos   = 0;
  	off_t begin = 0;
  
! 	read_lock_bh(&rose_route_list_lock);
  
  	len += sprintf(buffer, "lci  address     callsign   neigh  <-> lci  address     callsign   neigh\n");
  
***************
*** 1084,1090 ****
  			len += sprintf(buffer + len, "%3.3X  %-10s  %-9s  %05d      ",
  				rose_route->lci1,
  				rose2asc(&rose_route->src_addr),
! 				ax2asc(&rose_route->src_call),
  				rose_route->neigh1->number);
  		} else {
  			len += sprintf(buffer + len, "000  *           *          00000      ");
--- 1218,1224 ----
  			len += sprintf(buffer + len, "%3.3X  %-10s  %-9s  %05d      ",
  				rose_route->lci1,
  				rose2asc(&rose_route->src_addr),
! 				ax2asc(buf, &rose_route->src_call),
  				rose_route->neigh1->number);
  		} else {
  			len += sprintf(buffer + len, "000  *           *          00000      ");
***************
*** 1094,1100 ****
  			len += sprintf(buffer + len, "%3.3X  %-10s  %-9s  %05d\n",
  				rose_route->lci2,
  				rose2asc(&rose_route->dest_addr),
! 				ax2asc(&rose_route->dest_call),
  				rose_route->neigh2->number);
  		} else {
  			len += sprintf(buffer + len, "000  *           *          00000\n");
--- 1228,1234 ----
  			len += sprintf(buffer + len, "%3.3X  %-10s  %-9s  %05d\n",
  				rose_route->lci2,
  				rose2asc(&rose_route->dest_addr),
! 				ax2asc(buf, &rose_route->dest_call),
  				rose_route->neigh2->number);
  		} else {
  			len += sprintf(buffer + len, "000  *           *          00000\n");
***************
*** 1111,1117 ****
  			break;
  	}
  
! 	sti();
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
--- 1245,1251 ----
  			break;
  	}
  
! 	read_unlock_bh(&rose_neigh_list_lock);
  
  	*start = buffer + (offset - begin);
  	len   -= (offset - begin);
***************
*** 1126,1153 ****
   */
  void __exit rose_rt_free(void)
  {
! 	struct rose_neigh *s, *rose_neigh = rose_neigh_list;
! 	struct rose_node  *t, *rose_node  = rose_node_list;
! 	struct rose_route *u, *rose_route = rose_route_list;
  
  	while (rose_neigh != NULL) {
  		s          = rose_neigh;
  		rose_neigh = rose_neigh->next;
- 
  		rose_remove_neigh(s);
  	}
  
  	while (rose_node != NULL) {
  		t         = rose_node;
  		rose_node = rose_node->next;
- 
  		rose_remove_node(t);
  	}
  
  	while (rose_route != NULL) {
  		u          = rose_route;
  		rose_route = rose_route->next;
- 
  		rose_remove_route(u);
  	}
  }
--- 1260,1297 ----
   */
  void __exit rose_rt_free(void)
  {
! 	struct rose_neigh *s, *rose_neigh;
! 	struct rose_node  *t, *rose_node;
! 	struct rose_route *u, *rose_route;
! 
! 	write_lock_bh(&rose_node_list_lock);
! 	write_lock_bh(&rose_neigh_list_lock);
! 	write_lock_bh(&rose_route_list_lock);
  
+ 	rose_neigh = rose_neigh_list;
+ 	rose_node  = rose_node_list;
+ 	rose_route = rose_route_list;
+ 	
  	while (rose_neigh != NULL) {
  		s          = rose_neigh;
  		rose_neigh = rose_neigh->next;
  		rose_remove_neigh(s);
  	}
  
  	while (rose_node != NULL) {
  		t         = rose_node;
  		rose_node = rose_node->next;
  		rose_remove_node(t);
  	}
  
  	while (rose_route != NULL) {
  		u          = rose_route;
  		rose_route = rose_route->next;
  		rose_remove_route(u);
  	}
+ 
+ 	write_unlock_bh(&rose_route_list_lock);
+ 	write_unlock_bh(&rose_neigh_list_lock);
+ 	write_unlock_bh(&rose_node_list_lock);
+ 
  }
Index: linux-2.4.23/net/rose/rose_subr.c
diff -c linux-2.4.23/net/rose/rose_subr.c:1.1.1.1 linux-2.4.23/net/rose/rose_subr.c:1.2
*** linux-2.4.23/net/rose/rose_subr.c:1.1.1.1	Sun Nov 30 18:36:00 2003
--- linux-2.4.23/net/rose/rose_subr.c	Sun Nov 30 21:17:14 2003
***************
*** 428,433 ****
--- 428,434 ----
  	unsigned char *p = buffer + 1;
  	char *callsign;
  	int len, nb;
+ 	char buf[11];
  
  	/* National Facilities */
  	if (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {
***************
*** 483,489 ****
  
  	*p++ = FAC_CCITT_DEST_NSAP;
  
! 	callsign = ax2asc(&rose->dest_call);
  
  	*p++ = strlen(callsign) + 10;
  	*p++ = (strlen(callsign) + 9) * 2;		/* ??? */
--- 484,490 ----
  
  	*p++ = FAC_CCITT_DEST_NSAP;
  
! 	callsign = ax2asc(buf, &rose->dest_call);
  
  	*p++ = strlen(callsign) + 10;
  	*p++ = (strlen(callsign) + 9) * 2;		/* ??? */
***************
*** 498,504 ****
  
  	*p++ = FAC_CCITT_SRC_NSAP;
  
! 	callsign = ax2asc(&rose->source_call);
  
  	*p++ = strlen(callsign) + 10;
  	*p++ = (strlen(callsign) + 9) * 2;		/* ??? */
--- 499,505 ----
  
  	*p++ = FAC_CCITT_SRC_NSAP;
  
! 	callsign = ax2asc(buf, &rose->source_call);
  
  	*p++ = strlen(callsign) + 10;
  	*p++ = (strlen(callsign) + 9) * 2;		/* ??? */
