
Property changes on: linux/kernel
___________________________________________________________________
Name: svn:ignore
   + log
config_data.gz
config_data.h


Index: linux/.config
===================================================================
--- linux/.config	(.../linux)	(revision 0)
+++ linux/.config	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,1040 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.16
+# Wed Jul 12 14:53:50 2006
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+CONFIG_MIPS_ADM5120=y
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_PCI_ADM5120=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CONNTRACK_EVENTS is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+# CONFIG_IP_NF_FTP is not set
+# CONFIG_IP_NF_IRC is not set
+# CONFIG_IP_NF_NETBIOS_NS is not set
+# CONFIG_IP_NF_TFTP is not set
+# CONFIG_IP_NF_AMANDA is not set
+# CONFIG_IP_NF_PPTP is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_IPRANGE is not set
+# CONFIG_IP_NF_MATCH_MULTIPORT is not set
+# CONFIG_IP_NF_MATCH_TOS is not set
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_DSCP is not set
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+# CONFIG_IP_NF_MATCH_POLICY is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_IP_NF_TARGET_TCPMSS is not set
+# CONFIG_IP_NF_NAT is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_CLK_JIFFIES is not set
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
+# CONFIG_NET_SCH_CLK_CPU is not set
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_ESTIMATOR=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_DM9000 is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_ADM5120_GPIO=y
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_JFFS2_RUBIN=y
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+CONFIG_UFS_FS=m
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=ext2 console=ttyS0"
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
Index: linux/include/asm-mips/am5120/adm5120.h
===================================================================
--- linux/include/asm-mips/am5120/adm5120.h	(.../linux)	(revision 0)
+++ linux/include/asm-mips/am5120/adm5120.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,1083 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/adm5120.h
+;	 Date    : 2003.3.10
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __ADM5120_H__
+#define  __ADM5120_H__
+
+
+#include <asm/addrspace.h>
+
+
+/*=========================  Physical Memory Map  ============================*/
+#define SDRAM_BASE				0
+#define SMEM1_BASE				0x10000000
+
+#define EXTIO0_BASE				0x10C00000
+#define EXTIO1_BASE				0x10E00000
+#define MPMC_BASE				0x11000000
+#define USBHOST_BASE				0x11200000
+#define PCIMEM_BASE				0x11400000
+#define PCIIO_BASE				0x11500000
+#define PCICFG_BASE				0x115FFFF0
+#define MIPS_BASE				0x11A00000
+#define SWCTRL_BASE				0x12000000
+
+#define INTC_BASE				0x12200000
+#define SYSC_BASE				0x12400000
+
+#define UART0_BASE				0x12600000
+#define UART1_BASE				0x12800000
+
+#define SMEM0_BASE				0x1FC00000
+
+
+/*=======================  MIPS interrupt  ===================*/
+#define MIPSINT_SOFT0				0
+#define MIPSINT_SOFT1				1
+#define MIPSINT_IRQ				2
+#define MIPSINT_FIQ				3
+#define MIPSINT_REV0				4
+#define MIPSINT_REV1				5
+#define MIPSINT_REV2				6
+#define MIPSINT_TIMER				7
+
+
+
+/*====================  MultiPort Memory Controller (MPMC) ==================*/
+/* registers offset */
+#define MPMC_CONTROL_REG			0x0000
+#define MPMC_STATUS_REG				0x0004
+#define MPMC_CONFIG_REG				0x0008
+
+#define MPMC_DM_CONTROL_REG			0x0020
+#define MPMC_DM_REFRESH_REG			0x0024
+
+#define MPMC_DM_TRP_REG				0x0030
+#define MPMC_DM_TRAS_REG			0x0034
+#define MPMC_DM_TSREX_REG			0x0038
+#define MPMC_DM_TAPR_REG			0x003C
+#define MPMC_DM_TDAL_REG			0x0040
+#define MPMC_DM_TWR_REG				0x0044
+#define MPMC_DM_TRC_REG				0x0048
+#define MPMC_DM_TRFC_REG			0x004C
+#define MPMC_DM_TXSR_REG			0x0050
+#define MPMC_DM_TRRD_REG			0x0054
+#define MPMC_DM_TMRD_REG			0x0058
+
+#define MPMC_SM_EXTWAIT_REG			0x0080
+
+#define MPMC_DM_CONFIG0_REG			0x0100
+#define MPMC_DM_RASCAS0_REG			0x0104
+
+#define MPMC_DM_CONFIG1_REG			0x0120
+#define MPMC_DM_RASCAS1_REG			0x0124
+
+#define MPMC_SM_CONFIG0_REG			0x0200
+#define MPMC_SM_WAITWEN0_REG			0x0204
+#define MPMC_SM_WAITOEN0_REG			0x0208
+#define MPMC_SM_WAITRD0_REG			0x020C
+#define MPMC_SM_WAITPAGE0_REG			0x0210
+#define MPMC_SM_WAITWR0_REG			0x0214
+#define MPMC_SM_WAITTURN0_REG			0x0218
+
+#define MPMC_SM_CONFIG1_REG			0x0220
+#define MPMC_SM_WAITWEN1_REG			0x0224
+#define MPMC_SM_WAITOEN1_REG			0x0228
+#define MPMC_SM_WAITRD1_REG			0x022C
+#define MPMC_SM_WAITPAGE1_REG			0x0230
+#define MPMC_SM_WAITWR1_REG			0x0234
+#define MPMC_SM_WAITTURN1_REG			0x0238
+
+#define MPMC_SM_CONFIG2_REG			0x0240
+#define MPMC_SM_WAITWEN2_REG			0x0244
+#define MPMC_SM_WAITOEN2_REG			0x0248
+#define MPMC_SM_WAITRD2_REG			0x024C
+#define MPMC_SM_WAITPAGE2_REG			0x0250
+#define MPMC_SM_WAITWR2_REG			0x0254
+#define MPMC_SM_WAITTURN2_REG			0x0258
+
+#define MPMC_SM_CONFIG3_REG			0x0260
+#define MPMC_SM_WAITWEN3_REG			0x0264
+#define MPMC_SM_WAITOEN3_REG			0x0268
+#define MPMC_SM_WAITRD3_REG			0x026C
+#define MPMC_SM_WAITPAGE3_REG			0x0270
+#define MPMC_SM_WAITWR3_REG			0x0274
+#define MPMC_SM_WAITTURN3_REG			0x0278
+
+/* Macro for access MPMC register */
+#define MPMC_REG(_offset)				\
+		(*((volatile unsigned long *)(KSEG1ADDR(MPMC_BASE + (_offset)))))
+
+
+/* MPMC_CONTROL_REG (offset: 0x0000) */
+#define MPMC_DRAIN_W_BUF			0x00000008
+#define MPMC_LOW_POWER_MODE			0x00000004
+#define MPMC_ADDR_MIRROR			0x00000002
+#define MPMC_ENABLE				0x00000001
+#define MPMC_CONTROL_MASK			0x0000000f
+
+/* MPMC_STATUS_REG (offset: 0x0004) */
+#define MPMC_SREFACK				0x00000004
+#define MPMC_WBUF_DIRTY				0x00000002
+#define MPMC_BUSY				0x00000001
+#define MPMC_STATUS_MASK			0x00000007
+
+/* MPMC_CONFIG_REG (offset: 0x0008) */
+#define MPMC_CLK_RATIO_1_1			0x00000000
+#define MPMC_CLK_RATIO_1_2			0x00000100
+#define MPMC_LITTLE_ENDIAN			0x00000000
+#define MPMC_BIG_ENDIAN				0x00000001
+#define MPMC_CONFIG_MASK			0x00000101
+
+/* MPMC_DM_CONTROL_REG (offset: 0x0020) */
+#define DM_PVHHOUT_HI_VOLTAGE			0x00008000
+#define DM_RPOUT_HI_VOLTAGE			0x00004000
+#define DM_DEEP_SLEEP_MODE			0x00002000
+
+#define DM_SDRAM_NOP				0x00000180
+#define DM_SDRAM_PRECHARGE_ALL			0x00000100
+#define DM_SDRAM_MODE_SETTING			0x00000080
+#define DM_SDRAM_NORMAL_OP			0x00000000
+#define DM_SDRAM_OPMODE_MASK			0x00000180
+
+#define DM_SELF_REFRESH_MODE			0x00000004
+#define DM_CLKOUT_ALWAYS			0x00000002
+#define DM_CLKEN_ALWAYS				0x00000001
+
+#define MPMC_DM_CONTROL_MASK			0x0000e187
+
+
+/* MPMC_DM_REFRESH_REG (offset:0x0024) */
+#define MPMC_DM_REFRESH_MASK			0x00000300
+
+/* MPMC_DM_TRP_REG (offset: 0x0030) */
+#define MPMC_DM_TRP_MASK			0x0000000f
+
+/* MPMC_DM_TRAS_REG (offset: 0x0034) */
+#define MPMC_DM_TRAS_MASK			0x0000000f
+
+/* MPMC_DM_TSREX_REG (offset: 0x0038) */
+#define MPMC_DM_TSREX_MASK			0x0000000f
+
+/* MPMC_DM_TAPR_REG	(offset: 0x003C) */
+#define MPMC_DM_TAPR_MASK			0x0000000f
+
+/* MPMC_DM_TDAL_REG	(offset: 0x0040) */
+#define MPMC_DM_TDAL_MASK			0x0000000f
+
+/* MPMC_DM_TWR_REG (offset: 0x0044) */
+#define MPMC_DM_TWR_MASK			0x0000000f
+
+/* MPMC_DM_TRC_REG (offset: 0x0048) */
+#define MPMC_DM_TRC_MASK 			0x0000001f
+
+/* MPMC_DM_TRFC_REG (offset: 0x004C) */
+#define MPMC_DM_TRFC_MASK			0x0000001f
+
+/* MPMC_DM_TXSR_REG	(offset: 0x0050) */
+#define MPMC_DM_TXSR_MASK			0x0000001f
+
+/* MPMC_DM_TRRD_REG	(offset: 0x0054) */
+#define MPMC_DM_TRRD_MASK			0x0000000f
+
+/* MPMC_DM_TMRD_REG	(offset: 0x0058) */
+#define MPMC_DM_TMRD_MASK			0x0000000f
+
+/* MPMC_SM_EXTWAIT_REG (offset:	0x0080) */
+#define MPMC_SM_EXTWAIT_MASK			0x0000003f
+
+
+/* MPMC_DM_CONFIG0_REG (offset: 0x0100) */
+/* MPMC_DM_CONFIG1_REG (offset: 0x0120) */
+#define DM_CFG_ROW_WIDTH_13BIT			0x20000000
+#define DM_CFG_ROW_WIDTH_12BIT			0x10000000
+#define DM_CFG_ROW_WIDTH_11BIT			0x00000000
+#define DM_CFG_ROW_WIDTH_MASK			0x30000000
+#define DM_CFG_ROW_WIDTH_SHIFT			28
+
+#define DM_CFG_2BANK_DEV			0x00000000
+#define DM_CFG_4BANK_DEV			0x04000000
+#define DM_CFG_BANK_SHIFT			26
+
+#define DM_CFG_COL_WIDTH_11BIT			0x01400000
+#define DM_CFG_COL_WIDTH_10BIT			0x01000000
+#define DM_CFG_COL_WIDTH_9BIT			0x00c00000
+#define DM_CFG_COL_WIDTH_8BIT			0x00800000
+#define DM_CFG_COL_WIDTH_7BIT			0x00400000
+#define DM_CFG_COL_WIDTH_6BIT			0x00000000
+#define DM_CFG_COL_WIDTH_MASK			0x01c00000
+#define DM_CFG_COL_WIDTH_SHIFT			22
+
+#define DM_CFG_WRITE_PROTECT			0x00100000
+#define DM_CFG_BUFFER_EN			0x00080000
+
+#define DM_CFG_ADDR_MAPPING_MASK		0x00005F80
+
+#define DM_CFG_DEV_SYNC_FLASH			0x00000010
+#define DM_CFG_DEV_LOWPOWER_SDRAM		0x00000008
+#define DM_CFG_DEV_SDRAM			0x00000000
+#define DM_CFG_DEV_MASK				0x00000018
+
+
+/* MPMC_DM_RASCAS0_REG (offset: 0x0104) */
+/* MPMC_DM_RASCAS1_REG (offset: 0x0124) */
+
+#define DM_CAS_LATENCY_3			0x00000300
+#define DM_CAS_LATENCY_2			0x00000200
+#define DM_CAS_LATENCY_1			0x00000100
+
+#define DM_RAS_LATENCY_3			0x00000003
+#define DM_RAS_LATENCY_2			0x00000002
+#define DM_RAS_LATENCY_1			0x00000001
+
+
+/* MPMC_SM_CONFIG0_REG (offset: 0x0200) */
+/* MPMC_SM_CONFIG1_REG (offset: 0x0220) */
+/* MPMC_SM_CONFIG2_REG (offset: 0x0240) */
+/* MPMC_SM_CONFIG3_REG (offset: 0x0260) */
+
+#define SM_WRITE_PROTECT			0x00100000
+#define SM_WRITEBUF_ENABLE			0x00080000
+#define SM_EXTENDED_WAIT			0x00000100
+#define SM_PB					0x00000080
+#define SM_CS_HIGH				0x00000040
+#define SM_PAGE_MODE				0x00000008
+
+#define SM_MEM_WIDTH_32BIT			0x00000002
+#define SM_MEM_WIDTH_16BIT			0x00000001
+#define SM_MEM_WIDTH_8BIT			0x00000000
+
+#define MPMC_SM_CONFIG_MASK			0x001801cb
+
+
+/* MPMC_SM_WAITWEN0_REG	(offset: 0x0204) */
+/* MPMC_SM_WAITWEN1_REG	(offset: 0x0224) */
+/* MPMC_SM_WAITWEN2_REG	(offset: 0x0244) */
+/* MPMC_SM_WAITWEN3_REG	(offset: 0x0264) */
+#define MPMC_SM_WAITWEN_MASK			0x0000000f
+
+
+/* MPMC_SM_WAITOEN0_REG (offset: 0x0208) */
+/* MPMC_SM_WAITOEN1_REG (offset: 0x0228) */
+/* MPMC_SM_WAITOEN2_REG (offset: 0x0248) */
+/* MPMC_SM_WAITOEN3_REG (offset: 0x0268) */
+#define MPMC_SM_WAITOEN_MASK			0x0000000f
+
+/* MPMC_SM_WAITRD0_REG (offset: 0x020C) */
+/* MPMC_SM_WAITRD1_REG (offset: 0x022C) */
+/* MPMC_SM_WAITRD2_REG (offset: 0x024C) */
+/* MPMC_SM_WAITRD3_REG (offset: 0x026C) */
+#define MPMC_SM_WAITRD_MASK			0x0000001f
+
+/* MPMC_SM_WAITPAGE0_REG (offset: 0x0210) */
+/* MPMC_SM_WAITPAGE1_REG (offset: 0x0230) */
+/* MPMC_SM_WAITPAGE2_REG (offset: 0x0250) */
+/* MPMC_SM_WAITPAGE3_REG (offset: 0x0270) */
+#define MPMC_SM_WAITPAGE_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITWR0_REG (offset: 0x0214) */
+/* MPMC_SM_WAITWR1_REG (offset: 0x0234) */
+/* MPMC_SM_WAITWR2_REG (offset: 0x0254) */
+/* MPMC_SM_WAITWR3_REG (offset: 0x0274) */
+#define MPMC_SM_WAITWR_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITTURN0_REG (offset: 0x0218) */
+/* MPMC_SM_WAITTURN1_REG (offset: 0x0238) */
+/* MPMC_SM_WAITTURN2_REG (offset: 0x0258) */
+/* MPMC_SM_WAITTURN3_REG (offset: 0x0278) */
+#define MPMC_SM_WAITTURN_MASK			0x0000000f
+
+
+/* SDRAM mode register */
+/* ref: SDRAM data sheet. Ex: Micron MT48LC4M16A2 data sheet. */
+#define SDRAM_BTLEN_1				0x0000
+#define SDRAM_BTLEN_2				0x0001
+#define SDRAM_BTLEN_4				0x0002
+#define SDRAM_BTLEN_8				0x0003
+#define SDRAM_BTLEN_FULLPAGE			0x0007
+#define SDRAM_BTLEN_MASK			0x0007
+
+#define SDRAM_BT_SEQUENCIAL			0x0000
+#define SDRAM_BT_INTERLEVED			0x0008
+
+#define SDRAM_CAS_LATENCY_2			0x0020
+#define SDRAM_CAS_LATENCY_3			0x0030
+#define SDRAM_CAS_LATENCY_MASK			0x0030
+
+#define SDRAM_OPMODE_STANDARD			0x0000
+#define SDRAM_OPMODE_MASK			0x0180
+
+#define SDRAM_WBTMODE_ENABLE			0x0000
+#define SDRAM_WBTMODE_DISABLE			0x0200
+
+#define SDRAM_MODEREG_MASK			0x03FF
+
+
+
+/*==========================  Interrupt Controller  ==========================*/
+/* registers offset */
+#define IRQ_STATUS_REG				0x00	/* Read */
+#define IRQ_RAW_STATUS_REG			0x04	/* Read */
+#define IRQ_ENABLE_REG				0x08	/* Read/Write */
+#define IRQ_DISABLE_REG				0x0C	/* Write */
+#define IRQ_SOFT_REG				0x10	/* Write */
+
+#define IRQ_MODE_REG				0x14	/* Read/Write */
+#define FIQ_STATUS_REG				0x18	/* Read */
+
+/* test registers */
+#define IRQ_TESTSRC_REG				0x1c	/* Read/Write */
+#define IRQ_SRCSEL_REG				0x20	/* Read/Write */
+#define IRQ_LEVEL_REG				0x24	/* Read/Write */
+
+/*  Macro for accessing Interrupt controller register  */
+#define ADM5120_INTC_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(INTC_BASE + (_reg)))))
+
+/* interrupt levels */
+#define INT_LVL_TIMER				0	/* Timer */
+#define INT_LVL_UART0				1	/* Uart 0 */
+#define INT_LVL_UART1				2	/* Uart 1 */
+#define INT_LVL_USBHOST				3	/* USB Host */
+#define INT_LVL_EXTIO_0				4	/* External I/O 0 */
+#define INT_LVL_EXTIO_1				5	/* External I/O 1 */
+#define INT_LVL_PCI_0				6	/* PCI 0 */
+#define INT_LVL_PCI_1				7	/* PCI 1 */
+#define INT_LVL_PCI_2				8	/* PCI 2 */
+#define INT_LVL_SWITCH				9	/* Switch */
+#define INT_LVL_MAX				INT_LVL_SWITCH	
+
+/* interrupts */
+#define IRQ_TIMER				(0x1 << INT_LVL_TIMER)
+#define IRQ_UART0				(0x1 << INT_LVL_UART0)
+#define IRQ_UART1				(0x1 << INT_LVL_UART1)
+#define IRQ_USBHOST				(0x1 << INT_LVL_USBHOST)
+#define IRQ_EXTIO_0				(0x1 << INT_LVL_EXTIO_0)
+#define IRQ_EXTIO_1				(0x1 << INT_LVL_EXTIO_1)
+#define IRQ_PCI_INT0				(0x1 << INT_LVL_PCI_0)
+#define IRQ_PCI_INT1				(0x1 << INT_LVL_PCI_1)
+#define IRQ_PCI_INT2				(0x1 << INT_LVL_PCI_2)
+#define IRQ_SWITCH				(0x1 << INT_LVL_SWITCH)
+
+#define IRQ_MASK				0x3ff
+
+
+/* IRQ LEVEL reg */
+#define IRQ_EXTIO0_ACT_LOW			IRQ_EXTIO_0
+#define IRQ_EXTIO1_ACT_LOW			IRQ_EXTIO_1
+#define IRQ_PCIINT0_ACT_LOW			IRQ_PCI_INT0
+#define IRQ_PCIINT1_ACT_LOW			IRQ_PCI_INT1
+#define IRQ_PCIINT2_ACT_LOW			IRQ_PCI_INT2
+
+#define IRQ_LEVEL_MASK				0x01F0
+
+/*=========================  Switch Control Register  ========================*/
+/* Control Register */
+#define CODE_REG				0x0000
+#define SftRest_REG				0x0004
+#define Boot_done_REG				0x0008
+#define SWReset_REG				0x000C
+#define Global_St_REG				0x0010
+#define PHY_st_REG				0x0014
+#define Port_st_REG				0x0018
+#define Mem_control_REG				0x001C
+#define SW_conf_REG				0x0020
+#define CPUp_conf_REG				0x0024
+#define Port_conf0_REG				0x0028
+#define Port_conf1_REG				0x002C
+#define Port_conf2_REG				0x0030
+
+#define VLAN_G1_REG				0x0040
+#define VLAN_G2_REG				0x0044
+#define Send_trig_REG				0x0048
+#define Srch_cmd_REG				0x004C
+#define ADDR_st0_REG				0x0050
+#define ADDR_st1_REG				0x0054
+#define MAC_wt0_REG				0x0058
+#define MAC_wt1_REG				0x005C
+#define BW_cntl0_REG				0x0060
+#define BW_cntl1_REG				0x0064
+#define PHY_cntl0_REG				0x0068
+#define PHY_cntl1_REG				0x006C
+#define FC_th_REG				0x0070
+#define Adj_port_th_REG				0x0074
+#define Port_th_REG				0x0078
+#define PHY_cntl2_REG				0x007C
+#define PHY_cntl3_REG				0x0080
+#define Pri_cntl_REG				0x0084
+#define VLAN_pri_REG				0x0088
+#define TOS_en_REG				0x008C
+#define TOS_map0_REG				0x0090
+#define TOS_map1_REG				0x0094
+#define Custom_pri1_REG				0x0098
+#define Custom_pri2_REG				0x009C
+
+#define Empty_cnt_REG				0x00A4
+#define Port_cnt_sel_REG			0x00A8
+#define Port_cnt_REG				0x00AC
+#define SW_Int_st_REG				0x00B0
+#define SW_Int_mask_REG				0x00B4
+
+// GPIO config
+#define GPIO_conf0_REG				0x00B8
+#define GPIO_conf2_REG				0x00BC
+
+// Watch dog
+#define Watchdog0_REG				0x00C0
+#define Watchdog1_REG				0x00C4
+
+#define Swap_in_REG				0x00C8
+#define Swap_out_REG				0x00CC
+
+// Tx/Rx Descriptors
+#define Send_HBaddr_REG				0x00D0
+#define Send_LBaddr_REG				0x00D4
+#define Recv_HBaddr_REG				0x00D8
+#define Recv_LBaddr_REG				0x00DC
+#define Send_HWaddr_REG				0x00E0
+#define Send_LWaddr_REG				0x00E4
+#define Recv_HWaddr_REG				0x00E8
+#define Recv_LWaddr_REG				0x00EC
+
+// Timer Control 
+#define Timer_int_REG				0x00F0
+#define Timer_REG				0x00F4
+
+// LED control
+#define Port0_LED_REG				0x0100
+#define Port1_LED_REG				0x0104
+#define Port2_LED_REG				0x0108
+#define Port3_LED_REG				0x010c
+#define Port4_LED_REG				0x0110
+
+
+/* Macros for accessing Switch control register */
+#define ADM5120_SW_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(SWCTRL_BASE + (_reg)))))
+
+
+
+/* CODE_REG */
+#define CODE_ID_MASK				0x00FFFF
+#define CODE_ADM5120_ID				0x5120
+
+#define CODE_REV_MASK				0x0F0000
+#define CODE_REV_SHIFT				16
+#define CODE_REV_ADM5120_0			0x8
+
+#define CODE_CLK_MASK				0x300000
+#define CODE_CLK_SHIFT				20
+
+#define CPU_CLK_175MHZ				0x0
+#define CPU_CLK_200MHZ				0x1
+#define CPU_CLK_225MHZ				0x2
+#define CPU_CLK_250MHZ				0x3
+
+#define CPU_SPEED_175M				(175000000/2)
+#define CPU_SPEED_200M				(200000000/2)
+#define CPU_SPEED_225M				(225000000/2)
+#define CPU_SPEED_250M				(250000000/2)
+
+#define CPU_NAND_BOOT				0x01000000
+#define CPU_DCACHE_2K_WAY			(0x1 << 25)
+#define CPU_DCACHE_2WAY				(0x1 << 26)
+#define CPU_ICACHE_2K_WAY			(0x1 << 27)
+#define CPU_ICACHE_2WAY				(0x1 << 28)
+
+#define CPU_GMII_SUPPORT			0x20000000
+
+#define CPU_PQFP_MODE				(0x1 << 29)
+
+#define CPU_CACHE_LINE_SIZE			16
+
+/* SftRest_REG	*/
+#define SOFTWARE_RESET				0x1
+
+/* Boot_done_REG */
+#define BOOT_DONE				0x1
+
+/* SWReset_REG */
+#define SWITCH_RESET				0x1
+
+/* Global_St_REG */
+#define DATA_BUF_BIST_FAILED			(0x1 << 0)
+#define LINK_TAB_BIST_FAILED			(0x1 << 1)
+#define MC_TAB_BIST_FAILED			(0x1 << 2)
+#define ADDR_TAB_BIST_FAILED			(0x1 << 3)
+#define DCACHE_D_FAILED				(0x3 << 4)
+#define DCACHE_T_FAILED				(0x1 << 6)
+#define ICACHE_D_FAILED				(0x3 << 7)
+#define ICACHE_T_FAILED				(0x1 << 9)
+#define BIST_FAILED_MASK			0x03FF
+
+#define ALLMEM_TEST_DONE			(0x1 << 10)
+
+#define SKIP_BLK_CNT_MASK			0x1FF000
+#define SKIP_BLK_CNT_SHIFT			12
+
+
+/* PHY_st_REG */
+#define PORT_LINK_MASK				0x0000001F
+#define PORT_MII_LINKFAIL			0x00000020
+#define PORT_SPEED_MASK				0x00001F00
+
+#define PORT_GMII_SPD_MASK			0x00006000
+#define PORT_GMII_SPD_10M			0
+#define PORT_GMII_SPD_100M			0x00002000
+#define PORT_GMII_SPD_1000M			0x00004000
+
+#define PORT_DUPLEX_MASK			0x003F0000
+#define PORT_FLOWCTRL_MASK			0x1F000000
+
+#define PORT_GMII_FLOWCTRL_MASK			0x60000000
+#define PORT_GMII_FC_ON				0x20000000
+#define PORT_GMII_RXFC_ON			0x20000000
+#define PORT_GMII_TXFC_ON			0x40000000
+
+/* Port_st_REG */
+#define PORT_SECURE_ST_MASK			0x001F
+#define MII_PORT_TXC_ERR			0x0080
+
+/* Mem_control_REG */
+#define SDRAM_SIZE_4MBYTES			0x0001
+#define SDRAM_SIZE_8MBYTES			0x0002
+#define SDRAM_SIZE_16MBYTES			0x0003
+#define SDRAM_SIZE_64MBYTES			0x0004
+#define SDRAM_SIZE_128MBYTES			0x0005
+#define SDRAM_SIZE_MASK				0x0007
+
+#define MEMCNTL_SDRAM1_EN			(0x1 << 5)
+
+#define ROM_SIZE_DISABLE			0x0000
+#define ROM_SIZE_512KBYTES			0x0001
+#define ROM_SIZE_1MBYTES			0x0002
+#define	ROM_SIZE_2MBYTES			0x0003
+#define ROM_SIZE_4MBYTES			0x0004
+#define ROM_SIZE_8MBYTES			0x0005
+#define ROM_SIZE_MASK				0x0007
+
+#define ROM0_SIZE_SHIFT				8
+#define ROM1_SIZE_SHIFT				16
+
+
+/* SW_conf_REG */
+#define SW_AGE_TIMER_MASK			0x000000F0
+#define SW_AGE_TIMER_DISABLE			0x0
+#define SW_AGE_TIMER_FAST			0x00000080
+#define SW_AGE_TIMER_300SEC			0x00000010
+#define SW_AGE_TIMER_600SEC			0x00000020
+#define SW_AGE_TIMER_1200SEC			0x00000030
+#define SW_AGE_TIMER_2400SEC			0x00000040
+#define SW_AGE_TIMER_4800SEC			0x00000050
+#define SW_AGE_TIMER_9600SEC			0x00000060
+#define SW_AGE_TIMER_19200SEC			0x00000070
+//#define SW_AGE_TIMER_38400SEC			0x00000070
+
+#define SW_BC_PREV_MASK				0x00000300
+#define SW_BC_PREV_DISABLE			0
+#define SW_BC_PREV_64BC				0x00000100
+#define SW_BC_PREV_48BC				0x00000200
+#define SW_BC_PREV_32BC				0x00000300
+
+#define SW_MAX_LEN_MASK				0x00000C00
+#define SW_MAX_LEN_1536				0
+#define SW_MAX_LEN_1522				0x00000800
+#define SW_MAX_LEN_1518				0x00000400
+
+#define SW_DIS_COLABT				0x00001000
+
+#define SW_HASH_ALG_MASK			0x00006000
+#define SW_HASH_ALG_DIRECT			0
+#define SW_HASH_ALG_XOR48			0x00002000
+#define SW_HASH_ALG_XOR32			0x00004000
+
+#define SW_DISABLE_BACKOFF_TIMER		0x00008000
+
+#define SW_BP_NUM_MASK				0x000F0000
+#define SW_BP_NUM_SHIFT				16
+#define SW_BP_MODE_MASK				0x00300000
+#define SW_BP_MODE_DISABLE			0
+#define SW_BP_MODE_JAM				0x00100000
+#define SW_BP_MODE_JAMALL			0x00200000
+#define SW_BP_MODE_CARRIER			0x00300000
+#define SW_RESRV_MC_FILTER			0x00400000
+#define SW_BISR_DISABLE				0x00800000
+
+#define SW_DIS_MII_WAS_TX			0x01000000
+#define SW_BISS_EN				0x02000000
+#define SW_BISS_TH_MASK				0x0C000000
+#define SW_BISS_TH_SHIFT			26
+#define SW_REQ_LATENCY_MASK			0xF0000000
+#define SW_REQ_LATENCY_SHIFT			28
+
+
+/* CPUp_conf_REG */
+#define SW_CPU_PORT_DISABLE			0x00000001
+#define SW_PADING_CRC				0x00000002
+#define SW_BRIDGE_MODE				0x00000004
+
+#define SW_DIS_UN_SHIFT				9
+#define SW_DIS_UN_MASK				(0x3F << SW_DIS_UN_SHIFT)
+#define SW_DIS_MC_SHIFT				16
+#define SW_DIS_MC_MASK				(0x3F << SW_DIS_MC_SHIFT)
+#define SW_DIS_BC_SHIFT				24
+#define SW_DIS_BC_MASK				(0x3F << SW_DIS_BC_SHIFT)
+
+
+/* Port_conf0_REG */
+#define SW_DISABLE_PORT_MASK			0x0000003F
+#define SW_EN_MC_MASK				0x00003F00
+#define SW_EN_MC_SHIFT				8
+#define SW_EN_BP_MASK				0x003F0000
+#define SW_EN_BP_SHIFT				16
+#define SW_EN_FC_MASK				0x3F000000
+#define SW_EN_FC_SHIFT				24
+
+
+/* Port_conf1_REG */
+#define SW_DIS_SA_LEARN_MASK			0x0000003F
+#define SW_PORT_BLOCKING_MASK			0x00000FC0
+#define SW_PORT_BLOCKING_SHIFT			6
+#define SW_PORT_BLOCKING_ON			0x1
+
+#define SW_PORT_BLOCKING_MODE_MASK		0x0003F000
+#define SW_PORT_BLOCKING_MODE_SHIFT		12
+#define SW_PORT_BLOCKING_CTRLONLY		0x1
+
+#define SW_EN_PORT_AGE_MASK			0x03F00000
+#define SW_EN_PORT_AGE_SHIFT			20
+#define SW_EN_SA_SECURED_MASK			0xFC000000
+#define SW_EN_SA_SECURED_SHIFT			26
+
+
+/* Port_conf2_REG */
+#define SW_GMII_AN_EN				0x00000001
+#define SW_GMII_FORCE_SPD_MASK			0x00000006
+#define SW_GMII_FORCE_SPD_10M			0
+#define SW_GMII_FORCE_SPD_100M			0x2
+#define SW_GMII_FORCE_SPD_1000M			0x4
+
+#define SW_GMII_FORCE_FULL_DUPLEX		0x00000008
+
+#define SW_GMII_FORCE_RXFC			0x00000010
+#define SW_GMII_FORCE_TXFC			0x00000020
+
+#define SW_GMII_EN				0x00000040
+#define SW_GMII_REVERSE				0x00000080
+
+#define SW_GMII_TXC_CHECK_EN			0x00000100
+
+#define SW_LED_FLASH_TIME_MASK			0x00030000
+#define SW_LED_FLASH_TIME_30MS			0
+#define SW_LED_FLASH_TIME_60MS			0x00010000
+#define SW_LED_FLASH_TIME_240MS			0x00020000
+#define SW_LED_FLASH_TIME_480MS			0x00030000
+
+
+/* Send_trig_REG */
+#define SEND_TRIG_LOW				0x0001
+#define SEND_TRIG_HIGH				0x0002
+
+
+/* Srch_cmd_REG */
+#define SW_MAC_SEARCH_START			0x000001
+#define SW_MAX_SEARCH_AGAIN			0x000002
+
+/* MAC_wt0_REG */
+#define SW_MAC_WRITE				0x00000001
+#define SW_MAC_WRITE_DONE			0x00000002
+#define SW_MAC_FILTER_EN			0x00000004
+#define SW_MAC_VLANID_SHIFT			3
+#define SW_MAC_VLANID_MASK			0x00000038
+#define SW_MAC_VLANID_EN			0x00000040
+#define SW_MAC_PORTMAP_MASK			0x00001F80
+#define SW_MAC_PORTMAP_SHIFT			7
+#define SW_MAC_AGE_MASK				(0x7 << 13)
+#define SW_MAC_AGE_STATIC			(0x7 << 13)
+#define SW_MAC_AGE_VALID			(0x1 << 13)
+#define SW_MAC_AGE_EMPTY			0
+
+/* BW_cntl0_REG */
+#define SW_PORT_TX_NOLIMIT			0
+#define SW_PORT_TX_64K				1
+#define SW_PORT_TX_128K				2
+#define SW_PORT_TX_256K				3
+#define SW_PORT_TX_512K				4
+#define SW_PORT_TX_1M				5
+#define SW_PORT_TX_4M				6
+#define SW_PORT_TX_10MK				7
+
+/* BW_cntl1_REG */
+#define SW_TRAFFIC_SHAPE_IPG			(0x1 << 31)
+
+/* PHY_cntl0_REG */
+#define SW_PHY_ADDR_MASK			0x0000001F
+#define PHY_ADDR_MAX				0x1f
+#define SW_PHY_REG_ADDR_MASK			0x00001F00
+#define SW_PHY_REG_ADDR_SHIFT			8
+#define PHY_REG_ADDR_MAX			0x1f
+#define SW_PHY_WRITE				0x00002000
+#define SW_PHY_READ				0x00004000
+#define SW_PHY_WDATA_MASK			0xFFFF0000
+#define SW_PHY_WDATA_SHIFT			16
+
+
+/* PHY_cntl1_REG */
+#define SW_PHY_WRITE_DONE			0x00000001
+#define SW_PHY_READ_DONE			0x00000002
+#define SW_PHY_RDATA_MASK			0xFFFF0000
+#define SW_PHY_RDATA_SHIFT			16
+
+/* FC_th_REG */
+/* Adj_port_th_REG */
+/* Port_th_REG */
+
+/* PHY_cntl2_REG */
+#define SW_PHY_AN_MASK				0x0000001F
+#define SW_PHY_SPD_MASK				0x000003E0
+#define SW_PHY_SPD_SHIFT			5
+#define SW_PHY_DPX_MASK				0x00007C00
+#define SW_PHY_DPX_SHIFT			10
+#define SW_FORCE_FC_MASK			0x000F8000
+#define SW_FORCE_FC_SHIFT			15
+#define SW_PHY_NORMAL_MASK			0x01F00000
+#define SW_PHY_NORMAL_SHIFT			20
+#define SW_PHY_AUTOMDIX_MASK			0x3E000000
+#define SW_PHY_AUTOMDIX_SHIFT			25
+#define SW_PHY_REC_MCCAVERAGE			0x40000000
+
+
+/* PHY_cntl3_REG */
+/* Pri_cntl_REG */
+/* VLAN_pri_REG */
+/* TOS_en_REG */
+/* TOS_map0_REG */
+/* TOS_map1_REG */
+/* Custom_pri1_REG */
+/* Custom_pri2_REG */
+/* Empty_cnt_REG */
+/* Port_cnt_sel_REG */
+/* Port_cnt_REG */
+
+
+/* SW_Int_st_REG & SW_Int_mask_REG */
+#define SEND_H_DONE_INT				0x0000001
+#define SEND_L_DONE_INT				0x0000002
+#define RX_H_DONE_INT				0x0000004
+#define RX_L_DONE_INT				0x0000008
+#define RX_H_DESC_FULL_INT			0x0000010
+#define RX_L_DESC_FULL_INT			0x0000020
+#define PORT0_QUE_FULL_INT			0x0000040
+#define PORT1_QUE_FULL_INT			0x0000080
+#define PORT2_QUE_FULL_INT			0x0000100
+#define PORT3_QUE_FULL_INT			0x0000200
+#define PORT4_QUE_FULL_INT			0x0000400
+#define PORT5_QUE_FULL_INT			0x0000800
+
+#define CPU_QUE_FULL_INT			0x0002000
+#define GLOBAL_QUE_FULL_INT			0x0004000
+#define MUST_DROP_INT				0x0008000
+#define BC_STORM_INT				0x0010000
+
+#define PORT_STATUS_CHANGE_INT			0x0040000
+#define INTRUDER_INT				0x0080000
+#define	WATCHDOG0_EXPR_INT			0x0100000
+#define WATCHDOG1_EXPR_INT			0x0200000
+#define RX_DESC_ERR_INT				0x0400000
+#define SEND_DESC_ERR_INT			0x0800000
+#define CPU_HOLD_INT				0x1000000
+#define SWITCH_INT_MASK				0x1FDEFFF
+
+
+/* GPIO_conf0_REG */
+#define GPIO0_INPUT_MODE			0x00000001
+#define GPIO1_INPUT_MODE			0x00000002
+#define GPIO2_INPUT_MODE			0x00000004
+#define GPIO3_INPUT_MODE			0x00000008
+#define GPIO4_INPUT_MODE			0x00000010
+#define GPIO5_INPUT_MODE			0x00000020
+#define GPIO6_INPUT_MODE			0x00000040
+#define GPIO7_INPUT_MODE			0x00000080
+
+#define GPIO0_OUTPUT_MODE			0
+#define GPIO1_OUTPUT_MODE			0
+#define GPIO2_OUTPUT_MODE			0
+#define GPIO3_OUTPUT_MODE			0
+#define GPIO4_OUTPUT_MODE			0
+#define GPIO5_OUTPUT_MODE			0
+#define GPIO6_OUTPUT_MODE			0
+#define GPIO7_OUTPUT_MODE			0
+
+#define GPIO0_INPUT_MASK			0x00000100
+#define GPIO1_INPUT_MASK			0x00000200
+#define GPIO2_INPUT_MASK			0x00000400
+#define GPIO3_INPUT_MASK			0x00000800
+#define GPIO4_INPUT_MASK			0x00001000
+#define GPIO5_INPUT_MASK			0x00002000
+#define GPIO6_INPUT_MASK			0x00004000
+#define GPIO7_INPUT_MASK			0x00008000
+
+#define GPIO0_OUTPUT_EN				0x00010000
+#define GPIO1_OUTPUT_EN				0x00020000
+#define GPIO2_OUTPUT_EN				0x00040000
+#define GPIO3_OUTPUT_EN				0x00080000
+#define GPIO4_OUTPUT_EN				0x00100000
+#define GPIO5_OUTPUT_EN				0x00200000
+#define GPIO6_OUTPUT_EN				0x00400000
+#define GPIO7_OUTPUT_EN				0x00800000
+
+#define GPIO_CONF0_OUTEN_MASK			0x00ff0000
+
+#define GPIO0_OUTPUT_HI				0x01000000
+#define GPIO1_OUTPUT_HI				0x02000000
+#define GPIO2_OUTPUT_HI				0x04000000
+#define GPIO3_OUTPUT_HI				0x08000000
+#define GPIO4_OUTPUT_HI				0x10000000
+#define GPIO5_OUTPUT_HI				0x20000000
+#define GPIO6_OUTPUT_HI				0x40000000
+#define GPIO7_OUTPUT_HI				0x80000000
+
+#define GPIO0_OUTPUT_LOW			0
+#define GPIO1_OUTPUT_LOW			0
+#define GPIO2_OUTPUT_LOW			0
+#define GPIO3_OUTPUT_LOW			0
+#define GPIO4_OUTPUT_LOW			0
+#define GPIO5_OUTPUT_LOW			0
+#define GPIO6_OUTPUT_LOW			0
+#define GPIO7_OUTPUT_LOW			0
+
+
+/* GPIO_conf2_REG */
+#define EXTIO_WAIT_EN				(0x1 << 6)
+#define EXTIO_CS1_INT1_EN			(0x1 << 5)
+#define EXTIO_CS0_INT0_EN			(0x1 << 4)
+
+/* Watchdog0_REG, Watchdog1_REG */
+#define WATCHDOG0_RESET_EN			0x80000000
+#define WATCHDOG1_DROP_EN			0x80000000
+
+#define WATCHDOG_TIMER_SET_MASK			0x7FFF0000
+#define WATCHDOG_TIMER_SET_SHIFT		16
+#define WATCHDOG_TIMER_MASK			0x00007FFF
+
+
+/* Timer_int_REG */
+#define SW_TIMER_INT_DISABLE			0x10000
+#define SW_TIMER_INT				0x1
+
+/* Timer_REG */
+#define SW_TIMER_EN				0x10000
+#define SW_TIMER_MASK				0xffff
+#define SW_TIMER_10MS_TICKS			0x3D09
+#define SW_TIMER_1MS_TICKS			0x61A
+#define SW_TIMER_100US_TICKS			0x9D
+
+
+/* Port0_LED_REG, Port1_LED_REG, Port2_LED_REG, Port3_LED_REG, Port4_LED_REG*/
+#define GPIOL_INPUT_MODE			0x00
+#define GPIOL_OUTPUT_FLASH			0x01
+#define GPIOL_OUTPUT_LOW			0x02
+#define GPIOL_OUTPUT_HIGH			0x03
+#define GPIOL_LINK_LED				0x04
+#define GPIOL_SPEED_LED				0x05
+#define GPIOL_DUPLEX_LED			0x06
+#define GPIOL_ACT_LED				0x07
+#define GPIOL_COL_LED				0x08
+#define GPIOL_LINK_ACT_LED			0x09
+#define GPIOL_DUPLEX_COL_LED			0x0A
+#define GPIOL_10MLINK_ACT_LED			0x0B
+#define GPIOL_100MLINK_ACT_LED			0x0C
+#define GPIOL_CTRL_MASK				0x0F
+
+#define GPIOL_INPUT_MASK			0x7000
+#define GPIOL_INPUT_0_MASK			0x1000
+#define GPIOL_INPUT_1_MASK			0x2000
+#define GPIOL_INPUT_2_MASK			0x4000
+
+#define PORT_LED0_SHIFT				0
+#define PORT_LED1_SHIFT				4
+#define PORT_LED2_SHIFT				8
+
+
+/*===========================  UART Control Register  ========================*/
+#define UART_DR_REG				0x00
+#define UART_RSR_REG				0x04
+#define UART_ECR_REG				0x04
+#define UART_LCR_H_REG				0x08
+#define UART_LCR_M_REG				0x0c
+#define UART_LCR_L_REG				0x10
+#define UART_CR_REG				0x14
+#define UART_FR_REG				0x18
+#define UART_IIR_REG				0x1c
+#define UART_ICR_REG				0x1C
+#define UART_ILPR_REG				0x20
+
+/*  rsr/ecr reg  */
+#define UART_OVERRUN_ERR			0x08
+#define UART_BREAK_ERR				0x04
+#define UART_PARITY_ERR				0x02
+#define UART_FRAMING_ERR			0x01
+#define UART_RX_STATUS_MASK			0x0f
+#define UART_RX_ERROR				( UART_BREAK_ERR | UART_PARITY_ERR | UART_FRAMING_ERR)
+
+/*  lcr_h reg  */
+#define UART_SEND_BREAK				0x01
+#define UART_PARITY_EN				0x02
+#define UART_EVEN_PARITY			0x04
+#define UART_TWO_STOP_BITS			0x08
+#define UART_ENABLE_FIFO			0x10
+
+#define UART_WLEN_5BITS				0x00
+#define UART_WLEN_6BITS				0x20
+#define UART_WLEN_7BITS				0x40
+#define UART_WLEN_8BITS				0x60
+#define UART_WLEN_MASK				0x60
+
+/*  cr reg  */
+#define UART_PORT_EN				0x01
+#define UART_SIREN				0x02
+#define UART_SIRLP				0x04
+#define UART_MODEM_STATUS_INT_EN		0x08
+#define UART_RX_INT_EN				0x10
+#define UART_TX_INT_EN				0x20
+#define UART_RX_TIMEOUT_INT_EN			0x40
+#define UART_LOOPBACK_EN			0x80
+
+/*  fr reg  */
+#define UART_CTS				0x01
+#define UART_DSR				0x02
+#define UART_DCD				0x04
+#define UART_BUSY				0x08
+#define UART_RX_FIFO_EMPTY			0x10
+#define UART_TX_FIFO_FULL			0x20
+#define UART_RX_FIFO_FULL			0x40
+#define UART_TX_FIFO_EMPTY			0x80
+
+/*  iir/icr reg  */
+#define UART_MODEM_STATUS_INT			0x01
+#define UART_RX_INT				0x02
+#define UART_TX_INT				0x04
+#define UART_RX_TIMEOUT_INT			0x08
+
+#define UART_INT_MASK				0x0f
+
+#define ADM5120_UARTCLK_FREQ			62500000
+
+#define UART_BAUDDIV(_rate)			((unsigned long)(ADM5120_UARTCLK_FREQ/(16*(_rate)) - 1))
+
+/*  uart_baudrate  */
+#define UART_230400bps_DIVISOR			UART_BAUDDIV(230400)
+#define UART_115200bps_DIVISOR			UART_BAUDDIV(115200)
+#define UART_76800bps_DIVISOR			UART_BAUDDIV(76800)
+#define UART_57600bps_DIVISOR			UART_BAUDDIV(57600)
+#define UART_38400bps_DIVISOR			UART_BAUDDIV(38400)
+#define UART_19200bps_DIVISOR			UART_BAUDDIV(19200)
+#define UART_14400bps_DIVISOR			UART_BAUDDIV(14400)
+#define UART_9600bps_DIVISOR			UART_BAUDDIV(9600)
+#define UART_2400bps_DIVISOR			UART_BAUDDIV(2400)
+#define UART_1200bps_DIVISOR			UART_BAUDDIV(1200)
+
+
+/* Cache Controller */
+//#define ADM5120_CACHE_CTRL_BASE		0x70000000
+#define ADM5120_CACHE_LINE_SIZE			16
+//#define ADM5120_CACHE_CTRL_REGSIZE		4
+
+
+/********** GPIO macro *************/
+#define GPIO_MEASURE	0x000f00f0 //enable output status of pin 0, 1, 2, 3 
+
+#define GPIO_MEASURE_INIT() \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) = GPIO_MEASURE; \
+} while (0)
+
+
+#define GPIO_SET_HI(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) |= 1 << (24 + num); \
+} while (0)
+
+
+#define GPIO_SET_LOW(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) &= ~(1 << (24 + num)); \
+} while (0)
+
+
+#define GPIO_TOGGLE(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) ^= (1 << (24 + num)); \
+} while (0)
+
+
+#define BOOT_LINE_SIZE		256
+#define BSP_STR_LEN		64
+
+/*
+ * System configuration
+ */
+/*typedef struct BOARD_CFG_S
+{
+	unsigned long blmagic;
+	unsigned char bootline[BOOT_LINE_SIZE+1];
+	
+	unsigned long macmagic;
+	unsigned char mac[4][8];
+
+	unsigned long idmagic;    
+	unsigned char serial[BSP_STR_LEN+1];
+
+	unsigned long vermagic;
+	unsigned char ver[BSP_STR_LEN+1];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define BL_MAGIC			0x6c62676d
+#define MAC_MAGIC			0x636d676d
+#define VER_MAGIC			0x7276676d
+#define ID_MAGIC			0x6469676d
+*/
+typedef struct BOARD_CFG_S
+{
+	unsigned long macmagic;
+	unsigned char sr[3];
+	unsigned char mac[3][6];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define MAC_MAGIC			0x31305348
+
+
+#endif /* __ADM5120_H__ */
Index: linux/include/asm-mips/am5120/mx_parts.h
===================================================================
--- linux/include/asm-mips/am5120/mx_parts.h	(.../linux)	(revision 0)
+++ linux/include/asm-mips/am5120/mx_parts.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,10 @@
+/**********************************************************************************
+;   Auto generated by target/linux/linux-2.4/adm5120.mk
+;   DO NOT EDIT!!!
+;**********************************************************************************/
+#define FLASH_SIZE      0x00200000
+#define FLASH_PART_BOOT_ADDR    0x00000000
+#define FLASH_PART_BOOT_SIZE    0x00008000
+#define FLASH_PART_KERNEL_ADDR  0x00010000
+#define FLASH_PART_KERNEL_SIZE  0x000A0000
+#define FLASH_PART_ROOT_SIZE    0x00140000
Index: linux/include/asm-mips/am5120/prom.h
===================================================================
--- linux/include/asm-mips/am5120/prom.h	(.../linux)	(revision 0)
+++ linux/include/asm-mips/am5120/prom.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,49 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * MIPS boards bootprom interface for the Linux kernel.
+ *
+ */
+
+#ifndef _MIPS_PROM_H
+#define _MIPS_PROM_H
+
+extern char *prom_getcmdline(void);
+extern char *prom_getenv(char *name);
+extern void setup_prom_printf(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern void prom_init_cmdline(void);
+extern void prom_meminit(void);
+extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
+extern void prom_free_prom_memory (void);
+extern void mips_display_message(const char *str);
+extern void mips_display_word(unsigned int num);
+extern int get_ethernet_addr(char *ethernet_addr);
+
+/* Memory descriptor management. */
+#define PROM_MAX_PMEMBLOCKS    32
+struct prom_pmemblock {
+        unsigned long base; /* Within KSEG0. */
+        unsigned int size;  /* In bytes. */
+        unsigned int type;  /* free or prom memory */
+};
+
+#endif /* !(_MIPS_PROM_H) */
Index: linux/include/asm-mips/am5120/debug.h
===================================================================
--- linux/include/asm-mips/am5120/debug.h	(.../linux)	(revision 0)
+++ linux/include/asm-mips/am5120/debug.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,16 @@
+#define PDEBUG(debug_lev,fmt,args...)
+
+#ifdef ADM5120_DEBUG 
+#	define DEBUG_1 1
+#	define DEBUG_2 2
+#	define DEBUG_3 3
+#	define DEBUG_4 4
+#	define DEBUG_5 5
+#	ifndef DEBUG_DEF
+#		define DEBUG_DEF 0
+#	endif
+#	undef PDEBUG
+#	define PDEBUG(debug_lev,fmt,args...) \
+    	    if( debug_lev < DEBUG_DEF ) \
+		printk(KERN_NOTICE"%s: " fmt " \n", __FUNCTION__, ## args )
+#endif
Index: linux/include/asm-mips/am5120/mx29lv320b.h
===================================================================
--- linux/include/asm-mips/am5120/mx29lv320b.h	(.../linux)	(revision 0)
+++ linux/include/asm-mips/am5120/mx29lv320b.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,79 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/mx29lv320b.h
+;    Date    : 2003.07.30
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __MX29LV320B_H__
+#define  __MX29LV320B_H__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_PHYS_ADDR 	0x1FC00000
+
+#include<asm/am5120/mx_parts.h>
+
+#define FLASH_PART_ROOT_ADDR (FLASH_PART_KERNEL_ADDR + FLASH_PART_KERNEL_SIZE)
+#define FLASH_PART_DATA_ADDR (FLASH_PART_ROOT_ADDR + FLASH_PART_ROOT_SIZE)
+#define FLASH_PART_DATA_SIZE (FLASH_SIZE - FLASH_PART_DATA_ADDR)
+
+
+struct mtd_partition mx29lv320b_parts[] = {
+	{
+		.name =		"Boot Partition",
+		.offset =	FLASH_PART_BOOT_ADDR,
+		.size =		FLASH_PART_BOOT_SIZE,
+		.mask_flags =   MTD_WRITEABLE
+	},
+	{
+		.name =		"Kernel",
+		.offset =	FLASH_PART_KERNEL_ADDR,
+		.size =		FLASH_PART_KERNEL_SIZE
+	},
+	{
+		.name =		"Root",
+		.offset =	FLASH_PART_ROOT_ADDR,
+		.size =		FLASH_PART_ROOT_SIZE
+	},
+	{
+		.name =		"Data",
+		.offset =	FLASH_PART_DATA_ADDR,
+		.size =		FLASH_PART_DATA_SIZE
+	},
+	{
+		.name =		"WholeFlash",
+		.offset =	FLASH_PART_KERNEL_ADDR,
+		.size =		0x1F0000
+	}
+};
+
+#define PARTITION_COUNT (sizeof(mx29lv320b_parts)/sizeof(struct mtd_partition))
+
+#endif /* __MX29LV320B_H__ */
+
Index: linux/include/asm-mips/system.h
===================================================================
--- linux/include/asm-mips/system.h	(.../linux)	(revision 5)
+++ linux/include/asm-mips/system.h	(.../linux-kernel/linux)	(revision 28)
@@ -442,6 +442,7 @@
 extern void *set_vi_handler (int n, void *addr);
 extern void *set_vi_srs_handler (int n, void *addr, int regset);
 extern void *set_except_vector(int n, void *addr);
+extern unsigned long ebase;
 extern void per_cpu_trap_init(void);
 
 extern NORET_TYPE void die(const char *, struct pt_regs *);
Index: linux/include/asm-mips/asm.h
===================================================================
--- linux/include/asm-mips/asm.h	(.../linux)	(revision 5)
+++ linux/include/asm-mips/asm.h	(.../linux-kernel/linux)	(revision 28)
@@ -107,7 +107,7 @@
 /*
  * Print formatted string
  */
-#ifdef CONFIG_PRINTK
+//#ifdef CONFIG_PRINTK
 #define PRINT(string)                                   \
 		.set	push;				\
 		.set	reorder;                        \
@@ -115,10 +115,11 @@
 		jal	printk;                         \
 		.set	pop;				\
 		TEXT(string)
+/*
 #else
 #define PRINT(string)
 #endif
-
+*/
 #define	TEXT(msg)                                       \
 		.pushsection .data;			\
 8:		.asciiz	msg;                            \
Index: linux/include/asm-mips/bootinfo.h
===================================================================
--- linux/include/asm-mips/bootinfo.h	(.../linux)	(revision 5)
+++ linux/include/asm-mips/bootinfo.h	(.../linux-kernel/linux)	(revision 28)
@@ -218,6 +218,13 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+/*
+ * Valid machtype for group ADMtek
+ */
+#define MACH_GROUP_ADM_GW      23
+#define MACH_ADM_GW_5120       0
+
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);

Property changes on: linux/include/asm-mips
___________________________________________________________________
Name: svn:ignore
   + log
asm-offsets.h


Index: linux/include/linux/serial_core.h
===================================================================
--- linux/include/linux/serial_core.h	(.../linux)	(revision 5)
+++ linux/include/linux/serial_core.h	(.../linux-kernel/linux)	(revision 28)
@@ -82,6 +82,11 @@
 /* Samsung S3C2410 SoC and derivatives thereof */
 #define PORT_S3C2410    55
 
+/* ADMtek ADM5120 SoC */
+#define PORT_ADM5120   68
+
+
+
 /* SGI IP22 aka Indy / Challenge S / Indigo 2 */
 #define PORT_IP22ZILOG	56
 
Index: linux/include/linux/debug_net.h
===================================================================
--- linux/include/linux/debug_net.h	(.../linux)	(revision 0)
+++ linux/include/linux/debug_net.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,111 @@
+#include<linux/time.h>
+#include<linux/delay.h>
+#include<linux/interrupt.h>
+#include<linux/netfilter.h>
+
+/* functions */
+void debug_count_delta(struct timeval *tv1,struct timeval tv2);
+void debug_print_tv(struct timeval *tv,u32 cnt,struct timeval *tv1,char *str);
+void debug_div_tv(struct timeval *tv1,u32 z);
+void debug_sum_tv(struct timeval *tv1,struct timeval tv2);
+
+
+
+/* debug macroses */
+#define DEBUG_NET
+
+#ifdef DEBUG_NET
+
+#define DEBUG_NF_HOOK(pf, hook, skb, indev, outdev, okfn,counter_var)	\
+({int __ret; 								\
+struct timeval tv1,tv2; 						\
+disable_irq(9); 							\
+do_gettimeofday(&tv1); 							\
+__ret=nf_hook_thresh(pf, hook, &(skb), indev, outdev, okfn,INT_MIN, 1); \
+do_gettimeofday(&tv2); 							\
+if( __ret == 1 ) 							\
+	__ret = (okfn)(skb);                                            \
+enable_irq(9); 								\
+debug_count_delta(&tv1,tv2); 						\
+debug_sum_tv(& debug_ip_##counter_var,tv1); 				\
+debug_ip_##counter_var##_cnt+=1;  					\
+__ret; })
+
+#define DEBUG_NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond,counter_var) \
+({int __ret; \
+struct timeval tv1,tv2; \
+disable_irq(9); \
+do_gettimeofday(&tv1); \
+__ret=NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond); \
+do_gettimeofday(&tv2); \
+enable_irq(9); \
+debug_count_delta(&tv1,tv2); \
+debug_sum_tv(& debug_ip_ ## counter_var,tv1); \
+debug_ip_##counter_var##_cnt+=1 ;\
+__ret; })
+
+
+#define DEBUG_ADD_NEW_DELTA(tv1,tv2,counter_var) 	\
+({ 								\
+debug_count_delta(&tv1,tv2); 					\
+debug_sum_tv(& debug_ip_ ## counter_var,tv1); 			\
+debug_ip_##counter_var##_cnt+=1 ;				\
+})
+
+#else /* Not defined DEBUG_NET */
+
+#define DEBUG_NF_HOOK(pf, hook, skb, indev, outdev, okfn,counter_var) \
+({int __ret; \
+__ret=NF_HOOK(pf, hook, skb, indev, outdev, okfn); \
+__ret; })
+
+#define DEBUG_NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond,counter_var) \
+({ int __ret; \
+__ret=NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond); \
+__ret; })
+
+#endif /* DEBUG_NET */
+
+
+#define DEBUG_NET_OUTPUT(counter_var,str) \
+({	struct timeval rez;\
+	memset(&rez,0,sizeof(struct timeval)); \
+	if ( debug_ip_##counter_var##_cnt ){ \
+		rez.tv_sec=debug_ip_##counter_var.tv_sec; \
+		rez.tv_usec=debug_ip_##counter_var.tv_usec; \
+		debug_div_tv(&rez, debug_ip_##counter_var##_cnt ); \
+	} \
+	debug_print_tv(&rez,debug_ip_##counter_var##_cnt,&debug_ip_##counter_var,str);\
+})
+
+
+
+/* counters */
+	
+
+extern struct timeval debug_ip_arp;
+extern struct timeval debug_ip_igmp;
+extern struct timeval debug_ip_input;
+extern struct timeval debug_ip_output;
+extern struct timeval debug_ip_forward;
+extern struct timeval debug_ip_hook;
+extern struct timeval debug_ip_test;
+
+extern struct timeval debug_ip_vs_xmit;
+extern struct timeval debug_ip_ipt_REJECT;
+extern struct timeval debug_ip_raw;
+extern struct timeval debug_ip_xfrm4_input;
+extern struct timeval debug_ip_xfrm4_output;
+extern struct timeval debug_ip_ipmr;
+
+
+
+extern u32 debug_ip_arp_cnt;
+extern u32 debug_ip_igmp_cnt;
+extern u32 debug_ip_input_cnt;
+extern u32 debug_ip_output_cnt;
+extern u32  debug_ip_ipmr_cnt;
+extern u32  debug_ip_forward_cnt;
+extern u32  debug_ip_hook_cnt;
+extern u32  debug_ip_test_cnt;
+

Property changes on: linux/include/linux
___________________________________________________________________
Name: svn:ignore
   + autoconf.h
log
version.h
compile.h



Property changes on: linux/include
___________________________________________________________________
Name: svn:ignore
   + asm
log
config
asm-mips/asm-offsets.h
linux/autoconf.h
linux/version.h
linux/compile.h



Property changes on: linux/scripts/basic
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/genksyms
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/lxdialog
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/mod
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/kconfig/lxdialog
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/kconfig
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/ksymoops
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts/package
___________________________________________________________________
Name: svn:ignore
   + *



Property changes on: linux/scripts
___________________________________________________________________
Name: svn:ignore
   + *


Index: linux/compile
===================================================================
--- linux/compile	(.../linux)	(revision 0)
+++ linux/compile	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+#CROSS_COMPILE_PATH=/buildroot/build_mipsel/staging_dir/bin
+CROSS_COMPILE_PATH=../../staging_dir_mipsel/bin
+export PATH=$CROSS_COMPILE_PATH:$PATH
+make -j4 CROSS_COMPILE=mipsel-linux- V=1 CONFIG_CMDLINE_BOOL=y CONFIG_CMDLINE="root=/dev/hda0 fstype=aaaa"
+$CROSS_COMPILE_PATH/mipsel-linux-uclibc-nm vmlinux | grep -v '\(compiled\)\|\(\.o$\)\|\( [aUw] \)\|\(\.\.ng$\)\|\(LASH[RL]DI\)' | sort > System.map
+$CROSS_COMPILE_PATH/mipsel-linux-uclibc-objcopy -O binary vmlinux vmlinux.bin
+gzip -c vmlinux.bin > vmlinuz

Property changes on: linux/lib
___________________________________________________________________
Name: svn:ignore
   + crc32table.h
log
gen_crc32table



Property changes on: linux/usr
___________________________________________________________________
Name: svn:ignore
   + log
initramfs_list
initramfs_data.cpio.gz
gen_init_cpio
initramfs_data.cpio


Index: linux/arch/mips/kernel/head.S
===================================================================
--- linux/arch/mips/kernel/head.S	(.../linux)	(revision 5)
+++ linux/arch/mips/kernel/head.S	(.../linux-kernel/linux)	(revision 28)
@@ -25,6 +25,7 @@
 
 #include <kernel-entry-init.h>
 
+
 	.macro	ARC64_TWIDDLE_PC
 #if defined(CONFIG_ARC64) || defined(CONFIG_MAPPED_KERNEL)
 	/* We get launched at a XKPHYS address but the kernel is linked to
@@ -111,8 +112,10 @@
 	 * Reserved space for exception handlers.
 	 * Necessary for machines which link their kernels at KSEG0.
 	 */
-	.fill	0x400
+	.fill	0x6d8
+	j	kernel_entry
 
+
 EXPORT(stext)					# used for profiling
 EXPORT(_stext)
 
Index: linux/arch/mips/kernel/traps.c
===================================================================
--- linux/arch/mips/kernel/traps.c	(.../linux)	(revision 5)
+++ linux/arch/mips/kernel/traps.c	(.../linux-kernel/linux)	(revision 28)
@@ -780,8 +780,19 @@
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
 {
+       const int field = 2 * sizeof(unsigned long);
+
 	show_regs(regs);
+	printk("Hi    : %0*lx\n", field, regs->hi);
+	printk("Pagemask: %0*x\n", read_c0_pagemask());
+	printk("EntryHi : %0*lx\n", field, read_c0_entryhi());
+	printk("EntryLo0: %0*lx\n", field, read_c0_entrylo0());
+	printk("EntryLo1: %0*lx\n", field, read_c0_entrylo1());
+	printk("\n");
 	dump_tlb_all();
+	show_code((unsigned int *) regs->cp0_epc);
+	printk("\n");		
+	
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)

Property changes on: linux/arch/mips/kernel
___________________________________________________________________
Name: svn:ignore
   + log
asm-offsets.s
vmlinux.lds


Index: linux/arch/mips/Kconfig
===================================================================
--- linux/arch/mips/Kconfig	(.../linux)	(revision 5)
+++ linux/arch/mips/Kconfig	(.../linux-kernel/linux)	(revision 28)
@@ -10,8 +10,17 @@
 
 choice
 	prompt "System type"
-	default SGI_IP22
+	default MIPS_MTX1
 
+config MIPS_ADM5120
+	bool "Support for ADM5120 SoC"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select ADM5120_BOARDS
+	select SYS_HAS_CPU_MIPS32_R1		
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
+
 config MIPS_MTX1
 	bool "Support for 4G Systems MTX-1 board"
 	select DMA_NONCOHERENT
@@ -774,6 +783,7 @@
 
 endchoice
 
+source "arch/mips/adm5120/Kconfig"
 source "arch/mips/ddb5xxx/Kconfig"
 source "arch/mips/gt64120/ev64120/Kconfig"
 source "arch/mips/jazz/Kconfig"
@@ -933,6 +943,9 @@
 	bool
 	select SOC_AU1X00
 
+config MIPS_ADM5120	
+	bool
+
 config SOC_AU1550
 	bool
 	select SOC_AU1X00
Index: linux/arch/mips/adm5120/altera.bin
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: linux/arch/mips/adm5120/altera.bin
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: linux/arch/mips/adm5120/Kconfig
===================================================================
--- linux/arch/mips/adm5120/Kconfig	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/Kconfig	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,4 @@
+config PCI_ADM5120
+	bool "Add PCI control support for ADM5120"
+	depends on MIPS_ADM5120 && HW_HAS_PCI
+	
Index: linux/arch/mips/adm5120/fw_to_c
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: linux/arch/mips/adm5120/fw_to_c
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: linux/arch/mips/adm5120/setup.c
===================================================================
--- linux/arch/mips/adm5120/setup.c	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/setup.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,136 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *		Creator : daniell@admtek.com.tw
+ *	Copyright 1999, 2000 MIPS Technologies, Inc.
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+
+#define ADM5120_SOFTRESET	0x12000004
+#define STATUS_IE		0x00000001
+#define ALLINTS (IE_IRQ0 | IE_IRQ5 | STATUS_IE)
+
+#define ADM5120_CODEREG		0x12000000
+#define ADM5120_CPU_CLK_MASK	0x00300000
+#define ADM5120_CPU_CLK_175	0x00000000
+#define ADM5120_CPU_CLK_200	0x00100000
+#define ADM5120_CPU_CLK_225	0x00200000
+#define ADM5120_CPU_CLK_250	0x00300000
+
+void  mips_time_init(void);
+
+extern unsigned int mips_counter_frequency;
+
+void adm5120_restart(char *command)
+{
+	*(u32*)KSEG1ADDR(ADM5120_SOFTRESET)=1;
+}
+
+
+void adm5120_halt(void)
+{
+        printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+        while (1);
+}
+
+
+void adm5120_power_off(void)
+{
+        adm5120_halt();
+}
+
+void __init mips_time_init(void)
+{
+	u32 clock;
+
+	clock = *(u32*)KSEG1ADDR(ADM5120_CODEREG);
+
+	switch (clock & ADM5120_CPU_CLK_MASK) {
+		case ADM5120_CPU_CLK_175:
+			mips_counter_frequency = 87500000;
+			printk("CPU clock: 175MHz\n");
+			break;
+		case ADM5120_CPU_CLK_200:
+			mips_counter_frequency = 100000000;
+			printk("CPU clock: 200MHz\n");
+			break;
+		case ADM5120_CPU_CLK_225:
+			mips_counter_frequency = 112500000;
+			printk("CPU clock: 225MHz\n");
+			break;
+		case ADM5120_CPU_CLK_250:
+			mips_counter_frequency = 125000000;
+			printk("CPU clock: 250MHz\n");
+			break;
+	}
+}
+
+void __init mips_timer_setup(struct irqaction *irq)
+{
+	/* to generate the first timer interrupt */
+    	write_c0_compare(read_c0_count()+ mips_counter_frequency/HZ);
+	clear_c0_status(ST0_BEV);
+	set_c0_status(ALLINTS);
+}
+
+void __init plat_setup(void)
+{
+	printk("ADM5120 board setup\n");
+
+	board_time_init = mips_time_init;
+	board_timer_setup = mips_timer_setup;
+
+	_machine_restart = adm5120_restart;
+	_machine_halt = adm5120_halt;
+	pm_power_off = adm5120_power_off;
+
+	set_io_port_base(KSEG1);
+	load_altera_firmware();
+}
+
+
+const char *get_system_type(void)
+{
+	return "ADM5120 Board";
+}
+
+
+static struct resource adm5120_hcd_resources[] = {
+	{"res1",0x11200000,0x11200084,IORESOURCE_MEM},
+//	{"res2",0x3,0x3,IORESOURCE_IRQ},
+	{"res2",9,9,IORESOURCE_IRQ},
+};
+
+
+static u64 hcd_dmamask = 0x01ffffff;
+static struct platform_device adm5120hcd_device = {
+	.name		= "adm5120-hcd",
+	.id		= -1,
+	.dev 		= {
+	.dma_mask       	= &hcd_dmamask,
+	.coherent_dma_mask      = 0x01ffffff,
+	},
+	.num_resources	= ARRAY_SIZE(adm5120_hcd_resources),
+	.resource	= adm5120_hcd_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&adm5120hcd_device,
+};
+
+static int __init adm5120_init(void)
+{
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(adm5120_init);
Index: linux/arch/mips/adm5120/mipsIRQ.S
===================================================================
--- linux/arch/mips/adm5120/mipsIRQ.S	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/mipsIRQ.S	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,135 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+#define STATUS_IE	0x00000001
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *	
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+
+NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		
+	mfc0	s1, CP0_STATUS
+	and     s0, s0, s1
+	
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq		a0, zero, 1f
+	nop
+
+	move	a0, sp
+	jal		mips_timer_interrupt
+	nop
+
+	j		ret_from_irq
+	nop				
+
+1:
+	andi	a0, s0, CAUSEF_IP2
+	beq		a0, zero, 1f	
+	nop
+	
+	move	a0, sp			
+	jal		adm5120_hw0_irqdispatch	 
+	nop
+1:
+	j		ret_from_irq
+	nop							
+
+END(mipsIRQ)
+
+
+LEAF(mips_int_lock)
+	.set noreorder
+	mfc0	v0, CP0_STATUS
+	li		v1, ~STATUS_IE
+	and		v1, v1, v0
+	mtc0	v1, CP0_STATUS
+	j		ra
+	and		v0, v0, STATUS_IE
+	.set reorder
+END(mips_int_lock)
+
+
+LEAF(mips_int_unlock)
+	mfc0	v0, CP0_STATUS
+	and		a0, a0, STATUS_IE
+	or		v0, v0, a0
+	mtc0	v0, CP0_STATUS
+	j		ra
+	nop
+END(mips_int_unlock)
+
Index: linux/arch/mips/adm5120/altera.c
===================================================================
--- linux/arch/mips/adm5120/altera.c	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/altera.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,46 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/am5120/adm5120.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#define ALTERA_FW_SIZE 158224
+
+#define ALTERA_DEBUG 
+
+static char __initdata altera_fw[]={
+#include "altera.inc"
+};
+
+int __init
+load_altera_firmware(void)
+{
+    unsigned long io_addr;
+    u32 i;
+    u8 j;
+    u8 t_byte;
+
+    ADM5120_SW_REG(GPIO_conf2_REG)=0x00000010;
+    ADM5120_SW_REG(GPIO_conf0_REG)=0x08000000;
+    ADM5120_SW_REG(GPIO_conf0_REG)=0x08080000;    
+
+    io_addr=(unsigned long)ioremap((unsigned long)EXTIO0_BASE,1);
+    for(i=0;i<ALTERA_FW_SIZE;i++){
+	t_byte=altera_fw[i];
+	for( j=0;j<8;j++){
+	    writeb(t_byte,(unsigned long)io_addr);
+	    t_byte>>=1;
+	}
+    }
+    
+    i=0;
+    while( !( ADM5120_SW_REG(GPIO_conf0_REG) & 0x00000100 ) && i<20 ){
+	udelay(1000);
+	i++;
+    }
+    if( !( ADM5120_SW_REG(GPIO_conf0_REG) & 0x00000100 ) )
+	printk("Altera firmware load: fail\n");
+    else
+	printk("Altera firmware load: successful\n");    
+
+}
Index: linux/arch/mips/adm5120/memory.c
===================================================================
--- linux/arch/mips/adm5120/memory.c	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/memory.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2003 ADMtek Incorporated.
+ *	daniell@admtek.com.tw
+ * Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+
+
+/* References to section boundaries */
+extern char _end;
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+#define ADM5120_MEMCTRL			0x1200001c
+#define ADM5120_MEMCTRL_SDRAM_MASK	0x7
+
+static const unsigned long adm_sdramsize[] __initdata = {
+	0x0,		/* Reserved */
+	0x0400000,	/* 4Mb */
+	0x0800000,	/* 8Mb */
+	0x1000000,	/* 16Mb */
+	0x4000000,	/* 64Mb */
+	0x8000000,	/* 128Mb */
+};
+
+void __init prom_meminit(void)
+{
+	unsigned long base=CPHYSADDR(PFN_ALIGN(&_end));
+	unsigned long size;
+
+	u32 memctrl = *(u32*)KSEG1ADDR(ADM5120_MEMCTRL);
+	size = 0x2000000;
+	//adm_sdramsize[memctrl & ADM5120_MEMCTRL_SDRAM_MASK];
+	add_memory_region(base, size-base, BOOT_MEM_RAM);
+}
+
+
+void __init prom_free_prom_memory (void)
+{
+	/* We don't have prom memory to free... */
+	return;
+}
Index: linux/arch/mips/adm5120/altera.bin-old
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: linux/arch/mips/adm5120/altera.bin-old
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: linux/arch/mips/adm5120/irq.c
===================================================================
--- linux/arch/mips/adm5120/irq.c	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/irq.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,151 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *		Creator : daniell@admtek.com.tw
+ *	Carsten Langgaard, carstenl@mips.com
+ *	Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ *	Copyright (C) 2001 Ralf Baechle
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#define MIPS_CPU_TIMER_IRQ 7
+
+extern void breakpoint(void);
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+extern irq_desc_t irq_desc[];
+extern asmlinkage void mipsIRQ(void);
+
+int mips_int_lock(void);
+void mips_int_unlock(int);
+
+unsigned int mips_counter_frequency;
+
+#define ADM5120_INTC_REG(reg)	(*(volatile u32 *)(KSEG1ADDR(0x12200000+(reg))))
+#define ADM5120_INTC_STATUS	ADM5120_INTC_REG(0x00)
+#define ADM5120_INTC_ENABLE	ADM5120_INTC_REG(0x08)
+#define ADM5120_INTC_DISABLE	ADM5120_INTC_REG(0x0c)
+#define ADM5120_IRQ_MAX		9
+#define ADM5120_IRQ_MASK	0x3ff
+
+void adm5120_hw0_irqdispatch(struct pt_regs *regs)
+{
+	unsigned long intsrc;
+	int i;
+
+	intsrc = ADM5120_INTC_STATUS & ADM5120_IRQ_MASK;
+
+	for (i = 0; intsrc; intsrc >>= 1, i++)
+		if (intsrc & 0x1)
+			do_IRQ(i, regs);
+}
+
+void mips_timer_interrupt(struct pt_regs *regs)
+{
+	write_c0_compare(read_c0_count()+ mips_counter_frequency/HZ);
+	ll_timer_interrupt(MIPS_CPU_TIMER_IRQ, regs);
+}
+
+void enable_adm5120_irq(unsigned int irq)
+{
+	int s;
+
+	/* Disable all interrupts (FIQ/IRQ) */
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > ADM5120_IRQ_MAX)) 
+		goto err_exit;
+
+	ADM5120_INTC_ENABLE = (1<<irq);
+
+err_exit:
+
+	/* Restore the interrupts states */
+	mips_int_unlock(s);
+}
+
+
+void disable_adm5120_irq(unsigned int irq)
+{
+	int s;
+
+	/* Disable all interrupts (FIQ/IRQ) */
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > ADM5120_IRQ_MAX)) 
+		goto err_exit;
+
+	ADM5120_INTC_DISABLE = (1<<irq);
+
+err_exit:
+	/* Restore the interrupts states */
+	mips_int_unlock(s);
+}
+
+unsigned int startup_adm5120_irq(unsigned int irq)
+{
+	enable_adm5120_irq(irq);
+	return 0;
+}
+
+void shutdown_adm5120_irq(unsigned int irq)
+{
+	disable_adm5120_irq(irq);
+}
+
+static inline void ack_adm5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_DISABLE = (1 << irq_nr);
+}
+
+
+static void end_adm5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_ENABLE = (1 << irq_nr);
+}
+
+
+void set_affinity_adm5120_irq(unsigned int irq, cpumask_t mask)
+{
+	return;
+}
+
+	
+static hw_irq_controller adm5120_irq_type = {
+	"ADM5120 INTC",
+	startup_adm5120_irq,
+	shutdown_adm5120_irq,
+	enable_adm5120_irq,
+	disable_adm5120_irq,
+	ack_adm5120_irq,
+	end_adm5120_irq,
+	set_affinity_adm5120_irq
+};
+
+
+void __init arch_init_irq(void)
+{
+	int i;
+	set_except_vector(0, mipsIRQ);
+	
+	for (i = 0; i <= ADM5120_IRQ_MAX; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action= NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &adm5120_irq_type;
+	}
+}
+
Index: linux/arch/mips/adm5120/Makefile
===================================================================
--- linux/arch/mips/adm5120/Makefile	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,2 @@
+
+obj-y	:= setup.o prom.o irq.o memory.o mipsIRQ.o altera.o
Index: linux/arch/mips/adm5120/prom.c
===================================================================
--- linux/arch/mips/adm5120/prom.c	(.../linux)	(revision 0)
+++ linux/arch/mips/adm5120/prom.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,47 @@
+/*****************************************************************************
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2003 ADMtek Incorporated.
+ *	daniell@admtek.com.tw
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ *****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+
+void setup_prom_printf(int);
+void prom_printf(char *, ...);
+void prom_meminit(void);
+
+/*
+ * initialize the prom module.
+ */
+void __init prom_init(void)
+{
+	/* you should these macros defined in include/asm/bootinfo.h */
+	mips_machgroup = MACH_GROUP_ADM_GW;
+	mips_machtype = MACH_ADM_GW_5120;
+
+	/* init memory map */
+	prom_meminit();
+}
Index: linux/arch/mips/pci/Makefile
===================================================================
--- linux/arch/mips/pci/Makefile	(.../linux)	(revision 5)
+++ linux/arch/mips/pci/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -7,6 +7,7 @@
 #
 # PCI bus host bridge specific code
 #
+obj-$(CONFIG_PCI_ADM5120)	+= ops-adm5120.o pci-adm5120.o
 obj-$(CONFIG_ITE_BOARD_GEN)	+= ops-it8172.o
 obj-$(CONFIG_MIPS_BONITO64)	+= ops-bonito64.o
 obj-$(CONFIG_MIPS_GT64111)	+= ops-gt64111.o
Index: linux/arch/mips/pci/ops-adm5120.c
===================================================================
--- linux/arch/mips/pci/ops-adm5120.c	(.../linux)	(revision 0)
+++ linux/arch/mips/pci/ops-adm5120.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,59 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+volatile u32* pci_config_address_reg = (volatile u32*)KSEG1ADDR(0x115ffff0);
+volatile u32* pci_config_data_reg = (volatile u32*)KSEG1ADDR(0x115ffff8);
+
+#define PCI_ENABLE 0x80000000
+                          
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, uint32_t *val)
+{
+	*pci_config_address_reg = ((bus->number & 0xff) << 0x10) |
+	    ((devfn & 0xff) << 0x08) | (where & 0xfc) | PCI_ENABLE;
+	switch (size) {
+		case 1:
+			*val = ((*pci_config_data_reg)>>((where&3)<<3))&0xff;
+			break;
+		case 2:
+			*val = ((*pci_config_data_reg)>>((where&3)<<3))&0xffff;
+			break;
+		default:
+			*val = (*pci_config_data_reg);
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn, int where,
+                            int size, uint32_t val)
+{
+	*pci_config_address_reg = ((bus->number & 0xff) << 0x10) |
+	    ((devfn & 0xff) << 0x08) | (where & 0xfc) | PCI_ENABLE;
+	switch (size) {
+		case 1:
+			*(volatile u8 *)(((int)pci_config_data_reg) +
+			    (where & 3)) = val;
+			break;
+		case 2:
+			*(volatile u16 *)(((int)pci_config_data_reg) +
+			    (where & 2)) = (val);
+			break;
+		default:
+			*pci_config_data_reg = (val);
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops adm5120_pci_ops = {
+	pci_config_read,
+	pci_config_write
+};
Index: linux/arch/mips/pci/pci-adm5120.c
===================================================================
--- linux/arch/mips/pci/pci-adm5120.c	(.../linux)	(revision 0)
+++ linux/arch/mips/pci/pci-adm5120.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,93 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+extern struct pci_ops adm5120_pci_ops;
+
+#define ADM5120_CODE		0x12000000
+#define ADM5120_CODE_PQFP	0x20000000
+
+#define PCI_CMM_IOACC_EN	0x1
+#define PCI_CMM_MEMACC_EN	0x2
+#define PCI_CMM_MASTER_EN	0x4
+#define PCI_CMM_DEF \
+		(PCI_CMM_IOACC_EN | PCI_CMM_MEMACC_EN | PCI_CMM_MASTER_EN)
+
+#define PCI_DEF_CACHE_LINE_SZ	4
+
+
+struct resource pci_io_resource = {
+	"PCI IO space", 
+	0x11500000,  
+	0x115ffff0-1,
+	IORESOURCE_IO
+};
+
+struct resource pci_mem_resource = {
+	"PCI memory space", 
+	0x11400000,
+	0x11500000,
+	IORESOURCE_MEM
+};
+
+static struct pci_controller adm5120_controller = {
+	.pci_ops	= &adm5120_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+};
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (slot < 2 || slot > 4)
+		return -1;
+	return slot + 4;
+}
+
+static void adm5120_pci_fixup(struct pci_dev *dev)
+{
+	if (dev->devfn == 0) {
+		pci_write_config_word(dev, PCI_COMMAND, PCI_CMM_DEF);
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE,
+		    PCI_DEF_CACHE_LINE_SZ);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0);
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, adm5120_pci_fixup);
+
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+static int __init adm5120_pci_setup(void)
+{
+
+	if ((*(volatile u32 *)(KSEG1ADDR(ADM5120_CODE))) & ADM5120_CODE_PQFP) {
+		printk("System has no PCI BIOS\n");
+		return 1;
+	}
+	printk("System has PCI BIOS\n");
+
+	/* Avoid ISA compat ranges.  */
+	PCIBIOS_MIN_IO = 0x00000000;
+	PCIBIOS_MIN_MEM = 0x00000000;
+
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;	
+
+	register_pci_controller(&adm5120_controller);
+	return 0;
+}
+
+arch_initcall(adm5120_pci_setup);
Index: linux/arch/mips/Makefile
===================================================================
--- linux/arch/mips/Makefile	(.../linux)	(revision 5)
+++ linux/arch/mips/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -286,6 +286,12 @@
 load-$(CONFIG_MACH_JAZZ)	+= 0xffffffff80080000
 
 #
+# ADMtek 5120
+#
+core-$(CONFIG_MIPS_ADM5120)    += arch/mips/adm5120/
+load-$(CONFIG_MIPS_ADM5120)    += 0xffffffff80002000
+
+#
 # Common Alchemy Au1x00 stuff
 #
 core-$(CONFIG_SOC_AU1X00)	+= arch/mips/au1000/common/
Index: linux/arch/mips/mm/tlbex.c
===================================================================
--- linux/arch/mips/mm/tlbex.c	(.../linux)	(revision 5)
+++ linux/arch/mips/mm/tlbex.c	(.../linux-kernel/linux)	(revision 28)
@@ -742,7 +742,7 @@
 	}
 #endif
 
-	memcpy((void *)CAC_BASE, tlb_handler, 0x80);
+	memcpy((void *)ebase, tlb_handler, 0x80);
 }
 
 /*
@@ -838,6 +838,7 @@
 		break;
 
 	case CPU_R4300:
+	case CPU_4KC:	
 	case CPU_5KC:
 	case CPU_TX49XX:
 	case CPU_AU1000:
@@ -852,13 +853,12 @@
 
 	case CPU_R10000:
 	case CPU_R12000:
-	case CPU_4KC:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
-		tlbw(p);
+    		tlbw(p);
 		break;
 
 	case CPU_NEVADA:
@@ -1260,7 +1260,7 @@
 	}
 #endif
 
-	memcpy((void *)CAC_BASE, final_handler, 0x100);
+	memcpy((void *)ebase, final_handler, 0x100);
 }
 
 /*
Index: linux/Makefile
===================================================================
--- linux/Makefile	(.../linux)	(revision 5)
+++ linux/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -315,7 +315,7 @@
 DEPMOD		= /sbin/depmod
 KALLSYMS	= scripts/kallsyms
 PERL		= perl
-CHECK		= sparse
+CHECK		= sparse -Wbitwise
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise $(CF)
 MODFLAGS	= -DMODULE
@@ -739,6 +739,11 @@
 	$(call if_changed_rule,vmlinux__)
 	$(Q)rm -f .old_version
 
+vmlinuz: vmlinux
+	$(OBJCOPY) -O binary vmlinux vmlinux.bin
+	gzip vmlinux.bin -c >vmlinuz
+
+
 # The actual objects are generated when descending, 
 # make sure no implicit rule kicks in
 $(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): $(vmlinux-dirs) ;
Index: linux/drivers/serial/Makefile
===================================================================
--- linux/drivers/serial/Makefile	(.../linux)	(revision 5)
+++ linux/drivers/serial/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -11,7 +11,8 @@
 serial-8250-$(CONFIG_PCI) += 8250_pci.o
 serial-8250-$(CONFIG_HP300) += 8250_hp300.o
 
-obj-$(CONFIG_SERIAL_CORE) += serial_core.o
+obj-y += serial_core.o
+#$(CONFIG_SERIAL_CORE) += serial_core.o
 obj-$(CONFIG_SERIAL_21285) += 21285.o
 obj-$(CONFIG_SERIAL_8250) += 8250.o $(serial-8250-y)
 obj-$(CONFIG_SERIAL_8250_CS) += serial_cs.o
@@ -23,6 +24,8 @@
 obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
 obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
 obj-$(CONFIG_SERIAL_8250_AU1X00) += 8250_au1x00.o
+obj-y += adm5120_uart.o
+#$(CONFIG_SERIAL_ADM5120) += adm5120_uart.o
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
Index: linux/drivers/serial/Kconfig
===================================================================
--- linux/drivers/serial/Kconfig	(.../linux)	(revision 5)
+++ linux/drivers/serial/Kconfig	(.../linux-kernel/linux)	(revision 28)
@@ -225,6 +225,22 @@
 	  to this option.  The driver can handle 1 or 2 serial ports.
 	  If unsure, say N.
 
+config SERIAL_ADM5120
+       bool "ADM5120 serial port support"
+       depends on MIPS_ADM5120
+       select SERIAL_CORE
+       select SERIAL_CORE_CONSOLE
+       help
+         Driver for the on chip UARTs on the ADM5120 SoC
+
+config ADM5120_NR_UARTS
+       int "Maximum number of ADM5120 serial ports"
+       depends on SERIAL_ADM5120
+       default "2"
+       ---help---
+         Set this to the number of serial ports you want the driver to
+         support.
+
 comment "Non-8250 serial port support"
 
 config SERIAL_AMBA_PL010
Index: linux/drivers/serial/adm5120_uart.c
===================================================================
--- linux/drivers/serial/adm5120_uart.c	(.../linux)	(revision 0)
+++ linux/drivers/serial/adm5120_uart.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,523 @@
+/*
+ *	Serial driver for ADM5120 SoC
+ *
+ *	Derived from drivers/serial/uart00.c
+ *	Copyright 2001 Altera Corporation
+ *
+ *	Some pieces are derived from the ADMtek 2.4 serial driver.
+ *	Copyright (C) ADMtek Incorporated, 2003
+ *		daniell@admtek.com.tw
+ *	Which again was derived from drivers/char/serial.c
+ *	Copyright (C) Linus Torvalds et al.
+ *
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/console.h>
+
+#define ADM5120_UART_BASE0		0x12600000
+#define ADM5120_UART_BASE1		0x12800000
+#define ADM5120_UART_SIZE		0x20
+
+#define ADM5120_UART_IRQ0		1
+#define ADM5120_UART_IRQ1		2
+
+#define ADM5120_UART_REG(base, reg) \
+	(*(volatile u32 *)KSEG1ADDR((base)+(reg)))
+
+#define ADM5120_UART_BAUDDIV(rate)	((u32)((62500000/(8*(rate))+1)/2-1))
+#define ADM5120_UART_BAUD115200		ADM5120_UART_BAUDDIV(115200)
+
+#define ADM5120_UART_DATA		0x00
+#define ADM5120_UART_RS			0x04
+#define ADM5120_UART_LCR_H		0x08
+#define ADM5120_UART_LCR_M		0x0c
+#define ADM5120_UART_LCR_L		0x10
+#define ADM5120_UART_CR			0x14
+#define ADM5120_UART_FR			0x18
+#define ADM5120_UART_IR			0x1c
+
+#define ADM5120_UART_FE			0x01
+#define ADM5120_UART_PE			0x02
+#define ADM5120_UART_BE			0x04
+#define ADM5120_UART_OE			0x08
+#define ADM5120_UART_ERR		0x0f
+#define ADM5120_UART_FIFO_EN		0x10
+#define ADM5120_UART_EN			0x01
+#define ADM5120_UART_TIE		0x20
+#define ADM5120_UART_RIE		0x50
+#define ADM5120_UART_IE			0x78
+#define ADM5120_UART_CTS		0x01
+#define ADM5120_UART_DSR		0x02
+#define ADM5120_UART_DCD		0x04
+#define ADM5120_UART_TXFF		0x20
+#define ADM5120_UART_TXFE		0x80
+#define ADM5120_UART_RXFE		0x10
+#define ADM5120_UART_BRK		0x01
+#define ADM5120_UART_PEN		0x02
+#define ADM5120_UART_EPS		0x04
+#define ADM5120_UART_STP2		0x08
+#define ADM5120_UART_W5			0x00
+#define ADM5120_UART_W6			0x20
+#define ADM5120_UART_W7			0x40
+#define ADM5120_UART_W8			0x60
+#define ADM5120_UART_MIS		0x01
+#define ADM5120_UART_RIS		0x02
+#define ADM5120_UART_TIS		0x04
+#define ADM5120_UART_RTIS		0x08
+
+static void adm5120ser_stop_tx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_TIE;
+}
+
+static void adm5120ser_irq_rx(struct uart_port *port, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, ch, rds, flg, ignored = 0;
+
+	status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	while (!(status & ADM5120_UART_RXFE)) {
+		/* 
+		 * We need to read rds before reading the 
+		 * character from the fifo
+		 */
+		rds = ADM5120_UART_REG(port->iobase, ADM5120_UART_RS);
+		ch = ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA);
+		port->icount.rx++;
+
+/*
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+*/
+		flg = TTY_NORMAL;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (rds & ADM5120_UART_ERR)
+			goto handle_error;
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		tty_insert_flip_char(tty, ch, flg);
+
+	ignore_char:
+		status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	}
+ out:
+	tty_flip_buffer_push(tty);
+	return;
+
+ handle_error:
+ 	ADM5120_UART_REG(port->iobase, ADM5120_UART_RS) = 0xff;
+	if (rds & ADM5120_UART_BE) {
+		port->icount.brk++;
+		if (uart_handle_break(port))
+			goto ignore_char;
+	} else if (rds & ADM5120_UART_PE)
+		port->icount.parity++;
+	else if (rds & ADM5120_UART_FE)
+		port->icount.frame++;
+	if (rds & ADM5120_UART_OE)
+		port->icount.overrun++;
+
+	if (rds & port->ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+	rds &= port->read_status_mask;
+
+	if (rds & ADM5120_UART_BE)
+		flg = TTY_BREAK;
+	else if (rds & ADM5120_UART_PE)
+		flg = TTY_PARITY;
+	else if (rds & ADM5120_UART_FE)
+		flg = TTY_FRAME;
+
+	if (rds & ADM5120_UART_OE) {
+		/*
+		 * CHECK: does overrun affect the current character?
+		 * ASSUMPTION: it does not.
+		 */
+		tty_insert_flip_char(tty, ch, flg);
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef CONFIG_MAGIC_SYSRQ
+	port->sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void adm5120ser_irq_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	if (port->x_char) {
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA) =
+		    port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		adm5120ser_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA) =
+		    xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		adm5120ser_stop_tx(port);
+}
+
+static void adm5120ser_irq_modem(struct uart_port *port)
+{
+	unsigned int status;
+
+	status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+
+	if (status & ADM5120_UART_DCD)
+		uart_handle_dcd_change(port, status & ADM5120_UART_DCD);
+
+	if (status & ADM5120_UART_DSR)
+		port->icount.dsr++;
+
+	if (status & ADM5120_UART_CTS)
+		uart_handle_cts_change(port, status & ADM5120_UART_CTS);
+
+	wake_up_interruptible(&port->info->delta_msr_wait);
+}
+
+static irqreturn_t adm5120ser_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned long ir = ADM5120_UART_REG(port->iobase, ADM5120_UART_IR);
+
+	if (ir & (ADM5120_UART_RIS | ADM5120_UART_RTIS))
+		adm5120ser_irq_rx(port, regs);
+	if (ir & ADM5120_UART_TIS)
+		adm5120ser_irq_tx(port);
+	if (ir & ADM5120_UART_MIS) {
+		adm5120ser_irq_modem(port);
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_IR) = 0xff;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int adm5120ser_tx_empty(struct uart_port *port)
+{
+	unsigned int fr = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	return (fr & ADM5120_UART_TXFE) ? TIOCSER_TEMT : 0;
+}
+
+static void adm5120ser_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static unsigned int adm5120ser_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+	unsigned int fr = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+
+	if (fr & ADM5120_UART_CTS)
+		result |= TIOCM_CTS;
+	if (fr & ADM5120_UART_DSR)
+		result |= TIOCM_DSR;
+	if (fr & ADM5120_UART_DCD)
+		result |= TIOCM_CAR;
+	return result;
+}
+
+static void adm5120ser_start_tx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) |= ADM5120_UART_TIE;
+}
+
+static void adm5120ser_stop_rx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_RIE;
+}
+
+static void adm5120ser_enable_ms(struct uart_port *port)
+{
+}
+
+static void adm5120ser_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+	unsigned long lcrh;
+
+	spin_lock_irqsave(&port->lock, flags);
+	lcrh = ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H);
+	if (break_state == -1)
+		lcrh |= ADM5120_UART_BRK;
+	else
+		lcrh &= ~ADM5120_UART_BRK;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) = lcrh;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int adm5120ser_startup(struct uart_port *port)
+{
+	int ret;
+	ret = request_irq(port->irq, adm5120ser_irq, 0, "ADM5120 UART", port);
+	if (ret) {
+		printk(KERN_ERR "Couldn't get irq %d\n", port->irq);
+		return ret;
+	}
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) |=
+	    ADM5120_UART_FIFO_EN;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) |=
+	    ADM5120_UART_EN | ADM5120_UART_IE;
+	return 0;
+}
+
+static void adm5120ser_shutdown(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_IE;
+	free_irq(port->irq, port);
+}
+
+static void adm5120ser_set_termios(struct uart_port *port,
+    struct termios *termios, struct termios *old)
+{
+	unsigned int baud, quot, lcrh;
+	unsigned long flags;
+
+	termios->c_cflag |= CREAD;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	lcrh = ADM5120_UART_FIFO_EN;
+	switch (termios->c_cflag & CSIZE) {
+		case CS5:
+			lcrh |= ADM5120_UART_W5;
+			break;
+		case CS6:
+			lcrh |= ADM5120_UART_W6;
+			break;
+		case CS7:
+			lcrh |= ADM5120_UART_W7;
+			break;
+		default:
+			lcrh |= ADM5120_UART_W8;
+			break;
+	}
+	if (termios->c_cflag & CSTOPB)
+		lcrh |= ADM5120_UART_STP2;
+	if (termios->c_cflag & PARENB) {
+		lcrh |= ADM5120_UART_PEN;
+		if (!(termios->c_cflag & PARODD))
+			lcrh |= ADM5120_UART_EPS;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) = lcrh;
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = ADM5120_UART_OE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= ADM5120_UART_FE | ADM5120_UART_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= ADM5120_UART_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= ADM5120_UART_FE | ADM5120_UART_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= ADM5120_UART_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns to (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= ADM5120_UART_OE;
+	}
+
+	quot = ADM5120_UART_BAUD115200;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_L) = quot & 0xff;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_M) = quot >> 8;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *adm5120ser_type(struct uart_port *port)
+{
+	return port->type == PORT_ADM5120 ? "ADM5120" : NULL;
+}
+
+static void adm5120ser_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_ADM5120;
+}
+
+static void adm5120ser_release_port(struct uart_port *port)
+{
+	release_mem_region(port->iobase, ADM5120_UART_SIZE);
+}
+
+static int adm5120ser_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->iobase, ADM5120_UART_SIZE,
+	    "adm5120-uart") != NULL ? 0 : -EBUSY; 
+}
+
+static struct uart_ops adm5120ser_ops = {
+	.tx_empty =	adm5120ser_tx_empty,
+	.set_mctrl =	adm5120ser_set_mctrl,
+	.get_mctrl =	adm5120ser_get_mctrl,
+	.stop_tx =	adm5120ser_stop_tx,
+	.start_tx =	adm5120ser_start_tx,
+	.stop_rx =	adm5120ser_stop_rx,
+	.enable_ms =	adm5120ser_enable_ms,
+	.break_ctl =	adm5120ser_break_ctl,
+	.startup =	adm5120ser_startup,
+	.shutdown =	adm5120ser_shutdown,
+	.set_termios =	adm5120ser_set_termios,
+	.type =		adm5120ser_type,
+	.config_port =	adm5120ser_config_port,
+	.release_port =	adm5120ser_release_port,
+	.request_port =	adm5120ser_request_port,
+};
+
+static void adm5120console_put(const char c)
+{
+	while ((ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_FR) &
+	     ADM5120_UART_TXFF) != 0);
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_DATA) = c;
+}
+
+static void adm5120console_write(struct console *con, const char *s,
+    unsigned int count)
+{
+	while (count--) {
+		if (*s == '\n')
+			adm5120console_put('\r');
+		adm5120console_put(*s);
+		s++;
+	}
+}
+
+static int __init adm5120console_setup(struct console *con, char *options)
+{
+	/* Set to 115200 baud, 8N1 and enable FIFO */
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_L) =
+	    ADM5120_UART_BAUD115200 & 0xff;
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_M) =
+	    ADM5120_UART_BAUD115200 >> 8;
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_H) =
+	    ADM5120_UART_W8 | ADM5120_UART_FIFO_EN;
+	/* Enable port */
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_CR) =
+	    ADM5120_UART_EN;
+
+	return 0;
+}
+
+static struct uart_driver adm5120ser_reg;
+
+static struct console adm5120_serconsole = {
+	.name =		"ttyS",
+	.write =	adm5120console_write,
+	.device =	uart_console_device,
+	.setup =	adm5120console_setup,
+	.flags =	CON_PRINTBUFFER,
+	.cflag =	B115200 | CS8 | CREAD,
+	.index =	0,
+	.data =		&adm5120ser_reg,
+};
+
+static int __init adm5120console_init(void)
+{
+	register_console(&adm5120_serconsole);
+	return 0;
+}
+
+console_initcall(adm5120console_init);
+
+#define CONFIG_ADM5120_NR_UARTS 1
+static struct uart_port adm5120ser_ports[] = {
+	{
+		.iobase =	ADM5120_UART_BASE0,
+		.irq =		ADM5120_UART_IRQ0,
+		.uartclk =	62500000,
+		.fifosize =	16,
+		.ops =		&adm5120ser_ops,
+		.line =		0,
+		.flags =	ASYNC_BOOT_AUTOCONF,
+	},
+#if (CONFIG_ADM5120_NR_UARTS > 1)
+	{
+		.iobase =	ADM5120_UART_BASE1,
+		.irq =		ADM5120_UART_IRQ1,
+		.uartclk =	62500000,
+		.fifosize =	16,
+		.ops =		&adm5120ser_ops,
+		.line =		1,
+		.flags =	ASYNC_BOOT_AUTOCONF,
+	},
+#endif
+};
+
+static struct uart_driver adm5120ser_reg = {
+	.owner	=	THIS_MODULE,
+	.driver_name =	"ttyS",
+	.dev_name =	"ttyS",
+	.devfs_name =	"ttyS",	
+	.major =	TTY_MAJOR,
+	.minor =	64,
+	.nr =		CONFIG_ADM5120_NR_UARTS,
+	.cons =		&adm5120_serconsole,
+};
+
+static int __init adm5120ser_init(void)
+{
+	int ret, i;
+
+	ret = uart_register_driver(&adm5120ser_reg);
+	if (!ret) {
+		for (i = 0; i < CONFIG_ADM5120_NR_UARTS; i++)
+			uart_add_one_port(&adm5120ser_reg, &adm5120ser_ports[i]);
+	}
+
+	return ret;
+}
+
+__initcall(adm5120ser_init);
Index: linux/drivers/mtd/nand/nand_base.c_bkp
===================================================================
--- linux/drivers/mtd/nand/nand_base.c_bkp	(.../linux)	(revision 0)
+++ linux/drivers/mtd/nand/nand_base.c_bkp	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,2729 @@
+/*
+ *  drivers/mtd/nand.c
+ *
+ *  Overview:
+ *   This is the generic MTD driver for NAND flash devices. It should be
+ *   capable of working with almost all NAND chips currently available.
+ *   Basic support for AG-AND chips is provided.
+ *
+ *	Additional technical information is available on
+ *	http://www.linux-mtd.infradead.org/tech/nand.html
+ *
+ *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
+ * 		  2002 Thomas Gleixner (tglx@linutronix.de)
+ *
+ *  02-08-2004  tglx: support for strange chips, which cannot auto increment
+ *		pages on read / read_oob
+ *
+ *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes
+ *		pointed this out, as he marked an auto increment capable chip
+ *		as NOAUTOINCR in the board driver.
+ *		Make reads over block boundaries work too
+ *
+ *  04-14-2004	tglx: first working version for 2k page size chips
+ *
+ *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
+ *
+ *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
+ *		among multiple independend devices. Suggestions and initial patch
+ *		from Ben Dooks <ben-mtd@fluff.org>
+ *
+ *  12-05-2004	dmarlin: add workaround for Renesas AG-AND chips "disturb" issue.
+ *		Basically, any block not rewritten may lose data when surrounding blocks
+ *		are rewritten many times.  JFFS2 ensures this doesn't happen for blocks
+ *		it uses, but the Bad Block Table(s) may not be rewritten.  To ensure they
+ *		do not lose data, force them to be rewritten when some of the surrounding
+ *		blocks are erased.  Rather than tracking a specific nearby block (which
+ *		could itself go bad), use a page address 'mask' to select several blocks
+ *		in the same area, and rewrite the BBT when any of them are erased.
+ *
+ *  01-03-2005	dmarlin: added support for the device recovery command sequence for Renesas
+ *		AG-AND chips.  If there was a sudden loss of power during an erase operation,
+ * 		a "device recovery" operation must be performed when power is restored
+ * 		to ensure correct operation.
+ *
+ *  01-20-2005	dmarlin: added support for optional hardware specific callback routine to
+ *		perform extra error status checks on erase and write failures.  This required
+ *		adding a wrapper function for nand_read_ecc.
+ *
+ * 08-20-2005	vwool: suspend/resume added
+ *
+ * Credits:
+ *	David Woodhouse for adding multichip support
+ *
+ *	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
+ *	rework for 2K page size chips
+ *
+ * TODO:
+ *	Enable cached programming for 2k page size chips
+ *	Check, if mtd->ecctype should be set to MTD_ECC_HW
+ *	if we have HW ecc support.
+ *	The AG-AND chips have nice features for speed improvement,
+ *	which are not supported yet. Read / program 4 pages in one go.
+ *
+ * $Id: nand_base.c,v 1.150 2005/09/15 13:58:48 vwool Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/interrupt.h>
+#include <linux/bitops.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/partitions.h>
+#endif
+
+/* Define default oob placement schemes for large and small page devices */
+static struct nand_oobinfo nand_oob_8 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2},
+	.oobfree = { {3, 2}, {6, 2} }
+};
+
+static struct nand_oobinfo nand_oob_16 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 6,
+	.eccpos = {0, 1, 2, 3, 6, 7},
+	.oobfree = { {8, 8} }
+};
+
+static struct nand_oobinfo nand_oob_64 = {
+	.useecc = MTD_NANDECC_AUTOPLACE,
+	.eccbytes = 24,
+	.eccpos = {
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 38} }
+};
+
+/* This is used for padding purposes in nand_write_oob */
+static u_char ffchars[] = {
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/*
+ * NAND low-level MTD interface functions
+ */
+static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len);
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len);
+static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len);
+
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf);
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf);
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel);
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char *buf);
+static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs,
+			unsigned long count, loff_t to, size_t * retlen);
+static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs,
+			unsigned long count, loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel);
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr);
+static void nand_sync (struct mtd_info *mtd);
+
+/* Some internal functions */
+static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
+		struct nand_oobinfo *oobsel, int mode);
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode);
+#else
+#define nand_verify_pages(...) (0)
+#endif
+
+static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
+
+/**
+ * nand_release_device - [GENERIC] release chip
+ * @mtd:	MTD device structure
+ *
+ * Deselect, release chip lock and wake up anyone waiting on the device
+ */
+static void nand_release_device (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	/* De-select the NAND device */
+	this->select_chip(mtd, -1);
+
+	if (this->controller) {
+		/* Release the controller and the chip */
+		spin_lock(&this->controller->lock);
+		this->controller->active = NULL;
+		this->state = FL_READY;
+		wake_up(&this->controller->wq);
+		spin_unlock(&this->controller->lock);
+	} else {
+		/* Release the chip */
+		spin_lock(&this->chip_lock);
+		this->state = FL_READY;
+		wake_up(&this->wq);
+		spin_unlock(&this->chip_lock);
+	}
+}
+
+/**
+ * nand_read_byte - [DEFAULT] read one byte from the chip
+ * @mtd:	MTD device structure
+ *
+ * Default read function for 8bit buswith
+ */
+static u_char nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	return readb(this->IO_ADDR_R);
+}
+
+/**
+ * nand_write_byte - [DEFAULT] write one byte to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ *
+ * Default write function for 8it buswith
+ */
+static void nand_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *this = mtd->priv;
+	writeb(byte, this->IO_ADDR_W);
+}
+
+/**
+ * nand_read_byte16 - [DEFAULT] read one byte endianess aware from the chip
+ * @mtd:	MTD device structure
+ *
+ * Default read function for 16bit buswith with
+ * endianess conversion
+ */
+static u_char nand_read_byte16(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	return (u_char) cpu_to_le16(readw(this->IO_ADDR_R));
+}
+
+/**
+ * nand_write_byte16 - [DEFAULT] write one byte endianess aware to the chip
+ * @mtd:	MTD device structure
+ * @byte:	pointer to data byte to write
+ *
+ * Default write function for 16bit buswith with
+ * endianess conversion
+ */
+static void nand_write_byte16(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *this = mtd->priv;
+	writew(le16_to_cpu((u16) byte), this->IO_ADDR_W);
+}
+
+/**
+ * nand_read_word - [DEFAULT] read one word from the chip
+ * @mtd:	MTD device structure
+ *
+ * Default read function for 16bit buswith without
+ * endianess conversion
+ */
+static u16 nand_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	return readw(this->IO_ADDR_R);
+}
+
+/**
+ * nand_write_word - [DEFAULT] write one word to the chip
+ * @mtd:	MTD device structure
+ * @word:	data word to write
+ *
+ * Default write function for 16bit buswith without
+ * endianess conversion
+ */
+static void nand_write_word(struct mtd_info *mtd, u16 word)
+{
+	struct nand_chip *this = mtd->priv;
+	writew(word, this->IO_ADDR_W);
+}
+
+/**
+ * nand_select_chip - [DEFAULT] control CE line
+ * @mtd:	MTD device structure
+ * @chip:	chipnumber to select, -1 for deselect
+ *
+ * Default select function for 1 chip devices.
+ */
+static void nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	struct nand_chip *this = mtd->priv;
+	switch(chip) {
+	case -1:
+		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
+		break;
+	case 0:
+		this->hwcontrol(mtd, NAND_CTL_SETNCE);
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+/**
+ * nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i=0; i<len; i++)
+		writeb(buf[i], this->IO_ADDR_W);
+}
+
+/**
+ * nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i=0; i<len; i++)
+		buf[i] = readb(this->IO_ADDR_R);
+}
+
+/**
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int nand_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	for (i=0; i<len; i++)
+		if (buf[i] != readb(this->IO_ADDR_R))
+			return -EFAULT;
+
+	return 0;
+}
+
+/**
+ * nand_write_buf16 - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 16bit buswith
+ */
+static void nand_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+
+	for (i=0; i<len; i++)
+		writew(p[i], this->IO_ADDR_W);
+
+}
+
+/**
+ * nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 16bit buswith
+ */
+static void nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+
+	for (i=0; i<len; i++)
+		p[i] = readw(this->IO_ADDR_R);
+}
+
+/**
+ * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 16bit buswith
+ */
+static int nand_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	u16 *p = (u16 *) buf;
+	len >>= 1;
+
+	for (i=0; i<len; i++)
+		if (p[i] != readw(this->IO_ADDR_R))
+			return -EFAULT;
+
+	return 0;
+}
+
+/**
+ * nand_block_bad - [DEFAULT] Read bad block marker from the chip
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ * @getchip:	0, if the chip is already selected
+ *
+ * Check, if the block is bad.
+ */
+static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+	int page, chipnr, res = 0;
+	struct nand_chip *this = mtd->priv;
+	u16 bad;
+
+	if (getchip) {
+		page = (int)(ofs >> this->page_shift);
+		chipnr = (int)(ofs >> this->chip_shift);
+
+		/* Grab the lock and see if the device is available */
+		nand_get_device (this, mtd, FL_READING);
+
+		/* Select the NAND device */
+		this->select_chip(mtd, chipnr);
+	} else
+		page = (int) ofs;
+
+	if (this->options & NAND_BUSWIDTH_16) {
+		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
+		bad = cpu_to_le16(this->read_word(mtd));
+		if (this->badblockpos & 0x1)
+			bad >>= 8;
+		if ((bad & 0xFF) != 0xff)
+			res = 1;
+	} else {
+		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
+		if (this->read_byte(mtd) != 0xff)
+			res = 1;
+	}
+
+	if (getchip) {
+		/* Deselect and wake up anyone waiting on the device */
+		nand_release_device(mtd);
+	}
+
+	return res;
+}
+
+/**
+ * nand_default_block_markbad - [DEFAULT] mark a block bad
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ *
+ * This is the default implementation, which can be overridden by
+ * a hardware specific driver.
+*/
+static int nand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *this = mtd->priv;
+	u_char buf[2] = {0, 0};
+	size_t	retlen;
+	int block;
+
+	/* Get block number */
+	block = ((int) ofs) >> this->bbt_erase_shift;
+	if (this->bbt)
+		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* Do we have a flash based bad block table ? */
+	if (this->options & NAND_USE_FLASH_BBT)
+		return nand_update_bbt (mtd, ofs);
+
+	/* We write two bytes, so we dont have to mess with 16 bit access */
+	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
+	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
+}
+
+/**
+ * nand_check_wp - [GENERIC] check if the chip is write protected
+ * @mtd:	MTD device structure
+ * Check, if the device is write protected
+ *
+ * The function expects, that the device is already selected
+ */
+static int nand_check_wp (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	/* Check the WP bit */
+	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
+	return (this->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+}
+
+/**
+ * nand_block_checkbad - [GENERIC] Check if a block is marked bad
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ * @getchip:	0, if the chip is already selected
+ * @allowbbt:	1, if its allowed to access the bbt area
+ *
+ * Check, if the block is bad. Either by reading the bad block table or
+ * calling of the scan function.
+ */
+static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (!this->bbt)
+		return this->block_bad(mtd, ofs, getchip);
+
+	/* Return info from the table */
+	return nand_isbad_bbt (mtd, ofs, allowbbt);
+}
+
+/*
+ * Wait for the ready pin, after a command
+ * The timeout is catched later.
+ */
+static void nand_wait_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long	timeo = jiffies + 2;
+
+	/* wait until command is processed or timeout occures */
+	do {
+		if (this->dev_ready(mtd))
+			return;
+		touch_softlockup_watchdog();
+	} while (time_before(jiffies, timeo));
+}
+
+/**
+ * nand_command - [DEFAULT] Send command to NAND device
+ * @mtd:	MTD device structure
+ * @command:	the command to be sent
+ * @column:	the column address for this command, -1 if none
+ * @page_addr:	the page address for this command, -1 if none
+ *
+ * Send command to NAND device. This function is used for small page
+ * devices (256/512 Bytes per page)
+ */
+static void nand_command (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/* Begin command latch cycle */
+	this->hwcontrol(mtd, NAND_CTL_SETCLE);
+	/*
+	 * Write out the command to the device.
+	 */
+	if (command == NAND_CMD_SEQIN) {
+		int readcmd;
+
+		if (column >= mtd->oobblock) {
+			/* OOB area */
+			column -= mtd->oobblock;
+			readcmd = NAND_CMD_READOOB;
+		} else if (column < 256) {
+			/* First 256 bytes --> READ0 */
+			readcmd = NAND_CMD_READ0;
+		} else {
+			column -= 256;
+			readcmd = NAND_CMD_READ1;
+		}
+		this->write_byte(mtd, readcmd);
+	}
+	this->write_byte(mtd, command);
+
+	/* Set ALE and clear CLE to start address cycle */
+	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+
+	if (column != -1 || page_addr != -1) {
+		this->hwcontrol(mtd, NAND_CTL_SETALE);
+
+		/* Serially input address */
+		if (column != -1) {
+			/* Adjust columns for 16 bit buswidth */
+			if (this->options & NAND_BUSWIDTH_16)
+				column >>= 1;
+			this->write_byte(mtd, column);
+		}
+		if (page_addr != -1) {
+			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
+			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
+			/* One more address cycle for devices > 32MiB */
+			if (this->chipsize > (32 << 20))
+				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0x0f));
+		}
+		/* Latch in address */
+		this->hwcontrol(mtd, NAND_CTL_CLRALE);
+	}
+
+	/*
+	 * program and erase have their own busy handlers
+	 * status and sequential in needs no delay
+	*/
+	switch (command) {
+
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_STATUS:
+		return;
+
+	case NAND_CMD_RESET:
+		if (this->dev_ready)
+			break;
+		udelay(this->chip_delay);
+		this->hwcontrol(mtd, NAND_CTL_SETCLE);
+		this->write_byte(mtd, NAND_CMD_STATUS);
+		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		return;
+
+	/* This applies to read commands */
+	default:
+		/*
+		 * If we don't have access to the busy pin, we apply the given
+		 * command delay
+		*/
+		if (!this->dev_ready) {
+			udelay (this->chip_delay);
+			return;
+		}
+	}
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+	ndelay (100);
+
+	nand_wait_ready(mtd);
+}
+
+/**
+ * nand_command_lp - [DEFAULT] Send command to NAND large page device
+ * @mtd:	MTD device structure
+ * @command:	the command to be sent
+ * @column:	the column address for this command, -1 if none
+ * @page_addr:	the page address for this command, -1 if none
+ *
+ * Send command to NAND device. This is the version for the new large page devices
+ * We dont have the seperate regions as we have in the small page devices.
+ * We must emulate NAND_CMD_READOOB to keep the code compatible.
+ *
+ */
+static void nand_command_lp (struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	register struct nand_chip *this = mtd->priv;
+
+	/* Emulate NAND_CMD_READOOB */
+	if (command == NAND_CMD_READOOB) {
+		column += mtd->oobblock;
+		command = NAND_CMD_READ0;
+	}
+
+
+	/* Begin command latch cycle */
+	this->hwcontrol(mtd, NAND_CTL_SETCLE);
+	/* Write out the command to the device. */
+	this->write_byte(mtd, (command & 0xff));
+	/* End command latch cycle */
+	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+
+	if (column != -1 || page_addr != -1) {
+		this->hwcontrol(mtd, NAND_CTL_SETALE);
+
+		/* Serially input address */
+		if (column != -1) {
+			/* Adjust columns for 16 bit buswidth */
+			if (this->options & NAND_BUSWIDTH_16)
+				column >>= 1;
+			this->write_byte(mtd, column & 0xff);
+			this->write_byte(mtd, column >> 8);
+		}
+		if (page_addr != -1) {
+			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
+			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
+			/* One more address cycle for devices > 128MiB */
+			if (this->chipsize > (128 << 20))
+				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0xff));
+		}
+		/* Latch in address */
+		this->hwcontrol(mtd, NAND_CTL_CLRALE);
+	}
+
+	/*
+	 * program and erase have their own busy handlers
+	 * status, sequential in, and deplete1 need no delay
+	 */
+	switch (command) {
+
+	case NAND_CMD_CACHEDPROG:
+	case NAND_CMD_PAGEPROG:
+	case NAND_CMD_ERASE1:
+	case NAND_CMD_ERASE2:
+	case NAND_CMD_SEQIN:
+	case NAND_CMD_STATUS:
+	case NAND_CMD_DEPLETE1:
+		return;
+
+	/*
+	 * read error status commands require only a short delay
+	 */
+	case NAND_CMD_STATUS_ERROR:
+	case NAND_CMD_STATUS_ERROR0:
+	case NAND_CMD_STATUS_ERROR1:
+	case NAND_CMD_STATUS_ERROR2:
+	case NAND_CMD_STATUS_ERROR3:
+		udelay(this->chip_delay);
+		return;
+
+	case NAND_CMD_RESET:
+		if (this->dev_ready)
+			break;
+		udelay(this->chip_delay);
+		this->hwcontrol(mtd, NAND_CTL_SETCLE);
+		this->write_byte(mtd, NAND_CMD_STATUS);
+		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		return;
+
+	case NAND_CMD_READ0:
+		/* Begin command latch cycle */
+		this->hwcontrol(mtd, NAND_CTL_SETCLE);
+		/* Write out the start read command */
+		this->write_byte(mtd, NAND_CMD_READSTART);
+		/* End command latch cycle */
+		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
+		/* Fall through into ready check */
+
+	/* This applies to read commands */
+	default:
+		/*
+		 * If we don't have access to the busy pin, we apply the given
+		 * command delay
+		*/
+		if (!this->dev_ready) {
+			udelay (this->chip_delay);
+			return;
+		}
+	}
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+	ndelay (100);
+
+	nand_wait_ready(mtd);
+}
+
+/**
+ * nand_get_device - [GENERIC] Get chip for selected access
+ * @this:	the nand chip descriptor
+ * @mtd:	MTD device structure
+ * @new_state:	the state which is requested
+ *
+ * Get the device and lock it for exclusive access
+ */
+static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+{
+	struct nand_chip *active;
+	spinlock_t *lock;
+	wait_queue_head_t *wq;
+	DECLARE_WAITQUEUE (wait, current);
+
+	lock = (this->controller) ? &this->controller->lock : &this->chip_lock;
+	wq = (this->controller) ? &this->controller->wq : &this->wq;
+retry:
+	active = this;
+	spin_lock(lock);
+
+	/* Hardware controller shared among independend devices */
+	if (this->controller) {
+		if (this->controller->active)
+			active = this->controller->active;
+		else
+			this->controller->active = this;
+	}
+	if (active == this && this->state == FL_READY) {
+		this->state = new_state;
+		spin_unlock(lock);
+		return 0;
+	}
+	if (new_state == FL_PM_SUSPENDED) {
+		spin_unlock(lock);
+		return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
+	}
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(wq, &wait);
+	spin_unlock(lock);
+	schedule();
+	remove_wait_queue(wq, &wait);
+	goto retry;
+}
+
+/**
+ * nand_wait - [DEFAULT]  wait until the command is done
+ * @mtd:	MTD device structure
+ * @this:	NAND chip structure
+ * @state:	state to select the max. timeout value
+ *
+ * Wait for command done. This applies to erase and program only
+ * Erase can take up to 400ms and program up to 20ms according to
+ * general NAND and SmartMedia specs
+ *
+*/
+static int nand_wait(struct mtd_info *mtd, struct nand_chip *this, int state)
+{
+
+	unsigned long	timeo = jiffies;
+	int	status;
+
+	if (state == FL_ERASING)
+		 timeo += (HZ * 400) / 1000;
+	else
+		 timeo += (HZ * 20) / 1000;
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+	ndelay (100);
+
+	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
+		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
+	else
+		this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
+
+	while (time_before(jiffies, timeo)) {
+		/* Check, if we were interrupted */
+		if (this->state != state)
+			return 0;
+
+		if (this->dev_ready) {
+			if (this->dev_ready(mtd))
+				break;
+		} else {
+			if (this->read_byte(mtd) & NAND_STATUS_READY)
+				break;
+		}
+		cond_resched();
+	}
+	status = (int) this->read_byte(mtd);
+	return status;
+}
+
+/**
+ * nand_write_page - [GENERIC] write one page
+ * @mtd:	MTD device structure
+ * @this:	NAND chip structure
+ * @page: 	startpage inside the chip, must be called with (page & this->pagemask)
+ * @oob_buf:	out of band data buffer
+ * @oobsel:	out of band selecttion structre
+ * @cached:	1 = enable cached programming if supported by chip
+ *
+ * Nand_page_program function is used for write and writev !
+ * This function will always program a full page of data
+ * If you call it with a non page aligned buffer, you're lost :)
+ *
+ * Cached programming is not supported yet.
+ */
+static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
+	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
+{
+	int 	i, status;
+	u_char	ecc_code[32];
+	int	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
+	int  	*oob_config = oobsel->eccpos;
+	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
+	int	eccbytes = 0;
+
+	/* FIXME: Enable cached programming */
+	cached = 0;
+
+	/* Send command to begin auto page programming */
+	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	/* Write out complete page of data, take care of eccmode */
+	switch (eccmode) {
+	/* No ecc, write all */
+	case NAND_ECC_NONE:
+		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
+		this->write_buf(mtd, this->data_poi, mtd->oobblock);
+		break;
+
+	/* Software ecc 3/256, write all */
+	case NAND_ECC_SOFT:
+		for (; eccsteps; eccsteps--) {
+			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
+			for (i = 0; i < 3; i++, eccidx++)
+				oob_buf[oob_config[eccidx]] = ecc_code[i];
+			datidx += this->eccsize;
+		}
+		this->write_buf(mtd, this->data_poi, mtd->oobblock);
+		break;
+	default:
+		eccbytes = this->eccbytes;
+		for (; eccsteps; eccsteps--) {
+			/* enable hardware ecc logic for write */
+			this->enable_hwecc(mtd, NAND_ECC_WRITE);
+			this->write_buf(mtd, &this->data_poi[datidx], this->eccsize);
+			this->calculate_ecc(mtd, &this->data_poi[datidx], ecc_code);
+			for (i = 0; i < eccbytes; i++, eccidx++)
+				oob_buf[oob_config[eccidx]] = ecc_code[i];
+			/* If the hardware ecc provides syndromes then
+			 * the ecc code must be written immidiately after
+			 * the data bytes (words) */
+			if (this->options & NAND_HWECC_SYNDROME)
+				this->write_buf(mtd, ecc_code, eccbytes);
+			datidx += this->eccsize;
+		}
+		break;
+	}
+
+	/* Write out OOB data */
+	if (this->options & NAND_HWECC_SYNDROME)
+		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
+	else
+		this->write_buf(mtd, oob_buf, mtd->oobsize);
+
+	/* Send command to actually program the data */
+	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
+
+	if (!cached) {
+		/* call wait ready function */
+		status = this->waitfunc (mtd, this, FL_WRITING);
+
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_WRITING, status, page);
+		}
+
+		/* See if device thinks it succeeded */
+		if (status & NAND_STATUS_FAIL) {
+			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
+			return -EIO;
+		}
+	} else {
+		/* FIXME: Implement cached programming ! */
+		/* wait until cache is ready*/
+		// status = this->waitfunc (mtd, this, FL_CACHEDRPG);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+/**
+ * nand_verify_pages - [GENERIC] verify the chip contents after a write
+ * @mtd:	MTD device structure
+ * @this:	NAND chip structure
+ * @page: 	startpage inside the chip, must be called with (page & this->pagemask)
+ * @numpages:	number of pages to verify
+ * @oob_buf:	out of band data buffer
+ * @oobsel:	out of band selecttion structre
+ * @chipnr:	number of the current chip
+ * @oobmode:	1 = full buffer verify, 0 = ecc only
+ *
+ * The NAND device assumes that it is always writing to a cleanly erased page.
+ * Hence, it performs its internal write verification only on bits that
+ * transitioned from 1 to 0. The device does NOT verify the whole page on a
+ * byte by byte basis. It is possible that the page was not completely erased
+ * or the page is becoming unusable due to wear. The read with ECC would catch
+ * the error later when the ECC page check fails, but we would rather catch
+ * it early in the page write stage. Better to write no data than invalid data.
+ */
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode)
+{
+	int 	i, j, datidx = 0, oobofs = 0, res = -EIO;
+	int	eccsteps = this->eccsteps;
+	int	hweccbytes;
+	u_char 	oobdata[64];
+
+	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
+
+	/* Send command to read back the first page */
+	this->cmdfunc (mtd, NAND_CMD_READ0, 0, page);
+
+	for(;;) {
+		for (j = 0; j < eccsteps; j++) {
+			/* Loop through and verify the data */
+			if (this->verify_buf(mtd, &this->data_poi[datidx], mtd->eccsize)) {
+				DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write verify, page 0x%08x ", __FUNCTION__, page);
+				goto out;
+			}
+			datidx += mtd->eccsize;
+			/* Have we a hw generator layout ? */
+			if (!hweccbytes)
+				continue;
+			if (this->verify_buf(mtd, &this->oob_buf[oobofs], hweccbytes)) {
+				DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write verify, page 0x%08x ", __FUNCTION__, page);
+				goto out;
+			}
+			oobofs += hweccbytes;
+		}
+
+		/* check, if we must compare all data or if we just have to
+		 * compare the ecc bytes
+		 */
+		if (oobmode) {
+			if (this->verify_buf(mtd, &oob_buf[oobofs], mtd->oobsize - hweccbytes * eccsteps)) {
+				DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write verify, page 0x%08x ", __FUNCTION__, page);
+				goto out;
+			}
+		} else {
+			/* Read always, else autoincrement fails */
+			this->read_buf(mtd, oobdata, mtd->oobsize - hweccbytes * eccsteps);
+
+			if (oobsel->useecc != MTD_NANDECC_OFF && !hweccbytes) {
+				int ecccnt = oobsel->eccbytes;
+
+				for (i = 0; i < ecccnt; i++) {
+					int idx = oobsel->eccpos[i];
+					if (oobdata[idx] != oob_buf[oobofs + idx] ) {
+						DEBUG (MTD_DEBUG_LEVEL0,
+					       	"%s: Failed ECC write "
+						"verify, page 0x%08x, " "%6i bytes were succesful\n", __FUNCTION__, page, i);
+						goto out;
+					}
+				}
+			}
+		}
+		oobofs += mtd->oobsize - hweccbytes * eccsteps;
+		page++;
+		numpages--;
+
+		/* Apply delay or wait for ready/busy pin
+		 * Do this before the AUTOINCR check, so no problems
+		 * arise if a chip which does auto increment
+		 * is marked as NOAUTOINCR by the board driver.
+		 * Do this also before returning, so the chip is
+		 * ready for the next command.
+		*/
+		if (!this->dev_ready)
+			udelay (this->chip_delay);
+		else
+			nand_wait_ready(mtd);
+
+		/* All done, return happy */
+		if (!numpages)
+			return 0;
+
+
+		/* Check, if the chip supports auto page increment */
+		if (!NAND_CANAUTOINCR(this))
+			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
+	}
+	/*
+	 * Terminate the read command. We come here in case of an error
+	 * So we must issue a reset command.
+	 */
+out:
+	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
+	return res;
+}
+#endif
+
+/**
+ * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ *
+ * This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
+ * and flags = 0xff
+ */
+static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	return nand_do_read_ecc (mtd, from, len, retlen, buf, NULL, &mtd->oobinfo, 0xff);
+}
+
+
+/**
+ * nand_read_ecc - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ * @oob_buf:	filesystem supplied oob data buffer
+ * @oobsel:	oob selection structure
+ *
+ * This function simply calls nand_do_read_ecc with flags = 0xff
+ */
+static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
+{
+	/* use userspace supplied oobinfo, if zero */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+	return nand_do_read_ecc(mtd, from, len, retlen, buf, oob_buf, oobsel, 0xff);
+}
+
+
+/**
+ * nand_do_read_ecc - [MTD Interface] Read data with ECC
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ * @oob_buf:	filesystem supplied oob data buffer (can be NULL)
+ * @oobsel:	oob selection structure
+ * @flags:	flag to indicate if nand_get_device/nand_release_device should be preformed
+ *		and how many corrected error bits are acceptable:
+ *		  bits 0..7 - number of tolerable errors
+ *		  bit  8    - 0 == do not get/release chip, 1 == get/release chip
+ *
+ * NAND read with ECC
+ */
+int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			     size_t * retlen, u_char * buf, u_char * oob_buf,
+			     struct nand_oobinfo *oobsel, int flags)
+{
+
+	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
+	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
+	struct nand_chip *this = mtd->priv;
+	u_char *data_poi, *oob_data = oob_buf;
+	u_char ecc_calc[32];
+	u_char ecc_code[32];
+        int eccmode, eccsteps;
+	int	*oob_config, datidx;
+	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+	int	eccbytes;
+	int	compareecc = 1;
+	int	oobreadlen;
+
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	if (flags & NAND_GET_DEVICE)
+		nand_get_device (this, mtd, FL_READING);
+
+	/* Autoplace of oob data ? Use the default placement scheme */
+	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
+		oobsel = this->autooob;
+
+	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
+	oob_config = oobsel->eccpos;
+
+	/* Select the NAND device */
+	chipnr = (int)(from >> this->chip_shift);
+	this->select_chip(mtd, chipnr);
+
+	/* First we calculate the starting page */
+	realpage = (int) (from >> this->page_shift);
+	page = realpage & this->pagemask;
+
+	/* Get raw starting column */
+	col = from & (mtd->oobblock - 1);
+
+	end = mtd->oobblock;
+	ecc = this->eccsize;
+	eccbytes = this->eccbytes;
+
+	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
+		compareecc = 0;
+
+	oobreadlen = mtd->oobsize;
+	if (this->options & NAND_HWECC_SYNDROME)
+		oobreadlen -= oobsel->eccbytes;
+
+	/* Loop until all data read */
+	while (read < len) {
+
+		int aligned = (!col && (len - read) >= end);
+		/*
+		 * If the read is not page aligned, we have to read into data buffer
+		 * due to ecc, else we read into return buffer direct
+		 */
+		if (aligned)
+			data_poi = &buf[read];
+		else
+			data_poi = this->data_buf;
+
+		/* Check, if we have this page in the buffer
+		 *
+		 * FIXME: Make it work when we must provide oob data too,
+		 * check the usage of data_buf oob field
+		 */
+		if (realpage == this->pagebuf && !oob_buf) {
+			/* aligned read ? */
+			if (aligned)
+				memcpy (data_poi, this->data_buf, end);
+			goto readdata;
+		}
+
+		/* Check, if we must send the read command */
+		if (sndcmd) {
+			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
+			sndcmd = 0;
+		}
+
+		/* get oob area, if we have no oob buffer from fs-driver */
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
+			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+			oob_data = &this->data_buf[end];
+
+		eccsteps = this->eccsteps;
+
+		switch (eccmode) {
+		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
+			static unsigned long lastwhinge = 0;
+			if ((lastwhinge / HZ) != (jiffies / HZ)) {
+				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
+				lastwhinge = jiffies;
+			}
+			this->read_buf(mtd, data_poi, end);
+			break;
+		}
+
+		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
+			this->read_buf(mtd, data_poi, end);
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
+				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
+			break;
+
+		default:
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
+				this->enable_hwecc(mtd, NAND_ECC_READ);
+				this->read_buf(mtd, &data_poi[datidx], ecc);
+
+				/* HW ecc with syndrome calculation must read the
+				 * syndrome from flash immidiately after the data */
+				if (!compareecc) {
+					/* Some hw ecc generators need to know when the
+					 * syndrome is read from flash */
+					this->enable_hwecc(mtd, NAND_ECC_READSYN);
+					this->read_buf(mtd, &oob_data[i], eccbytes);
+					/* We calc error correction directly, it checks the hw
+					 * generator for an error, reads back the syndrome and
+					 * does the error correction on the fly */
+					ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
+					if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
+						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
+							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
+						ecc_failed++;
+					}
+				} else {
+					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
+				}
+			}
+			break;
+		}
+
+		/* read oobdata */
+		this->read_buf(mtd, &oob_data[mtd->oobsize - oobreadlen], oobreadlen);
+
+		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
+		if (!compareecc)
+			goto readoob;
+
+		/* Pick the ECC bytes out of the oob data */
+		for (j = 0; j < oobsel->eccbytes; j++)
+			ecc_code[j] = oob_data[oob_config[j]];
+
+		/* correct data, if neccecary */
+		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
+			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
+
+			/* Get next chunk of ecc bytes */
+			j += eccbytes;
+
+			/* Check, if we have a fs supplied oob-buffer,
+			 * This is the legacy mode. Used by YAFFS1
+			 * Should go away some day
+			 */
+			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
+				int *p = (int *)(&oob_data[mtd->oobsize]);
+				p[i] = ecc_status;
+			}
+
+			if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
+				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
+				ecc_failed++;
+			}
+		}
+
+	readoob:
+		/* check, if we have a fs supplied oob-buffer */
+		if (oob_buf) {
+			/* without autoplace. Legacy mode used by YAFFS1 */
+			switch(oobsel->useecc) {
+			case MTD_NANDECC_AUTOPLACE:
+			case MTD_NANDECC_AUTOPL_USR:
+				/* Walk through the autoplace chunks */
+				for (i = 0; oobsel->oobfree[i][1]; i++) {
+					int from = oobsel->oobfree[i][0];
+					int num = oobsel->oobfree[i][1];
+					memcpy(&oob_buf[oob], &oob_data[from], num);
+					oob += num;
+				}
+				break;
+			case MTD_NANDECC_PLACE:
+				/* YAFFS1 legacy mode */
+				oob_data += this->eccsteps * sizeof (int);
+			default:
+				oob_data += mtd->oobsize;
+			}
+		}
+	readdata:
+		/* Partial page read, transfer data into fs buffer */
+		if (!aligned) {
+			for (j = col; j < end && read < len; j++)
+				buf[read++] = data_poi[j];
+			this->pagebuf = realpage;
+		} else
+			read += mtd->oobblock;
+
+		/* Apply delay or wait for ready/busy pin
+		 * Do this before the AUTOINCR check, so no problems
+		 * arise if a chip which does auto increment
+		 * is marked as NOAUTOINCR by the board driver.
+		*/
+		if (!this->dev_ready)
+			udelay (this->chip_delay);
+		else
+			nand_wait_ready(mtd);
+
+		if (read == len)
+			break;
+
+		/* For subsequent reads align to page boundary. */
+		col = 0;
+		/* Increment page address */
+		realpage++;
+
+		page = realpage & this->pagemask;
+		/* Check, if we cross a chip boundary */
+		if (!page) {
+			chipnr++;
+			this->select_chip(mtd, -1);
+			this->select_chip(mtd, chipnr);
+		}
+		/* Check, if the chip supports auto page increment
+		 * or if we have hit a block boundary.
+		*/
+		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
+			sndcmd = 1;
+	}
+
+	/* Deselect and wake up anyone waiting on the device */
+	if (flags & NAND_GET_DEVICE)
+		nand_release_device(mtd);
+
+	/*
+	 * Return success, if no ECC failures, else -EBADMSG
+	 * fs driver will take care of that, because
+	 * retlen == desired len and result == -EBADMSG
+	 */
+	*retlen = read;
+	return ecc_failed ? -EBADMSG : 0;
+}
+
+/**
+ * nand_read_oob - [MTD Interface] NAND read out-of-band
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ *
+ * NAND read out-of-band data from the spare area
+ */
+static int nand_read_oob (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
+{
+	int i, col, page, chipnr;
+	struct nand_chip *this = mtd->priv;
+	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+
+	/* Shift to get page */
+	page = (int)(from >> this->page_shift);
+	chipnr = (int)(from >> this->chip_shift);
+
+	/* Mask to get column */
+	col = from & (mtd->oobsize - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_oob: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd , FL_READING);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Send the read command */
+	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
+	/*
+	 * Read the data, if we read more than one page
+	 * oob data, let the device transfer the data !
+	 */
+	i = 0;
+	while (i < len) {
+		int thislen = mtd->oobsize - col;
+		thislen = min_t(int, thislen, len);
+		this->read_buf(mtd, &buf[i], thislen);
+		i += thislen;
+
+		/* Read more ? */
+		if (i < len) {
+			page++;
+			col = 0;
+
+			/* Check, if we cross a chip boundary */
+			if (!(page & this->pagemask)) {
+				chipnr++;
+				this->select_chip(mtd, -1);
+				this->select_chip(mtd, chipnr);
+			}
+
+			/* Apply delay or wait for ready/busy pin
+			 * Do this before the AUTOINCR check, so no problems
+			 * arise if a chip which does auto increment
+			 * is marked as NOAUTOINCR by the board driver.
+			 */
+			if (!this->dev_ready)
+				udelay (this->chip_delay);
+			else
+				nand_wait_ready(mtd);
+
+			/* Check, if the chip supports auto page increment
+			 * or if we have hit a block boundary.
+			*/
+			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
+				/* For subsequent page reads set offset to 0 */
+			        this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
+			}
+		}
+	}
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	/* Return happy */
+	*retlen = len;
+	return 0;
+}
+
+/**
+ * nand_read_raw - [GENERIC] Read raw data including oob into buffer
+ * @mtd:	MTD device structure
+ * @buf:	temporary buffer
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @ooblen:	number of oob data bytes to read
+ *
+ * Read raw data including oob into buffer
+ */
+int nand_read_raw (struct mtd_info *mtd, uint8_t *buf, loff_t from, size_t len, size_t ooblen)
+{
+	struct nand_chip *this = mtd->priv;
+	int page = (int) (from >> this->page_shift);
+	int chip = (int) (from >> this->chip_shift);
+	int sndcmd = 1;
+	int cnt = 0;
+	int pagesize = mtd->oobblock + mtd->oobsize;
+	int	blockcheck = (1 << (this->phys_erase_shift - this->page_shift)) - 1;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_read_raw: Attempt read beyond end of device\n");
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd , FL_READING);
+
+	this->select_chip (mtd, chip);
+
+	/* Add requested oob length */
+	len += ooblen;
+
+	while (len) {
+		if (sndcmd)
+			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
+		sndcmd = 0;
+
+		this->read_buf (mtd, &buf[cnt], pagesize);
+
+		len -= pagesize;
+		cnt += pagesize;
+		page++;
+
+		if (!this->dev_ready)
+			udelay (this->chip_delay);
+		else
+			nand_wait_ready(mtd);
+
+		/* Check, if the chip supports auto page increment */
+		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
+			sndcmd = 1;
+	}
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+	return 0;
+}
+
+
+/**
+ * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer
+ * @mtd:	MTD device structure
+ * @fsbuf:	buffer given by fs driver
+ * @oobsel:	out of band selection structre
+ * @autoplace:	1 = place given buffer into the oob bytes
+ * @numpages:	number of pages to prepare
+ *
+ * Return:
+ * 1. Filesystem buffer available and autoplacement is off,
+ *    return filesystem buffer
+ * 2. No filesystem buffer or autoplace is off, return internal
+ *    buffer
+ * 3. Filesystem buffer is given and autoplace selected
+ *    put data from fs buffer into internal buffer and
+ *    retrun internal buffer
+ *
+ * Note: The internal buffer is filled with 0xff. This must
+ * be done only once, when no autoplacement happens
+ * Autoplacement sets the buffer dirty flag, which
+ * forces the 0xff fill before using the buffer again.
+ *
+*/
+static u_char * nand_prepare_oobbuf (struct mtd_info *mtd, u_char *fsbuf, struct nand_oobinfo *oobsel,
+		int autoplace, int numpages)
+{
+	struct nand_chip *this = mtd->priv;
+	int i, len, ofs;
+
+	/* Zero copy fs supplied buffer */
+	if (fsbuf && !autoplace)
+		return fsbuf;
+
+	/* Check, if the buffer must be filled with ff again */
+	if (this->oobdirty) {
+		memset (this->oob_buf, 0xff,
+			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
+		this->oobdirty = 0;
+	}
+
+	/* If we have no autoplacement or no fs buffer use the internal one */
+	if (!autoplace || !fsbuf)
+		return this->oob_buf;
+
+	/* Walk through the pages and place the data */
+	this->oobdirty = 1;
+	ofs = 0;
+	while (numpages--) {
+		for (i = 0, len = 0; len < mtd->oobavail; i++) {
+			int to = ofs + oobsel->oobfree[i][0];
+			int num = oobsel->oobfree[i][1];
+			memcpy (&this->oob_buf[to], fsbuf, num);
+			len += num;
+			fsbuf += num;
+		}
+		ofs += mtd->oobavail;
+	}
+	return this->oob_buf;
+}
+
+#define NOTALIGNED(x) (x & (mtd->oobblock-1)) != 0
+
+/**
+ * nand_write - [MTD Interface] compability function for nand_write_ecc
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @len:	number of bytes to write
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @buf:	the data to write
+ *
+ * This function simply calls nand_write_ecc with oob buffer and oobsel = NULL
+ *
+*/
+static int nand_write (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
+}
+
+/**
+ * nand_write_ecc - [MTD Interface] NAND write with ECC
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @len:	number of bytes to write
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @buf:	the data to write
+ * @eccbuf:	filesystem supplied oob data buffer
+ * @oobsel:	oob selection structure
+ *
+ * NAND write with ECC
+ */
+static int nand_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			   size_t * retlen, const u_char * buf, u_char * eccbuf, struct nand_oobinfo *oobsel)
+{
+	int startpage, page, ret = -EIO, oob = 0, written = 0, chipnr;
+	int autoplace = 0, numpages, totalpages;
+	struct nand_chip *this = mtd->priv;
+	u_char *oobbuf, *bufstart;
+	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+
+	/* Initialize retlen, in case of early exit */
+	*retlen = 0;
+
+	/* Do not allow write past end of device */
+	if ((to + len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+	/* reject writes, which are not page aligned */
+	if (NOTALIGNED (to) || NOTALIGNED(len)) {
+		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_WRITING);
+
+	/* Calculate chipnr */
+	chipnr = (int)(to >> this->chip_shift);
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd))
+		goto out;
+
+	/* if oobsel is NULL, use chip defaults */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+
+	/* Autoplace of oob data ? Use the default placement scheme */
+	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
+		oobsel = this->autooob;
+		autoplace = 1;
+	}
+	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		autoplace = 1;
+
+	/* Setup variables and oob buffer */
+	totalpages = len >> this->page_shift;
+	page = (int) (to >> this->page_shift);
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
+		this->pagebuf = -1;
+
+	/* Set it relative to chip */
+	page &= this->pagemask;
+	startpage = page;
+	/* Calc number of pages we can write in one go */
+	numpages = min (ppblock - (startpage  & (ppblock - 1)), totalpages);
+	oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, autoplace, numpages);
+	bufstart = (u_char *)buf;
+
+	/* Loop until all data is written */
+	while (written < len) {
+
+		this->data_poi = (u_char*) &buf[written];
+		/* Write one page. If this is the last page to write
+		 * or the last page in this block, then use the
+		 * real pageprogram command, else select cached programming
+		 * if supported by the chip.
+		 */
+		ret = nand_write_page (mtd, this, page, &oobbuf[oob], oobsel, (--numpages > 0));
+		if (ret) {
+			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
+			goto out;
+		}
+		/* Next oob page */
+		oob += mtd->oobsize;
+		/* Update written bytes count */
+		written += mtd->oobblock;
+		if (written == len)
+			goto cmp;
+
+		/* Increment page address */
+		page++;
+
+		/* Have we hit a block boundary ? Then we have to verify and
+		 * if verify is ok, we have to setup the oob buffer for
+		 * the next pages.
+		*/
+		if (!(page & (ppblock - 1))){
+			int ofs;
+			this->data_poi = bufstart;
+			ret = nand_verify_pages (mtd, this, startpage,
+				page - startpage,
+				oobbuf, oobsel, chipnr, (eccbuf != NULL));
+			if (ret) {
+				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
+				goto out;
+			}
+			*retlen = written;
+
+			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
+			if (eccbuf)
+				eccbuf += (page - startpage) * ofs;
+			totalpages -= page - startpage;
+			numpages = min (totalpages, ppblock);
+			page &= this->pagemask;
+			startpage = page;
+			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
+					autoplace, numpages);
+			oob = 0;
+			/* Check, if we cross a chip boundary */
+			if (!page) {
+				chipnr++;
+				this->select_chip(mtd, -1);
+				this->select_chip(mtd, chipnr);
+			}
+		}
+	}
+	/* Verify the remaining pages */
+cmp:
+	this->data_poi = bufstart;
+ 	ret = nand_verify_pages (mtd, this, startpage, totalpages,
+		oobbuf, oobsel, chipnr, (eccbuf != NULL));
+	if (!ret)
+		*retlen = written;
+	else
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
+
+out:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+
+/**
+ * nand_write_oob - [MTD Interface] NAND write out-of-band
+ * @mtd:	MTD device structure
+ * @to:		offset to write to
+ * @len:	number of bytes to write
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @buf:	the data to write
+ *
+ * NAND write out-of-band
+ */
+static int nand_write_oob (struct mtd_info *mtd, loff_t to, size_t len, size_t * retlen, const u_char * buf)
+{
+	int column, page, status, ret = -EIO, chipnr;
+	struct nand_chip *this = mtd->priv;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+
+	/* Shift to get page */
+	page = (int) (to >> this->page_shift);
+	chipnr = (int) (to >> this->chip_shift);
+
+	/* Mask to get column */
+	column = to & (mtd->oobsize - 1);
+
+	/* Initialize return length value */
+	*retlen = 0;
+
+	/* Do not allow write past end of page */
+	if ((column + len) > mtd->oobsize) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_WRITING);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Reset the chip. Some chips (like the Toshiba TC5832DC found
+	   in one of my DiskOnChip 2000 test units) will clear the whole
+	   data page too if we don't do this. I have no clue why, but
+	   I seem to have 'fixed' it in the doc2000 driver in
+	   August 1999.  dwmw2. */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd))
+		goto out;
+
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page == this->pagebuf)
+		this->pagebuf = -1;
+
+	if (NAND_MUST_PAD(this)) {
+		/* Write out desired data */
+		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock, page & this->pagemask);
+		/* prepad 0xff for partial programming */
+		this->write_buf(mtd, ffchars, column);
+		/* write data */
+		this->write_buf(mtd, buf, len);
+		/* postpad 0xff for partial programming */
+		this->write_buf(mtd, ffchars, mtd->oobsize - (len+column));
+	} else {
+		/* Write out desired data */
+		this->cmdfunc (mtd, NAND_CMD_SEQIN, mtd->oobblock + column, page & this->pagemask);
+		/* write data */
+		this->write_buf(mtd, buf, len);
+	}
+	/* Send command to program the OOB data */
+	this->cmdfunc (mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = this->waitfunc (mtd, this, FL_WRITING);
+
+	/* See if device thinks it succeeded */
+	if (status & NAND_STATUS_FAIL) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
+		ret = -EIO;
+		goto out;
+	}
+	/* Return happy */
+	*retlen = len;
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	this->cmdfunc (mtd, NAND_CMD_READOOB, column, page & this->pagemask);
+
+	if (this->verify_buf(mtd, buf, len)) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write verify, page 0x%08x\n", page);
+		ret = -EIO;
+		goto out;
+	}
+#endif
+	ret = 0;
+out:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+
+/**
+ * nand_writev - [MTD Interface] compabilty function for nand_writev_ecc
+ * @mtd:	MTD device structure
+ * @vecs:	the iovectors to write
+ * @count:	number of vectors
+ * @to:		offset to write to
+ * @retlen:	pointer to variable to store the number of written bytes
+ *
+ * NAND write with kvec. This just calls the ecc function
+ */
+static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+		loff_t to, size_t * retlen)
+{
+	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));
+}
+
+/**
+ * nand_writev_ecc - [MTD Interface] write with iovec with ecc
+ * @mtd:	MTD device structure
+ * @vecs:	the iovectors to write
+ * @count:	number of vectors
+ * @to:		offset to write to
+ * @retlen:	pointer to variable to store the number of written bytes
+ * @eccbuf:	filesystem supplied oob data buffer
+ * @oobsel:	oob selection structure
+ *
+ * NAND write with iovec with ecc
+ */
+static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+		loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel)
+{
+	int i, page, len, total_len, ret = -EIO, written = 0, chipnr;
+	int oob, numpages, autoplace = 0, startpage;
+	struct nand_chip *this = mtd->priv;
+	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
+	u_char *oobbuf, *bufstart;
+
+	/* Preset written len for early exit */
+	*retlen = 0;
+
+	/* Calculate total length of data */
+	total_len = 0;
+	for (i = 0; i < count; i++)
+		total_len += (int) vecs[i].iov_len;
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+	       "nand_writev: to = 0x%08x, len = %i, count = %ld\n", (unsigned int) to, (unsigned int) total_len, count);
+
+	/* Do not allow write past end of page */
+	if ((to + total_len) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_writev: Attempted write past end of device\n");
+		return -EINVAL;
+	}
+
+	/* reject writes, which are not page aligned */
+	if (NOTALIGNED (to) || NOTALIGNED(total_len)) {
+		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_WRITING);
+
+	/* Get the current chip-nr */
+	chipnr = (int) (to >> this->chip_shift);
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd))
+		goto out;
+
+	/* if oobsel is NULL, use chip defaults */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+
+	/* Autoplace of oob data ? Use the default placement scheme */
+	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
+		oobsel = this->autooob;
+		autoplace = 1;
+	}
+	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		autoplace = 1;
+
+	/* Setup start page */
+	page = (int) (to >> this->page_shift);
+	/* Invalidate the page cache, if we write to the cached page */
+	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))
+		this->pagebuf = -1;
+
+	startpage = page & this->pagemask;
+
+	/* Loop until all kvec' data has been written */
+	len = 0;
+	while (count) {
+		/* If the given tuple is >= pagesize then
+		 * write it out from the iov
+		 */
+		if ((vecs->iov_len - len) >= mtd->oobblock) {
+			/* Calc number of pages we can write
+			 * out of this iov in one go */
+			numpages = (vecs->iov_len - len) >> this->page_shift;
+			/* Do not cross block boundaries */
+			numpages = min (ppblock - (startpage & (ppblock - 1)), numpages);
+			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
+			bufstart = (u_char *)vecs->iov_base;
+			bufstart += len;
+			this->data_poi = bufstart;
+			oob = 0;
+			for (i = 1; i <= numpages; i++) {
+				/* Write one page. If this is the last page to write
+				 * then use the real pageprogram command, else select
+				 * cached programming if supported by the chip.
+				 */
+				ret = nand_write_page (mtd, this, page & this->pagemask,
+					&oobbuf[oob], oobsel, i != numpages);
+				if (ret)
+					goto out;
+				this->data_poi += mtd->oobblock;
+				len += mtd->oobblock;
+				oob += mtd->oobsize;
+				page++;
+			}
+			/* Check, if we have to switch to the next tuple */
+			if (len >= (int) vecs->iov_len) {
+				vecs++;
+				len = 0;
+				count--;
+			}
+		} else {
+			/* We must use the internal buffer, read data out of each
+			 * tuple until we have a full page to write
+			 */
+			int cnt = 0;
+			while (cnt < mtd->oobblock) {
+				if (vecs->iov_base != NULL && vecs->iov_len)
+					this->data_buf[cnt++] = ((u_char *) vecs->iov_base)[len++];
+				/* Check, if we have to switch to the next tuple */
+				if (len >= (int) vecs->iov_len) {
+					vecs++;
+					len = 0;
+					count--;
+				}
+			}
+			this->pagebuf = page;
+			this->data_poi = this->data_buf;
+			bufstart = this->data_poi;
+			numpages = 1;
+			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
+			ret = nand_write_page (mtd, this, page & this->pagemask,
+				oobbuf, oobsel, 0);
+			if (ret)
+				goto out;
+			page++;
+		}
+
+		this->data_poi = bufstart;
+		ret = nand_verify_pages (mtd, this, startpage, numpages, oobbuf, oobsel, chipnr, 0);
+		if (ret)
+			goto out;
+
+		written += mtd->oobblock * numpages;
+		/* All done ? */
+		if (!count)
+			break;
+
+		startpage = page & this->pagemask;
+		/* Check, if we cross a chip boundary */
+		if (!startpage) {
+			chipnr++;
+			this->select_chip(mtd, -1);
+			this->select_chip(mtd, chipnr);
+		}
+	}
+	ret = 0;
+out:
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	*retlen = written;
+	return ret;
+}
+
+/**
+ * single_erease_cmd - [GENERIC] NAND standard block erase command function
+ * @mtd:	MTD device structure
+ * @page:	the page address of the block which will be erased
+ *
+ * Standard erase command for NAND chips
+ */
+static void single_erase_cmd (struct mtd_info *mtd, int page)
+{
+	struct nand_chip *this = mtd->priv;
+	/* Send commands to erase a block */
+	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
+	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
+}
+
+/**
+ * multi_erease_cmd - [GENERIC] AND specific block erase command function
+ * @mtd:	MTD device structure
+ * @page:	the page address of the block which will be erased
+ *
+ * AND multi block erase command function
+ * Erase 4 consecutive blocks
+ */
+static void multi_erase_cmd (struct mtd_info *mtd, int page)
+{
+	struct nand_chip *this = mtd->priv;
+	/* Send commands to erase a block */
+	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
+	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
+	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page++);
+	this->cmdfunc (mtd, NAND_CMD_ERASE1, -1, page);
+	this->cmdfunc (mtd, NAND_CMD_ERASE2, -1, -1);
+}
+
+/**
+ * nand_erase - [MTD Interface] erase block(s)
+ * @mtd:	MTD device structure
+ * @instr:	erase instruction
+ *
+ * Erase one ore more blocks
+ */
+static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
+{
+	return nand_erase_nand (mtd, instr, 0);
+}
+
+#define BBT_PAGE_MASK	0xffffff3f
+/**
+ * nand_erase_intern - [NAND Interface] erase block(s)
+ * @mtd:	MTD device structure
+ * @instr:	erase instruction
+ * @allowbbt:	allow erasing the bbt area
+ *
+ * Erase one ore more blocks
+ */
+int nand_erase_nand (struct mtd_info *mtd, struct erase_info *instr, int allowbbt)
+{
+	int page, len, status, pages_per_block, ret, chipnr;
+	struct nand_chip *this = mtd->priv;
+	int rewrite_bbt[NAND_MAX_CHIPS]={0};	/* flags to indicate the page, if bbt needs to be rewritten. */
+	unsigned int bbt_masked_page;		/* bbt mask to compare to page being erased. */
+						/* It is used to see if the current page is in the same */
+						/*   256 block group and the same bank as the bbt. */
+
+	DEBUG (MTD_DEBUG_LEVEL3,
+	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
+
+	/* Start address must align on block boundary */
+	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Unaligned address\n");
+		return -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (instr->len & ((1 << this->phys_erase_shift) - 1)) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Length not block aligned\n");
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((instr->len + instr->addr) > mtd->size) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Erase past end of device\n");
+		return -EINVAL;
+	}
+
+	instr->fail_addr = 0xffffffff;
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_ERASING);
+
+	/* Shift to get first page */
+	page = (int) (instr->addr >> this->page_shift);
+	chipnr = (int) (instr->addr >> this->chip_shift);
+
+	/* Calculate pages in each block */
+	pages_per_block = 1 << (this->phys_erase_shift - this->page_shift);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, chipnr);
+
+	/* Check the WP bit */
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd)) {
+		DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: Device is write protected!!!\n");
+		instr->state = MTD_ERASE_FAILED;
+		goto erase_exit;
+	}
+
+	/* if BBT requires refresh, set the BBT page mask to see if the BBT should be rewritten */
+	if (this->options & BBT_AUTO_REFRESH) {
+		bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+	} else {
+		bbt_masked_page = 0xffffffff;	/* should not match anything */
+	}
+
+	/* Loop through the pages */
+	len = instr->len;
+
+	instr->state = MTD_ERASING;
+
+	while (len) {
+		/* Check if we have a bad block, we do not erase bad blocks ! */
+		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
+			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
+			instr->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+
+		/* Invalidate the page cache, if we erase the block which contains
+		   the current cached page */
+		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
+			this->pagebuf = -1;
+
+		this->erase_cmd (mtd, page & this->pagemask);
+
+		status = this->waitfunc (mtd, this, FL_ERASING);
+
+		/* See if operation failed and additional status checks are available */
+		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
+			status = this->errstat(mtd, this, FL_ERASING, status, page);
+		}
+
+		/* See if block erase succeeded */
+		if (status & NAND_STATUS_FAIL) {
+			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
+			instr->state = MTD_ERASE_FAILED;
+			instr->fail_addr = (page << this->page_shift);
+			goto erase_exit;
+		}
+
+		/* if BBT requires refresh, set the BBT rewrite flag to the page being erased */
+		if (this->options & BBT_AUTO_REFRESH) {
+			if (((page & BBT_PAGE_MASK) == bbt_masked_page) &&
+			     (page != this->bbt_td->pages[chipnr])) {
+				rewrite_bbt[chipnr] = (page << this->page_shift);
+			}
+		}
+
+		/* Increment page address and decrement length */
+		len -= (1 << this->phys_erase_shift);
+		page += pages_per_block;
+
+		/* Check, if we cross a chip boundary */
+		if (len && !(page & this->pagemask)) {
+			chipnr++;
+			this->select_chip(mtd, -1);
+			this->select_chip(mtd, chipnr);
+
+			/* if BBT requires refresh and BBT-PERCHIP,
+			 *   set the BBT page mask to see if this BBT should be rewritten */
+			if ((this->options & BBT_AUTO_REFRESH) && (this->bbt_td->options & NAND_BBT_PERCHIP)) {
+				bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+			}
+
+		}
+	}
+	instr->state = MTD_ERASE_DONE;
+
+erase_exit:
+
+	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
+	/* Do call back function */
+	if (!ret)
+		mtd_erase_callback(instr);
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	/* if BBT requires refresh and erase was successful, rewrite any selected bad block tables */
+	if ((this->options & BBT_AUTO_REFRESH) && (!ret)) {
+		for (chipnr = 0; chipnr < this->numchips; chipnr++) {
+			if (rewrite_bbt[chipnr]) {
+				/* update the BBT for chip */
+				DEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt (%d:0x%0x 0x%0x)\n",
+					chipnr, rewrite_bbt[chipnr], this->bbt_td->pages[chipnr]);
+				nand_update_bbt (mtd, rewrite_bbt[chipnr]);
+			}
+		}
+	}
+
+	/* Return more or less happy */
+	return ret;
+}
+
+/**
+ * nand_sync - [MTD Interface] sync
+ * @mtd:	MTD device structure
+ *
+ * Sync is actually a wait for chip ready function
+ */
+static void nand_sync (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_sync: called\n");
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device (this, mtd, FL_SYNCING);
+	/* Release it and go back */
+	nand_release_device (mtd);
+}
+
+
+/**
+ * nand_block_isbad - [MTD Interface] Check whether the block at the given offset is bad
+ * @mtd:	MTD device structure
+ * @ofs:	offset relative to mtd start
+ */
+static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
+{
+	/* Check for invalid offset */
+	if (ofs > mtd->size)
+		return -EINVAL;
+
+	return nand_block_checkbad (mtd, ofs, 1, 0);
+}
+
+/**
+ * nand_block_markbad - [MTD Interface] Mark the block at the given offset as bad
+ * @mtd:	MTD device structure
+ * @ofs:	offset relative to mtd start
+ */
+static int nand_block_markbad (struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *this = mtd->priv;
+	int ret;
+
+        if ((ret = nand_block_isbad(mtd, ofs))) {
+        	/* If it was bad already, return success and do nothing. */
+		if (ret > 0)
+			return 0;
+        	return ret;
+        }
+
+	return this->block_markbad(mtd, ofs);
+}
+
+/**
+ * nand_suspend - [MTD Interface] Suspend the NAND flash
+ * @mtd:	MTD device structure
+ */
+static int nand_suspend(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	return nand_get_device (this, mtd, FL_PM_SUSPENDED);
+}
+
+/**
+ * nand_resume - [MTD Interface] Resume the NAND flash
+ * @mtd:	MTD device structure
+ */
+static void nand_resume(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (this->state == FL_PM_SUSPENDED)
+		nand_release_device(mtd);
+	else
+		printk(KERN_ERR "resume() called for the chip which is not "
+				"in suspended state\n");
+
+}
+
+
+/**
+ * nand_scan - [NAND Interface] Scan for the NAND device
+ * @mtd:	MTD device structure
+ * @maxchips:	Number of chips to scan for
+ *
+ * This fills out all the not initialized function pointers
+ * with the defaults.
+ * The flash ID is read and the mtd/chip structures are
+ * filled with the appropriate values. Buffers are allocated if
+ * they are not provided by the board driver
+ *
+ */
+int nand_scan (struct mtd_info *mtd, int maxchips)
+{
+	int i, nand_maf_id, nand_dev_id, busw, maf_id;
+	struct nand_chip *this = mtd->priv;
+
+	/* Get buswidth to select the correct functions*/
+	busw = this->options & NAND_BUSWIDTH_16;
+
+	/* check for proper chip_delay setup, set 20us if not */
+	if (!this->chip_delay)
+		this->chip_delay = 20;
+
+	/* check, if a user supplied command function given */
+	if (this->cmdfunc == NULL)
+		this->cmdfunc = nand_command;
+
+	/* check, if a user supplied wait function given */
+	if (this->waitfunc == NULL)
+		this->waitfunc = nand_wait;
+
+	if (!this->select_chip)
+		this->select_chip = nand_select_chip;
+	if (!this->write_byte)
+		this->write_byte = busw ? nand_write_byte16 : nand_write_byte;
+	if (!this->read_byte)
+		this->read_byte = busw ? nand_read_byte16 : nand_read_byte;
+	if (!this->write_word)
+		this->write_word = nand_write_word;
+	if (!this->read_word)
+		this->read_word = nand_read_word;
+	if (!this->block_bad)
+		this->block_bad = nand_block_bad;
+	if (!this->block_markbad)
+		this->block_markbad = nand_default_block_markbad;
+	if (!this->write_buf)
+		this->write_buf = busw ? nand_write_buf16 : nand_write_buf;
+	if (!this->read_buf)
+		this->read_buf = busw ? nand_read_buf16 : nand_read_buf;
+	if (!this->verify_buf)
+		this->verify_buf = busw ? nand_verify_buf16 : nand_verify_buf;
+	if (!this->scan_bbt)
+		this->scan_bbt = nand_default_bbt;
+
+	/* Select the device */
+	this->select_chip(mtd, 0);
+
+	/* Send the command for reading device ID */
+	this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	nand_maf_id = this->read_byte(mtd);
+	nand_dev_id = this->read_byte(mtd);
+
+	/* Print and store flash device information */
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+
+		if (nand_dev_id != nand_flash_ids[i].id)
+			continue;
+
+		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
+		this->chipsize = nand_flash_ids[i].chipsize << 20;
+
+		/* New devices have all the information in additional id bytes */
+		if (!nand_flash_ids[i].pagesize) {
+			int extid;
+			/* The 3rd id byte contains non relevant data ATM */
+			extid = this->read_byte(mtd);
+			/* The 4th id byte is the important one */
+			extid = this->read_byte(mtd);
+			/* Calc pagesize */
+			mtd->oobblock = 1024 << (extid & 0x3);
+			extid >>= 2;
+			/* Calc oobsize */
+			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock >> 9);
+			extid >>= 2;
+			/* Calc blocksize. Blocksize is multiples of 64KiB */
+			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
+			extid >>= 2;
+			/* Get buswidth information */
+			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+
+		} else {
+			/* Old devices have this data hardcoded in the
+			 * device id table */
+			mtd->erasesize = nand_flash_ids[i].erasesize;
+			mtd->oobblock = nand_flash_ids[i].pagesize;
+			mtd->oobsize = mtd->oobblock / 32;
+			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
+		}
+
+		/* Try to identify manufacturer */
+		for (maf_id = 0; nand_manuf_ids[maf_id].id != 0x0; maf_id++) {
+			if (nand_manuf_ids[maf_id].id == nand_maf_id)
+				break;
+		}
+
+		/* Check, if buswidth is correct. Hardware drivers should set
+		 * this correct ! */
+		if (busw != (this->options & NAND_BUSWIDTH_16)) {
+			printk (KERN_INFO "NAND device: Manufacturer ID:"
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
+				nand_manuf_ids[maf_id].name , mtd->name);
+			printk (KERN_WARNING
+				"NAND bus width %d instead %d bit\n",
+					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
+					busw ? 16 : 8);
+			this->select_chip(mtd, -1);
+			return 1;
+		}
+
+		/* Calculate the address shift from the page size */
+		this->page_shift = ffs(mtd->oobblock) - 1;
+		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
+		this->chip_shift = ffs(this->chipsize) - 1;
+
+		/* Set the bad block position */
+		this->badblockpos = mtd->oobblock > 512 ?
+			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+
+		/* Get chip options, preserve non chip based options */
+		this->options &= ~NAND_CHIPOPTIONS_MSK;
+		this->options |= nand_flash_ids[i].options & NAND_CHIPOPTIONS_MSK;
+		/* Set this as a default. Board drivers can override it, if neccecary */
+		this->options |= NAND_NO_AUTOINCR;
+		/* Check if this is a not a samsung device. Do not clear the options
+		 * for chips which are not having an extended id.
+		 */
+		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
+			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+
+		/* Check for AND chips with 4 page planes */
+		if (this->options & NAND_4PAGE_ARRAY)
+			this->erase_cmd = multi_erase_cmd;
+		else
+			this->erase_cmd = single_erase_cmd;
+
+		/* Do not replace user supplied command function ! */
+		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
+			this->cmdfunc = nand_command_lp;
+
+		printk (KERN_INFO "NAND device: Manufacturer ID:"
+			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
+			nand_manuf_ids[maf_id].name , nand_flash_ids[i].name);
+		break;
+	}
+
+	if (!nand_flash_ids[i].name) {
+		printk (KERN_WARNING "No NAND device found!!!\n");
+		this->select_chip(mtd, -1);
+		return 1;
+	}
+
+	for (i=1; i < maxchips; i++) {
+		this->select_chip(mtd, i);
+
+		/* Send the command for reading device ID */
+		this->cmdfunc (mtd, NAND_CMD_READID, 0x00, -1);
+
+		/* Read manufacturer and device IDs */
+		if (nand_maf_id != this->read_byte(mtd) ||
+		    nand_dev_id != this->read_byte(mtd))
+			break;
+	}
+	if (i > 1)
+		printk(KERN_INFO "%d NAND chips detected\n", i);
+
+	/* Allocate buffers, if neccecary */
+	if (!this->oob_buf) {
+		size_t len;
+		len = mtd->oobsize << (this->phys_erase_shift - this->page_shift);
+		this->oob_buf = kmalloc (len, GFP_KERNEL);
+		if (!this->oob_buf) {
+			printk (KERN_ERR "nand_scan(): Cannot allocate oob_buf\n");
+			return -ENOMEM;
+		}
+		this->options |= NAND_OOBBUF_ALLOC;
+	}
+
+	if (!this->data_buf) {
+		size_t len;
+		len = mtd->oobblock + mtd->oobsize;
+		this->data_buf = kmalloc (len, GFP_KERNEL);
+		if (!this->data_buf) {
+			if (this->options & NAND_OOBBUF_ALLOC)
+				kfree (this->oob_buf);
+			printk (KERN_ERR "nand_scan(): Cannot allocate data_buf\n");
+			return -ENOMEM;
+		}
+		this->options |= NAND_DATABUF_ALLOC;
+	}
+
+	/* Store the number of chips and calc total size for mtd */
+	this->numchips = i;
+	mtd->size = i * this->chipsize;
+	/* Convert chipsize to number of pages per chip -1. */
+	this->pagemask = (this->chipsize >> this->page_shift) - 1;
+	/* Preset the internal oob buffer */
+	memset(this->oob_buf, 0xff, mtd->oobsize << (this->phys_erase_shift - this->page_shift));
+
+	/* If no default placement scheme is given, select an
+	 * appropriate one */
+	if (!this->autooob) {
+		/* Select the appropriate default oob placement scheme for
+		 * placement agnostic filesystems */
+		switch (mtd->oobsize) {
+		case 8:
+			this->autooob = &nand_oob_8;
+			break;
+		case 16:
+			this->autooob = &nand_oob_16;
+			break;
+		case 64:
+			this->autooob = &nand_oob_64;
+			break;
+		default:
+			printk (KERN_WARNING "No oob scheme defined for oobsize %d\n",
+				mtd->oobsize);
+			BUG();
+		}
+	}
+
+	/* The number of bytes available for the filesystem to place fs dependend
+	 * oob data */
+	mtd->oobavail = 0;
+	for (i = 0; this->autooob->oobfree[i][1]; i++)
+		mtd->oobavail += this->autooob->oobfree[i][1];
+
+	/*
+	 * check ECC mode, default to software
+	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
+	 * fallback to software ECC
+	*/
+	this->eccsize = 256;	/* set default eccsize */
+	this->eccbytes = 3;
+
+	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		if (mtd->oobblock < 2048) {
+			printk(KERN_WARNING "2048 byte HW ECC not possible on %d byte page size, fallback to SW ECC\n",
+			       mtd->oobblock);
+			this->eccmode = NAND_ECC_SOFT;
+			this->calculate_ecc = nand_calculate_ecc;
+			this->correct_data = nand_correct_data;
+		} else
+			this->eccsize = 2048;
+		break;
+
+	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW6_512:
+	case NAND_ECC_HW8_512:
+		if (mtd->oobblock == 256) {
+			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
+			this->eccmode = NAND_ECC_SOFT;
+			this->calculate_ecc = nand_calculate_ecc;
+			this->correct_data = nand_correct_data;
+		} else
+			this->eccsize = 512; /* set eccsize to 512 */
+		break;
+
+	case NAND_ECC_HW3_256:
+		break;
+
+	case NAND_ECC_NONE:
+		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
+		this->eccmode = NAND_ECC_NONE;
+		break;
+
+	case NAND_ECC_SOFT:
+		this->calculate_ecc = nand_calculate_ecc;
+		this->correct_data = nand_correct_data;
+		break;
+
+	default:
+		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
+		BUG();
+	}
+
+	/* Check hardware ecc function availability and adjust number of ecc bytes per
+	 * calculation step
+	*/
+	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		this->eccbytes += 4;
+	case NAND_ECC_HW8_512:
+		this->eccbytes += 2;
+	case NAND_ECC_HW6_512:
+		this->eccbytes += 3;
+	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW3_256:
+		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
+			break;
+		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
+		BUG();
+	}
+
+	mtd->eccsize = this->eccsize;
+
+	/* Set the number of read / write steps for one page to ensure ECC generation */
+	switch (this->eccmode) {
+	case NAND_ECC_HW12_2048:
+		this->eccsteps = mtd->oobblock / 2048;
+		break;
+	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW6_512:
+	case NAND_ECC_HW8_512:
+		this->eccsteps = mtd->oobblock / 512;
+		break;
+	case NAND_ECC_HW3_256:
+	case NAND_ECC_SOFT:
+		this->eccsteps = mtd->oobblock / 256;
+		break;
+
+	case NAND_ECC_NONE:
+		this->eccsteps = 1;
+		break;
+	}
+
+	/* Initialize state, waitqueue and spinlock */
+	this->state = FL_READY;
+	init_waitqueue_head (&this->wq);
+	spin_lock_init (&this->chip_lock);
+
+	/* De-select the device */
+	this->select_chip(mtd, -1);
+
+	/* Invalidate the pagebuffer reference */
+	this->pagebuf = -1;
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH | MTD_ECC;
+	mtd->ecctype = MTD_ECC_SW;
+	mtd->erase = nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = nand_read;
+	mtd->write = nand_write;
+	mtd->read_ecc = nand_read_ecc;
+	mtd->write_ecc = nand_write_ecc;
+	mtd->read_oob = nand_read_oob;
+	mtd->write_oob = nand_write_oob;
+	mtd->readv = NULL;
+	mtd->writev = nand_writev;
+	mtd->writev_ecc = nand_writev_ecc;
+	mtd->sync = nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = nand_suspend;
+	mtd->resume = nand_resume;
+	mtd->block_isbad = nand_block_isbad;
+	mtd->block_markbad = nand_block_markbad;
+
+	/* and make the autooob the default one */
+	memcpy(&mtd->oobinfo, this->autooob, sizeof(mtd->oobinfo));
+
+	mtd->owner = THIS_MODULE;
+
+	/* Check, if we should skip the bad block table scan */
+	if (this->options & NAND_SKIP_BBTSCAN)
+		return 0;
+
+	/* Build bad block table */
+	return this->scan_bbt (mtd);
+}
+
+/**
+ * nand_release - [NAND Interface] Free resources held by the NAND device
+ * @mtd:	MTD device structure
+*/
+void nand_release (struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	/* Deregister partitions */
+	del_mtd_partitions (mtd);
+#endif
+	/* Deregister the device */
+	del_mtd_device (mtd);
+
+	/* Free bad block table memory */
+	kfree (this->bbt);
+	/* Buffer allocated by nand_scan ? */
+	if (this->options & NAND_OOBBUF_ALLOC)
+		kfree (this->oob_buf);
+	/* Buffer allocated by nand_scan ? */
+	if (this->options & NAND_DATABUF_ALLOC)
+		kfree (this->data_buf);
+}
+
+EXPORT_SYMBOL_GPL (nand_scan);
+EXPORT_SYMBOL_GPL (nand_release);
+
+MODULE_LICENSE ("GPL");
+MODULE_AUTHOR ("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
+MODULE_DESCRIPTION ("Generic NAND flash driver code");
Index: linux/drivers/mtd/nand/adm5120.c
===================================================================
--- linux/drivers/mtd/nand/adm5120.c	(.../linux)	(revision 0)
+++ linux/drivers/mtd/nand/adm5120.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,219 @@
+/*
+ *  drivers/mtd/nand/adm5120.c
+ *
+ *  Copyright (C) 2000 Polyakov Artyom (art@granch.ru)
+ *
+ *  Derived from drivers/mtd/spia.c
+ *       Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com) *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   SPIA board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 64Mibit (8MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/delay.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include "adm5120.h"
+
+#define DEBUG_ADM5120
+#define DEBUG_ADM5120_LEVEL 0
+#include <asm/am5120/debug.h>
+
+/*
+ * MTD structure for SPIA board
+ */
+
+static struct mtd_info *adm5120_mtd = NULL;
+/*
+ * Values specific to the ADM5120 board
+ */
+static int adm5120_fio_pbase = NAND_REG_PBASE;
+static int adm5120_fio_base;
+
+/*
+ * Define partitions for flash device
+ */
+#define FLASH_SIZE      0x02000000
+#define FLASH_PART_BOOT_ADDR    0x00000000
+#define FLASH_PART_BOOT_SIZE    0x00020000
+#define FLASH_PART_KERNEL_ADDR  0x00020000
+#define FLASH_PART_KERNEL_SIZE  0x00200000
+#define FLASH_PART_ROOT_ADDR    (FLASH_PART_KERNEL_ADDR + FLASH_PART_KERNEL_SIZE)
+#define FLASH_PART_ROOT_SIZE    FLASH_SIZE-FLASH_PART_ROOT_ADDR
+															
+#define NUM_PARTITIONS 3
+static struct mtd_partition partition_info32M[] = {
+    {	.name         = "Boot Partition",
+        .offset       = FLASH_PART_BOOT_ADDR,
+	.size         = FLASH_PART_BOOT_SIZE	},
+    {	.name         = "Kernel partition",
+	.offset       = FLASH_PART_KERNEL_ADDR,
+	.size         = FLASH_PART_KERNEL_SIZE    },
+    {	.name	      = "Root partition",
+	.offset       =  FLASH_PART_ROOT_ADDR,
+	.size         =  FLASH_PART_ROOT_SIZE
+	    },
+
+};
+					
+
+/* 
+ *	hardware specific access to control-lines
+ */
+static void adm5120_hwcontrol(struct mtd_info *mtd, int cmd){
+
+    switch (cmd){
+    case NAND_CTL_SETCLE:
+        writeb(0x01,(unsigned char *)adm5120_fio_base + NAND_SET_CLE);
+        break;
+    case NAND_CTL_CLRCLE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_CLR_CLE);
+        break;
+    case NAND_CTL_SETALE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_SET_ALE);
+        break;
+    case NAND_CTL_CLRALE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_CLR_ALE);
+        break;
+    case NAND_CTL_SETNCE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_SET_CEn);
+        break;
+    case NAND_CTL_CLRNCE:
+        writeb( 0x01, (unsigned char *)adm5120_fio_base + NAND_CLR_CEn);
+    default:
+        break;
+    }
+}
+
+
+int adm5120_device_ready(struct mtd_info *mtd)
+{
+	udelay(20);
+	return 1;
+}
+    
+
+/*
+ * Main initialization routine
+ */
+int __init adm5120_init (void)
+{
+	struct nand_chip *this;
+	int err;
+
+	/* Allocate memory for MTD device structure and private data */
+	adm5120_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+
+        if (!adm5120_mtd) {
+                printk ("adm5120: Unable to allocate NAND MTD device structure.\n");
+                err = -ENOMEM;
+                goto out;
+        }
+        PDEBUG(1,"Memory for MTD device structure and private data allocated");
+															
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&adm5120_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) adm5120_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	adm5120_mtd->priv = this;
+
+	/*
+	 * Set GPIO Port E control register so that the pins are configured
+	 * to be outputs for controlling the NAND flash.
+	 */
+        adm5120_fio_base=(unsigned long)ioremap(adm5120_fio_pbase,1024);
+	if(!adm5120_fio_base){
+	    printk("adm5120: Ioremap failed\n");
+	    err=-ENXIO;	     
+
+	}
+	PDEBUG(1,"IO Remap successfull");
+											 
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = (void __iomem *)adm5120_fio_base;
+        this->IO_ADDR_W = (void __iomem *)adm5120_fio_base;
+	/* Set address of hardware control function */       
+        this->hwcontrol = adm5120_hwcontrol;
+	this->dev_ready = adm5120_device_ready;
+       /* 20 us command delay time */
+       this->chip_delay = 20;
+       this->eccmode = NAND_ECC_SOFT;
+							       
+	/* Scan to find existence of the device */
+	if (nand_scan (adm5120_mtd, 1)) {
+		err=-ENXIO;
+                goto out_mtd;		
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(adm5120_mtd, partition_info32M, NUM_PARTITIONS);
+
+
+/*--------------- DEBUG
+	size_t retlen;	
+	u_char buf[20];
+	int i,j;
+	
+	mdelay(1000);
+	printk("oob listing:\n");
+	mdelay(1000);
+	mdelay(1000);	
+	mdelay(1000);
+	mdelay(1000);	
+	mdelay(1000);	
+	for(i=0x0000; i<=0x20000; i+=0x4000){
+	    adm5120_mtd->read_oob (adm5120_mtd,i,16,&retlen,buf);
+	    printk("%08x (%d): ",i,retlen);
+	    for(j=0;j<16;j++)
+		printk("%02x ",buf[j] & 0xff);
+	    mdelay(100);
+	    printk("\n");	    
+	}
+
+//--------------- END DEBUG */
+	/* Return happy */
+	return 0;
+out_mtd:
+        kfree (adm5120_mtd);
+out:
+        return err;
+		
+}
+module_init(adm5120_init);
+
+/*
+ * Clean up routine
+
+#ifdef MODULE
+static void __exit spia_cleanup (void)
+{
+	// Release resources, unregister device 
+	nand_release (spia_mtd);
+
+	// Free the MTD device structure 
+	kfree (spia_mtd);
+}
+module_exit(spia_cleanup);
+#endif
+*/
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Artyom U. Plyakov <art@sigrand.ru");
+MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on ADM5120 board");
Index: linux/drivers/mtd/nand/nand_base.c
===================================================================
--- linux/drivers/mtd/nand/nand_base.c	(.../linux)	(revision 5)
+++ linux/drivers/mtd/nand/nand_base.c	(.../linux-kernel/linux)	(revision 28)
@@ -5,14 +5,14 @@
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
  *   Basic support for AG-AND chips is provided.
- *
+ *   
  *	Additional technical information is available on
  *	http://www.linux-mtd.infradead.org/tech/nand.html
- *
+ *	
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
  *
- *  02-08-2004  tglx: support for strange chips, which cannot auto increment
+ *  02-08-2004  tglx: support for strange chips, which cannot auto increment 
  *		pages on read / read_oob
  *
  *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes
@@ -21,36 +21,16 @@
  *		Make reads over block boundaries work too
  *
  *  04-14-2004	tglx: first working version for 2k page size chips
- *
+ *  
  *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
  *
  *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
  *		among multiple independend devices. Suggestions and initial patch
  *		from Ben Dooks <ben-mtd@fluff.org>
  *
- *  12-05-2004	dmarlin: add workaround for Renesas AG-AND chips "disturb" issue.
- *		Basically, any block not rewritten may lose data when surrounding blocks
- *		are rewritten many times.  JFFS2 ensures this doesn't happen for blocks
- *		it uses, but the Bad Block Table(s) may not be rewritten.  To ensure they
- *		do not lose data, force them to be rewritten when some of the surrounding
- *		blocks are erased.  Rather than tracking a specific nearby block (which
- *		could itself go bad), use a page address 'mask' to select several blocks
- *		in the same area, and rewrite the BBT when any of them are erased.
- *
- *  01-03-2005	dmarlin: added support for the device recovery command sequence for Renesas
- *		AG-AND chips.  If there was a sudden loss of power during an erase operation,
- * 		a "device recovery" operation must be performed when power is restored
- * 		to ensure correct operation.
- *
- *  01-20-2005	dmarlin: added support for optional hardware specific callback routine to
- *		perform extra error status checks on erase and write failures.  This required
- *		adding a wrapper function for nand_read_ecc.
- *
- * 08-20-2005	vwool: suspend/resume added
- *
  * Credits:
- *	David Woodhouse for adding multichip support
- *
+ *	David Woodhouse for adding multichip support  
+ *	
  *	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
  *	rework for 2K page size chips
  *
@@ -61,7 +41,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.150 2005/09/15 13:58:48 vwool Exp $
+ * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -105,8 +85,8 @@
 	.useecc = MTD_NANDECC_AUTOPLACE,
 	.eccbytes = 24,
 	.eccpos = {
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
+		40, 41, 42, 43, 44, 45, 46, 47, 
+		48, 49, 50, 51, 52, 53, 54, 55, 
 		56, 57, 58, 59, 60, 61, 62, 63},
 	.oobfree = { {2, 38} }
 };
@@ -149,19 +129,19 @@
 static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
 		struct nand_oobinfo *oobsel, int mode);
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode);
 #else
 #define nand_verify_pages(...) (0)
 #endif
+		
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
 
-static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
-
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
- *
- * Deselect, release chip lock and wake up anyone waiting on the device
+ * 
+ * Deselect, release chip lock and wake up anyone waiting on the device 
  */
 static void nand_release_device (struct mtd_info *mtd)
 {
@@ -169,21 +149,17 @@
 
 	/* De-select the NAND device */
 	this->select_chip(mtd, -1);
-
+	/* Do we have a hardware controller ? */
 	if (this->controller) {
-		/* Release the controller and the chip */
 		spin_lock(&this->controller->lock);
 		this->controller->active = NULL;
-		this->state = FL_READY;
-		wake_up(&this->controller->wq);
 		spin_unlock(&this->controller->lock);
-	} else {
-		/* Release the chip */
-		spin_lock(&this->chip_lock);
-		this->state = FL_READY;
-		wake_up(&this->wq);
-		spin_unlock(&this->chip_lock);
 	}
+	/* Release the chip */
+	spin_lock (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock (&this->chip_lock);
 }
 
 /**
@@ -215,7 +191,7 @@
  * nand_read_byte16 - [DEFAULT] read one byte endianess aware from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith with
+ * Default read function for 16bit buswith with 
  * endianess conversion
  */
 static u_char nand_read_byte16(struct mtd_info *mtd)
@@ -242,7 +218,7 @@
  * nand_read_word - [DEFAULT] read one word from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith without
+ * Default read function for 16bit buswith without 
  * endianess conversion
  */
 static u16 nand_read_word(struct mtd_info *mtd)
@@ -256,7 +232,7 @@
  * @mtd:	MTD device structure
  * @word:	data word to write
  *
- * Default write function for 16bit buswith without
+ * Default write function for 16bit buswith without 
  * endianess conversion
  */
 static void nand_write_word(struct mtd_info *mtd, u16 word)
@@ -277,7 +253,7 @@
 	struct nand_chip *this = mtd->priv;
 	switch(chip) {
 	case -1:
-		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
+		this->hwcontrol(mtd, NAND_CTL_CLRNCE);	
 		break;
 	case 0:
 		this->hwcontrol(mtd, NAND_CTL_SETNCE);
@@ -300,13 +276,15 @@
 {
 	int i;
 	struct nand_chip *this = mtd->priv;
+	
+					
 
 	for (i=0; i<len; i++)
 		writeb(buf[i], this->IO_ADDR_W);
 }
 
 /**
- * nand_read_buf - [DEFAULT] read chip data into buffer
+ * nand_read_buf - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -317,13 +295,12 @@
 {
 	int i;
 	struct nand_chip *this = mtd->priv;
-
 	for (i=0; i<len; i++)
 		buf[i] = readb(this->IO_ADDR_R);
 }
 
 /**
- * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -356,14 +333,14 @@
 	struct nand_chip *this = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
-
+	
 	for (i=0; i<len; i++)
 		writew(p[i], this->IO_ADDR_W);
-
+		
 }
 
 /**
- * nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * nand_read_buf16 - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -382,7 +359,7 @@
 }
 
 /**
- * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -409,7 +386,7 @@
  * @ofs:	offset from device start
  * @getchip:	0, if the chip is already selected
  *
- * Check, if the block is bad.
+ * Check, if the block is bad. 
  */
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
@@ -426,27 +403,37 @@
 
 		/* Select the NAND device */
 		this->select_chip(mtd, chipnr);
-	} else
-		page = (int) ofs;
+	} else 
+		page = (int) ofs;	
 
 	if (this->options & NAND_BUSWIDTH_16) {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
 		bad = cpu_to_le16(this->read_word(mtd));
 		if (this->badblockpos & 0x1)
-			bad >>= 8;
+			bad >>= 1;
 		if ((bad & 0xFF) != 0xff)
 			res = 1;
 	} else {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
-		if (this->read_byte(mtd) != 0xff)
-			res = 1;
+		
+		u8 tmp=this->read_byte(mtd);
+		if ( tmp!= 0xff){
+		    printk("NAND_BAD_BLOCK (%08x): oob= %02x",page,tmp);
+		    int i;
+		    for(i=0;i<15;i++){
+			udelay(20);
+			printk(" %02x",this->read_byte(mtd));
+		    }
+		    printk("\n");
+		    res = 1;
+		}
 	}
-
+		
 	if (getchip) {
 		/* Deselect and wake up anyone waiting on the device */
 		nand_release_device(mtd);
-	}
-
+	}	
+	
 	return res;
 }
 
@@ -464,34 +451,33 @@
 	u_char buf[2] = {0, 0};
 	size_t	retlen;
 	int block;
-
+	
 	/* Get block number */
 	block = ((int) ofs) >> this->bbt_erase_shift;
-	if (this->bbt)
-		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
 
 	/* Do we have a flash based bad block table ? */
 	if (this->options & NAND_USE_FLASH_BBT)
 		return nand_update_bbt (mtd, ofs);
-
+		
 	/* We write two bytes, so we dont have to mess with 16 bit access */
 	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
 	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
 }
 
-/**
+/** 
  * nand_check_wp - [GENERIC] check if the chip is write protected
  * @mtd:	MTD device structure
- * Check, if the device is write protected
+ * Check, if the device is write protected 
  *
- * The function expects, that the device is already selected
+ * The function expects, that the device is already selected 
  */
 static int nand_check_wp (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 	/* Check the WP bit */
 	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
-	return (this->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+	return (this->read_byte(mtd) & 0x80) ? 0 : 1; 
 }
 
 /**
@@ -507,31 +493,14 @@
 static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
 {
 	struct nand_chip *this = mtd->priv;
-
+	
 	if (!this->bbt)
 		return this->block_bad(mtd, ofs, getchip);
-
+	
 	/* Return info from the table */
 	return nand_isbad_bbt (mtd, ofs, allowbbt);
 }
 
-/*
- * Wait for the ready pin, after a command
- * The timeout is catched later.
- */
-static void nand_wait_ready(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-	unsigned long	timeo = jiffies + 2;
-
-	/* wait until command is processed or timeout occures */
-	do {
-		if (this->dev_ready(mtd))
-			return;
-		touch_softlockup_watchdog();
-	} while (time_before(jiffies, timeo));
-}
-
 /**
  * nand_command - [DEFAULT] Send command to NAND device
  * @mtd:	MTD device structure
@@ -592,13 +561,13 @@
 		/* Latch in address */
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
+	
+	/* 
+	 * program and erase have their own busy handlers 
 	 * status and sequential in needs no delay
 	*/
 	switch (command) {
-
+			
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
@@ -607,35 +576,37 @@
 		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		while ( !(this->read_byte(mtd) & 0x40));
 		return;
 
-	/* This applies to read commands */
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
+	
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-
-	nand_wait_ready(mtd);
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd));
 }
 
 /**
- * nand_command_lp - [DEFAULT] Send command to NAND large page device
+ * 
+ nand_command_lp - [DEFAULT] Send command to NAND large page device
  * @mtd:	MTD device structure
  * @command:	the command to be sent
  * @column:	the column address for this command, -1 if none
@@ -655,12 +626,12 @@
 		column += mtd->oobblock;
 		command = NAND_CMD_READ0;
 	}
-
-
+	
+		
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/* Write out the command to the device. */
-	this->write_byte(mtd, (command & 0xff));
+	this->write_byte(mtd, command);
 	/* End command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 
@@ -674,7 +645,7 @@
 				column >>= 1;
 			this->write_byte(mtd, column & 0xff);
 			this->write_byte(mtd, column >> 8);
-		}
+		}	
 		if (page_addr != -1) {
 			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
 			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
@@ -683,43 +654,33 @@
 				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0xff));
 		}
 		/* Latch in address */
+		
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
-	 * status, sequential in, and deplete1 need no delay
-	 */
+	
+	/* 
+	 * program and erase have their own busy handlers 
+	 * status and sequential in needs no delay
+	*/
 	switch (command) {
-
+			
 	case NAND_CMD_CACHEDPROG:
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
 	case NAND_CMD_SEQIN:
 	case NAND_CMD_STATUS:
-	case NAND_CMD_DEPLETE1:
 		return;
 
-	/*
-	 * read error status commands require only a short delay
-	 */
-	case NAND_CMD_STATUS_ERROR:
-	case NAND_CMD_STATUS_ERROR0:
-	case NAND_CMD_STATUS_ERROR1:
-	case NAND_CMD_STATUS_ERROR2:
-	case NAND_CMD_STATUS_ERROR3:
-		udelay(this->chip_delay);
-		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		while ( !(this->read_byte(mtd) & 0x40));
 		return;
 
 	case NAND_CMD_READ0:
@@ -730,68 +691,67 @@
 		/* End command latch cycle */
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 		/* Fall through into ready check */
-
-	/* This applies to read commands */
+		
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
-
+	
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-
-	nand_wait_ready(mtd);
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd));
 }
 
 /**
  * nand_get_device - [GENERIC] Get chip for selected access
  * @this:	the nand chip descriptor
  * @mtd:	MTD device structure
- * @new_state:	the state which is requested
+ * @new_state:	the state which is requested 
  *
  * Get the device and lock it for exclusive access
  */
-static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
 {
-	struct nand_chip *active;
-	spinlock_t *lock;
-	wait_queue_head_t *wq;
+	struct nand_chip *active = this;
+
 	DECLARE_WAITQUEUE (wait, current);
 
-	lock = (this->controller) ? &this->controller->lock : &this->chip_lock;
-	wq = (this->controller) ? &this->controller->wq : &this->wq;
+	/* 
+	 * Grab the lock and see if the device is available 
+	*/
 retry:
-	active = this;
-	spin_lock(lock);
-
 	/* Hardware controller shared among independend devices */
 	if (this->controller) {
+		spin_lock (&this->controller->lock);
 		if (this->controller->active)
 			active = this->controller->active;
 		else
 			this->controller->active = this;
+		spin_unlock (&this->controller->lock);
 	}
-	if (active == this && this->state == FL_READY) {
-		this->state = new_state;
-		spin_unlock(lock);
-		return 0;
-	}
-	if (new_state == FL_PM_SUSPENDED) {
-		spin_unlock(lock);
-		return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
-	}
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	add_wait_queue(wq, &wait);
-	spin_unlock(lock);
-	schedule();
-	remove_wait_queue(wq, &wait);
+	
+	if (active == this) {
+		spin_lock (&this->chip_lock);
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			spin_unlock (&this->chip_lock);
+			return;
+		}
+	}	
+	set_current_state (TASK_UNINTERRUPTIBLE);
+	add_wait_queue (&active->wq, &wait);
+	spin_unlock (&active->chip_lock);
+	schedule ();
+	remove_wait_queue (&active->wq, &wait);
 	goto retry;
 }
 
@@ -802,7 +762,7 @@
  * @state:	state to select the max. timeout value
  *
  * Wait for command done. This applies to erase and program only
- * Erase can take up to 400ms and program up to 20ms according to
+ * Erase can take up to 400ms and program up to 20ms according to 
  * general NAND and SmartMedia specs
  *
 */
@@ -811,7 +771,7 @@
 
 	unsigned long	timeo = jiffies;
 	int	status;
-
+	
 	if (state == FL_ERASING)
 		 timeo += (HZ * 400) / 1000;
 	else
@@ -823,22 +783,23 @@
 
 	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
 		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
-	else
+	else	
 		this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
 
-	while (time_before(jiffies, timeo)) {
+	while (time_before(jiffies, timeo)) {		
 		/* Check, if we were interrupted */
-		if (this->state != state)
+/*		if (this->state != state)
 			return 0;
 
 		if (this->dev_ready) {
 			if (this->dev_ready(mtd))
-				break;
+				break;	
 		} else {
-			if (this->read_byte(mtd) & NAND_STATUS_READY)
-				break;
-		}
-		cond_resched();
+*/		
+		if (this->read_byte(mtd) & NAND_STATUS_READY)
+			break;
+//		}
+		yield ();
 	}
 	status = (int) this->read_byte(mtd);
 	return status;
@@ -859,7 +820,7 @@
  *
  * Cached programming is not supported yet.
  */
-static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
+static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, 
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
@@ -868,10 +829,10 @@
 	int  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
 	int	eccbytes = 0;
-
+	
 	/* FIXME: Enable cached programming */
 	cached = 0;
-
+	
 	/* Send command to begin auto page programming */
 	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
 
@@ -882,7 +843,7 @@
 		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
-
+		
 	/* Software ecc 3/256, write all */
 	case NAND_ECC_SOFT:
 		for (; eccsteps; eccsteps--) {
@@ -911,12 +872,21 @@
 		}
 		break;
 	}
-
+										
 	/* Write out OOB data */
+	
 	if (this->options & NAND_HWECC_SYNDROME)
 		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
-	else
-		this->write_buf(mtd, oob_buf, mtd->oobsize);
+	else {
+/*		mdelay(100);
+    		printk("write oob(%08x): ",page);
+	    	for(i=0;i< mtd->oobsize;i++){
+		    printk("%02x ",oob_buf[i] & 0xff);
+		}
+		printk("\n");
+*/		this->write_buf(mtd, oob_buf, mtd->oobsize);
+	}
+		
 
 	/* Send command to actually program the data */
 	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
@@ -924,14 +894,8 @@
 	if (!cached) {
 		/* call wait ready function */
 		status = this->waitfunc (mtd, this, FL_WRITING);
-
-		/* See if operation failed and additional status checks are available */
-		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
-			status = this->errstat(mtd, this, FL_WRITING, status, page);
-		}
-
 		/* See if device thinks it succeeded */
-		if (status & NAND_STATUS_FAIL) {
+		if (status & 0x01) {
 			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
 			return -EIO;
 		}
@@ -940,7 +904,7 @@
 		/* wait until cache is ready*/
 		// status = this->waitfunc (mtd, this, FL_CACHEDRPG);
 	}
-	return 0;
+	return 0;	
 }
 
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -956,19 +920,19 @@
  * @oobmode:	1 = full buffer verify, 0 = ecc only
  *
  * The NAND device assumes that it is always writing to a cleanly erased page.
- * Hence, it performs its internal write verification only on bits that
+ * Hence, it performs its internal write verification only on bits that 
  * transitioned from 1 to 0. The device does NOT verify the whole page on a
- * byte by byte basis. It is possible that the page was not completely erased
- * or the page is becoming unusable due to wear. The read with ECC would catch
- * the error later when the ECC page check fails, but we would rather catch
+ * byte by byte basis. It is possible that the page was not completely erased 
+ * or the page is becoming unusable due to wear. The read with ECC would catch 
+ * the error later when the ECC page check fails, but we would rather catch 
  * it early in the page write stage. Better to write no data than invalid data.
  */
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode)
 {
 	int 	i, j, datidx = 0, oobofs = 0, res = -EIO;
 	int	eccsteps = this->eccsteps;
-	int	hweccbytes;
+	int	hweccbytes; 
 	u_char 	oobdata[64];
 
 	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
@@ -1008,7 +972,7 @@
 
 			if (oobsel->useecc != MTD_NANDECC_OFF && !hweccbytes) {
 				int ecccnt = oobsel->eccbytes;
-
+		
 				for (i = 0; i < ecccnt; i++) {
 					int idx = oobsel->eccpos[i];
 					if (oobdata[idx] != oob_buf[oobofs + idx] ) {
@@ -1018,62 +982,61 @@
 						goto out;
 					}
 				}
-			}
+			}	
 		}
 		oobofs += mtd->oobsize - hweccbytes * eccsteps;
 		page++;
 		numpages--;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		 * Do this also before returning, so the chip is
 		 * ready for the next command.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
+			while (!this->dev_ready(mtd));	
 
 		/* All done, return happy */
 		if (!numpages)
 			return 0;
-
-
-		/* Check, if the chip supports auto page increment */
+		
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this))
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 	}
-	/*
+	/* 
 	 * Terminate the read command. We come here in case of an error
 	 * So we must issue a reset command.
 	 */
-out:
+out:	 
 	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
 	return res;
 }
 #endif
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read - [MTD Interface] MTD compability function for nand_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
  * @retlen:	pointer to variable to store the number of read bytes
  * @buf:	the databuffer to put data
  *
- * This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
- * and flags = 0xff
- */
+ * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
+*/
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
-	return nand_do_read_ecc (mtd, from, len, retlen, buf, NULL, &mtd->oobinfo, 0xff);
-}
+	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+}			   
 
 
 /**
- * nand_read_ecc - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read_ecc - [MTD Interface] Read data with ECC
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
@@ -1082,39 +1045,11 @@
  * @oob_buf:	filesystem supplied oob data buffer
  * @oobsel:	oob selection structure
  *
- * This function simply calls nand_do_read_ecc with flags = 0xff
+ * NAND read with ECC
  */
 static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
-	/* use userspace supplied oobinfo, if zero */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-	return nand_do_read_ecc(mtd, from, len, retlen, buf, oob_buf, oobsel, 0xff);
-}
-
-
-/**
- * nand_do_read_ecc - [MTD Interface] Read data with ECC
- * @mtd:	MTD device structure
- * @from:	offset to read from
- * @len:	number of bytes to read
- * @retlen:	pointer to variable to store the number of read bytes
- * @buf:	the databuffer to put data
- * @oob_buf:	filesystem supplied oob data buffer (can be NULL)
- * @oobsel:	oob selection structure
- * @flags:	flag to indicate if nand_get_device/nand_release_device should be preformed
- *		and how many corrected error bits are acceptable:
- *		  bits 0..7 - number of tolerable errors
- *		  bit  8    - 0 == do not get/release chip, 1 == get/release chip
- *
- * NAND read with ECC
- */
-int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			     size_t * retlen, u_char * buf, u_char * oob_buf,
-			     struct nand_oobinfo *oobsel, int flags)
-{
-
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
@@ -1128,7 +1063,6 @@
 	int	compareecc = 1;
 	int	oobreadlen;
 
-
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
@@ -1139,14 +1073,17 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	if (flags & NAND_GET_DEVICE)
-		nand_get_device (this, mtd, FL_READING);
+	nand_get_device (this, mtd ,FL_READING);
 
+	/* use userspace supplied oobinfo, if zero */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+	
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 		oobsel = this->autooob;
-
-	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
+		
+	eccmode = NAND_ECC_NONE;//oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	oob_config = oobsel->eccpos;
 
 	/* Select the NAND device */
@@ -1163,28 +1100,28 @@
 	end = mtd->oobblock;
 	ecc = this->eccsize;
 	eccbytes = this->eccbytes;
-
+	
 	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
 		compareecc = 0;
 
 	oobreadlen = mtd->oobsize;
-	if (this->options & NAND_HWECC_SYNDROME)
+	if (this->options & NAND_HWECC_SYNDROME) 
 		oobreadlen -= oobsel->eccbytes;
 
 	/* Loop until all data read */
 	while (read < len) {
-
+		
 		int aligned = (!col && (len - read) >= end);
-		/*
+		/* 
 		 * If the read is not page aligned, we have to read into data buffer
 		 * due to ecc, else we read into return buffer direct
 		 */
 		if (aligned)
 			data_poi = &buf[read];
-		else
+		else 
 			data_poi = this->data_buf;
-
-		/* Check, if we have this page in the buffer
+		
+		/* Check, if we have this page in the buffer 
 		 *
 		 * FIXME: Make it work when we must provide oob data too,
 		 * check the usage of data_buf oob field
@@ -1200,31 +1137,32 @@
 		if (sndcmd) {
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 			sndcmd = 0;
-		}
+		}	
 
 		/* get oob area, if we have no oob buffer from fs-driver */
-		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
-			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 			oob_data = &this->data_buf[end];
 
 		eccsteps = this->eccsteps;
-
+		
+		udelay(100);
+		
 		switch (eccmode) {
 		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
 			static unsigned long lastwhinge = 0;
 			if ((lastwhinge / HZ) != (jiffies / HZ)) {
-				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
+//				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
 				lastwhinge = jiffies;
 			}
 			this->read_buf(mtd, data_poi, end);
 			break;
 		}
-
+			
 		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
 			this->read_buf(mtd, data_poi, end);
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc) 
 				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-			break;
+			break;	
 
 		default:
 			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
@@ -1241,17 +1179,16 @@
 					/* We calc error correction directly, it checks the hw
 					 * generator for an error, reads back the syndrome and
 					 * does the error correction on the fly */
-					ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
-					if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
-						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
+					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
+						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " 
 							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
 						ecc_failed++;
 					}
 				} else {
 					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-				}
+				}	
 			}
-			break;
+			break;						
 		}
 
 		/* read oobdata */
@@ -1259,8 +1196,8 @@
 
 		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
 		if (!compareecc)
-			goto readoob;
-
+			goto readoob;	
+		
 		/* Pick the ECC bytes out of the oob data */
 		for (j = 0; j < oobsel->eccbytes; j++)
 			ecc_code[j] = oob_data[oob_config[j]];
@@ -1268,24 +1205,24 @@
 		/* correct data, if neccecary */
 		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
 			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
-
+			
 			/* Get next chunk of ecc bytes */
 			j += eccbytes;
-
-			/* Check, if we have a fs supplied oob-buffer,
+			
+			/* Check, if we have a fs supplied oob-buffer, 
 			 * This is the legacy mode. Used by YAFFS1
 			 * Should go away some day
 			 */
-			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
+			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
 				int *p = (int *)(&oob_data[mtd->oobsize]);
 				p[i] = ecc_status;
 			}
-
-			if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
+			
+			if (ecc_status == -1) {	
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
 				ecc_failed++;
 			}
-		}
+		}		
 
 	readoob:
 		/* check, if we have a fs supplied oob-buffer */
@@ -1293,14 +1230,14 @@
 			/* without autoplace. Legacy mode used by YAFFS1 */
 			switch(oobsel->useecc) {
 			case MTD_NANDECC_AUTOPLACE:
-			case MTD_NANDECC_AUTOPL_USR:
 				/* Walk through the autoplace chunks */
-				for (i = 0; oobsel->oobfree[i][1]; i++) {
+				for (i = 0, j = 0; j < mtd->oobavail; i++) {
 					int from = oobsel->oobfree[i][0];
 					int num = oobsel->oobfree[i][1];
 					memcpy(&oob_buf[oob], &oob_data[from], num);
-					oob += num;
+					j+= num;
 				}
+				oob += mtd->oobavail;
 				break;
 			case MTD_NANDECC_PLACE:
 				/* YAFFS1 legacy mode */
@@ -1311,25 +1248,25 @@
 		}
 	readdata:
 		/* Partial page read, transfer data into fs buffer */
-		if (!aligned) {
+		if (!aligned) { 
 			for (j = col; j < end && read < len; j++)
 				buf[read++] = data_poi[j];
-			this->pagebuf = realpage;
-		} else
+			this->pagebuf = realpage;	
+		} else		
 			read += mtd->oobblock;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
-
+			while (!this->dev_ready(mtd));	
+			
 		if (read == len)
-			break;
+			break;	
 
 		/* For subsequent reads align to page boundary. */
 		col = 0;
@@ -1343,16 +1280,15 @@
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
 		}
-		/* Check, if the chip supports auto page increment
-		 * or if we have hit a block boundary.
-		*/
+		/* Check, if the chip supports auto page increment 
+		 * or if we have hit a block boundary. 
+		*/ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
-			sndcmd = 1;
+			sndcmd = 1;				
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	if (flags & NAND_GET_DEVICE)
-		nand_release_device(mtd);
+	nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1384,7 +1320,7 @@
 	/* Shift to get page */
 	page = (int)(from >> this->page_shift);
 	chipnr = (int)(from >> this->chip_shift);
-
+	
 	/* Mask to get column */
 	col = from & (mtd->oobsize - 1);
 
@@ -1406,17 +1342,33 @@
 
 	/* Send the read command */
 	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
-	/*
+	/* 
 	 * Read the data, if we read more than one page
 	 * oob data, let the device transfer the data !
 	 */
+	 
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: col=%d page=%d,page&mask=%d\n",
+			col, page,page & this->pagemask);
+		
 	i = 0;
 	while (i < len) {
+
 		int thislen = mtd->oobsize - col;
 		thislen = min_t(int, thislen, len);
 		this->read_buf(mtd, &buf[i], thislen);
 		i += thislen;
 
+/*!!!*/		udelay(100);		
+		/* Apply delay or wait for ready/busy pin 
+		 * Do this before the AUTOINCR check, so no problems
+		 * arise if a chip which does auto increment
+		 * is marked as NOAUTOINCR by the board driver.
+		*/
+		if (!this->dev_ready) 
+			udelay (this->chip_delay);
+		else
+			while (!this->dev_ready(mtd));	
+
 		/* Read more ? */
 		if (i < len) {
 			page++;
@@ -1428,20 +1380,10 @@
 				this->select_chip(mtd, -1);
 				this->select_chip(mtd, chipnr);
 			}
-
-			/* Apply delay or wait for ready/busy pin
-			 * Do this before the AUTOINCR check, so no problems
-			 * arise if a chip which does auto increment
-			 * is marked as NOAUTOINCR by the board driver.
-			 */
-			if (!this->dev_ready)
-				udelay (this->chip_delay);
-			else
-				nand_wait_ready(mtd);
-
-			/* Check, if the chip supports auto page increment
-			 * or if we have hit a block boundary.
-			*/
+				
+			/* Check, if the chip supports auto page increment 
+			 * or if we have hit a block boundary. 
+			*/ 
 			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
 				/* For subsequent page reads set offset to 0 */
 			        this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
@@ -1487,27 +1429,27 @@
 	nand_get_device (this, mtd , FL_READING);
 
 	this->select_chip (mtd, chip);
-
+	
 	/* Add requested oob length */
 	len += ooblen;
-
+	
 	while (len) {
 		if (sndcmd)
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
-		sndcmd = 0;
+		sndcmd = 0;	
 
 		this->read_buf (mtd, &buf[cnt], pagesize);
 
 		len -= pagesize;
 		cnt += pagesize;
 		page++;
-
-		if (!this->dev_ready)
+		
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
-
-		/* Check, if the chip supports auto page increment */
+			while (!this->dev_ready(mtd));	
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
 			sndcmd = 1;
 	}
@@ -1518,8 +1460,8 @@
 }
 
 
-/**
- * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer
+/** 
+ * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer 
  * @mtd:	MTD device structure
  * @fsbuf:	buffer given by fs driver
  * @oobsel:	out of band selection structre
@@ -1548,20 +1490,20 @@
 	int i, len, ofs;
 
 	/* Zero copy fs supplied buffer */
-	if (fsbuf && !autoplace)
+	if (fsbuf && !autoplace) 
 		return fsbuf;
 
 	/* Check, if the buffer must be filled with ff again */
-	if (this->oobdirty) {
-		memset (this->oob_buf, 0xff,
+	if (this->oobdirty) {	
+		memset (this->oob_buf, 0xff, 
 			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
 		this->oobdirty = 0;
-	}
-
+	}	
+	
 	/* If we have no autoplacement or no fs buffer use the internal one */
 	if (!autoplace || !fsbuf)
 		return this->oob_buf;
-
+	
 	/* Walk through the pages and place the data */
 	this->oobdirty = 1;
 	ofs = 0;
@@ -1595,7 +1537,7 @@
 {
 	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
 }
-
+			   
 /**
  * nand_write_ecc - [MTD Interface] NAND write with ECC
  * @mtd:	MTD device structure
@@ -1617,7 +1559,7 @@
 	u_char *oobbuf, *bufstart;
 	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
 
-	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i, oobsel=%d\n", (unsigned int) to, (int) len, oobsel);
 
 	/* Initialize retlen, in case of early exit */
 	*retlen = 0;
@@ -1628,7 +1570,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1647,24 +1589,22 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
+		
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+	}	
 
 	/* Setup variables and oob buffer */
 	totalpages = len >> this->page_shift;
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
+	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))  
 		this->pagebuf = -1;
-
+	
 	/* Set it relative to chip */
 	page &= this->pagemask;
 	startpage = page;
@@ -1686,14 +1626,14 @@
 		if (ret) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
 			goto out;
-		}
+		}	
 		/* Next oob page */
 		oob += mtd->oobsize;
 		/* Update written bytes count */
 		written += mtd->oobblock;
-		if (written == len)
+		if (written == len) 
 			goto cmp;
-
+		
 		/* Increment page address */
 		page++;
 
@@ -1704,13 +1644,13 @@
 		if (!(page & (ppblock - 1))){
 			int ofs;
 			this->data_poi = bufstart;
-			ret = nand_verify_pages (mtd, this, startpage,
+			ret = nand_verify_pages (mtd, this, startpage, 
 				page - startpage,
 				oobbuf, oobsel, chipnr, (eccbuf != NULL));
 			if (ret) {
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 				goto out;
-			}
+			}	
 			*retlen = written;
 
 			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
@@ -1720,9 +1660,8 @@
 			numpages = min (totalpages, ppblock);
 			page &= this->pagemask;
 			startpage = page;
-			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
+			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, 
 					autoplace, numpages);
-			oob = 0;
 			/* Check, if we cross a chip boundary */
 			if (!page) {
 				chipnr++;
@@ -1738,7 +1677,7 @@
 		oobbuf, oobsel, chipnr, (eccbuf != NULL));
 	if (!ret)
 		*retlen = written;
-	else
+	else	
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 
 out:
@@ -1798,7 +1737,7 @@
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd))
 		goto out;
-
+	
 	/* Invalidate the page cache, if we write to the cached page */
 	if (page == this->pagebuf)
 		this->pagebuf = -1;
@@ -1824,7 +1763,7 @@
 	status = this->waitfunc (mtd, this, FL_WRITING);
 
 	/* See if device thinks it succeeded */
-	if (status & NAND_STATUS_FAIL) {
+	if (status & 0x01) {
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
 		ret = -EIO;
 		goto out;
@@ -1861,10 +1800,10 @@
  *
  * NAND write with kvec. This just calls the ecc function
  */
-static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen)
 {
-	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));
+	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));	
 }
 
 /**
@@ -1879,7 +1818,7 @@
  *
  * NAND write with iovec with ecc
  */
-static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel)
 {
 	int i, page, len, total_len, ret = -EIO, written = 0, chipnr;
@@ -1905,7 +1844,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(total_len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1924,21 +1863,19 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
 
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+	}	
 
 	/* Setup start page */
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))
+	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))  
 		this->pagebuf = -1;
 
 	startpage = page & this->pagemask;
@@ -1962,10 +1899,10 @@
 			oob = 0;
 			for (i = 1; i <= numpages; i++) {
 				/* Write one page. If this is the last page to write
-				 * then use the real pageprogram command, else select
+				 * then use the real pageprogram command, else select 
 				 * cached programming if supported by the chip.
 				 */
-				ret = nand_write_page (mtd, this, page & this->pagemask,
+				ret = nand_write_page (mtd, this, page & this->pagemask, 
 					&oobbuf[oob], oobsel, i != numpages);
 				if (ret)
 					goto out;
@@ -1981,12 +1918,12 @@
 				count--;
 			}
 		} else {
-			/* We must use the internal buffer, read data out of each
+			/* We must use the internal buffer, read data out of each 
 			 * tuple until we have a full page to write
 			 */
 			int cnt = 0;
 			while (cnt < mtd->oobblock) {
-				if (vecs->iov_base != NULL && vecs->iov_len)
+				if (vecs->iov_base != NULL && vecs->iov_len) 
 					this->data_buf[cnt++] = ((u_char *) vecs->iov_base)[len++];
 				/* Check, if we have to switch to the next tuple */
 				if (len >= (int) vecs->iov_len) {
@@ -1995,10 +1932,10 @@
 					count--;
 				}
 			}
-			this->pagebuf = page;
-			this->data_poi = this->data_buf;
+			this->pagebuf = page;	
+			this->data_poi = this->data_buf;	
 			bufstart = this->data_poi;
-			numpages = 1;
+			numpages = 1;		
 			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
 			ret = nand_write_page (mtd, this, page & this->pagemask,
 				oobbuf, oobsel, 0);
@@ -2011,7 +1948,7 @@
 		ret = nand_verify_pages (mtd, this, startpage, numpages, oobbuf, oobsel, chipnr, 0);
 		if (ret)
 			goto out;
-
+			
 		written += mtd->oobblock * numpages;
 		/* All done ? */
 		if (!count)
@@ -2079,8 +2016,7 @@
 {
 	return nand_erase_nand (mtd, instr, 0);
 }
-
-#define BBT_PAGE_MASK	0xffffff3f
+ 
 /**
  * nand_erase_intern - [NAND Interface] erase block(s)
  * @mtd:	MTD device structure
@@ -2093,13 +2029,8 @@
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *this = mtd->priv;
-	int rewrite_bbt[NAND_MAX_CHIPS]={0};	/* flags to indicate the page, if bbt needs to be rewritten. */
-	unsigned int bbt_masked_page;		/* bbt mask to compare to page being erased. */
-						/* It is used to see if the current page is in the same */
-						/*   256 block group and the same bank as the bbt. */
 
-	DEBUG (MTD_DEBUG_LEVEL3,
-	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
+	DEBUG (MTD_DEBUG_LEVEL3,"nand_erase: start = 0x%08x, len = %i allowbbt=%d page_shift=%d\n", (unsigned int) instr->addr, (unsigned int) instr->len,allowbbt,this->page_shift);
 
 	/* Start address must align on block boundary */
 	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
@@ -2142,13 +2073,6 @@
 		goto erase_exit;
 	}
 
-	/* if BBT requires refresh, set the BBT page mask to see if the BBT should be rewritten */
-	if (this->options & BBT_AUTO_REFRESH) {
-		bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
-	} else {
-		bbt_masked_page = 0xffffffff;	/* should not match anything */
-	}
-
 	/* Loop through the pages */
 	len = instr->len;
 
@@ -2156,42 +2080,29 @@
 
 	while (len) {
 		/* Check if we have a bad block, we do not erase bad blocks ! */
-		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
+		if (nand_block_checkbad(mtd, ((loff_t) page) >> this->page_shift, 0, allowbbt)) {
 			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
-
-		/* Invalidate the page cache, if we erase the block which contains
+		
+		/* Invalidate the page cache, if we erase the block which contains 
 		   the current cached page */
 		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
 			this->pagebuf = -1;
 
 		this->erase_cmd (mtd, page & this->pagemask);
-
+		
 		status = this->waitfunc (mtd, this, FL_ERASING);
 
-		/* See if operation failed and additional status checks are available */
-		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
-			status = this->errstat(mtd, this, FL_ERASING, status, page);
-		}
-
 		/* See if block erase succeeded */
-		if (status & NAND_STATUS_FAIL) {
+		if (status & 0x01) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = (page << this->page_shift);
 			goto erase_exit;
 		}
-
-		/* if BBT requires refresh, set the BBT rewrite flag to the page being erased */
-		if (this->options & BBT_AUTO_REFRESH) {
-			if (((page & BBT_PAGE_MASK) == bbt_masked_page) &&
-			     (page != this->bbt_td->pages[chipnr])) {
-				rewrite_bbt[chipnr] = (page << this->page_shift);
-			}
-		}
-
+		
 		/* Increment page address and decrement length */
 		len -= (1 << this->phys_erase_shift);
 		page += pages_per_block;
@@ -2201,13 +2112,6 @@
 			chipnr++;
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
-
-			/* if BBT requires refresh and BBT-PERCHIP,
-			 *   set the BBT page mask to see if this BBT should be rewritten */
-			if ((this->options & BBT_AUTO_REFRESH) && (this->bbt_td->options & NAND_BBT_PERCHIP)) {
-				bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
-			}
-
 		}
 	}
 	instr->state = MTD_ERASE_DONE;
@@ -2222,18 +2126,6 @@
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
-	/* if BBT requires refresh and erase was successful, rewrite any selected bad block tables */
-	if ((this->options & BBT_AUTO_REFRESH) && (!ret)) {
-		for (chipnr = 0; chipnr < this->numchips; chipnr++) {
-			if (rewrite_bbt[chipnr]) {
-				/* update the BBT for chip */
-				DEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt (%d:0x%0x 0x%0x)\n",
-					chipnr, rewrite_bbt[chipnr], this->bbt_td->pages[chipnr]);
-				nand_update_bbt (mtd, rewrite_bbt[chipnr]);
-			}
-		}
-	}
-
 	/* Return more or less happy */
 	return ret;
 }
@@ -2265,9 +2157,9 @@
 static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
 {
 	/* Check for invalid offset */
-	if (ofs > mtd->size)
+	if (ofs > mtd->size) 
 		return -EINVAL;
-
+	
 	return nand_block_checkbad (mtd, ofs, 1, 0);
 }
 
@@ -2292,34 +2184,6 @@
 }
 
 /**
- * nand_suspend - [MTD Interface] Suspend the NAND flash
- * @mtd:	MTD device structure
- */
-static int nand_suspend(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-
-	return nand_get_device (this, mtd, FL_PM_SUSPENDED);
-}
-
-/**
- * nand_resume - [MTD Interface] Resume the NAND flash
- * @mtd:	MTD device structure
- */
-static void nand_resume(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-
-	if (this->state == FL_PM_SUSPENDED)
-		nand_release_device(mtd);
-	else
-		printk(KERN_ERR "resume() called for the chip which is not "
-				"in suspended state\n");
-
-}
-
-
-/**
  * nand_scan - [NAND Interface] Scan for the NAND device
  * @mtd:	MTD device structure
  * @maxchips:	Number of chips to scan for
@@ -2333,7 +2197,7 @@
  */
 int nand_scan (struct mtd_info *mtd, int maxchips)
 {
-	int i, nand_maf_id, nand_dev_id, busw, maf_id;
+	int i, j, nand_maf_id, nand_dev_id, busw;
 	struct nand_chip *this = mtd->priv;
 
 	/* Get buswidth to select the correct functions*/
@@ -2386,13 +2250,13 @@
 
 	/* Print and store flash device information */
 	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
-
-		if (nand_dev_id != nand_flash_ids[i].id)
+				
+		if (nand_dev_id != nand_flash_ids[i].id) 
 			continue;
 
 		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
 		this->chipsize = nand_flash_ids[i].chipsize << 20;
-
+		
 		/* New devices have all the information in additional id bytes */
 		if (!nand_flash_ids[i].pagesize) {
 			int extid;
@@ -2404,14 +2268,14 @@
 			mtd->oobblock = 1024 << (extid & 0x3);
 			extid >>= 2;
 			/* Calc oobsize */
-			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock >> 9);
+			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
 			extid >>= 2;
 			/* Calc blocksize. Blocksize is multiples of 64KiB */
 			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
 			extid >>= 2;
 			/* Get buswidth information */
 			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
-
+		
 		} else {
 			/* Old devices have this data hardcoded in the
 			 * device id table */
@@ -2421,33 +2285,27 @@
 			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
 		}
 
-		/* Try to identify manufacturer */
-		for (maf_id = 0; nand_manuf_ids[maf_id].id != 0x0; maf_id++) {
-			if (nand_manuf_ids[maf_id].id == nand_maf_id)
-				break;
-		}
-
 		/* Check, if buswidth is correct. Hardware drivers should set
 		 * this correct ! */
 		if (busw != (this->options & NAND_BUSWIDTH_16)) {
 			printk (KERN_INFO "NAND device: Manufacturer ID:"
-				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-				nand_manuf_ids[maf_id].name , mtd->name);
-			printk (KERN_WARNING
-				"NAND bus width %d instead %d bit\n",
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+				nand_manuf_ids[i].name , mtd->name);
+			printk (KERN_WARNING 
+				"NAND bus width %d instead %d bit\n", 
 					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
 					busw ? 16 : 8);
 			this->select_chip(mtd, -1);
-			return 1;
+			return 1;	
 		}
-
-		/* Calculate the address shift from the page size */
+		
+		/* Calculate the address shift from the page size */	
 		this->page_shift = ffs(mtd->oobblock) - 1;
 		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
 		this->chip_shift = ffs(this->chipsize) - 1;
 
 		/* Set the bad block position */
-		this->badblockpos = mtd->oobblock > 512 ?
+		this->badblockpos = mtd->oobblock > 512 ? 
 			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
 
 		/* Get chip options, preserve non chip based options */
@@ -2457,10 +2315,10 @@
 		this->options |= NAND_NO_AUTOINCR;
 		/* Check if this is a not a samsung device. Do not clear the options
 		 * for chips which are not having an extended id.
-		 */
+		 */	
 		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
 			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
-
+		
 		/* Check for AND chips with 4 page planes */
 		if (this->options & NAND_4PAGE_ARRAY)
 			this->erase_cmd = multi_erase_cmd;
@@ -2470,10 +2328,15 @@
 		/* Do not replace user supplied command function ! */
 		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
 			this->cmdfunc = nand_command_lp;
-
+				
+		/* Try to identify manufacturer */
+		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
+			if (nand_manuf_ids[j].id == nand_maf_id)
+				break;
+		}
 		printk (KERN_INFO "NAND device: Manufacturer ID:"
-			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-			nand_manuf_ids[maf_id].name , nand_flash_ids[i].name);
+			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+			nand_manuf_ids[j].name , nand_flash_ids[i].name);
 		break;
 	}
 
@@ -2496,7 +2359,7 @@
 	}
 	if (i > 1)
 		printk(KERN_INFO "%d NAND chips detected\n", i);
-
+	
 	/* Allocate buffers, if neccecary */
 	if (!this->oob_buf) {
 		size_t len;
@@ -2508,7 +2371,7 @@
 		}
 		this->options |= NAND_OOBBUF_ALLOC;
 	}
-
+	
 	if (!this->data_buf) {
 		size_t len;
 		len = mtd->oobblock + mtd->oobsize;
@@ -2535,7 +2398,7 @@
 	if (!this->autooob) {
 		/* Select the appropriate default oob placement scheme for
 		 * placement agnostic filesystems */
-		switch (mtd->oobsize) {
+		switch (mtd->oobsize) { 
 		case 8:
 			this->autooob = &nand_oob_8;
 			break;
@@ -2551,19 +2414,22 @@
 			BUG();
 		}
 	}
-
+	
 	/* The number of bytes available for the filesystem to place fs dependend
 	 * oob data */
-	mtd->oobavail = 0;
-	for (i = 0; this->autooob->oobfree[i][1]; i++)
-		mtd->oobavail += this->autooob->oobfree[i][1];
+	if (this->options & NAND_BUSWIDTH_16) {
+		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
+		if (this->autooob->eccbytes & 0x01)
+			mtd->oobavail--;
+	} else
+		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
 
-	/*
+	/* 
 	 * check ECC mode, default to software
 	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
-	 * fallback to software ECC
+	 * fallback to software ECC 
 	*/
-	this->eccsize = 256;	/* set default eccsize */
+	this->eccsize = 256;	/* set default eccsize */	
 	this->eccbytes = 3;
 
 	switch (this->eccmode) {
@@ -2578,56 +2444,56 @@
 			this->eccsize = 2048;
 		break;
 
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW6_512:
-	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW3_512: 
+	case NAND_ECC_HW6_512: 
+	case NAND_ECC_HW8_512: 
 		if (mtd->oobblock == 256) {
 			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
 			this->eccmode = NAND_ECC_SOFT;
 			this->calculate_ecc = nand_calculate_ecc;
 			this->correct_data = nand_correct_data;
-		} else
+		} else 
 			this->eccsize = 512; /* set eccsize to 512 */
 		break;
-
+			
 	case NAND_ECC_HW3_256:
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
 		break;
 
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->calculate_ecc = nand_calculate_ecc;
 		this->correct_data = nand_correct_data;
 		break;
 
 	default:
 		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-		BUG();
-	}
+		BUG();	
+	}	
 
-	/* Check hardware ecc function availability and adjust number of ecc bytes per
+	/* Check hardware ecc function availability and adjust number of ecc bytes per 
 	 * calculation step
 	*/
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
 		this->eccbytes += 4;
-	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW8_512: 
 		this->eccbytes += 2;
-	case NAND_ECC_HW6_512:
+	case NAND_ECC_HW6_512: 
 		this->eccbytes += 3;
-	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW3_512: 
 	case NAND_ECC_HW3_256:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-		BUG();
+		BUG();	
 	}
-
+		
 	mtd->eccsize = this->eccsize;
-
+	
 	/* Set the number of read / write steps for one page to ensure ECC generation */
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
@@ -2639,15 +2505,15 @@
 		this->eccsteps = mtd->oobblock / 512;
 		break;
 	case NAND_ECC_HW3_256:
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->eccsteps = mtd->oobblock / 256;
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		this->eccsteps = 1;
 		break;
 	}
-
+	
 	/* Initialize state, waitqueue and spinlock */
 	this->state = FL_READY;
 	init_waitqueue_head (&this->wq);
@@ -2678,8 +2544,8 @@
 	mtd->sync = nand_sync;
 	mtd->lock = NULL;
 	mtd->unlock = NULL;
-	mtd->suspend = nand_suspend;
-	mtd->resume = nand_resume;
+	mtd->suspend = NULL;
+	mtd->resume = NULL;
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
 
@@ -2688,16 +2554,16 @@
 
 	mtd->owner = THIS_MODULE;
 
-	/* Check, if we should skip the bad block table scan */
-	if (this->options & NAND_SKIP_BBTSCAN)
-		return 0;
-
 	/* Build bad block table */
-	return this->scan_bbt (mtd);
+//	int ret=this->scan_bbt (mtd);
+//	DEBUG (MTD_DEBUG_LEVEL3,
+//	       "nand_scan_bbt: ret=%x",ret);
+	
+	return 0;
 }
 
 /**
- * nand_release - [NAND Interface] Free resources held by the NAND device
+ * nand_release - [NAND Interface] Free resources held by the NAND device 
  * @mtd:	MTD device structure
 */
 void nand_release (struct mtd_info *mtd)
@@ -2711,8 +2577,9 @@
 	/* Deregister the device */
 	del_mtd_device (mtd);
 
-	/* Free bad block table memory */
-	kfree (this->bbt);
+	/* Free bad block table memory, if allocated */
+	if (this->bbt)
+		kfree (this->bbt);
 	/* Buffer allocated by nand_scan ? */
 	if (this->options & NAND_OOBBUF_ALLOC)
 		kfree (this->oob_buf);
@@ -2721,8 +2588,8 @@
 		kfree (this->data_buf);
 }
 
-EXPORT_SYMBOL_GPL (nand_scan);
-EXPORT_SYMBOL_GPL (nand_release);
+EXPORT_SYMBOL (nand_scan);
+EXPORT_SYMBOL (nand_release);
 
 MODULE_LICENSE ("GPL");
 MODULE_AUTHOR ("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
Index: linux/drivers/mtd/nand/adm5120.h
===================================================================
--- linux/drivers/mtd/nand/adm5120.h	(.../linux)	(revision 0)
+++ linux/drivers/mtd/nand/adm5120.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,91 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : David Weng
+;    File    : adm5120.h
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __ADM5120_H__
+#define  __ADM5120_H__
+
+
+/*=========================  Physical Memory Map  ============================*/
+#define ADM5120_SDRAM_BASE						0
+#define ADM5120_SMEM1_BASE						0x10000000
+#define MEM_KSEG1_BASE							0xA0000000
+
+#define ADM5120_EXTIO0_BASE						0x10C00000
+#define ADM5120_EXTIO1_BASE						0x10E00000
+#define ADM5120_MPMC_BASE						0x11000000
+#define ADM5120_USBHOST_BASE					0x11200000
+#define ADM5120_PCIMEM_BASE						0x11400000
+#define ADM5120_PCIIO_BASE						0x11500000
+#define ADM5120_PCICFG_BASE						0x115FFFF0
+#define ADM5120_MIPS_BASE						0x11A00000
+#define ADM5120_SWCTRL_BASE						0x12000000
+#define ADM5120_INTC_BASE						0x12200000
+#define ADM5120_SYSC_BASE						0x12400000
+#define ADM5120_UART0_BASE						0x12600000
+#define ADM5120_UART1_BASE						0x12800000
+#define ADM5120_SMEM0_BASE						0x1FC00000
+
+
+#define NAND_REG_PBASE				ADM5120_SMEM1_BASE
+
+/* NAND flash interface */
+#define NAND_RW_REG                             0x00
+#define NAND_CLR_CE_REG                       0x01
+#define NAND_SET_CE_REG                         0x02
+#define NAND_CLR_CLE_REG                      0x03
+#define NAND_SET_CLE_REG                        0x04
+#define NAND_CLR_ALE_REG                      0x05
+#define NAND_SET_ALE_REG                        0x06
+#define NAND_SET_SPn_REG                       0x07
+#define NAND_CLR_SPn_REG                         0x08
+#define NAND_CLR_WP_REG                       0x09
+#define NAND_SET_WP_REG                         0x0a
+#define NAND_RDY_REG                            0x0b
+
+#define NAND_SET_BIT                            0x01
+#define NAND_ENABLE                             0x100
+
+/* Macros for accessing NAND flash interface register */
+#define ADM5120_NAND_REG(_reg)		\
+	(*((volatile unsigned long *)(PA2VA(ADM5120_SMEM1_BASE + (_reg)))))
+
+
+#define NAND_SET_CEn    0x1     //CE# low
+#define NAND_CLR_CEn    0x2     //CE# high
+#define NAND_CLR_CLE    0x3     //CLE low
+#define NAND_SET_CLE    0x4     //CLE high
+#define NAND_CLR_ALE    0x5     //ALE low
+#define NAND_SET_ALE    0x6     //ALE high
+#define NAND_SET_SPn    0x7     //SP# low (use spare area)
+#define NAND_CLR_SPn    0x8     //SP# high (do not use spare area)
+#define NAND_SET_WPn    0x9     //WP# low
+#define NAND_CLR_WPn    0xA     //WP# high
+#define NAND_STS_REG    0xB     //Status register
+
+#endif
Index: linux/drivers/mtd/nand/Makefile
===================================================================
--- linux/drivers/mtd/nand/Makefile	(.../linux)	(revision 5)
+++ linux/drivers/mtd/nand/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -6,10 +6,14 @@
 obj-$(CONFIG_MTD_NAND)			+= nand.o nand_ecc.o
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
 
+obj-y					+= adm5120.o
+
 obj-$(CONFIG_MTD_NAND_SPIA)		+= spia.o
 obj-$(CONFIG_MTD_NAND_TOTO)		+= toto.o
 obj-$(CONFIG_MTD_NAND_AUTCPU12)		+= autcpu12.o
 obj-$(CONFIG_MTD_NAND_EDB7312)		+= edb7312.o
+obj-$(CONFIG_MTD_NAND_TX4925NDFMC)	+= tx4925ndfmc.o
+obj-$(CONFIG_MTD_NAND_TX4938NDFMC)	+= tx4938ndfmc.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
Index: linux/drivers/debug/Makefile
===================================================================
--- linux/drivers/debug/Makefile	(.../linux)	(revision 0)
+++ linux/drivers/debug/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,2 @@
+obj-y		+= debug_net.o
+
Index: linux/drivers/debug/debug_net.c
===================================================================
--- linux/drivers/debug/debug_net.c	(.../linux)	(revision 0)
+++ linux/drivers/debug/debug_net.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,174 @@
+#include <linux/time.h>
+#include <linux/module.h>
+
+
+struct timeval debug_ip_arp;
+u32 debug_ip_arp_cnt;
+struct timeval debug_ip_igmp;
+u32 debug_ip_igmp_cnt;
+struct timeval debug_ip_input;
+u32 debug_ip_input_cnt;
+struct timeval debug_ip_output;
+u32 debug_ip_output_cnt;
+struct timeval debug_ip_forward;
+u32  debug_ip_forward_cnt;
+struct timeval debug_ip_hook;
+u32  debug_ip_hook_cnt;
+
+struct timeval debug_ip_test;
+u32  debug_ip_test_cnt;
+
+struct timeval debug_ip_ipmr;
+u32  debug_ip_ipmr_cnt;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_vs_xmit;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_ipt_REJECT;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_raw;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_xfrm4_input;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_xfrm4_output;
+//u32 debug_ip_arp_cnt;
+
+static int __init debug_net_init(void)
+{
+	struct timeval probe1,probe2,tv1,tv2;
+	u32 cntr=0;
+	
+	printk("\n");
+
+	do_gettimeofday(&probe1);
+	
+	do_gettimeofday(&tv1);
+	do_gettimeofday(&tv2);
+	debug_count_delta(&tv1,tv2);
+	debug_sum_tv( &tv2,tv1);
+	cntr+=1 ;
+	
+	do_gettimeofday(&probe2);
+	debug_count_delta(&probe1,probe2);
+	printk("%s: CALIBRATING: delay= %ld.%06ld\n\n",__FUNCTION__,probe1.tv_sec,probe1.tv_usec);
+	
+	printk("\n%s: ZEROING COUNTERS\n\n",__FUNCTION__);
+	memset(&debug_ip_arp,0,sizeof(struct timeval));
+	memset(&debug_ip_igmp,0,sizeof(struct timeval)); 
+	memset(&debug_ip_input,0,sizeof(struct timeval));
+	memset(&debug_ip_output,0,sizeof(struct timeval));		
+	memset(&debug_ip_forward,0,sizeof(struct timeval));		
+	memset(&debug_ip_ipmr,0,sizeof(struct timeval));			
+	memset(&debug_ip_hook,0,sizeof(struct timeval));				
+	memset(&debug_ip_test,0,sizeof(struct timeval));				
+
+
+	debug_ip_arp_cnt=0;
+	debug_ip_igmp_cnt=0;
+	debug_ip_input_cnt=0;
+	debug_ip_output_cnt=0;
+	debug_ip_forward_cnt=0;
+	debug_ip_ipmr_cnt=0;
+	debug_ip_test_cnt=0;	
+	debug_ip_hook_cnt=0;	
+
+	
+	return 0;
+}
+
+
+int debug_count_delta(struct timeval *tv1,struct timeval tv2)
+{
+        struct timeval *left,*right;    
+	int d=0;
+	if(tv1->tv_sec > tv2.tv_sec){
+		left=tv1;
+		right=&tv2;
+	}else{
+    		right=tv1;
+    		left=&tv2;
+        }
+	
+
+	left->tv_sec-=right->tv_sec;
+	d=left->tv_usec-right->tv_usec;
+	if( d < 0 ){
+		if( left->tv_sec ){
+			d+=1000000;
+			left->tv_sec--;
+		}
+		else
+			d*=-1;
+	}
+
+	tv1->tv_sec=left->tv_sec;
+	tv1->tv_usec=d;
+	return 0;	
+}
+
+void debug_sum_tv(struct timeval *tv1,struct timeval tv2)
+{
+        struct timeval *left,*right;    
+	int s;
+	
+	left=tv1;
+	right=&tv2;
+
+	left->tv_sec+=right->tv_sec;	
+
+	s=left->tv_usec+right->tv_usec;
+	if( s>1000000 ){
+	    left->tv_sec++;
+	    s-=1000000;
+	}
+	left->tv_usec=s;
+}
+
+void debug_div_tv(struct timeval *tv1,u32 z)
+{
+    u32 a;
+    tv1->tv_usec= (tv1->tv_usec/z);
+    if( (a=tv1->tv_sec%z) ){
+	tv1->tv_usec+= (a*1000000)/z;
+    }
+    tv1->tv_sec/=z;
+    
+}
+
+void debug_print_tv(struct timeval *tv,u32 cnt,struct timeval *tv1,char *str)
+{
+    sprintf(str,"avg = %ld.%06ld, num= %d,global=%ld.%06ld",tv->tv_sec,tv->tv_usec,
+    cnt,tv1->tv_sec,tv1->tv_usec);
+}
+
+// export functions
+EXPORT_SYMBOL(debug_count_delta);
+EXPORT_SYMBOL(debug_print_tv);
+EXPORT_SYMBOL(debug_sum_tv);
+EXPORT_SYMBOL(debug_div_tv);
+
+// export counters
+EXPORT_SYMBOL(debug_ip_arp);
+EXPORT_SYMBOL(debug_ip_igmp);
+EXPORT_SYMBOL(debug_ip_input);
+EXPORT_SYMBOL(debug_ip_output);
+EXPORT_SYMBOL(debug_ip_ipmr);
+EXPORT_SYMBOL(debug_ip_forward);
+EXPORT_SYMBOL(debug_ip_hook);
+EXPORT_SYMBOL(debug_ip_test);
+EXPORT_SYMBOL(debug_ip_vs_xmit);
+EXPORT_SYMBOL(debug_ip_ipt_REJECT);
+EXPORT_SYMBOL(debug_ip_raw);
+EXPORT_SYMBOL(debug_ip_xfrm4_input);
+EXPORT_SYMBOL(debug_ip_xfrm4_output);
+
+EXPORT_SYMBOL(debug_ip_arp_cnt);
+EXPORT_SYMBOL(debug_ip_igmp_cnt);
+EXPORT_SYMBOL(debug_ip_input_cnt);
+EXPORT_SYMBOL(debug_ip_output_cnt);
+EXPORT_SYMBOL(debug_ip_ipmr_cnt);
+EXPORT_SYMBOL(debug_ip_forward_cnt);
+EXPORT_SYMBOL(debug_ip_hook_cnt);
+EXPORT_SYMBOL(debug_ip_test_cnt);
+
+
+module_init(debug_net_init);
Index: linux/drivers/video/Kconfig
===================================================================
--- linux/drivers/video/Kconfig	(.../linux)	(revision 5)
+++ linux/drivers/video/Kconfig	(.../linux-kernel/linux)	(revision 28)
@@ -1233,8 +1233,6 @@
 	  various panels and CRTs by passing in kernel cmd line option
 	  au1200fb:panel=<name>.
 
-source "drivers/video/geode/Kconfig"
-
 config FB_FFB
 	bool "Creator/Creator3D/Elite3D support"
 	depends on FB_SBUS && SPARC64
Index: linux/drivers/pci/setup-bus.c
===================================================================
--- linux/drivers/pci/setup-bus.c	(.../linux)	(revision 5)
+++ linux/drivers/pci/setup-bus.c	(.../linux-kernel/linux)	(revision 28)
@@ -41,8 +41,10 @@
  * have a P2P bridge below a cardbus bridge, we need 4K.
  */
 #define CARDBUS_IO_SIZE		(256)
-#define CARDBUS_MEM_SIZE	(32*1024*1024)
+//#define CARDBUS_MEM_SIZE     (32*1024*1024)
+#define CARDBUS_MEM_SIZE       (64*1024)
 
+
 static void __devinit
 pbus_assign_resources_sorted(struct pci_bus *bus)
 {
Index: linux/drivers/char/Kconfig
===================================================================
--- linux/drivers/char/Kconfig	(.../linux)	(revision 5)
+++ linux/drivers/char/Kconfig	(.../linux-kernel/linux)	(revision 28)
@@ -468,9 +468,10 @@
        depends on SGI_TIOCX
        help
          If you have an SGI Altix with an attached SABrick
-         say Y or M here, otherwise say N.
+         say Y or M here, otherwise say 
+	 
+source "drivers/char/tpm/Kconfig"
 
-source "drivers/serial/Kconfig"
 
 config UNIX98_PTYS
 	bool "Unix98 PTY support" if EMBEDDED
@@ -1055,8 +1056,12 @@
 	  The mmtimer device allows direct userspace access to the
 	  Altix system timer.
 
-source "drivers/char/tpm/Kconfig"
+config ADM5120_GPIO
+       tristate "ADM5120 GPIO"
+       depends on MIPS_ADM5120
 
+
+
 config TELCLOCK
 	tristate "Telecom clock driver for MPBL0010 ATCA SBC"
 	depends on EXPERIMENTAL
Index: linux/drivers/char/Makefile
===================================================================
--- linux/drivers/char/Makefile	(.../linux)	(revision 5)
+++ linux/drivers/char/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -80,6 +80,7 @@
 obj-$(CONFIG_FTAPE) += ftape/
 obj-$(CONFIG_COBALT_LCD) += lcd.o
 obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
+obj-$(CONFIG_ADM5120_GPIO) += adm5120_gpio.o
 obj-$(CONFIG_AU1000_GPIO) += au1000_gpio.o
 obj-$(CONFIG_AU1000_USB_TTY) += au1000_usbtty.o
 obj-$(CONFIG_AU1000_USB_RAW) += au1000_usbraw.o
Index: linux/drivers/char/adm5120_gpio.c
===================================================================
--- linux/drivers/char/adm5120_gpio.c	(.../linux)	(revision 0)
+++ linux/drivers/char/adm5120_gpio.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,57 @@
+/*
+ *	ADM5120 LED (GPIO) driver
+ *
+ *	Copyright (C) Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#define LED_MINOR 151
+#define GPIO_IO        ((unsigned long *)0xb20000b8)
+
+MODULE_AUTHOR("Jeroen Vreeken");
+MODULE_LICENSE("GPL");
+
+static ssize_t adm5120_led_write(struct file *file, const char __user *data,
+	size_t len, loff_t *ppos)
+{
+	unsigned char val;
+
+	if (!len || get_user(val, data))
+		return -EFAULT;
+	*GPIO_IO=(*GPIO_IO & 0x00ffffff) | (val<<24);
+	return 1;
+}
+
+static struct file_operations adm5120_led_fops = {
+	.owner	= THIS_MODULE,
+	.write	= adm5120_led_write,
+};
+
+static struct miscdevice adm5120_led_device = {
+	LED_MINOR,
+	"led",
+	&adm5120_led_fops,
+};
+
+static int __init adm5120_led_init(void)
+{
+	printk(KERN_INFO "ADM5120 LED & GPIO driver\n");
+	if (misc_register(&adm5120_led_device)) {
+		printk(KERN_WARNING "Couldn't register device %d\n", LED_MINOR);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static void __exit adm5120_led_exit(void)
+{
+	misc_deregister(&adm5120_led_device);
+}
+
+module_init(adm5120_led_init);
+module_exit(adm5120_led_exit);

Property changes on: linux/drivers/char
___________________________________________________________________
Name: svn:ignore
   + log
defkeymap.c
consolemap_deftbl.c


Index: linux/drivers/net/adm5120sw_napi.c
===================================================================
--- linux/drivers/net/adm5120sw_napi.c	(.../linux)	(revision 0)
+++ linux/drivers/net/adm5120sw_napi.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,1345 @@
+/*
+ *	ADM5120 built in ethernet switch driver
+ *
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ *
+ *	Inspiration for this driver came from the original ADMtek 2.4 
+ *	driver, Copyright ADMtek Inc.
+ *
+ *      Ported back to 2.4(.18-adm) and added default MAC address
+ *      table by Sergio Aguayo.
+ *
+ *      Andrey Ivanov <andrey-s-ivanov@yandex.ru> 07/2006
+ *        Improved performance: added support for NAPI.
+ *        Revised init logic.
+ *
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/in6.h>
+
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+
+#include <asm/checksum.h>
+#include "adm5120sw.h"
+
+MODULE_AUTHOR("Andrey Ivanov (andrey-s-ivanov@yandex.ru), Jeroen Vreeken (pe1rxq@amsat.org) and Sergio Aguayo (webmaster@qmailhosting.net)");
+MODULE_DESCRIPTION("ADM5120 ethernet switch driver");
+MODULE_LICENSE("GPL");
+
+#define PFX "adm5120sw: "
+
+#if 1
+#define DEBUG_PRINT(args...) printk( KERN_DEBUG PFX args )
+#else
+#define DEBUG_PRINT(args...) (void) 0
+#endif
+
+
+/*
+ *	The ADM5120 uses an internal matrix to determine which ports
+ *	belong to which VLAN.
+ *	The default generates a VLAN (and device) for each port 
+ *	(including MII port) and the CPU port is part of all of them.
+ *
+ *	Another example, one big switch and everything mapped to eth0:
+ *	0x7f, 0x00, 0x00, 0x00, 0x00, 0x00
+ */
+static unsigned char vlan_matrix[SW_DEVS] = {
+   	0x41, 0x42, 0x44, 0x48, 0x50, 0x60     /* 6 different interfaces, not connected */
+/*   0x5e, 0x41, 0, 0, 0, 0  /* Edimax layout 4+1 */
+};
+
+/*
+ *      The ADM5120 Demo board has its own MAC address on flash
+ *      memory but for some reason Edimax and others decided not to
+ *      use that space for such purpose. They instead have their
+ *      own structure for this and other data. Understanding
+ *      that structure is outside the kernel's scope and anyway
+ *      the initscripts of such devices will certainly set the
+ *      MAC addresses to the correct value before using any
+ *      net interface.
+ *
+ *      Just in case we have an initscript that doesn't set any
+ *      MAC address, we have this table to associate each device
+ *      with its own address.
+ */
+static unsigned char default_macaddrs[SW_DEVS][6] __initdata = 
+{
+     { 0x00, 0x50, 0xfc, 0x11, 0x22, 0x33 },
+     { 0x00, 0x50, 0xfc, 0x33, 0x22, 0x11 },
+     { 0x00, 0x50, 0xfc, 0x11, 0x22, 0x34 },
+     { 0x00, 0x50, 0xfc, 0x33, 0x22, 0x12 },
+     { 0x00, 0x50, 0xfc, 0x11, 0x22, 0x35 },
+     { 0x00, 0x50, 0xfc, 0x33, 0x22, 0x13 },
+
+};
+
+static struct net_device *adm5120_devs[SW_DEVS];
+static int adm5120_nrdevs = SW_DEVS;
+
+static int int_enabled = 0;
+
+static spinlock_t init_tx_lock = SPIN_LOCK_UNLOCKED; /* lock for tx rings and init code */
+static spinlock_t rx_lock = SPIN_LOCK_UNLOCKED; /* lock for rx rings */
+static spinlock_t int_lock = SPIN_LOCK_UNLOCKED;
+
+struct timer_list tx_watchdog_timer; /* timer for tx ring */
+static int tx_queues_stopped = 0;
+static u32 enable_vlan_mask = 0;
+static int port2vlan[SW_MAX_PORTS];
+
+static struct adm5120_dma
+	adm5120_dma_txh_v[ADM5120_DMA_TXH] __attribute__((aligned(16))),
+	adm5120_dma_txl_v[ADM5120_DMA_TXL] __attribute__((aligned(16))),
+	adm5120_dma_rxh_v[ADM5120_DMA_RXH] __attribute__((aligned(16))),
+	adm5120_dma_rxl_v[ADM5120_DMA_RXL] __attribute__((aligned(16)));
+static struct sk_buff
+	*adm5120_skb_txh[ADM5120_DMA_TXH],
+	*adm5120_skb_txl[ADM5120_DMA_TXL],
+	*adm5120_skb_rxh[ADM5120_DMA_RXH],
+	*adm5120_skb_rxl[ADM5120_DMA_RXL];
+
+static struct tx_ring tx_h_ring, tx_l_ring;
+static struct rx_ring rx_h_ring, rx_l_ring;
+
+static int adm5120_poll(struct net_device *dev, int *budget);
+
+static struct net_device poll_dev = {
+	refcnt: ATOMIC_INIT(1),
+	state: (1UL << __LINK_STATE_START),
+	poll: adm5120_poll,
+/*	quota: 0, */
+	weight: 64,
+/*	poll_list: LIST_HEAD_INIT(poll_dev.poll_list) */
+};
+
+static void adm5120_restart(void);
+
+
+static inline void adm5120_set_reg(unsigned int reg, unsigned long val)
+{
+	*(volatile unsigned long*) (SW_BASE + reg) = val;
+}
+
+static inline unsigned long adm5120_get_reg(unsigned int reg)
+{
+	return *(volatile unsigned long*) (SW_BASE + reg);
+}
+
+static void adm5120_print_regs(void)
+{
+	unsigned int reg;
+
+	for (reg = 0; reg < 0x100; reg += 4)
+	{
+		DEBUG_PRINT("%.2x: 0x%.8lx\n", reg, adm5120_get_reg(reg));
+	}
+}
+
+static void adm5120_print_tx_ring(struct tx_ring *ring)
+{
+	DEBUG_PRINT("num_desc: %d\n", ring->num_desc);
+	DEBUG_PRINT("   avail: %d\n", ring->avail);
+	DEBUG_PRINT("head_idx: %d\n", ring->head_idx);
+	DEBUG_PRINT("tail_idx: %d\n", ring->tail_idx);
+}
+
+
+static void inline _adm5120_mask_int(void)
+{
+#if 0
+	adm5120_set_reg(ADM5120_INT_MASK,
+			adm5120_get_reg(ADM5120_INT_MASK) | ADM5120_INTHANDLE);
+#else
+	adm5120_set_reg(ADM5120_INT_MASK, ADM5120_INTMASKALL);
+#endif
+}
+
+static void inline _adm5120_unmask_int(void)
+{
+#if 0
+	adm5120_set_reg(ADM5120_INT_MASK,
+			adm5120_get_reg(ADM5120_INT_MASK) & ~ADM5120_INTHANDLE);
+#else
+	adm5120_set_reg(ADM5120_INT_MASK, ~ADM5120_INTHANDLE);
+#endif
+}
+
+static void inline _adm5120_try_unmask_int(void)
+{
+	if (int_enabled)
+		_adm5120_unmask_int();
+}
+
+static void inline adm5120_disable_int(void)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&int_lock, flag);
+	int_enabled = 0;
+	_adm5120_mask_int();
+	spin_unlock_irqrestore(&int_lock, flag);
+}
+
+static void inline adm5120_enable_int(void)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&int_lock, flag);
+	int_enabled = 1;
+	if (!test_bit(__LINK_STATE_RX_SCHED, &poll_dev.state)) /* not enable ints while in poll mode */
+		_adm5120_unmask_int();
+	spin_unlock_irqrestore(&int_lock, flag);
+}
+
+
+
+
+
+static int adm5120_rx(struct rx_ring *ring, int *budget)
+{
+	struct sk_buff *skb, *skbn;
+	struct adm5120_sw *priv;
+	struct net_device *dev;
+	int port, vlan, len;
+	int work = 0;
+	int empty = 0;
+	int idx = ring->idx;
+	volatile struct adm5120_dma *descl = ring->desc;
+	volatile struct adm5120_dma *desc;
+	struct sk_buff **skbl = ring->skb;
+
+	for (;;)
+	{
+
+		desc = &descl[idx];
+
+		if (desc->data & ADM5120_DMA_OWN)
+		{
+			empty = 1;
+			break;
+		}
+
+		if (work >= *budget)
+			break;
+		
+		skb = skbl[idx];
+		skbn = NULL;
+
+		port = (desc->status & ADM5120_DMA_PORTID) >> ADM5120_DMA_PORTSHIFT;
+		vlan = port2vlan[port];
+		if (vlan == -1)
+		{
+			printk( KERN_ERR PFX "rx error: port not mapped to vlan.\n");
+			goto next;
+		}
+
+		dev = adm5120_devs[vlan];
+		priv = dev->priv;
+
+		len = ((desc->status & ADM5120_DMA_LEN) >> ADM5120_DMA_LENSHIFT) - ETH_FCS;
+		if (len <= 0 || len > ADM5120_DMA_RXSIZE ||
+		    desc->status & ADM5120_DMA_FCSERR) 
+		{
+			priv->stats.rx_errors++;
+			goto next;
+		}
+
+		skbn = dev_alloc_skb(ADM5120_DMA_RXSIZE + 16);
+		if (!skbn) 
+		{
+			DEBUG_PRINT("can't alloc rx buf: out of memory.\n");
+			priv->stats.rx_dropped++;
+			goto next;
+		}
+
+		skb_reserve(skbn, 2);
+		skbl[idx] = skbn;
+
+		skb_put(skb, len);
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	next:
+		desc->status = 0;
+		desc->cntl = 0;
+		desc->len = ADM5120_DMA_RXSIZE;
+		wmb();
+		desc->data = ADM5120_DMA_ADDR(skbl[idx]->data) | ADM5120_DMA_OWN |
+			(idx == ring->num_desc - 1 ? ADM5120_DMA_RINGEND : 0);
+
+		if (skbn)
+		{
+			dev->last_rx = jiffies;
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += len;
+			netif_receive_skb(skb);
+		}
+
+		if (++idx == ring->num_desc)
+			idx = 0;
+
+		++work;
+	}
+
+	ring->idx = idx;
+	*budget -= work;
+
+	return empty;
+}
+
+static inline void adm5120_stop_tx_queues(void)
+{
+	int i;
+	for (i = 0; i < adm5120_nrdevs; i++)
+		if (enable_vlan_mask & (1 << i))
+			netif_stop_queue(adm5120_devs[i]);
+
+	mod_timer(&tx_watchdog_timer, jiffies + ETH_TX_TIMEOUT);
+
+	tx_queues_stopped = 1;
+	DEBUG_PRINT("tx queues stopped\n");
+}
+
+static inline void adm5120_wake_tx_queues(void)
+{
+	int i;
+	for (i = 0; i < adm5120_nrdevs; i++)
+		if (enable_vlan_mask & (1 << i))
+			netif_wake_queue(adm5120_devs[i]);
+
+	del_timer(&tx_watchdog_timer);
+
+	tx_queues_stopped = 0;
+	DEBUG_PRINT("tx queues waked\n");
+}
+
+static inline void adm5120_start_tx_queues(void)
+{
+	int i;
+	for (i = 0; i < adm5120_nrdevs; i++)
+		if (enable_vlan_mask & (1 << i))
+			netif_start_queue(adm5120_devs[i]);
+
+	del_timer(&tx_watchdog_timer);
+
+	tx_queues_stopped = 0;
+	DEBUG_PRINT("tx queues started\n");
+}
+
+
+static inline void adm5120_tx(struct tx_ring *ring)
+{
+	volatile struct adm5120_dma *descl = ring->desc;
+	struct sk_buff **skbl = ring->skb;
+	int idx = ring->tail_idx;
+
+	while (ring->avail < ring->num_desc && 
+	       !(descl[idx].data & ADM5120_DMA_OWN)) {
+		dev_kfree_skb_any(skbl[idx]);
+		skbl[idx] = NULL;
+
+		++ring->avail;
+
+		if (++idx == ring->num_desc)
+			idx = 0;
+	}
+
+	ring->tail_idx = idx;
+}
+
+static unsigned long saved_int_st = 0; /* saves not completed ints for next poll iteration */
+
+static int adm5120_poll(struct net_device *dev, int *budget)
+{
+	unsigned long int_st;
+	int work = 0;
+	int start_quota = min(dev->quota, *budget);
+	int quota = start_quota;
+
+
+	int_st = adm5120_get_reg(ADM5120_INT_ST);
+/*	DEBUG_PRINT("      int_st = 0x%.8lx, start_quota = %d\n", int_st, start_quota); */
+	int_st &= ADM5120_INTHANDLE;
+	/* acknowledge ints */
+	adm5120_set_reg(ADM5120_INT_ST, int_st);
+	int_st |= saved_int_st;
+	saved_int_st = 0;
+
+	if (int_st & (ADM5120_INT_TXH | ADM5120_INT_TXL)) {
+		spin_lock_bh(&init_tx_lock);
+
+		/* tx high priority packets to cpu */
+		if (int_st & ADM5120_INT_TXH)	
+			adm5120_tx(&tx_h_ring);
+
+		/* tx normal priority packets to cpu */
+		if (int_st & ADM5120_INT_TXL)	
+			adm5120_tx(&tx_l_ring);
+
+		if( tx_queues_stopped && 
+		    tx_h_ring.avail > ADM5120_TXH_WAKEUP_THRESH && 
+		    tx_l_ring.avail > ADM5120_TXL_WAKEUP_THRESH )
+			adm5120_wake_tx_queues();
+
+		spin_unlock_bh(&init_tx_lock);
+	}
+
+	if (int_st & (ADM5120_INT_RXH | ADM5120_INT_RXL)) {
+		spin_lock_bh(&rx_lock);
+
+		if (int_st & ADM5120_INT_RXH) {
+			if (adm5120_rx(&rx_h_ring, &quota))
+				DEBUG_PRINT("rx hring empty.\n");
+			else
+				saved_int_st |= ADM5120_INT_RXH; /* rx hring not empty */
+		}
+
+		if (int_st & ADM5120_INT_RXL) {
+			if (adm5120_rx(&rx_l_ring, &quota))
+				DEBUG_PRINT("rx lring empty.\n");
+			else
+				saved_int_st |= ADM5120_INT_RXL; /* rx lring not empty */
+		}
+		spin_unlock_bh(&rx_lock);
+	}
+
+	if (int_st & ADM5120_INT_HFULL)
+		DEBUG_PRINT("rx hring full.\n");
+
+	if (int_st & ADM5120_INT_LFULL)
+		DEBUG_PRINT("rx lring full.\n");
+
+
+	work = start_quota - quota;
+	dev->quota -= work;
+	*budget -= work;
+
+/*	DEBUG_PRINT("saved_int_st = 0x%.8lx, work = %d\n", saved_int_st, work); */
+
+	if (!saved_int_st) { /* if all rx rings empty */
+		unsigned long flag;
+
+		DEBUG_PRINT("exiting poll mode.\n");
+		spin_lock_irqsave(&int_lock, flag);
+
+		netif_rx_complete(dev);
+		/* enable ints */
+		_adm5120_try_unmask_int();
+
+		spin_unlock_irqrestore(&int_lock, flag);
+
+		return 0;
+	}
+
+	return 1;
+}
+
+static irqreturn_t
+adm5120_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long flag;
+
+	spin_lock_irqsave(&int_lock, flag);
+
+	if (netif_rx_schedule_prep(&poll_dev)) {
+		/* disable interrupts */
+		_adm5120_mask_int();
+		/* tell system we have work to be done. */
+		__netif_rx_schedule(&poll_dev);
+		DEBUG_PRINT("entering poll mode.\n");
+	} else {
+		printk(KERN_ERR PFX "error!: interrupt while in poll mode"
+		       ", mask: 0x%.8lx, state: 0x%.8lx\n", 
+		       adm5120_get_reg(ADM5120_INT_MASK), adm5120_get_reg(ADM5120_INT_ST));
+	}
+
+	spin_unlock_irqrestore(&int_lock, flag);
+	return IRQ_HANDLED;
+}
+
+static int adm5120_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int ret = 0;
+	struct tx_ring *ring = &tx_l_ring;
+	volatile struct adm5120_dma *desc;
+	struct adm5120_sw *priv = dev->priv;
+	int trigger = ADM5120_SEND_TRIG_L;
+	int idx;
+	u32 len;
+
+	spin_lock_bh(&init_tx_lock);
+
+	idx = ring->head_idx;
+	desc = &ring->desc[idx];
+
+	dev->trans_start = jiffies;
+	if (ring->avail == 0) {
+/*		dev_kfree_skb(skb);*/
+		priv->stats.tx_dropped++;
+#if 0
+		adm5120_print_regs();
+		adm5120_print_tx_ring(ring);
+#endif
+/*		printk(KERN_INFO PFX "warning: tx ring full when queue awake!\n");*/
+
+		ret = 1;
+		goto out;
+	}
+
+	ring->skb[ring->head_idx] = skb;
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+
+/*	desc->cntl = 0;*/
+	desc->len = skb->len; /* len; */
+	desc->status = (len << ADM5120_DMA_LENSHIFT) | priv->vlan_mask;
+	wmb();
+	desc->data = (ADM5120_DMA_ADDR(skb->data) | ADM5120_DMA_OWN |
+		(idx == ring->num_desc - 1 ? ADM5120_DMA_RINGEND : 0));
+	wmb();
+/*	udelay(10);*/
+	adm5120_set_reg(ADM5120_SEND_TRIG, trigger);
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += skb->len;
+
+	--ring->avail;
+	if (ring->avail == 0 && !tx_queues_stopped)
+		adm5120_stop_tx_queues();
+	
+	if (++idx == ring->num_desc)
+		idx = 0;
+
+	ring->head_idx = idx;
+
+out:	
+	spin_unlock_bh(&init_tx_lock);
+
+	return ret;
+}
+
+#if 0
+static void adm5120_tx_timeout(struct net_device *dev)
+{
+	/* restart switch */
+	adm5120_restart();
+}
+#endif
+
+static void tx_watchdog(unsigned long arg)
+{
+	printk(KERN_ERR PFX "error: tx ring hangup, will reset switch\n");
+	adm5120_restart();
+}
+
+static void adm5120_set_vlan(char *matrix)
+{
+	unsigned long val;
+
+	val = matrix[0] + (matrix[1]<<8) + (matrix[2]<<16) + (matrix[3]<<24);
+	adm5120_set_reg(ADM5120_VLAN_GI, val);
+	val = matrix[4] + (matrix[5]<<8);
+	adm5120_set_reg(ADM5120_VLAN_GII, val);
+}
+
+static void adm5120_set_vlan_mask(int vlan, unsigned long vlan_mask)
+{
+	unsigned long reg;
+	int shift;
+	unsigned long mask = 0x7f;
+
+	if (vlan < 0 || vlan > 6) 
+		return;
+	
+	vlan_mask &= 0x7f;
+	if (vlan <= 3)
+	{
+		shift = 8 * vlan;
+		reg = adm5120_get_reg(ADM5120_VLAN_GI) & ~(mask << shift);
+		reg |= vlan_mask << shift;
+		adm5120_set_reg(ADM5120_VLAN_GI, reg);
+	}
+	else
+	{
+		shift = 8 * (vlan - 4);
+		reg = adm5120_get_reg(ADM5120_VLAN_GII) & ~(mask << shift);
+		reg |= vlan_mask << shift;
+		adm5120_set_reg(ADM5120_VLAN_GII, reg);
+	}
+}
+static void adm5120_clear_vlan_mask(int vlan)
+{
+	unsigned long reg;
+	int shift;
+	unsigned long mask = 0x7f;
+
+	if (vlan < 0 || vlan > 6) 
+		return;
+	
+	if (vlan <= 3)
+	{
+		shift = 8 * vlan;
+		reg = adm5120_get_reg(ADM5120_VLAN_GI) & ~(mask << shift);
+		adm5120_set_reg(ADM5120_VLAN_GI, reg);
+	}
+	else
+	{
+		shift = 8 * (vlan - 4);
+		reg = adm5120_get_reg(ADM5120_VLAN_GII) & ~(mask << shift);
+		adm5120_set_reg(ADM5120_VLAN_GII, reg);
+	}
+}
+
+static struct net_device_stats *adm5120_stats(struct net_device *dev)
+{
+	return &((struct adm5120_sw *)dev->priv)->stats;
+}
+
+static void adm5120_set_multicast_list(struct net_device *dev)
+{
+	struct adm5120_sw *priv = dev->priv;
+	int portmask;
+
+	portmask = vlan_matrix[priv->vlan] & 0x3f;
+
+	if (dev->flags & IFF_PROMISC)
+		adm5120_set_reg(ADM5120_CPUP_CONF,
+		    adm5120_get_reg(ADM5120_CPUP_CONF) &
+		    ~((portmask << ADM5120_DISUNSHIFT) & ADM5120_DISUNALL));
+	else
+		adm5120_set_reg(ADM5120_CPUP_CONF,
+		    adm5120_get_reg(ADM5120_CPUP_CONF) |
+		    (portmask << ADM5120_DISUNSHIFT));
+
+	if (dev->flags & IFF_PROMISC || dev->flags & IFF_ALLMULTI ||
+	    dev->mc_count)
+		adm5120_set_reg(ADM5120_CPUP_CONF,
+		    adm5120_get_reg(ADM5120_CPUP_CONF) &
+		    ~((portmask << ADM5120_DISMCSHIFT) & ADM5120_DISMCALL));
+	else
+		adm5120_set_reg(ADM5120_CPUP_CONF,
+		    adm5120_get_reg(ADM5120_CPUP_CONF) |
+		    (portmask << ADM5120_DISMCSHIFT));
+}
+
+static void adm5120_write_mac(struct net_device *dev)
+{
+	struct adm5120_sw *priv = dev->priv;
+	unsigned char *mac = dev->dev_addr;
+
+	adm5120_set_reg(ADM5120_MAC_WT1,
+	    mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+	adm5120_set_reg(ADM5120_MAC_WT0, 
+			(mac[0] << 16) | (mac[1] << 24) | 
+			(priv->vlan << 3) | ADM5120_MAC_WRITE | ADM5120_VLAN_EN);
+
+	while (!(adm5120_get_reg(ADM5120_MAC_WT0) & ADM5120_MAC_WRITE_DONE));
+}
+
+static int adm5120_set_mac_address(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = p;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+	adm5120_write_mac(dev);
+	return 0;
+}
+
+static void make_port2vlan(void)
+{
+	int vlan, port;
+
+	for (port = 0; port < SW_MAX_PORTS; ++port)
+		port2vlan[port] = -1;
+	
+	for (vlan = 0; vlan < adm5120_nrdevs; vlan++) {
+		for (port = 0; port < SW_MAX_PORTS; ++port) {
+			if (vlan_matrix[vlan] & (1 << port))
+				port2vlan[port] = vlan;
+		}
+	}
+}
+
+static int adm5120_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	int err;
+	struct adm5120_info info;
+	struct adm5120_sw *priv = dev->priv;
+
+	switch(cmd) {
+		case SIOCGADMINFO:
+			info.magic = 0x5120;
+			info.ports = adm5120_nrdevs;
+			info.vlan = priv->vlan;
+			err = copy_to_user(rq->ifr_data, &info, sizeof(info));
+			if (err)
+				return -EFAULT;
+			break;
+		case SIOCSMATRIX:
+			if (!capable(CAP_NET_ADMIN))
+				return -EPERM;
+			err = copy_from_user(vlan_matrix, rq->ifr_data,
+			    sizeof(vlan_matrix));
+			if (err)
+				return -EFAULT;
+			make_port2vlan();
+			adm5120_set_vlan(vlan_matrix);
+			break;
+		case SIOCGMATRIX:
+			err = copy_to_user(rq->ifr_data, vlan_matrix,
+			    sizeof(vlan_matrix));
+			if (err)
+				return -EFAULT;
+			break;
+		default:
+			return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static void adm5120_dma_tx_init(struct tx_ring *ring, struct adm5120_dma *dma, 
+				struct sk_buff **skb, int num)
+{
+	memset(dma, 0, sizeof(struct adm5120_dma) * num);
+	dma[num - 1].data |= ADM5120_DMA_RINGEND;
+	memset(skb, 0, sizeof(struct skb*) * num);
+
+	ring->desc = (void *) KSEG1ADDR((u32)dma);
+	ring->skb = skb;
+	ring->num_desc = num;
+	ring->avail = num;
+	ring->head_idx = 0;
+	ring->tail_idx = 0;
+}
+
+static void adm5120_dma_tx_free(struct tx_ring *ring)
+{
+	struct sk_buff **skbl = ring->skb;
+	int idx = ring->tail_idx;
+
+	while (ring->avail < ring->num_desc) {
+		dev_kfree_skb_any(skbl[idx]);
+		skbl[idx] = NULL;
+
+		++ring->avail;
+
+		if (++idx == ring->num_desc)
+			idx = 0;
+	}
+
+/*	ring->tail_idx = idx; */
+}
+
+static void adm5120_dma_tx_reinit(struct tx_ring *ring)
+{
+	adm5120_dma_tx_free(ring);
+
+	memset(ring->desc, 0, sizeof(struct adm5120_dma) * ring->num_desc);
+	ring->desc[ring->num_desc - 1].data |= ADM5120_DMA_RINGEND;
+	memset(ring->skb, 0, sizeof(struct skb*) * ring->num_desc);
+
+	ring->tail_idx = 0;
+	ring->head_idx = 0;
+}
+
+static int adm5120_dma_rx_init(struct rx_ring *ring, struct adm5120_dma *dma, 
+				struct sk_buff **skb, int num)
+{
+	int i;
+	int ret = 0;
+
+	memset(dma, 0, sizeof(struct adm5120_dma) * num);
+	for (i = 0; i < num; i++) {
+		skb[i] = dev_alloc_skb(ADM5120_DMA_RXSIZE + 16);
+		if (!skb[i])
+		{
+			printk(KERN_INFO PFX "error: can't alloc rx buffers\n");
+			ret = -ENOMEM;
+			goto error;
+		}
+
+		skb_reserve(skb[i], 2);
+		dma[i].data = ADM5120_DMA_ADDR(skb[i]->data) | ADM5120_DMA_OWN;
+		dma[i].cntl = 0;
+		dma[i].len = ADM5120_DMA_RXSIZE;
+		dma[i].status = 0;
+	}
+	dma[i - 1].data |= ADM5120_DMA_RINGEND;
+
+	ring->desc = (void *) KSEG1ADDR((u32)dma);
+	ring->skb = skb;
+	ring->num_desc = num;
+	ring->idx = 0;
+
+exit:
+	return ret;
+error:
+	while (i--)
+		dev_kfree_skb(skb[i]);
+/*	
+	memset(dma, 0, sizeof(struct adm5120_dma) * num);
+	memset(skb, 0, sizeof(struct sk_buff *) * num);
+	memset(ring, 0, sizeof(struct rx_ring));
+*/
+	goto exit;
+}
+
+static void adm5120_dma_rx_reinit(struct rx_ring *ring)
+{
+	int idx = rx_h_ring.idx;
+	volatile struct adm5120_dma *descl = rx_h_ring.desc;
+	volatile struct adm5120_dma *desc;
+	struct sk_buff **skbl = ring->skb;
+
+	idx = rx_h_ring.idx;
+	desc = rx_h_ring.desc;
+	while (!(descl[idx].data & ADM5120_DMA_OWN)) {
+		desc = &descl[idx];
+
+		desc->status = 0;
+		desc->cntl = 0;
+		desc->len = ADM5120_DMA_RXSIZE;
+		wmb();
+		desc->data = ADM5120_DMA_ADDR(skbl[idx]->data) | ADM5120_DMA_OWN |
+			(idx == ring->num_desc - 1 ? ADM5120_DMA_RINGEND : 0);
+
+		if (++idx == rx_h_ring.num_desc)
+			idx = 0;
+	}
+
+	ring->idx = 0;
+}
+
+static void adm5120_dma_rx_free(struct rx_ring *ring)
+{
+	int i;
+	struct sk_buff **skb = ring->skb;
+	int num = ring->num_desc;
+
+	for (i = 0; i < num; i++)
+		dev_kfree_skb(skb[i]);
+}
+
+static int adm5120_dma_init_rings(void)
+{
+	int ret;
+
+	ret = adm5120_dma_rx_init(&rx_h_ring, adm5120_dma_rxh_v, adm5120_skb_rxh, ADM5120_DMA_RXH);
+	if (ret)
+		goto exit;
+
+	ret = adm5120_dma_rx_init(&rx_l_ring, adm5120_dma_rxl_v, adm5120_skb_rxl, ADM5120_DMA_RXL);
+	if (ret)
+		goto exit;
+
+	adm5120_dma_tx_init(&tx_h_ring, adm5120_dma_txh_v, adm5120_skb_txh, ADM5120_DMA_TXH);
+	adm5120_dma_tx_init(&tx_l_ring, adm5120_dma_txl_v, adm5120_skb_txl, ADM5120_DMA_TXL);
+exit:
+	return ret;
+}
+
+static void adm5120_dma_reinit_rings(void)
+{
+	adm5120_dma_rx_reinit(&rx_h_ring); 
+	adm5120_dma_rx_reinit(&rx_l_ring);
+
+	adm5120_dma_tx_reinit(&tx_h_ring);
+	adm5120_dma_tx_reinit(&tx_l_ring);
+}
+
+static void adm5120_dma_free_rings(void)
+{
+	adm5120_dma_rx_free(&rx_h_ring);
+	adm5120_dma_rx_free(&rx_l_ring);
+
+	adm5120_dma_tx_free(&tx_h_ring);
+	adm5120_dma_tx_free(&tx_l_ring);
+}
+
+static void _adm5120_reset(void)
+{
+	DEBUG_PRINT("regs before reset:\n");
+	adm5120_print_regs();
+
+	/* Resetting PHY before switch reset */
+	adm5120_set_reg(ADM5120_PHY_CNTL2,
+			adm5120_get_reg(ADM5120_PHY_CNTL2) & ~ADM5120_NORMAL); 
+/*	adm5120_set_reg(ADM5120_PHY_CNTL2,
+		adm5120_get_reg(ADM5120_PHY_CNTL2) | ADM5120_NORMAL); */
+
+	/* Switch reset */
+	adm5120_set_reg(ADM5120_SWITCH_RESET, 0x01);
+
+	udelay(1000);
+
+
+	DEBUG_PRINT("regs after reset:\n");
+	adm5120_print_regs();
+}
+
+static void _adm5120_up(void)
+{
+	/* disable ints */
+	adm5120_disable_int();
+	adm5120_set_reg(ADM5120_INT_ST, ADM5120_INTMASKALL);
+
+
+	adm5120_set_reg(ADM5120_CPUP_CONF,
+			ADM5120_DISCCPUPORT | ADM5120_CRC_PADDING |
+			ADM5120_DISUNALL | ADM5120_DISMCALL);
+	adm5120_set_reg(ADM5120_PORT_CONF0, ADM5120_ENMC | ADM5120_ENBP | ADM5120_DISALL);
+
+	adm5120_set_reg(ADM5120_PHY_CNTL2, adm5120_get_reg(ADM5120_PHY_CNTL2) |
+			ADM5120_AUTONEG | ADM5120_NORMAL | ADM5120_AUTOMDIX);
+	adm5120_set_reg(ADM5120_PHY_CNTL3, adm5120_get_reg(ADM5120_PHY_CNTL3) |
+			ADM5120_PHY_NTH);
+
+	/* clear all vlan settings */
+	adm5120_set_reg(ADM5120_VLAN_GI, 0);
+	adm5120_set_reg(ADM5120_VLAN_GII, 0);
+
+	/* set tx/rx rings */
+	adm5120_set_reg(ADM5120_SEND_HBADDR, (u32) adm5120_dma_txh_v);
+	adm5120_set_reg(ADM5120_SEND_LBADDR, (u32) adm5120_dma_txl_v);
+	adm5120_set_reg(ADM5120_RECEIVE_HBADDR, (u32) adm5120_dma_rxh_v);
+	adm5120_set_reg(ADM5120_RECEIVE_LBADDR, (u32) adm5120_dma_rxl_v);
+
+	/* enable ints */
+	adm5120_enable_int();
+
+	/* enable CPU port */
+	adm5120_set_reg(ADM5120_CPUP_CONF,
+			ADM5120_CRC_PADDING | ADM5120_DISUNALL | ADM5120_DISMCALL);
+
+/*	adm5120_set_vlan(vlan_matrix); */
+}
+
+static void _adm5120_down(void)
+{
+	/* disable ints */
+	adm5120_disable_int();
+
+	/* Disable all ports */
+	adm5120_set_reg(ADM5120_PORT_CONF0,
+			adm5120_get_reg(ADM5120_PORT_CONF0) | ADM5120_DISALL);
+	/* Disable CPU port */
+	adm5120_set_reg(ADM5120_CPUP_CONF,
+			adm5120_get_reg(ADM5120_CPUP_CONF) | ADM5120_DISCCPUPORT);
+
+	/* Wait until switch DMA idle. At least 1ms is required!!!! */
+	mdelay(2);
+
+	/* reset switch  */
+	_adm5120_reset();
+}
+
+
+static void adm5120_disable_all_ports(u32 vlan_mask)
+{
+	adm5120_set_reg(ADM5120_PORT_CONF0, 
+			adm5120_get_reg(ADM5120_PORT_CONF0) | ADM5120_DISALL);
+}
+
+static void adm5120_enable_ports(u32 vlan_mask)
+{
+	int i;
+	unsigned long enable_ports;
+
+	enable_ports = 0;
+	for (i = 0; i < adm5120_nrdevs; i++) {
+		if (vlan_mask & (1 << i))
+			enable_ports |= vlan_matrix[i];
+	}
+	/* enable ports of active vlans */
+	adm5120_set_reg(ADM5120_PORT_CONF0,
+			(adm5120_get_reg(ADM5120_PORT_CONF0) & ~ADM5120_DISALL) | (~enable_ports & 0x3f));
+}
+
+static int adm5120_open(struct net_device *dev)
+{
+	int ret = 0;
+	struct adm5120_sw *priv = dev->priv;
+
+	spin_lock_bh(&init_tx_lock);
+	
+	if (!enable_vlan_mask) {
+		spin_lock_bh(&rx_lock);
+
+		ret = adm5120_dma_init_rings();
+		if (ret)
+			goto exit;
+
+		_adm5120_up();
+
+		tx_queues_stopped = 0;
+
+		spin_unlock_bh(&rx_lock);
+	}
+
+	enable_vlan_mask |= priv->vlan_mask;
+
+	/* enable ports of active vlans */
+	adm5120_enable_ports(enable_vlan_mask);
+
+	/* enable vlan */
+	adm5120_set_vlan_mask(priv->vlan, vlan_matrix[priv->vlan]);
+
+	/* set mac address */
+	adm5120_write_mac(dev);
+
+	if (tx_queues_stopped)
+		netif_stop_queue(dev);
+	else
+		netif_start_queue(dev);
+	
+exit:
+	spin_unlock_bh(&init_tx_lock);
+
+	return ret;
+}
+
+static int adm5120_stop(struct net_device *dev)
+{
+	struct adm5120_sw *priv = dev->priv;
+
+	spin_lock_bh(&init_tx_lock);
+
+	if (!tx_queues_stopped)
+		netif_stop_queue(dev);
+
+	enable_vlan_mask &= ~priv->vlan_mask;
+
+	/* enable ports of active vlans */
+	adm5120_enable_ports(enable_vlan_mask);
+	/* disable vlan */
+	adm5120_clear_vlan_mask(priv->vlan);
+
+
+	if (!enable_vlan_mask) {
+		spin_lock_bh(&rx_lock);
+
+		del_timer(&tx_watchdog_timer);
+
+		_adm5120_down();
+		adm5120_dma_free_rings();
+
+		spin_unlock_bh(&rx_lock);
+	}
+
+	spin_unlock_bh(&init_tx_lock);
+
+	return 0;
+}
+
+static void adm5120_restart(void)
+{
+	int i;
+
+	spin_lock_bh(&init_tx_lock);
+
+	if (!enable_vlan_mask || !tx_queues_stopped)
+		goto out;
+
+	spin_lock_bh(&rx_lock);
+
+	_adm5120_down();
+	adm5120_dma_reinit_rings();
+	_adm5120_up();
+
+	spin_unlock_bh(&rx_lock);
+
+	/* enable ports of active vlans */
+	adm5120_enable_ports(enable_vlan_mask);
+
+	for (i = 0; i < adm5120_nrdevs; i++) {
+		if (enable_vlan_mask & (1 << i)) {
+			/* enable vlan */
+			adm5120_set_vlan_mask(i, vlan_matrix[i]);
+			/* set mac address */
+			adm5120_write_mac(adm5120_devs[i]);
+		}
+	}
+
+
+	adm5120_wake_tx_queues();
+
+out:
+	spin_unlock_bh(&init_tx_lock);
+}
+
+
+
+static int adm5120_get_regs(char *buf)
+{
+	unsigned int reg;
+	char *p = buf;
+
+	for (reg = 0; reg <= 0x110; reg += 4)
+		p += sprintf(p, "%3.2x: 0x%.8lx\n", reg, adm5120_get_reg(reg));
+
+	return p - buf;
+}
+
+static int adm5120_get_state(char *buf)
+{
+	char *p = buf;
+
+	p += sprintf(p, "      int_enabled: %d\n", int_enabled);
+	p += sprintf(p, "tx_queues_stopped: %d\n", tx_queues_stopped);
+	p += sprintf(p, " enable_vlan_mask: 0x%.2x\n", enable_vlan_mask);
+
+	return p - buf;
+}
+
+static int adm5120_get_tx_ring(char *buf, struct tx_ring *ring)
+{
+	int i;
+	volatile struct adm5120_dma *desc = ring->desc;
+	struct sk_buff **skb = ring->skb;
+	char *p = buf;
+
+	p += sprintf(p, "    desc: 0x%.8p\n", ring->desc);
+	p += sprintf(p, "     skb: 0x%.8p\n", ring->skb);
+	p += sprintf(p, "num_desc: %d\n", ring->num_desc);
+	p += sprintf(p, "   avail: %d\n", ring->avail);
+	p += sprintf(p, "head_idx: %d\n", ring->head_idx);
+	p += sprintf(p, "tail_idx: %d\n\n", ring->tail_idx);
+
+	for (i = 0; i < ring->num_desc; ++i) {
+		p += sprintf(p, "%4d: skb: 0x%.8p%s%s%s%s\n", i, 
+			     skb[i],
+			     desc[i].data & ADM5120_DMA_OWN ? " OWN" : "",
+			     desc[i].data & ADM5120_DMA_RINGEND ? " RINGEND" : "",
+			     i == ring->head_idx ? " head" : "",
+			     i == ring->tail_idx ? " tail" : "");
+	}
+
+	return p - buf;
+}
+
+static int adm5120_get_rx_ring(char *buf, struct rx_ring *ring)
+{
+	int i;
+	volatile struct adm5120_dma *desc = ring->desc;
+	struct sk_buff **skb = ring->skb;
+	char *p = buf;
+
+	p += sprintf(p, "    desc: 0x%.8p\n", ring->desc);
+	p += sprintf(p, "     skb: 0x%.8p\n", ring->skb);
+	p += sprintf(p, "num_desc: %d\n", ring->num_desc);
+	p += sprintf(p, "     idx: %d\n", ring->idx);
+
+	for (i = 0; i < ring->num_desc; ++i) {
+		p += sprintf(p, "%4d: skb: 0x%.8p%s%s%s\n", i, 
+			     skb[i],
+			     desc[i].data & ADM5120_DMA_OWN ? " OWN" : "",
+			     desc[i].data & ADM5120_DMA_RINGEND ? " RINGEND" : "",
+			     i == ring->idx ? " idx" : "" );
+	}
+
+	return p - buf;
+}
+
+static int proc_calc_metrics(char *page, char **start, off_t off,
+				 int count, int *eof, int len)
+{
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+}
+
+static int adm5120_read_state_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+
+	spin_lock_bh(&init_tx_lock);
+	len = adm5120_get_state(page);
+	spin_unlock_bh(&init_tx_lock);
+
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int adm5120_read_regs_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len = adm5120_get_regs(page);
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int adm5120_read_tx_hring_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+
+	spin_lock_bh(&init_tx_lock);
+	len = adm5120_get_tx_ring(page, &tx_h_ring);
+	spin_unlock_bh(&init_tx_lock);
+
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int adm5120_read_tx_lring_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+
+	spin_lock_bh(&init_tx_lock);
+	len = adm5120_get_tx_ring(page, &tx_l_ring);
+	spin_unlock_bh(&init_tx_lock);
+
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int adm5120_read_rx_hring_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+
+	spin_lock_bh(&rx_lock);
+	len = adm5120_get_rx_ring(page, &rx_h_ring);
+	spin_unlock_bh(&rx_lock);
+
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int adm5120_read_rx_lring_proc(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	int len;
+
+	spin_lock_bh(&rx_lock);
+	len = adm5120_get_rx_ring(page, &rx_l_ring);
+	spin_unlock_bh(&rx_lock);
+
+	return proc_calc_metrics(page, start, off, count, eof, len);
+}
+
+static int __init adm5120_init(void)
+{
+	int i, err;
+	struct net_device *dev;
+
+	printk("adm5120 switch driver version 1.1\n");
+	printk(PFX "initialized with %d vlans.\n", adm5120_nrdevs);
+	printk(PFX "using NAPI.\n" ); 
+	printk(PFX "ring sizes:\n" );
+	printk(PFX "rxh = %d, rxl = %d\n", ADM5120_DMA_RXH, ADM5120_DMA_RXL );
+	printk(PFX "txh = %d, txl = %d\n", ADM5120_DMA_TXH, ADM5120_DMA_TXL );
+
+	adm5120_disable_int();
+	err = request_irq(SW_IRQ, adm5120_irq, 0, "ethernet switch", NULL);
+	if (err) {
+		printk(KERN_INFO PFX "error: can't register interrupt handler\n");
+		goto out;
+	}
+
+	make_port2vlan();
+
+	init_timer(&tx_watchdog_timer);
+	tx_watchdog_timer.data = (unsigned long) 0;
+	tx_watchdog_timer.function = tx_watchdog;
+
+	for (i = 0; i < adm5120_nrdevs; i++) {
+		dev = alloc_etherdev(sizeof(struct adm5120_sw));
+		if (!dev) {
+			err = -ENOMEM;
+			goto out_int;
+		}
+		adm5120_devs[i] = dev;
+
+		strcpy(dev->name, IFACE_NAME_PFX "%d");
+		
+		SET_MODULE_OWNER(dev);
+		memset(dev->priv, 0, sizeof(struct adm5120_sw));
+		((struct adm5120_sw*)dev->priv)->vlan = i;
+		((struct adm5120_sw*)dev->priv)->vlan_mask = (u32) 1 << i;
+		dev->base_addr = SW_BASE;
+		dev->irq = SW_IRQ;
+
+		dev->open = adm5120_open;
+		dev->stop = adm5120_stop;
+		dev->hard_start_xmit = adm5120_start_xmit;
+
+		dev->get_stats = adm5120_stats;
+		dev->set_multicast_list = adm5120_set_multicast_list;
+		dev->set_mac_address = adm5120_set_mac_address;
+		dev->do_ioctl = adm5120_do_ioctl;
+
+#if 0
+		dev->tx_timeout = adm5120_tx_timeout;
+		dev->watchdog_timeo = ETH_TX_TIMEOUT;
+#endif
+		/* HACK alert!!!  In the original admtek driver it is asumed
+		   that you can read the MAC addressess from flash, but edimax
+		   decided to leave that space intentionally blank...
+		 */
+/*		memcpy(dev->dev_addr, "\x00\x50\xfc\x11\x22\x01", 6);
+		dev->dev_addr[5] += i;*/
+	        memcpy(dev->dev_addr, default_macaddrs[i], 6);
+		
+		err = register_netdev(dev);
+		if (err) {
+		        unregister_netdev(dev);
+			goto out_int;
+		}
+	}
+
+	create_proc_read_entry("adm5120sw-regs", 0, NULL, adm5120_read_regs_proc, NULL);
+	create_proc_read_entry("adm5120sw-state", 0, NULL, adm5120_read_state_proc, NULL);
+	create_proc_read_entry("adm5120sw-txh", 0, NULL, adm5120_read_tx_hring_proc, NULL);
+	create_proc_read_entry("adm5120sw-txl", 0, NULL, adm5120_read_tx_lring_proc, NULL);
+	create_proc_read_entry("adm5120sw-rxh", 0, NULL, adm5120_read_rx_hring_proc, NULL);
+	create_proc_read_entry("adm5120sw-rxl", 0, NULL, adm5120_read_rx_lring_proc, NULL);
+	
+
+	return 0;
+
+out_int:
+	/* Undo everything that did succeed */
+	while (i--)
+		unregister_netdev(adm5120_devs[i]);
+
+	free_irq(SW_IRQ, NULL);
+out:
+	printk(KERN_ERR PFX "init failed.\n");
+	return err;
+}
+
+static void __exit adm5120_exit(void)
+{
+	int i;
+
+	remove_proc_entry("adm5120sw-regs", NULL);
+	remove_proc_entry("adm5120sw-state", NULL);
+	remove_proc_entry("adm5120sw-txh", NULL);
+	remove_proc_entry("adm5120sw-txl", NULL);
+	remove_proc_entry("adm5120sw-rxh", NULL);
+	remove_proc_entry("adm5120sw-rxl", NULL);
+
+	for (i = 0; i < adm5120_nrdevs; i++) {
+		unregister_netdev(adm5120_devs[i]);
+	}
+
+	free_irq(SW_IRQ, NULL);
+
+}
+
+module_init(adm5120_init);
+module_exit(adm5120_exit);
Index: linux/drivers/net/adm5120sw_napi.h
===================================================================
--- linux/drivers/net/adm5120sw_napi.h	(.../linux)	(revision 0)
+++ linux/drivers/net/adm5120sw_napi.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,139 @@
+/*
+ *	Defines for ADM5120 built in ethernet switch driver
+ *
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ *
+ *	Values come from ADM5120 datasheet and original ADMtek 2.4 driver,
+ *	Copyright ADMtek Inc.
+ */
+
+#ifndef _INCLUDE_ADM5120SW_H_
+#define _INCLUDE_ADM5120SW_H_
+
+#define IFACE_NAME_PFX "adm"
+
+#define SW_BASE	KSEG1ADDR(0x12000000)
+#define SW_DEVS	6
+#define SW_MAX_PORTS 6
+#define SW_IRQ 	9
+
+#define ETH_TX_TIMEOUT  HZ/4
+#define ETH_FCS 4;
+
+#define ADM5120_CODE		0x00		/* CPU description */
+#define ADM5120_CODE_PQFP	0x20000000	/* package type */
+#define ADM5120_SWITCH_RESET	0x0c		/* switch reset */
+#define ADM5120_CPUP_CONF	0x24		/* CPU port config */
+#define ADM5120_DISCCPUPORT	0x00000001	/* disable cpu port */
+#define ADM5120_CRC_PADDING	0x00000002	/* software crc */
+#define ADM5120_DISUNSHIFT	9
+#define ADM5120_DISUNALL	0x00007e00	/* disable unknown from all */
+#define ADM5120_DISMCSHIFT	16
+#define ADM5120_DISMCALL	0x003f0000	/* disable multicast from all */
+#define ADM5120_PORT_CONF0	0x28
+#define ADM5120_DISALL		0x0000003f	/* Disable all ports */
+#define ADM5120_ENMC		0x00003f00	/* Enable MC routing (ex cpu) */
+#define ADM5120_ENBP		0x003f0000	/* Enable Back Pressure */
+#define ADM5120_VLAN_GI		0x40		/* VLAN settings */
+#define ADM5120_VLAN_GII	0x44
+#define ADM5120_SEND_TRIG	0x48
+#define ADM5120_SEND_TRIG_L	0x00000001
+#define ADM5120_SEND_TRIG_H	0x00000002
+#define ADM5120_MAC_WT0		0x58
+#define ADM5120_MAC_WRITE	0x00000001
+#define ADM5120_MAC_WRITE_DONE	0x00000002
+#define ADM5120_VLAN_EN		0x00000040
+#define ADM5120_MAC_WT1		0x5c
+#define ADM5120_PHY_CNTL2	0x7c
+#define ADM5120_AUTONEG		0x0000001f	/* Auto negotiate */
+#define ADM5120_NORMAL		0x01f00000	/* PHY normal mode */
+#define ADM5120_AUTOMDIX	0x3e000000	/* Auto MDIX */
+#define ADM5120_PHY_CNTL3	0x80
+#define ADM5120_PHY_NTH		0x00000400
+#define ADM5120_INT_ST		0xb0
+#define ADM5120_INT_RXH		0x0000004
+#define ADM5120_INT_RXL		0x0000008
+#define ADM5120_INT_HFULL	0x0000010
+#define ADM5120_INT_LFULL	0x0000020
+#define ADM5120_INT_TXH		0x0000001
+#define ADM5120_INT_TXL		0x0000002
+#define ADM5120_INT_MASK	0xb4
+#define ADM5120_INTMASKALL	0x1fdefff	/* All interrupts */
+#define ADM5120_INTHANDLE	(ADM5120_INT_RXH | ADM5120_INT_RXL | \
+				 ADM5120_INT_HFULL | ADM5120_INT_LFULL | \
+				 ADM5120_INT_TXH | ADM5120_INT_TXL)
+#define ADM5120_SEND_HBADDR	0xd0
+#define ADM5120_SEND_LBADDR	0xd4
+#define ADM5120_RECEIVE_HBADDR	0xd8
+#define ADM5120_RECEIVE_LBADDR	0xdc
+
+#define ADM5120_SEND_HWADDR	0xe0
+#define ADM5120_SEND_LWADDR	0xe4
+#define ADM5120_RECEIVE_HWADDR	0xe8
+#define ADM5120_RECEIVE_LWADDR	0xec
+
+struct adm5120_dma {
+	u32 data;
+	u32 cntl;
+	u32 len;
+	u32 status;
+} __attribute__ ((packed));
+
+#define	ADM5120_DMA_MASK	0x00ffffff
+#define ADM5120_DMA_OWN		0x80000000	/* buffer owner */
+#define ADM5120_DMA_RINGEND	0x10000000	/* Last in DMA ring */
+
+#define ADM5120_DMA_ADDR(ptr)	((u32)(ptr) & ADM5120_DMA_MASK)
+#define ADM5120_DMA_PORTID	0x00007000
+#define ADM5120_DMA_PORTSHIFT	12
+#define ADM5120_DMA_LEN		0x07ff0000
+#define ADM5120_DMA_LENSHIFT	16
+#define ADM5120_DMA_FCSERR	0x00000008
+
+#define ADM5120_DMA_TXH		16
+#define ADM5120_DMA_TXL		128
+#define ADM5120_DMA_RXH		16
+#define ADM5120_DMA_RXL		128
+
+#define ADM5120_TXH_WAKEUP_THRESH 8
+#define ADM5120_TXL_WAKEUP_THRESH 16
+
+
+#define ADM5120_DMA_RXSIZE	1550
+#define ADM5120_DMA_EXTRA	20
+
+struct adm5120_sw {
+	int vlan;
+	u32 vlan_mask;
+	struct net_device_stats	stats;
+};
+
+#define SIOCSMATRIX	SIOCDEVPRIVATE
+#define SIOCGMATRIX	SIOCDEVPRIVATE+1
+#define SIOCGADMINFO	SIOCDEVPRIVATE+2
+
+struct adm5120_info {
+	u16	magic;
+	u16	ports;
+	u16	vlan;
+};
+
+
+struct rx_ring {
+	volatile struct adm5120_dma *desc;
+	struct sk_buff **skb;
+	int num_desc;
+	int idx;
+};
+
+struct tx_ring {
+	volatile struct adm5120_dma *desc;
+	struct sk_buff **skb;
+	int num_desc;
+	int avail;
+	int head_idx;
+	int tail_idx;
+};
+
+
+#endif /* _INCLUDE_ADM5120SW_H_ */
Index: linux/drivers/net/Makefile
===================================================================
--- linux/drivers/net/Makefile	(.../linux)	(revision 5)
+++ linux/drivers/net/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -23,6 +23,8 @@
 #
 obj-$(CONFIG_PLIP) += plip.o
 
+obj-y += adm5120sw.o
+
 obj-$(CONFIG_ROADRUNNER) += rrunner.o
 
 obj-$(CONFIG_HAPPYMEAL) += sunhme.o
@@ -38,6 +40,8 @@
 
 obj-$(CONFIG_OAKNET) += oaknet.o 8390.o
 
+obj-y += sg16lan/
+
 obj-$(CONFIG_DGRS) += dgrs.o
 obj-$(CONFIG_VORTEX) += 3c59x.o
 obj-$(CONFIG_TYPHOON) += typhoon.o
Index: linux/drivers/net/sg16lan/cx28975.h
===================================================================
--- linux/drivers/net/sg16lan/cx28975.h	(.../linux)	(revision 0)
+++ linux/drivers/net/sg16lan/cx28975.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,131 @@
+
+enum  CX28975_API_commands {
+	_DSL_RESET_SYSTEM	= 0x00,
+	_DSL_SYSTEM_ENABLE	= 0x01,
+	_DSL_AFE_CONFIG		= 0x02,
+	_DSL_TRAINING_MODE	= 0x03,
+	_DSL_CLOCK_CONFIG	= 0x04,
+	_DSL_PCM_MF_LEN		= 0x05,
+	_DSL_SYSTEM_CONFIG	= 0x06,
+	_DSL_LOOPBACK		= 0x09,
+	_DSL_ACTIVATION		= 0x0b,
+	_DSL_FORCE_DEACTIVATE	= 0x0c,
+	_DSL_TEST_MODE		= 0x0d,
+	_DSL_DATA_RATE		= 0x0e,
+	_DSL_PREACTIVATION_CFG	= 0x0f,
+	_DSL_FR_PCM_CONFIG	= 0x10,
+	_DSL_FR_HDSL_CONFIG	= 0x11,
+	_DSL_PCM_CLK_CONF	= 0x12,
+	_DSL_GHS_GET_FINAL_RATE = 0x81,
+	_AFE_TX_GAIN		= 0x13,
+	_DSL_PREACT_USER_INFO	= 0x14,
+	_DSL_PREACT_RATE_LIST	= 0x15,
+	_DSL_TX_ISO_PULSE	= 0x16,
+	_BP_ERLE_TEST_MODE	= 0x18,
+	_DSL_MULTI_PAIR_CONFIG	= 0x19,
+	_DSL_NB_MULTI_RATE_CONFIG	= 0x1a,
+	_DSL_MULTI_RATE_CONFIG	= 0x1b,
+	_ATM_PHY_MODE		= 0x1c,
+	_ATM_PHY_UTOPIA_CONFIG	= 0x1d,
+	_ATM_PHY_IF_MODE	= 0x1e,
+	_ATM_PHY_INJECT_HEC_ERROR	= 0x1f,
+	_ATM_PHY_CONFIG		= 0x20,
+	_DSL_TNB_BER_STATE	= 0x21,
+	_DSL_RNB_BER_STATE	= 0x22,
+	_DSL_TP_BER_STATE	= 0x23,
+	_DSL_RP_BER_STATE	= 0x24,
+	_DSL_PRBS_CONFIGURE	= 0x25,
+	_DSL_CONST_FILL		= 0x26,
+	_DSL_DBANK		= 0x27,
+	_DSL_NB_CONFIG		= 0x28,
+	_DSL_TNB_FRM_OFST	= 0x29,
+	_DSL_RNB_FRM_OFST	= 0x2a,
+	_DSL_TP_FRM_OFST	= 0x2e,
+	_DSL_RP_FRM_OFST	= 0x2f,
+	_DSL_TP_MAPPER_VALUE	= 0x30,
+	_DSL_TP_MAPPER_WRITE	= 0x31,
+	_DSL_RP_MAPPER_VALUE	= 0x32,
+	_DSL_RP_MAPPER_WRITE	= 0x33,
+	_DSL_TH_MAPPER_VALUE	= 0x34,
+	_DSL_TH_MAPPER_WRITE	= 0x35,
+	_DSL_RH_MAPPER_VALUE	= 0x36,
+	_DSL_RH_MAPPER_WRITE	= 0x37,
+	_DSL_TNB_MAPPER_VALUE	= 0x38,
+	_DSL_TNB_MAPPER_WRITE	= 0x39,
+	_DSL_RNB_MAPPER_VALUE	= 0x3a,
+	_DSL_RNB_MAPPER_WRITE	= 0x3b,
+	_DSL_CLEAR_ERROR_CTRS	= 0x40,
+	_DSL_INJECT_CRC_ERROR	= 0x41,
+	_DSL_THRESHOLDS		= 0x43,
+	_DSL_FR_SET_STATE_MACHINE	= 0x4a,
+	_DSL_FR_TNB_RESET	= 0x4b,
+	_DSL_FR_RNB_RESET	= 0x4c,
+	_EOC_RESET		= 0x4d,
+	_DSL_FR_TX_RESET	= 0x4e,
+	_DSL_FR_RX_RESET	= 0x4f,
+	_DSL_INTR_HOST_MASK	= 0x50,
+	_DSL_INTR_API_SUBMASK	= 0x51,
+	_DSL_DOWNLOAD_START	= 0x53,
+	_DSL_DOWNLOAD_DATA	= 0x54,
+	_DSL_DOWNLOAD_END	= 0x55,
+	_DSL_DPLL_CLOCK_GEN	= 0x58,
+	_DSL_NB_DPLL_CLOCK_GEN	= 0x59,
+	_DSL_WRITE_REG		= 0x75,
+	_DSL_WRITE_AFE		= 0x76
+};
+
+enum  CX28975_status_commands {
+	_DSL_READ_CONTROL	= 0x80,
+	_DSL_FAR_END_ATTEN	= 0x82,
+	_DSL_NOISE_MARGIN	= 0x83,
+	_DSL_STATUS		= 0x85,
+	_DSL_PREACT_GET_FE_CAPS	= 0x88,
+	_DSL_PREACT_GET_OPT_DATA_RATE	= 0x89,
+	_DSL_VERSIONS		= 0x8a,
+	_DSL_TP_BER_RESULTS	= 0x8c,
+	_DSL_RP_BER_RESULTS	= 0x8d,
+	_DSL_STAGE_NUMBER	= 0x8f,
+	_DSL_AFE_SETTING	= 0x90,
+	_DSL_TNB_BER_RESULTS	= 0x91,
+	_DSL_RNB_BER_RESULTS	= 0x92,
+	_BP_ERLE_RESULTS	= 0x93,
+	_DSL_POWER_BACK_OFF_RESULT	= 0x94,
+	_DSL_OPER_ERR_CTRS	= 0x9c,
+	_DSL_TIME		= 0x9d,
+	_DSL_HDSL_PERF_ERR_CTRS	= 0x9e,
+	_DSL_READ_REG		= 0xa0,
+	_DSL_READ_AFE		= 0xa1,
+	_DSL_SYSTEM_PERF_ERR_CTRS	= 0xa2,
+	_DSL_TP_MAPPER_READ	= 0xa3,
+	_DSL_RP_MAPPER_READ	= 0xa4,
+	_DSL_TH_MAPPER_READ	= 0xa5,
+	_DSL_RH_MAPPER_READ	= 0xa6,
+	_DSL_TNB_MAPPER_READ	= 0xa7,
+	_DSL_RNB_MAPPER_READ	= 0xa8,
+	_EOC_RX_GET_STATS	= 0xae,
+	_EOC_TX_SEND_COMMAND	= 0xb0,
+	_EOC_RX_GET_MSG		= 0xb1,
+	_EOC_TX_GET_MSG_STATUS	= 0xb2,
+	_EOC_TX_DELETE_MSG	= 0xb3,
+	_ATM_PHY_OPER_ERR_CTRS	= 0xb8,
+	_ATM_PHY_PERF_ERR_CTRS	= 0xb9,
+	_ATM_PHY_CELL_CTRS	= 0xba
+};
+
+
+enum  CX28975_acknoledge_status_codes {
+	_ACK_NOT_COMPLETE	= 0x00,
+	_ACK_PASS		= 0x01,
+	_ACK_BUSY		= 0x02,
+	_ACK_NOT_APPLICABLE	= 0x03,
+	_ACK_INVALID_DEST	= 0x04,
+	_ACK_INVALID_OPCODE	= 0x05,
+	_ACK_INVALID_LENGTH	= 0x06,
+	_ACK_INVALID_DATA	= 0x07,
+	_ACK_INVALID_CHKSUM	= 0x08,
+	_ACK_NO_RESULT		= 0x09,
+	_ACK_NOT_AVAILABLE	= 0x0a,
+	_ACK_BOOT_WAKE_UP	= 0x0d,
+	_ACK_OPER_WAKE_UP	= 0x0e
+};
+
Index: linux/drivers/net/sg16lan/sg16lan.c
===================================================================
--- linux/drivers/net/sg16lan/sg16lan.c	(.../linux)	(revision 0)
+++ linux/drivers/net/sg16lan/sg16lan.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,2425 @@
+/* sg16lan.c:  Sigrand SG-16PCI SHDSL modem driver for linux (kernel 2.6.x)
+ *
+ *	Written 2005-2006 by Artem U. Polyakov (artpol@sigrand.ru)
+ *
+ *	This driver presents SG-16PCI modem 
+ *	to system as common ethernet-like netcard.
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU General Public License.
+ *
+ *
+ *	10.11.2005	initial revision of Granch SBNI16 modem driver v1.0 
+ *                      wtitten by Denis I. Timofeev
+ *	11.12.2005	Version 2.0 ( sysfs, firmware hotplug support )
+ */
+
+#include "cx28975.h"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fcntl.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/byteorder.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/timer.h>
+#include <net/arp.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include<linux/firmware.h>
+#include<linux/dma-mapping.h>
+#include <linux/vermagic.h>
+#include <linux/config.h>
+
+#include <asm/tlbdebug.h>
+
+MODULE_DESCRIPTION( "Sigrand SG-16PCI driver Version 2.0\n" );
+MODULE_AUTHOR( "Maintainer: Polyakov Artem artpol@sigrand.ru\n" );
+MODULE_LICENSE( "GPL" );
+MODULE_VERSION("2.0");
+
+/* -------------------------------------------------------------------------- */
+
+/* CR bits */
+#define	TXEN	0x01		/* transmitter enable */
+#define	RXEN	0x02		/* receiver  enable */
+#define	NCRC	0x04		/* ignore received CRC */
+#define	DLBK	0x08		/* digital loopback */
+#define CMOD	0x10		/* 0 - use CRC-32, 1 - CRC-16 */
+#define FMOD	0x20		/* interframe fill: 0 - all ones, 1 - 0xfe */
+#define PMOD	0x40		/* data polarity: 0 - normal, 1 - invert */
+#define XRST	0x80		/* reset the transceiver */
+
+/* CRB bits */
+#define RDBE	0x01		/* read burst enable */
+#define WTBE	0x02		/* write burst enable */
+#define RODD	0x04		/* receive 2-byte alignment */
+#define RXDE	0x08		/* receive data enable */
+
+/* SR and IMR bits */
+#define	TXS	0x01		/* transmit success */
+#define	RXS	0x02		/* receive success */
+/* SR only */
+#define	CRC	0x04		/* CRC error */
+#define	OFL	0x08		/* fifo overflow error */
+#define	UFL	0x10		/* fifo underflow error */
+#define	EXT	0x20		/* interrupt from sk70725 */
+/* IMR only */
+#define	TSI	0x80		/* generate test interrupt */
+
+#define LAST_FRAG 0x00008000
+
+/* We don't have official vendor id yet... */
+#define SG16_PCI_VENDOR 0x55 
+#define SG16_PCI_DEVICE 0x9d
+
+#define ETHER_MIN_LEN	64
+#define SG16_MAX_FRAME	(1536 + 16)
+
+#define TX_TIMEOUT	400
+
+/* SHDSL parameters*/
+#define MAX_AUTO_RATE	2304
+#define MIN_AUTO_RATE	192
+#define MAX_RATE	6016
+#define MIN_RATE	64
+#define MAX_REMCFGF_RATE	5696
+#define MAX_REMCFGAB_RATE	2304
+#define MIN_REMCFG_RATE		192
+
+
+#define ANNEX_A		0x01
+#define ANNEX_B		0x02
+#define ANNEX_F		0x03
+
+
+/*Debug parameters*/
+//#define DEBUG_ON
+#define PDEBUG(fmt,args...) 
+#ifdef DEBUG_ON
+#	undef PDEBUG
+#	define PDEBUG(fmt,args...) \
+		    printk(KERN_NOTICE "sg16lan.c: %s " fmt " \n", __FUNCTION__, ## args  )
+#endif
+
+static int dnum=0;
+struct net_device *devs[10];
+
+//static int FLG=0;
+
+/* Internal consts */
+#define EFWDLOAD 0x20
+#define iotype u8*
+
+/* SG-16PCI ioctl params */
+#define SIOCDEVLOADFW	 	SIOCDEVPRIVATE
+#define SIOCDEVGETSTATS	 	SIOCDEVPRIVATE+1
+#define SIOCDEVCLRSTATS	 	SIOCDEVPRIVATE+2
+
+/* Portability */
+//#define IO_READ_WRITE
+#ifndef IO_READ_WRITE
+#	define iowrite8(val,addr)  writeb(val,addr)
+#	define iowrite32(val,addr)  writel(val,addr)
+#	define ioread8(addr) readb(addr)
+#	define ioread32(addr) readl(addr)
+#endif
+/* -------------------------------------------------------------------------- */
+
+struct sg16_hw_regs {
+	u8  CRA, CRB, SR, IMR, CTDR, LTDR, CRDR, LRDR;
+};
+
+struct hw_descr {
+	u32  address;
+	u32  length;
+};
+
+struct cx28975_cmdarea {
+	u8  intr_host;
+	u8  intr_8051;
+	u8  map_version;
+
+	u8  in_dest;
+	u8  in_opcode;
+	u8  in_zero;
+	u8  in_length;
+	u8  in_csum;
+	u8  in_data[ 75 ];
+	u8  in_datasum;
+
+	u8  out_dest;
+	u8  out_opcode;
+	u8  out_ack;
+	u8  out_length;
+	u8  out_csum;
+	u8  out_data[ 75 ];
+	u8  out_datasum;
+};
+
+#define XQLEN	8
+#define RQLEN	8
+
+/* net_device private data */
+
+#define FW_NAME_SIZE 255
+struct shdsl_config
+{
+    char fw_name[FW_NAME_SIZE];
+    u16 lrate:	10;
+    u16 master:	1;
+    u16 mod:	2;
+    u16 autob:	1;
+    u16 autob_en: 1;    
+    u16 need_preact: 1;
+    u8 remcfg :1;
+    u8 annex :2;
+    u8 :5;
+};
+
+struct hdlc_config
+{
+    u8  crc16: 1;
+    u8  fill_7e: 1;
+    u8  inv: 1;
+    u8  rburst: 1;
+    u8  wburst: 1;
+};
+
+struct net_local{
+    
+    struct net_device_stats	stats;
+    wait_queue_head_t  wait_for_intr;
+
+
+    struct device *dev;
+    /*Configuration structures*/
+    struct hdlc_config hdlc_cfg;
+    struct shdsl_config shdsl_cfg;
+    u8 irqret;
+
+    /* SG-16PCI controller statistics */
+    struct sg16_stats {
+    	u32  sent_pkts, rcvd_pkts;
+	u32  crc_errs, ufl_errs, ofl_errs, last_time;
+    } in_stats;
+
+    spinlock_t rlock,xlock;
+    
+    void *mem_base;		/* mapped memory address */
+
+    volatile struct sg16_hw_regs	*regs;
+    volatile struct hw_descr	*tbd;
+    volatile struct hw_descr	*rbd;
+    volatile struct cx28975_cmdarea	*cmdp;
+
+    /* transmit and reception queues */
+    struct sk_buff *xq[ XQLEN ], *rq[ RQLEN ];
+    unsigned head_xq, tail_xq, head_rq, tail_rq;
+
+    /* the descriptors mapped onto the first buffers in xq and rq */
+    unsigned head_tdesc, head_rdesc;
+    u8 fw_state;
+    
+    /* timered link check entire */
+    struct timer_list link_state;
+};
+
+/* SHDSL transceiver statistics */
+struct dsl_stats {
+	u8	status_1, status_3;
+	u8	attenuat, nmr, tpbo, rpbo;
+	u16	losw, segd, crc, sega, losd;
+	u16	all_atmpt,atmpt;
+};
+
+/*- Driver initialisation -*/
+static int  sg16_init( void );
+static void sg16_exit( void );
+module_init(sg16_init);
+module_exit(sg16_exit);
+static int __devinit  sg16_init_one( struct pci_dev *,
+					const struct pci_device_id * );
+static void __devexit  sg16_remove_one( struct pci_dev * );
+
+/*- Net device specific functions -*/
+static int __init  sg16_probe( struct net_device * );
+static irqreturn_t  sg16_interrupt( int, void *, struct pt_regs * );
+static int  sg16_open( struct net_device * );
+static int  sg16_close( struct net_device * );
+static int  sg16_start_xmit( struct sk_buff *, struct net_device * );
+static struct net_device_stats  *sg16_get_stats( struct net_device * );
+static void  set_multicast_list( struct net_device * );
+
+/*-----------------------------------------------------------------------------
+
+static int  sg16_ioctl( struct net_device *, struct ifreq *, int );
+
+/*-----------------------------------------------------------------------------*/
+
+/*- Functions serving SG-16PCI control -*/
+
+static void hdlc_init( struct net_local *nl);
+static void hdlc_shutdown( struct net_local *nl );
+
+static int  shdsl_ready( struct net_local *nl, u16 expect_state);
+
+/*-----------------------------------------------------------------------------*/
+
+//static int  shdsl_dload_fw(struct device *dev);
+static int  shdsl_dload_fw(struct net_device *dev, struct firmware *fw);
+
+/*-----------------------------------------------------------------------------*/
+
+static int  shdsl_preactivation(struct net_local *nl);
+static int  shdsl_get_stat(struct net_local *nl, struct dsl_stats *ds);
+static int  shdsl_clr_stat( struct net_local  *nl );
+static int  shdsl_issue_cmd( struct net_local *, u8, u8 *, u8 );
+static void shdsl_interrupt( struct net_device * );
+static void shdsl_link_chk( unsigned long );
+
+/*- Functions, serving transmit-receive process -*/
+static void  recv_init_frames( struct net_device * );
+static void  recv_alloc_buffs( struct net_device * );
+static void  recv_free_buffs( struct net_device * );
+static void  xmit_free_buffs( struct net_device * );
+static void  sg16_tx_timeout( struct net_device * );
+
+/*- Sysfs specific functions -*/
+
+#define ADDIT_ATTR
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+#undef ADDIT_ATTR
+#define ADDIT_ATTR struct device_attribute *attr,
+#endif    
+
+static int init_sg16_in_sysfs( struct device *);
+static void del_sg16_from_sysfs(struct device *dev);
+// shdsl attribs
+
+static ssize_t show_rate( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_rate( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(rate,0644,show_rate,store_rate);	
+
+static ssize_t show_crate( struct device *dev, ADDIT_ATTR char *buff );
+static DEVICE_ATTR(crate,0644,show_crate,NULL);
+
+static ssize_t show_master( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_master( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(master,0644,show_master,store_master);	
+
+static ssize_t show_remcfg( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_remcfg( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(remcfg,0644,show_remcfg,store_remcfg);	
+
+static ssize_t show_annex( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_annex( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(annex,0644,show_annex,store_annex);	
+
+static ssize_t show_mod( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_mod( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(mod,0644,show_mod,store_mod);	
+
+static ssize_t show_autob( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_autob( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(autobaud,0644,show_autob,store_autob);	
+
+static ssize_t show_download( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_download( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(download,0644,show_download,store_download);	
+
+// hdlc attribs 
+static ssize_t show_crc16( struct device *dev, ADDIT_ATTR char *buff );
+static ssize_t store_crc16( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(crc16,0644,show_crc16,store_crc16);	
+
+static ssize_t show_fill_7e( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_fill_7e( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(fill_7e,0644,show_fill_7e,store_fill_7e);	
+
+static ssize_t show_inv( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_inv( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(inv,0644,show_inv,store_inv);	
+
+static ssize_t show_rburst( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_rburst( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(rburst,0644,show_rburst,store_rburst);
+
+static ssize_t show_wburst( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_wburst( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(wburst,0644,show_wburst,store_wburst);	
+
+//address
+static ssize_t store_maddr( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(maddr,0200,NULL,store_maddr);	
+
+// Statistic
+static ssize_t show_dev_state( struct device *dev, ADDIT_ATTR char *buff ); 
+static DEVICE_ATTR(state,0644,show_dev_state,NULL);	
+
+static ssize_t show_statistic( struct device *dev, ADDIT_ATTR char *buff ); 
+static ssize_t store_statistic( struct device *dev, ADDIT_ATTR const char *buff, size_t size ); 
+static DEVICE_ATTR(statistic,0644,show_statistic,store_statistic);	
+
+
+//debug
+static ssize_t show_debug( struct device *dev, ADDIT_ATTR char *buf );
+static ssize_t store_debug( struct device *dev, ADDIT_ATTR const char *buff, size_t size );
+static DEVICE_ATTR(debug,0644,show_debug,store_debug);	
+
+
+
+/* pci-driver initialisation block */
+/*----------------------------------------------------------------------------*/
+
+#define SG16_PCI_VENDOR 	0x55 
+#define SG16_PCI_DEVICE 	0x9d
+static struct pci_device_id  sg16_pci_tbl[] __devinitdata = {
+	{ PCI_DEVICE(SG16_PCI_VENDOR,SG16_PCI_DEVICE) },
+	{ 0 }
+};
+MODULE_DEVICE_TABLE( pci, sg16_pci_tbl );
+
+static struct pci_driver  sg16_driver = {
+	name:		"sg16lan",
+	probe:		sg16_init_one,
+	remove:		sg16_remove_one,
+	id_table:	sg16_pci_tbl
+};
+
+int
+sg16_init( void ){
+    pci_module_init( &sg16_driver );
+    return 0;
+}
+
+void
+sg16_exit( void ){
+    pci_unregister_driver( &sg16_driver );
+}
+
+void
+dsl_init( struct net_device *ndev)
+{
+    ether_setup(ndev);    
+    ndev->init = sg16_probe;
+}
+
+
+static int __devinit
+sg16_init_one( struct pci_dev  *pdev,  const struct pci_device_id  *ent )
+{
+    struct net_device  *ndev;
+    struct device *dev_dev=(struct device*)&(pdev->dev);
+    struct device_driver *dev_drv=(struct device_driver*)(dev_dev->driver);
+    struct net_local * nl;
+    u8 err;
+
+    if( pci_enable_device( pdev ) )
+    	return  -EIO;
+    pci_set_master(pdev); 
+    /* register network device */
+	if( !( ndev = alloc_netdev( sizeof(struct net_local),"dsl%d",dsl_init)) )
+	    return  -ENOMEM;
+    /* set some net device fields */
+    pci_set_drvdata( pdev, ndev );
+    ndev->mem_start = pci_resource_start( pdev, 1 );
+    ndev->mem_end = pci_resource_end( pdev,1 );
+    ndev->irq = pdev->irq;
+
+    /* network interface initialisation */
+    if( register_netdev( ndev ) ) {
+	err=ENODEV;
+	goto err1;
+    }
+devs[dnum]=ndev;
+dnum++;    
+    /* device private data initialisation */
+    nl=(struct net_local *)netdev_priv( ndev);
+    nl->dev=dev_dev;
+    /* shutdown device before startup*/
+    hdlc_shutdown(nl);
+
+    /* Create symlink from driver dir to device dir in sysfs  */
+    sysfs_create_link( &(dev_drv->kobj),&(dev_dev->kobj),ndev->name );
+
+    /* Create sysfs entires */
+    if( init_sg16_in_sysfs( dev_dev ) )
+    {
+        printk( KERN_ERR "%s: unable to create sysfs entires\n",ndev->name);
+        err=-EPERM;	    
+        goto err2;
+    }
+
+    nl->shdsl_cfg.need_preact=1;
+/*
+#ifndef AUTOSTART_OFF
+
+    if( shdsl_dload_fw(dev_dev)  )
+	printk(KERN_NOTICE"%s: cannot download firmware\n",ndev->name);
+    else
+    {
+	// check that autobaud is aviable in this firmware 
+	if( shdsl_preactivation(nl) )
+	    printk(KERN_ERR"%s, I/O error\n",ndev->name);
+	else
+	{
+	    // Starting device activation 
+            t=0x42;
+	    if( ( err=shdsl_issue_cmd(nl,_DSL_ACTIVATION,&t,1) ) )
+    		return -EIO;
+	    nl->shdsl_cfg.need_preact=0;
+	}
+    }
+#endif	
+/*
+    /* timered link chk entire */
+    nl->link_state.data = ( unsigned long )ndev;
+    nl->link_state.function = shdsl_link_chk;
+    init_timer( &(nl->link_state) );
+    
+    return  0;
+
+err2:
+    unregister_netdev( ndev );
+    free_irq( ndev->irq, ndev );
+    release_mem_region( ndev->mem_start, 0x1000 );
+    iounmap( ((struct net_local *)ndev->priv)->mem_base );
+err1:	    
+    free_netdev(ndev);    
+    return err;
+}
+
+static void __devexit
+sg16_remove_one( struct pci_dev  *pdev )
+{
+    struct net_device  *ndev = pci_get_drvdata( pdev );
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);    
+    struct device *dev_dev=(struct device*)&(pdev->dev);
+    struct device_driver *dev_drv=(struct device_driver*)(dev_dev->driver);
+
+    /* timer entry */
+    del_timer_sync( &(nl->link_state) );
+
+    /* shutdown device */
+    hdlc_shutdown(nl);
+    
+    /* Remove symlink on device from driver dir in sysfs */
+    sysfs_remove_link(&(dev_drv->kobj),ndev->name);
+    /* Remove sysfs entires */
+    del_sg16_from_sysfs(dev_dev);
+
+    /* Remove network device from OS */
+    unregister_netdev( ndev );
+    free_irq( ndev->irq, ndev );
+    release_mem_region( ndev->mem_start, 0x1000 );
+    iounmap( ((struct net_local *)ndev->priv)->mem_base );
+    free_netdev( ndev );
+}
+
+/* Network interface specific functions */
+/* -------------------------------------------------------------------------- */
+
+static int __init
+sg16_probe( struct net_device  *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);
+
+    // Carrier off
+    netif_carrier_off( ndev );
+    
+    /* generate 'unique' MAC address */
+    *(u16 *)ndev->dev_addr = htons( 0x00ff );
+    *(u32 *)(ndev->dev_addr + 2) = htonl( 0x01a39000 | ((u32)ndev->priv & 0x00000fff) );
+
+    /* Init net device handler functions */
+    ndev->open		= &sg16_open;
+    ndev->stop		= &sg16_close;
+    ndev->hard_start_xmit	= &sg16_start_xmit;
+    ndev->get_stats		= &sg16_get_stats;
+    ndev->set_multicast_list	= &set_multicast_list;
+    ndev->tx_timeout		= &sg16_tx_timeout;
+    ndev->watchdog_timeo	= TX_TIMEOUT;
+//    ndev->do_ioctl           	= &sg16_ioctl;
+	    
+
+    if( !request_mem_region( ndev->mem_start, 0x1000, ndev->name ) )
+	return  -ENODEV;
+
+    /* set network device private data */
+    memset( nl, 0, sizeof(struct net_local) );
+    spin_lock_init( &nl->rlock );
+    spin_lock_init( &nl->xlock );
+    init_waitqueue_head( &nl->wait_for_intr );
+    nl->mem_base = (void *) ioremap( ndev->mem_start, 0x1000 );
+    nl->tbd  = (struct hw_descr *) nl->mem_base;
+    nl->rbd  = (struct hw_descr *) ((u8 *)nl->mem_base + 0x400);
+    nl->regs = (struct sg16_hw_regs *) ((u8 *)nl->mem_base + 0x800);
+    nl->cmdp = (struct cx28975_cmdarea *) ((u8 *)nl->mem_base + 0xc00);
+    memset( &nl->in_stats, 0, sizeof(struct sg16_stats) );    
+
+    if( request_irq(ndev->irq, sg16_interrupt, SA_SHIRQ, ndev->name, ndev) ) 
+    {
+        printk( KERN_ERR "%s: unable to get IRQ %d.\n",
+    		ndev->name, ndev->irq );
+        goto err_exit;
+    }
+	
+    printk( KERN_NOTICE "%s: Sigrand SG-16PCI SHDSL (irq %d, mem %#lx)\n",
+		ndev->name, ndev->irq, ndev->mem_start );
+    SET_MODULE_OWNER( ndev );
+
+    return  0;
+
+err_exit:
+    iounmap( nl->mem_base );
+    release_mem_region( ndev->mem_start, 0x1000 );
+    return  -ENODEV;
+}
+
+static irqreturn_t
+sg16_interrupt( int  irq,  void  *dev_id,  struct pt_regs  *regs )
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct net_local  *nl  = (struct net_local *)netdev_priv(dev);		
+	u8  status = ioread8((iotype)&(nl->regs->SR));
+
+	if( status == 0 )
+		return IRQ_NONE;
+
+	if( status & ~((u8)EXT) ){
+	    PDEBUG("ndev=%s, status=%02x",dev->name,0xff & status);
+	    PDEBUG("%02x %02x %02x %02x %02x %02x %02x %02x",
+		    ioread8((iotype)&(nl->regs->CRA)),
+		    ioread8((iotype)&(nl->regs->CRB)),
+		    ioread8((iotype)&(nl->regs->SR)),
+		    ioread8((iotype)&(nl->regs->IMR)),
+		    ioread8((iotype)&(nl->regs->CTDR)),
+		    ioread8((iotype)&(nl->regs->LTDR)),
+		    ioread8((iotype)&(nl->regs->CRDR)),
+		    ioread8((iotype)&(nl->regs->LRDR))
+		);
+	}
+
+	if( status & EXT )
+	{
+	    shdsl_interrupt( dev ),
+	    iowrite8( EXT, (iotype)&(nl->regs->SR));						
+	}
+	/*
+	 * Whether transmit error is occured, we have to re-enable the
+	 * transmitter. That's enough, because linux doesn't fragment
+	 * packets.
+	 */
+	if( status & UFL ){
+	    iowrite8( ioread8((iotype)&(nl->regs->CRA)) | TXEN,
+	    	    (iotype)&(nl->regs->CRA) );
+	    iowrite8( UFL,(iotype)&(nl->regs->SR));				
+	    ++nl->in_stats.ufl_errs;
+	    ++nl->stats.tx_errors;
+	    ++nl->stats.tx_fifo_errors;
+	}
+	if( status & RXS ){
+	    if( spin_trylock( &(nl->rlock) ) ){
+		recv_init_frames( dev );
+		recv_alloc_buffs( dev );
+		spin_unlock( &(nl->rlock) );
+	    }
+	    iowrite8( RXS,(iotype)&(nl->regs->SR));
+	}
+	if( status & TXS ){
+	    xmit_free_buffs( dev );
+	    iowrite8( TXS,(iotype)&(nl->regs->SR));		
+	}
+	if( status & CRC ){
+	    ++nl->in_stats.crc_errs;
+	    ++nl->stats.rx_errors;
+    	    ++nl->stats.rx_crc_errors;
+	    iowrite8( CRC,(iotype)&(nl->regs->SR));				
+	}
+	if( status & OFL ){
+	    ++nl->in_stats.ofl_errs;
+	    ++nl->stats.rx_errors;
+	    ++nl->stats.rx_over_errors;
+	    iowrite8( OFL,(iotype)&(nl->regs->SR));		
+	}
+	PDEBUG("%02x end",status & 0xff);	
+	return IRQ_HANDLED;
+}
+
+/* Open/initialize the board */
+static int
+sg16_open( struct net_device  *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);		
+    int err;
+    u8 t;    
+    /* shdsl preactivation */
+    if( nl->shdsl_cfg.need_preact )
+    {
+/*TODO: is it correctly just reset SHDLS without 
+	deactivation?
+*/
+	iowrite8( EXT, (iotype)&(nl->regs->IMR) ); 
+        iowrite8( 0xff, (iotype)&(nl->regs->SR) ); 
+	iowrite8( XRST , (iotype)&(nl->regs->CRA));       			    
+	iowrite8( RXDE , (iotype)&(nl->regs->CRB));       			    
+	t=0;
+	if( shdsl_issue_cmd( nl, _DSL_RESET_SYSTEM, &t, 1 ) )
+    	    return -EBUSY;
+
+	if( !shdsl_ready(nl, _ACK_OPER_WAKE_UP )  )
+	{
+		printk(KERN_NOTICE"%s, firmware wasn't loaded\n",ndev->name);	    
+		return -EBUSY;
+	}
+	if( shdsl_preactivation(nl) )
+	{
+		printk(KERN_ERR"%s, I/O error\n",ndev->name);
+		return -EBUSY;
+	}
+        /* Starting device activation */
+	t=0x42;
+        if( ( err=shdsl_issue_cmd(nl,_DSL_ACTIVATION,&t,1) ) )
+	    return -EIO;
+	nl->shdsl_cfg.need_preact=0;	
+    }
+    
+    /* init descripts, allocate receiving buffers */
+    nl->head_xq = nl->tail_xq = nl->head_rq = nl->tail_rq = 0;
+    nl->head_tdesc = nl->head_rdesc = 0;
+    iowrite8( 0, (iotype)&(nl->regs->CTDR));
+    iowrite8( 0, (iotype)&(nl->regs->LTDR));
+    iowrite8( 0, (iotype)&(nl->regs->CRDR));
+    iowrite8( 0, (iotype)&(nl->regs->LRDR));
+    recv_alloc_buffs( ndev );
+    /* enable receive/transmit functions */
+    hdlc_init(nl);
+    memset( &nl->stats, 0, sizeof(struct net_device_stats) );
+    return 0;
+}
+
+static int
+sg16_close( struct net_device  *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);
+    unsigned long  flags;    
+
+    /* disable receive/transmit functions */        
+    iowrite8( XRST ,(iotype)&(nl->regs->CRA));       			    
+    /* drop receive/transmit queries */
+    spin_lock_irqsave( &nl->rlock, flags );
+    recv_free_buffs( ndev );
+    spin_unlock_irqrestore( &nl->rlock, flags );
+
+    iowrite8( ioread8( (iotype)&(nl->regs->LTDR) ), ( iotype)&(nl->regs->CTDR) );
+    xmit_free_buffs( ndev );
+    return 0;
+}
+
+
+static struct net_device_stats *
+sg16_get_stats( struct net_device  *dev )
+{
+	struct net_local  *nl  = (struct net_local *)netdev_priv(dev);		
+	return  &(nl)->stats;
+}
+
+static void
+set_multicast_list( struct net_device  *dev )
+{
+	return;		/* SG-16PCI always operate in promiscuos mode */
+}
+
+
+struct cx28975_fw {
+    u8   *firmw_image;
+    u32  firmw_len;
+};
+	
+/*
+static int
+sg16_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )
+{
+    struct firmware fw;
+    u8 mas[100*1024];
+    struct cx28975_fw fw_in;
+    int  error = 0;
+    int err;
+		
+    if( cmd ==  SIOCDEVLOADFW ){
+		    
+        if( current->euid != 0 )        /* root only */
+/*	    return  -EPERM;
+        if( (dev->flags & IFF_UP) == IFF_UP )
+	    return  -EBUSY;
+	PDEBUG("verify_area for addr");			    
+        if( (error = verify_area( VERIFY_READ, ifr->ifr_data,
+		            sizeof(struct cx28975_fw) )) != 0 )
+	    return  error;
+	PDEBUG("cp to fw_in");
+        copy_from_user( &fw_in, ifr->ifr_data, sizeof fw_in );
+	PDEBUG("verify_area for fw");		
+        if( (error = verify_area( VERIFY_READ, fw_in.firmw_image,
+                      fw_in.firmw_len )) != 0 )
+	    return  error;
+/*
+        if( !(fw.data = kmalloc( fw_in.firmw_len, GFP_KERNEL )) )
+	      return  -ENOMEM;
+*/
+/*	fw.data=mas;
+	PDEBUG("kmalloced");
+	copy_from_user( fw.data, fw_in.firmw_image, fw_in.firmw_len );
+	fw.size= fw_in.firmw_len;
+	printk("%s: buf allocated and filled, addr=%08x\n",fw.data); 	
+	PDEBUG("start dload");	
+	if( shdsl_dload_fw(dev, &fw ) )
+	    error=-1;
+	kfree( fw.data );
+    }
+    return  error;
+}
+*/																																      
+
+/* Control device functions */
+/*----------------------------------------------------------------------------*/
+
+static void
+hdlc_shutdown(struct net_local *nl)
+{
+    iowrite8( 0, (iotype)&( nl->regs->CRA));    
+    iowrite8( RXDE , (iotype)&( nl->regs->CRB));
+    iowrite8( 0, (iotype)&( nl->regs->IMR));
+    iowrite8( 0xff, (iotype)&( nl->regs->SR));
+}
+
+static void
+hdlc_init( struct net_local *nl)
+{
+    u8 cfg_byte;
+
+    cfg_byte=XRST | RXEN | TXEN;			
+    if( nl->hdlc_cfg.crc16 )		
+        cfg_byte|=CMOD;			
+    if( nl->hdlc_cfg.fill_7e )		
+        cfg_byte|=FMOD;			
+    if( nl->hdlc_cfg.inv )		
+        cfg_byte|=PMOD;			
+    iowrite8(cfg_byte,(iotype)&(nl->regs->CRA));
+
+    cfg_byte=ioread8( (iotype)&(nl->regs->CRB)) | RODD;		
+    if( nl->hdlc_cfg.rburst )		
+        cfg_byte|=RDBE;			
+    if( nl->hdlc_cfg.wburst )		
+        cfg_byte|=WTBE;			
+    iowrite8(cfg_byte,(iotype)&(nl->regs->CRB)); 
+}
+
+
+static int 
+shdsl_ready( struct net_local *nl, u16 expect_state)
+{
+#ifdef DEBUG_ON
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;
+#endif
+    u8 ret_val=1;
+    u32 ret;
+    PDEBUG("start");
+    if( (nl->irqret & 0x1f) != expect_state ){
+	ret=interruptible_sleep_on_timeout( &nl->wait_for_intr, HZ*10 );
+        PDEBUG("after ret");	
+	if( ( nl->irqret & 0x1f) != expect_state ){
+	    PDEBUG("fail wait, irqret=%02x expect=%02x",nl->irqret & 0x1f,0xff & expect_state );
+	    ret_val=0;
+	}
+    }
+    nl->irqret=0;
+    PDEBUG("end");    
+    return ret_val;
+}
+
+static int
+shdsl_dload_fw(struct net_device *ndev, struct firmware *fw)
+{
+//    struct net_device *ndev= (struct net_device *)dev_get_drvdata(dev);
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);			
+    struct shdsl_config *cfg = (struct shdsl_config *)&(nl->shdsl_cfg);
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;
+//    struct firmware *fw;
+    size_t img_len;
+    u32   t;
+    int  i;
+    u8 cksum = 0;
+
+    PDEBUG("%s before loading",ndev->name);
+    
+    for(i=0;i< fw->size;i++)
+        cksum += fw->data[i];
+				    
+
+/* 1.Prepare to download process */
+    hdlc_shutdown(nl);
+    udelay(10);
+    iowrite8( 0, (iotype)&(p->intr_host) );
+    ioread8( (iotype)&(p->intr_host) );    
+    iowrite8(XRST,(iotype)&(nl->regs->CRA));
+    iowrite8(EXT,(iotype)&(nl->regs->IMR)); 
+    udelay(10);
+    PDEBUG("%s: hdlc settings",ndev->name);    
+    if( !shdsl_ready(nl,_ACK_BOOT_WAKE_UP) )
+	goto err_exit;
+
+    PDEBUG("%s: before dload start",ndev->name);
+/* 2.Download process */
+    t = fw->size;
+    if( shdsl_issue_cmd( nl, _DSL_DOWNLOAD_START, (u8 *) &t, 4 ) )
+    	goto err_exit;
+    PDEBUG("%s: dload start",ndev->name);
+    
+    for( i = 0, img_len=fw->size;  img_len >= 75;  i += 75, img_len -= 75 ){
+	
+	if( shdsl_issue_cmd( nl, _DSL_DOWNLOAD_DATA, fw->data + i, 75 ) ){
+	    printk("%s: %s cmd error on %d byte\n",__FUNCTION__,ndev->name,i);                
+    	    goto err_exit;
+	}
+    }
+
+    PDEBUG("%s: dload tail",ndev->name);
+    if( img_len
+        &&  shdsl_issue_cmd( nl, _DSL_DOWNLOAD_DATA, fw->data + i, img_len ) )
+    	goto err_exit;
+    PDEBUG("%s: dload end",ndev->name);
+    t = (cksum ^ 0xff) + 1;
+    if( shdsl_issue_cmd( nl, _DSL_DOWNLOAD_END, (u8 *) &t, 1 ) )
+    	goto err_exit;
+    PDEBUG("%s: dload complete",ndev->name);
+/* 3.Check that donload is successfull */
+    if( !shdsl_ready(nl,_ACK_OPER_WAKE_UP) ){
+	PDEBUG("no _ACK_OPER_WAKE_UP");	
+	goto err_exit;
+    }
+    PDEBUG("%s: dload successfull",ndev->name);	
+    
+/* 4. Check that auto rate selection supported */
+    udelay(10);
+    t=0;
+    if( shdsl_issue_cmd( nl,_DSL_VERSIONS, (u8 *)&t, 1 ) )
+	goto err_exit;    
+
+    if( !( ioread8( (iotype)&(p->out_data) + 4 ) & 1 ) )
+    {
+        cfg->autob_en=0;
+	cfg->autob=0;
+    }
+    else
+	cfg->autob_en=1;
+
+    PDEBUG("%s: %s exit\n",__FUNCTION__,ndev->name);
+    return  0;
+
+err_exit:
+    PDEBUG("%s: %s err exit\n",__FUNCTION__,ndev->name);
+    return -EIO;
+}
+
+static int
+shdsl_preactivation(struct net_local *nl)
+{
+    static char  thresh[] = { +8, -4, -16, -40 };
+    struct shdsl_config *cfg = (struct shdsl_config*)&(nl->shdsl_cfg);
+    u8 t, parm[ 36 ];
+    u8 iter;
+    u16 tmp;
+    u32 max_rate=0 ,min_rate=0;
+
+/* Start preactivation process */    
+
+//----_DSL_SYSTEM_ENABLE----//
+
+    t = cfg->master ? 1 : 9;
+    if( shdsl_issue_cmd( nl, _DSL_SYSTEM_ENABLE, &t, 1 ) )
+    	return  -EIO;
+	
+//----_DSL_SYSTEM_CONFIG----//
+	
+    t = 0x63;
+    if( shdsl_issue_cmd( nl, _DSL_SYSTEM_CONFIG, &t, 1 ) )
+    	return  -EIO;
+
+//---- _DSL_MULTI_RATE_CONFIG----//
+
+    // Check rate value
+    if( cfg->autob ){
+	max_rate=MAX_AUTO_RATE;
+	min_rate=MIN_AUTO_RATE;
+    }else if( cfg->remcfg ){
+	if( cfg->master ){
+	    if( cfg->annex==ANNEX_F )
+		max_rate=MAX_REMCFGF_RATE;
+	    else if( cfg->master )
+		max_rate=MAX_REMCFGAB_RATE;
+	    min_rate=MIN_REMCFG_RATE;
+	}
+    }else{
+	max_rate=MAX_RATE;
+	min_rate=MIN_RATE;
+    }
+
+    if( max_rate ){
+	tmp=(min_rate >> 3) & 0x3ff;
+	cfg->lrate= ( cfg->lrate < tmp ) ? tmp : cfg->lrate;
+	tmp=(max_rate >> 3) & 0x3ff;
+	cfg->lrate= ( cfg->lrate > tmp ) ? tmp : cfg->lrate;
+    }
+    else
+	cfg->lrate= 192 >> 3;
+
+    memset( parm, 0, 8 );
+    *(u16 *)parm = ( cfg->lrate >> 3 ) & 0x7f ;
+    parm[2] = parm[3] = parm[0];
+    parm[5] = cfg->lrate & 7;
+    parm[4] = parm[7] = 1;
+    parm[6] = 0;
+    if( shdsl_issue_cmd( nl, _DSL_MULTI_RATE_CONFIG, parm, 8 ) )
+    	return  -EIO;    
+
+//----_DSL_PREACT_RATE_LIST----//
+
+    // if DSL configured with automatic rate select
+    if( cfg->autob )	
+    {
+        // Set List of aviable Rates	
+	memset( parm, 0, 36 );
+	parm[0]=0;
+	parm[1]=( u8 )( ((cfg->lrate - ( (MIN_AUTO_RATE >> 3) & 0x7f) ) >> 3 ) & 0x7f )+ 1;
+    	for(iter=0; iter<parm[1] ; iter++)
+	    parm[iter+2]=3+iter;	    
+	if( shdsl_issue_cmd( nl, _DSL_PREACT_RATE_LIST, parm, iter+2 ) )
+    	    return  -EIO;
+    }
+
+//----_DSL_TRAINING_MODE----//
+
+    if( cfg->autob )
+        parm[0] = 0x02 | 0x01<<4;	// In auto rate mode using only TCPAM16
+    else if( cfg->remcfg ){
+	if( ( cfg->mod==0x00 || cfg->mod==0x01 ) &&
+		cfg->master && cfg->annex==ANNEX_F )
+	    parm[0] = 0x02 |(cfg->mod << 4);
+	else
+	    parm[0] = 0x02 | 0x01 << 4;
+	
+    }
+    else
+        parm[0] = 0x02 | (cfg->mod << 4);
+    parm[1] = 0;
+
+    if( shdsl_issue_cmd( nl, _DSL_TRAINING_MODE, parm, 2 ) )
+    	return  -EIO;
+
+//----_DSL_PREACTIVATION_CFG----//
+
+    memset( parm, 0, 12 );
+    parm[0] = 0x04;	// pre-activation: G.hs
+    if( cfg->autob )
+        parm[1] = 0x01;	// Line probe Enabled
+    else	
+        parm[1] = 0x00;	// Line probe Disabled	
+	
+    if( cfg->autob || cfg->remcfg )
+        parm[4] = 0x00;	// HTU-C send Mode Select message
+    else
+        parm[4] = 0x04;	// No remote configuration
+
+    parm[5] = 0x01;	// TPS-TC Config= Clear Channel
+    parm[6] = 0x00;
+    
+    parm[7]=cfg->annex; // annex A,B,F
+    parm[8] = 0xff;	// i-bit mask (all bits)
+    if( shdsl_issue_cmd( nl, _DSL_PREACTIVATION_CFG, parm, 12 ) )
+    	return  -EIO;
+
+//----_DSL_THRESHOLDS----//
+
+    parm[0] = 0x03;	// dying gasp time - 3 frames
+    parm[1] = thresh[ cfg->mod ];	
+    parm[2] = 0xff;	// attenuation
+    parm[3] = 0x04;	// line probe NMR (+2 dB)
+    parm[4] = 0x00;	// reserved 
+    parm[5] = 0x00;
+    if( shdsl_issue_cmd( nl, _DSL_THRESHOLDS, parm, 6 ) )
+    	return  -EIO;
+
+//----_DSL_FR_PCM_CONFIG----//
+
+    t = cfg->master ? 0x23 : 0x21;
+    if( shdsl_issue_cmd( nl, _DSL_FR_PCM_CONFIG, &t, 1 ) )
+    	return  -EIO;
+
+//----_DSL_INTR_HOST_MASK----//
+
+    t = 0x02;
+    if( shdsl_issue_cmd( nl, _DSL_INTR_HOST_MASK, &t, 1 ) )
+    	return  -EIO;
+
+    return 0;
+}
+
+static int
+shdsl_get_stat(struct net_local *nl, struct dsl_stats *ds)
+{
+    u8 t;
+    int  i;    
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;    
+
+    t = 0;
+    if( shdsl_issue_cmd( nl, _DSL_FAR_END_ATTEN, &t, 1 ) )
+    	return -EIO;
+    ds->attenuat = ioread8( (iotype)&(p->out_data) );
+
+    if( shdsl_issue_cmd( nl, _DSL_NOISE_MARGIN, &t, 1 ) )
+	return -EIO;
+    ds->nmr = ioread8( (iotype)&(p->out_data) );
+
+    if( shdsl_issue_cmd( nl, _DSL_POWER_BACK_OFF_RESULT, &t, 1 ) )
+	return -EIO;
+    ds->tpbo = ioread8( (iotype)&(p->out_data) );
+    ds->rpbo = ioread8( (iotype)&(p->out_data) + 1 );
+
+    if( !shdsl_issue_cmd( nl, _DSL_SYSTEM_PERF_ERR_CTRS, &t, 1 ) ) {
+	for( i = 0;  i < 4;  ++i )
+	    ((u8 *)&(ds->all_atmpt))[i] = ioread8( (iotype)&(p->out_data) + i );
+    }
+    else
+	return -EIO;
+    if( !shdsl_issue_cmd( nl, _DSL_HDSL_PERF_ERR_CTRS, &t, 1 ) ) {
+	for( i = 0;  i < 10;  ++i )
+	    ((u8 *)&(ds->losw))[i] = ioread8( (iotype)&(p->out_data) + i );
+    }
+    else
+	return -EIO;
+    return 0;
+    
+}
+
+static int
+shdsl_clr_stat( struct net_local  *nl )
+{
+    u8 t;
+    memset( &nl->in_stats, 0, sizeof(struct sg16_stats) );
+    t =0;
+    if( shdsl_issue_cmd( nl, _DSL_CLEAR_ERROR_CTRS, &t, 1 ) )
+	return -EIO;
+    t =0x04;
+    if( shdsl_issue_cmd( nl, _DSL_CLEAR_ERROR_CTRS, &t, 1 ) )
+	return -EIO;
+
+    return 0;
+}
+
+static int
+shdsl_issue_cmd( struct net_local  *nl,  u8  cmd,  u8  *data,  u8  size )
+{
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;
+    int  i;
+    u8  cksum = 0, tmp;
+    u8 *databuf = p->in_data;
+
+/*
+if( cmd==_DSL_DOWNLOAD_DATA)
+    printk("%s: start\n",__FUNCTION__);                
+*/
+    iowrite8( 0xf0, (iotype)&(p->in_dest) );
+    iowrite8( cmd, (iotype)&(p->in_opcode ) );
+    iowrite8( 0, (iotype)&(p->in_zero ) );
+    iowrite8(--size, (iotype)&(p->in_length ) );
+    iowrite8( ( 0xf0 ^ cmd ^ size ^ 0xaa ),(iotype)&(p->in_csum) ); 
+
+/*
+if( cmd==_DSL_DOWNLOAD_DATA)
+    printk("%s: send data to chip\n",__FUNCTION__);                
+*/
+    for( i = 0;  i <= size;  ++i )
+    {
+	cksum ^= *data;
+	tmp=(u8)*data++;
+	iowrite8( tmp,(iotype)(databuf++));	// only 1 byte per cycle!
+    }
+/*
+if( cmd==_DSL_DOWNLOAD_DATA)
+    printk("%s: send data to chip complete\n",__FUNCTION__);                
+*/
+    iowrite8( cksum^0xaa, (iotype)&(p->in_datasum) );
+    iowrite8( _ACK_NOT_COMPLETE, (iotype)&(p->out_ack) );
+    iowrite8( 0xfe, (iotype)&(p->intr_8051) );
+    if( shdsl_ready(nl,_ACK_PASS ) ){
+	PDEBUG("return successfully");                
+	return  0;
+    }else
+	return  -EIO;
+}
+
+static void
+shdsl_interrupt( struct net_device  *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);	
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;
+    
+    if(  ioread8( (iotype)&(p->intr_host) ) != 0xfe )
+    	return;
+
+    if( ioread8( (iotype)&(p->out_ack) ) & 0x80  )
+    {
+	nl->link_state.expires = jiffies + HZ/2;    
+	add_timer( &(nl->link_state) );    
+    }
+    // inquiry answer     
+    else
+    {
+	nl->irqret=ioread8( (iotype)&(p->out_ack) );
+	wake_up( &nl->wait_for_intr );	
+	PDEBUG("wake up %s",ndev->name);	
+    }
+    // Clear acknoledgement register
+    iowrite8(0, (iotype)&(p->out_ack));
+    // interrupt served
+    iowrite8( 0, (u8 *)&(p->intr_host) );
+    ioread8( (u8 *)&(p->intr_host) );
+}
+
+
+static void
+shdsl_link_chk( unsigned long data )
+{
+    struct net_device *ndev=(struct net_device *)data;
+    struct net_local  *nl  =(struct net_local *)netdev_priv(ndev);	
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;
+    struct timeval tv;    
+
+
+    // Link state
+    if( ioread8( (iotype)((u8*)p + 0x3c7) ) & 2 ) 
+    {
+        // link up
+	if( ( ioread8( (iotype)( (u8*)p + 0x3c0) ) & 0xc0) == 0x40 )
+	{
+	    PDEBUG("Activate:");
+	    PDEBUG("%02x %02x %02x %02x %02x %02x %02x %02x",
+		    ioread8((iotype)&(nl->regs->CRA)),
+		    ioread8((iotype)&(nl->regs->CRB)),
+		    ioread8((iotype)&(nl->regs->SR)),
+		    ioread8((iotype)&(nl->regs->IMR)),
+		    ioread8((iotype)&(nl->regs->CTDR)),
+		    ioread8((iotype)&(nl->regs->LTDR)),
+		    ioread8((iotype)&(nl->regs->CRDR)),
+		    ioread8((iotype)&(nl->regs->LRDR))
+		);
+		
+
+	    // set hdlc registers
+	    iowrite8( 0xff, (iotype)&(nl->regs->SR) );    				    
+	    iowrite8( ioread8( (iotype)&(nl->regs->CRB) ) & ~RXDE,
+			(iotype)&(nl->regs->CRB) );
+	    iowrite8( EXT | UFL | OFL | RXS | TXS ,
+			(iotype)&(nl->regs->IMR) );    			
+
+	    do_gettimeofday( &tv );
+	    nl->in_stats.last_time = tv.tv_sec;
+	    //reset Rx FIFO	    
+/*	    iowrite8( 0xf0, (iotype)&(p->in_dest) );
+	    iowrite8( _DSL_FR_RX_RESET, (iotype)&(p->in_opcode ) );
+	    iowrite8( 0, (iotype)&(p->in_zero ) );
+	    iowrite8(0, (iotype)&(p->in_length ) );
+	    iowrite8( ( 0xf0 ^ _DSL_FR_RX_RESET ^ 0 ^ 0xaa ),(iotype)&(p->in_csum) ); 
+	    cksum ^= 0x8;
+	    iowrite8( 0x8,(iotype)&(p->in_data));	// only 1 byte per cycle!
+	    iowrite8( cksum^0xaa, (iotype)&(p->in_datasum) );
+	    iowrite8( _ACK_NOT_COMPLETE, (iotype)&(p->out_ack) );
+	    iowrite8( 0xfe, (iotype)&(p->intr_8051) );
+*/	    // enable packet receiving-transmitting
+	    netif_wake_queue( ndev );
+	    netif_carrier_on( ndev );
+	}
+	// link down
+	else 
+	if( ( ioread8( (iotype)((u8*)p + 0x3c0) ) & 0xc0) != 0x40 )
+	{
+	    PDEBUG("Deactivate");
+		
+	    iowrite8( ioread8( (iotype)&(nl->regs->CRB) ) | RXDE,
+			(iotype)&(nl->regs->CRB) );
+	    iowrite8( EXT, (iotype)&(nl->regs->IMR) );    			
+	    netif_stop_queue( ndev );
+	    netif_carrier_off( ndev );
+	}
+    }
+}
+
+/* --------------------------------------------------------------------------
+ *   Functions, serving transmit-receive process   *
+ * -------------------------------------------------------------------------- */
+static int
+sg16_start_xmit( struct sk_buff *skb, struct net_device *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);	
+    unsigned long  flags;
+    dma_addr_t bus_addr;
+    struct sk_buff *nskb;
+    unsigned  cur_tbd;
+    unsigned pad;
+
+    if ( !netif_carrier_ok(ndev) ){
+	dev_kfree_skb_any( skb );
+	return 0;
+    }
+
+    /* fix concurent racing in transmit */
+    spin_lock_irqsave( &nl->xlock, flags );
+
+    if( nl->tail_xq == ((nl->head_xq - 1) & (XQLEN - 1)) ) {
+    	netif_stop_queue( ndev );
+	goto  err_exit;
+    }
+
+    /*
+     * we don't have to check if the descriptor queue was overflowed,
+     * because of XQLEN < 128
+     */
+     if( skb->len < ETHER_MIN_LEN )
+     {
+	pad = ETHER_MIN_LEN - skb->len;
+        /* if we have enough space just fill it with 0 and resize skb*/
+	/* If the skbuff is non linear tailroom is always zero.. */
+		 
+	if(skb_tailroom(skb) >= pad)
+	{
+     	    memset(skb->data + skb->len, 0, pad);
+	    skb->len = ETHER_MIN_LEN;			
+	}
+	else
+	{
+	    nskb = skb_copy_expand(skb, skb_headroom(skb), skb_tailroom(skb) + pad, GFP_ATOMIC);
+	    skb = nskb;
+	    if(skb)
+	    	memset(skb->data + skb->len, 0, pad);
+	    skb->len = ETHER_MIN_LEN;
+        }
+    }
+
+    /* Map the buffer for DMA */
+    bus_addr = dma_map_single(nl->dev,skb->data, skb->len , DMA_TO_DEVICE );
+
+
+    nl->xq[ nl->tail_xq++ ] = skb;
+    nl->tail_xq &= (XQLEN - 1);
+    cur_tbd = ioread8( (iotype)&(nl->regs->LTDR)) & 0x7f;
+    iowrite32( cpu_to_le32( bus_addr ) , (iotype)&(nl->tbd[ cur_tbd ].address) ) ;
+    iowrite32( cpu_to_le32( skb->len | LAST_FRAG ),(iotype)&(nl->tbd[ cur_tbd ].length ) ) ;
+
+    cur_tbd = (cur_tbd + 1) & 0x7f;
+    iowrite8(cur_tbd,(iotype)&(nl->regs->LTDR));
+
+    /*
+     * Probably, it's the best place to increment statistic counters
+     * though those frames hasn't been actually transferred yet.
+     */
+    ++nl->in_stats.sent_pkts;
+    ++nl->stats.tx_packets;
+    nl->stats.tx_bytes += skb->len;
+    ndev->trans_start = jiffies;
+
+    spin_unlock_irqrestore( &nl->xlock, flags );
+
+    return 0;
+err_exit:
+    spin_unlock_irqrestore( &nl->xlock, flags );
+    return  -EBUSY;
+}
+
+
+static void
+recv_init_frames( struct net_device *dev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(dev);		
+    unsigned  cur_rbd = ioread8( (iotype)&(nl->regs->CRDR) ) & 0x7f;
+    dma_addr_t bus_addr;    
+    unsigned  len;
+
+    while( nl->head_rdesc != cur_rbd ) {
+
+	PDEBUG("Get packet");
+	struct sk_buff  *skb = nl->rq[ nl->head_rq++ ];
+	nl->head_rq &= (RQLEN - 1);
+
+	bus_addr=le32_to_cpu( ioread32( (u32*)&(nl->rbd[ nl->head_rdesc ].address)) );
+	dma_unmap_single(nl->dev,bus_addr, SG16_MAX_FRAME , DMA_FROM_DEVICE );
+
+	len = nl->rbd[ nl->head_rdesc ].length & 0x7ff;
+	if( len < ETHER_MIN_LEN )
+	    len = ETHER_MIN_LEN;
+	
+	skb_put( skb, len );
+	skb->protocol = eth_type_trans( skb, dev );
+	netif_rx( skb );
+		
+	++nl->in_stats.rcvd_pkts;
+	++nl->stats.rx_packets;
+	nl->stats.rx_bytes += len;
+	nl->head_rdesc = (nl->head_rdesc + 1) & 0x7f;
+    }
+    return;
+    
+}
+
+static void
+recv_alloc_buffs( struct net_device *dev )
+{
+
+    struct net_local  *nl  = (struct net_local *)netdev_priv(dev);		
+    unsigned  cur_rbd = ioread8((iotype)&(nl->regs->LRDR)) & 0x7f;
+    dma_addr_t bus_addr;
+    struct sk_buff  *skb;
+
+    
+    while( nl->tail_rq != ((nl->head_rq -1) & (RQLEN - 1)) )
+    {
+	skb = dev_alloc_skb( SG16_MAX_FRAME );
+	skb->dev = dev;
+	skb_reserve( skb, 2 );	// align ip on longword boundaries
+
+	nl->rq[ nl->tail_rq++ ] = skb;
+	nl->tail_rq &= (RQLEN - 1);
+
+	/* DMA memory */
+	bus_addr = dma_map_single(nl->dev,skb->data, 
+		    SG16_MAX_FRAME , DMA_FROM_DEVICE );
+	iowrite32( cpu_to_le32( bus_addr ),
+		    (u32 *)&(nl->rbd[ cur_rbd ].address) ) ;
+	iowrite32( 0, (u32*)&(nl->rbd[ cur_rbd ].length ) ) ;
+	cur_rbd = (cur_rbd + 1) & 0x7f;
+	iowrite8(cur_rbd,(iotype)&(nl->regs->LRDR));
+    }
+}
+
+static void
+recv_free_buffs( struct net_device *ndev)
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);		
+    unsigned  last_rbd = ioread8( (iotype)&(nl->regs->LRDR)) & 0x7f;
+    dma_addr_t bus_addr;    
+    struct sk_buff  *skb;
+    
+    iowrite8( ioread8( (iotype)&(nl->regs->CRDR)), (iotype)&(nl->regs->LRDR));
+    while( nl->head_rdesc != last_rbd )
+    {
+	skb = nl->rq[ nl->head_rq++ ];
+	nl->head_rq &= (RQLEN - 1);
+	bus_addr=le32_to_cpu( ioread32( (u32*)&(nl->rbd[ nl->head_rdesc ].address) ) );
+	nl->head_rdesc = (nl->head_rdesc + 1) & 0x7f;
+	dma_unmap_single(nl->dev,bus_addr, SG16_MAX_FRAME , DMA_FROM_DEVICE );
+        dev_kfree_skb_any( skb );
+    }
+    return;
+}
+
+static void
+xmit_free_buffs( struct net_device *dev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(dev);		
+    unsigned  cur_tbd = ioread8((iotype)&(nl->regs->CTDR));
+    dma_addr_t bus_addr;
+
+    spin_lock( &nl->xlock );
+
+    if( netif_queue_stopped( dev )  &&  nl->head_tdesc != cur_tbd ){
+    	netif_wake_queue( dev );
+    }
+		    
+    while( nl->head_tdesc != cur_tbd )
+    {
+	/* unmap DMA memory */
+	bus_addr=le32_to_cpu( ioread32( (u32*)&(nl->tbd[ nl->head_tdesc ].address)) );
+	dma_unmap_single(nl->dev,bus_addr, nl->xq[ nl->head_xq]->len, DMA_TO_DEVICE );
+	dev_kfree_skb_any( nl->xq[ nl->head_xq++ ] );
+	nl->head_xq &= (XQLEN - 1);
+	nl->head_tdesc = (nl->head_tdesc + 1) & 0x7f;
+    }
+
+    spin_unlock( &nl->xlock );
+    return;
+}
+
+/*
+ * xmit_free_buffs may also be used to drop the queue - just turn
+ * the transmitter off, and set CTDR == LTDR
+ */
+
+static void
+sg16_tx_timeout( struct net_device  *ndev )
+{
+    struct net_local  *nl  = (struct net_local *)netdev_priv(ndev);		
+    
+    printk( KERN_ERR "%s: transmit timeout\n", ndev->name );
+    if( ioread8( (iotype)&(nl->regs->SR)) & TXS )
+    {
+        iowrite8( TXS,(iotype)&(nl->regs->SR));
+        printk( KERN_ERR "%s: interrupt posted but not delivered\n",
+    		ndev->name );
+    }
+    xmit_free_buffs( ndev );
+}
+
+
+/*----------------------------------------------------------------------------
+ *Sysfs specific functions
+ *----------------------------------------------------------------------------*/
+
+static int __devinit 
+init_sg16_in_sysfs(struct device *dev)
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct shdsl_config *shcfg=&(nl->shdsl_cfg);
+    struct hdlc_config *hdcfg=&(nl->hdlc_cfg);
+
+    /* initialising default parameters */
+    //shdsl
+    strcpy(shcfg->fw_name,"sg16.bin");
+
+// set default role
+#ifdef SG16_MASTER
+    shcfg->master=1;
+#else
+    shcfg->master=0;
+#endif    
+
+// set remote master configuration mode
+#ifdef SG16_REMCFG
+    shcfg->remcfg=1;
+    shcfg->annex=ANNEX_F;    
+#else
+    shcfg->remcfg=0;
+    shcfg->annex=ANNEX_A;    
+#endif    
+
+// set default rate
+#ifdef SG_RATE
+    shcfg->lrate=SG16_RATE>>3;
+#else    
+    shcfg->lrate=128>>3;
+#endif
+
+// set coding type
+#ifdef SG16_MOD 
+#if SG16_MOD == 1
+    shcfg->mod=1;
+#elif SG16_MOD == 2
+    shcfg->mod=2;
+#elif SG16_MOD == 3
+    shcfg->mod=3;
+#else
+    shcfg->mod=0;
+#endif
+#endif
+
+#ifdef SG16_AUTOB
+    shcfg->autob=1;
+#else
+    shcfg->autob=0;
+#endif
+    
+//hdlc
+#ifdef SG16_NORBURST
+    hdcfg->rburst=0;
+#else    
+    hdcfg->rburst=1;
+#endif
+    
+#ifdef SG16_NOWBURST
+    hdcfg->wburst=0;
+#else
+    hdcfg->wburst=1;
+#endif    
+
+#ifdef SG16_CRC16
+    hdcfg->crc16=1;
+#else
+    hdcfg->crc16=0;
+#endif
+    
+#ifdef SG16_FILL7E
+    hdcfg->fill_7e=1;
+#else    
+    hdcfg->fill_7e=0;
+#endif
+
+#ifdef SG16_INV
+    hdcfg->inv=1;    
+#else    
+    hdcfg->inv=0;
+#endif    
+
+    /* creating attributes of device in sysfs */
+    //shdsl
+    if( device_create_file(dev,&dev_attr_rate) )	goto err_ext;
+    if( device_create_file(dev,&dev_attr_crate))	goto err_ext0;
+    if( device_create_file(dev,&dev_attr_master)) 	goto err_ext1;
+    if( device_create_file(dev,&dev_attr_remcfg))	goto err_ext2;    
+    if( device_create_file(dev,&dev_attr_annex)) 	goto err_ext3;
+    if( device_create_file(dev,&dev_attr_mod)) 		goto err_ext4;
+    if( device_create_file(dev,&dev_attr_autobaud)) 	goto err_ext5;
+    if( device_create_file(dev,&dev_attr_download)) 	goto err_ext6;    
+    //hdlc
+    if( device_create_file(dev,&dev_attr_crc16))	goto err_ext7;
+    if( device_create_file(dev,&dev_attr_fill_7e))	goto err_ext8;
+    if( device_create_file(dev,&dev_attr_inv))		goto err_ext9;
+    if( device_create_file(dev,&dev_attr_rburst))	goto err_ext10;
+    if( device_create_file(dev,&dev_attr_wburst))	goto err_ext11;
+    //addr
+    if( device_create_file(dev,&dev_attr_maddr))	goto err_ext12;    
+    //stat
+    if( device_create_file(dev,&dev_attr_state)) 	goto err_ext13;        
+    if( device_create_file(dev,&dev_attr_statistic))	goto err_ext14;        
+    //debug
+    if( device_create_file(dev,&dev_attr_debug))	goto err_ext15;
+
+    return 0;
+
+err_ext15:
+    device_remove_file(dev,&dev_attr_statistic);        
+err_ext14:
+    device_remove_file(dev,&dev_attr_state);        
+err_ext13:
+    device_remove_file(dev,&dev_attr_maddr);        
+err_ext12:
+    device_remove_file(dev,&dev_attr_wburst);
+err_ext11:
+    device_remove_file(dev,&dev_attr_rburst);
+err_ext10:
+    device_remove_file(dev,&dev_attr_inv);
+err_ext9:
+    device_remove_file(dev,&dev_attr_fill_7e);
+err_ext8:
+    device_remove_file(dev,&dev_attr_crc16);
+err_ext7:
+    device_remove_file(dev,&dev_attr_download);    
+err_ext6:
+    device_remove_file(dev,&dev_attr_autobaud);
+err_ext5:
+    device_remove_file(dev,&dev_attr_mod);    
+err_ext4:
+    device_remove_file(dev,&dev_attr_annex);    
+err_ext3:
+    device_remove_file(dev,&dev_attr_remcfg);        
+err_ext2:
+    device_remove_file(dev,&dev_attr_master);
+err_ext1:
+    device_remove_file(dev,&dev_attr_crate);	            
+err_ext0:    
+    device_remove_file(dev,&dev_attr_rate);	
+err_ext:
+    printk("%s: error\n",__FUNCTION__);
+    return -1;
+}
+
+static void __devexit
+del_sg16_from_sysfs(struct device *dev)
+{
+    /* removing attributes of device from sysfs */
+    //shdsl
+    device_remove_file(dev,&dev_attr_rate);	
+    device_remove_file(dev,&dev_attr_crate);	    
+    device_remove_file(dev,&dev_attr_master);
+    device_remove_file(dev,&dev_attr_remcfg);    
+    device_remove_file(dev,&dev_attr_annex);    
+    device_remove_file(dev,&dev_attr_mod);
+    device_remove_file(dev,&dev_attr_autobaud);
+    device_remove_file(dev,&dev_attr_download);    
+    //hdlc
+    device_remove_file(dev,&dev_attr_crc16);
+    device_remove_file(dev,&dev_attr_fill_7e);
+    device_remove_file(dev,&dev_attr_inv);
+    device_remove_file(dev,&dev_attr_rburst);
+    device_remove_file(dev,&dev_attr_wburst);
+    //addr
+    device_remove_file(dev,&dev_attr_maddr);        
+    //stat
+    device_remove_file(dev,&dev_attr_state);        
+    device_remove_file(dev,&dev_attr_statistic);        
+    //debug
+    device_remove_file(dev,&dev_attr_debug);            
+}
+
+/* rate attributes */
+static ssize_t
+show_rate( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    u8 t=0;
+    u16 tmp=0;
+    
+    if( !(cfg->remcfg && !cfg->master) )
+	return snprintf(buf,PAGE_SIZE,"%u\n",(cfg->lrate)<<3);
+    else{
+	if( netif_carrier_ok(ndev) )
+	{
+	    t=_DSL_DATA_RATE;
+	    if( !shdsl_issue_cmd(nl,_DSL_READ_CONTROL,&t,0) )
+	    {
+		tmp=ioread8( (u8 *)(nl->cmdp->out_data+1)) & 0x3;
+		tmp=(tmp<<8)+ioread8( (u8 *)(nl->cmdp->out_data) );
+		tmp--;
+	    } 
+	}
+    }
+    return snprintf(buf,PAGE_SIZE,"%u\n",tmp<<3);    
+}
+
+static ssize_t
+store_rate( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    char *endp;
+    u16 tmp;
+    
+    /* if interface is up*/
+    if( (ndev->flags & IFF_UP) )
+	return size;
+    if( !size ) return size;
+
+    tmp=simple_strtoul( buf,&endp,0);
+    if( !tmp )
+	return size;
+    cfg->lrate=(tmp >> 3) & 0x3ff;
+    nl->shdsl_cfg.need_preact=1;
+
+    return size;
+}
+
+
+static ssize_t
+show_crate( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    u8 t=0;
+    u32 tmp=0;
+    
+    if( !cfg->autob && !( cfg->remcfg && !cfg->master ) )
+	tmp=cfg->lrate;    	
+    else
+    {
+	if( cfg->autob  && netif_carrier_ok(ndev) ){
+	    if( !shdsl_issue_cmd(nl,_DSL_GHS_GET_FINAL_RATE,&t,0) )    
+	    {
+		tmp=ioread8( (u8 *)(nl->cmdp->out_data+2));
+		tmp=(tmp<<3)+ioread8( (u8 *)(nl->cmdp->out_data+3) );
+	    }
+	}
+	else if( cfg->remcfg && netif_carrier_ok(ndev) )
+	{
+	    t=_DSL_DATA_RATE;
+	    if( !shdsl_issue_cmd(nl,_DSL_READ_CONTROL,&t,0) )
+	    {
+		tmp=ioread8( (u8 *)(nl->cmdp->out_data+1)) & 0x3;
+		tmp=(tmp<<8)+ioread8( (u8 *)(nl->cmdp->out_data) );
+		tmp--;		
+	    } 
+	}
+    }
+    return snprintf(buf,PAGE_SIZE,"%u\n",tmp<<3);
+}
+
+/* master attribute */
+static ssize_t
+show_master( struct device *dev, ADDIT_ATTR char *buf ) 
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+
+    if( cfg->master )
+	return snprintf(buf,PAGE_SIZE,"master");
+    else
+	return snprintf(buf,PAGE_SIZE,"slave"); 
+}
+
+static ssize_t
+store_master( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+
+    /* if interface is up */
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( size > 0 ){
+	if( buf[0]=='0' )
+	    cfg->master=0;
+	else
+	if( buf[0]=='1' )
+	    cfg->master=1;
+    }    
+    nl->shdsl_cfg.need_preact=1;
+    return strnlen(buf,PAGE_SIZE);
+}
+
+
+/* Remote configuration setup */
+static ssize_t
+show_remcfg( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+
+    if( cfg->remcfg )
+	return snprintf(buf,PAGE_SIZE,"preact");
+    else
+	return snprintf(buf,PAGE_SIZE,"local"); 
+}
+
+static ssize_t
+store_remcfg( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+
+    /* if interface is up */
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( size > 0 ){
+	if( buf[0]=='0' )
+	    cfg->remcfg=0;
+	else if( buf[0]=='1' )
+	    cfg->remcfg=1;
+    }    
+
+    nl->shdsl_cfg.need_preact=1;
+    return strnlen(buf,PAGE_SIZE);
+}
+/* Annex setup */
+static ssize_t 
+show_annex( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    u8 t=cfg->annex;
+
+    switch( t ){
+    case ANNEX_A:
+	return snprintf(buf,PAGE_SIZE,"Annex=A");
+    case ANNEX_B:
+	return snprintf(buf,PAGE_SIZE,"Annex=B"); 
+    case ANNEX_F:
+	return snprintf(buf,PAGE_SIZE,"Annex=F"); 
+    default:
+	cfg->annex=ANNEX_A;
+	return snprintf(buf,PAGE_SIZE,"Annex=A");    
+    }
+}
+
+static ssize_t
+store_annex( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    u8 tmp;
+
+    /* if interface is up */
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( !size )	return size;
+
+    tmp=buf[0];
+    switch(tmp)
+    {
+    case '0':
+	cfg->annex=ANNEX_A;
+	break;
+    case '1':
+	cfg->annex=ANNEX_B;
+	break;
+    case '2':
+	cfg->annex=ANNEX_F;
+	break;
+    default:
+	cfg->annex=ANNEX_A;
+	break;
+    }
+
+    nl->shdsl_cfg.need_preact=1;
+    return strnlen(buf,PAGE_SIZE);
+}
+
+/* mod attribute */
+static ssize_t
+show_mod( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    char  *modstr[] = {"TCPAM32", "TCPAM16", "TCPAM8", "TCPAM4"};    
+    u8 t=0;
+    u16 tmp=0;
+
+    if( cfg->remcfg ){
+	if( !netif_carrier_ok(ndev) )
+	    return snprintf(buf,PAGE_SIZE,"Unknown\n");	
+	else{
+	    t=_DSL_DATA_RATE;
+	    if( !shdsl_issue_cmd(nl,_DSL_READ_CONTROL,&t,0) )
+	    {
+		tmp=ioread8( (u8 *)(nl->cmdp->out_data+1)) & 0x3;
+		tmp=(tmp<<8)+ioread8( (u8 *)(nl->cmdp->out_data) );
+		tmp--;		
+	    } 
+	    if( !tmp )
+		return snprintf(buf,PAGE_SIZE,"Unknown\n");	
+	    else if( (tmp<<3) > 2304 )
+		return snprintf(buf,PAGE_SIZE,"TCPAM32\n");	
+	    else
+		return snprintf(buf,PAGE_SIZE,"TCPAM16\n");	
+	}
+    }
+    return snprintf(buf,PAGE_SIZE,"%s\n",modstr[cfg->mod]);
+}
+
+static ssize_t
+store_mod( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    char tmp;    
+
+    /* if interface is up */
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( !size )	return size;
+	
+    tmp=buf[0];
+    switch(tmp)
+    {
+    case '0':
+	cfg->mod=0;
+	break;
+    case '1':
+	cfg->mod=1;
+	break;
+    case '2':
+	cfg->mod=2;
+	break;
+    case '3':
+	cfg->mod=3;
+	break;
+    }
+    nl->shdsl_cfg.need_preact=1;
+    return size;
+}
+
+/* autobaud attribute */
+static ssize_t
+show_autob( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+
+    if( cfg->autob )
+	return snprintf(buf,PAGE_SIZE,"auto\n");
+    else if( cfg->remcfg && !cfg->master )
+	return snprintf(buf,PAGE_SIZE,"remote\n");    
+    else
+	return snprintf(buf,PAGE_SIZE,"static\n");
+}
+
+static ssize_t
+store_autob( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct shdsl_config *cfg=&(nl->shdsl_cfg);
+    u8 tmp;
+    
+    /* if interface is up */
+    if( ndev->flags & IFF_UP )
+	return size;
+    /* correct input data */
+    if( !size )
+	return 0;
+
+    /* check that autobaud is aviable in this firmware */
+    if( !cfg->autob_en )
+    {
+	cfg->autob=0;
+	return size;
+    }
+	
+    /* change auto rate state */
+    tmp=buf[0];
+    switch(tmp)
+    {
+    case '0':
+	cfg->autob=0;
+	break;
+    case '1':
+	cfg->autob=1;
+	break;
+    }
+    nl->shdsl_cfg.need_preact=1;
+    return size;
+}
+
+
+/* download attribute */
+static ssize_t
+show_download( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    u8 t;
+
+    /* if UP => fw is downloaded */
+    if( ndev->flags & IFF_UP )
+	return snprintf(buf,PAGE_SIZE,"1");
+
+    /* Reset of system */
+    udelay(2);
+    t=0;
+    if( shdsl_issue_cmd( nl, _DSL_RESET_SYSTEM, &t, 1 ) )
+	return snprintf(buf,PAGE_SIZE,"0");
+    udelay(2);
+    if( !shdsl_ready( nl, _ACK_OPER_WAKE_UP ) )
+	return snprintf(buf,PAGE_SIZE,"0");
+
+    return snprintf(buf,PAGE_SIZE,"1");
+}	
+
+static ssize_t
+store_download( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    
+struct firmware *fw;    
+struct shdsl_config *cfg = (struct shdsl_config *)&(nl->shdsl_cfg);
+
+    PDEBUG("start");    
+    
+    if( !size )	return 0;
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    PDEBUG("before dload");    
+    if( buf[0] == '1' ){
+	if( request_firmware((const struct firmware **)&fw,cfg->fw_name,dev) ){
+	    printk(KERN_ERR"%s: firmware file not found\n",ndev->name); 
+	    release_firmware(fw);	
+	    return -ENOENT;
+	}
+	else
+	    shdsl_dload_fw(ndev,fw);
+    }
+
+    nl->shdsl_cfg.need_preact=1;
+    return size;
+}
+
+/* CRC count attribute */
+static ssize_t
+show_crc16( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+
+    if( cfg->crc16 )
+	return snprintf(buf,PAGE_SIZE,"crc16");
+    else
+	return snprintf(buf,PAGE_SIZE,"crc32");    
+}
+
+static ssize_t
+store_crc16( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+    u8 cfg_bt;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( !size )	return 0;
+    
+    switch(buf[0]){
+    case '1':
+	if( cfg->crc16 )
+    	    break;
+	cfg->crc16=1;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) | CMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    case '0':
+	if( !(cfg->crc16) )
+	    break;
+	cfg->crc16=0;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) & ~CMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    }	
+
+    return size;	
+}
+
+static ssize_t
+show_fill_7e( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+
+    if( cfg->fill_7e )
+	return snprintf(buf,PAGE_SIZE,"on");
+    else
+	return snprintf(buf,PAGE_SIZE,"off");    
+}
+
+static ssize_t
+store_fill_7e( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+    u8 cfg_bt;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+    
+    if( !size )	return 0;
+    
+    switch(buf[0]){
+    case '1':
+	if( cfg->fill_7e )
+    	    break;
+	cfg->fill_7e=1;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) | FMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    case '0':
+	if( !(cfg->fill_7e) )
+	    break;
+	cfg->fill_7e=0;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) & ~FMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    }	
+    return size;	
+}
+
+static ssize_t 
+show_inv( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+
+    if( cfg->inv )
+	return snprintf(buf,PAGE_SIZE,"on");
+    else
+	return snprintf(buf,PAGE_SIZE,"off");    
+}
+
+static ssize_t
+store_inv( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+    u8 cfg_bt;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( !size )
+	return 0;
+    
+    switch(buf[0]){
+    case '1':
+	if( cfg->inv )
+    	    break;
+	cfg->inv=1;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) | PMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    case '0':
+	if( !(cfg->inv) )
+	    break;
+	cfg->inv=0;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRA)) & ~PMOD;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRA));
+	break;
+    }	
+    return size;	
+}
+
+static ssize_t
+show_rburst( struct device *dev, ADDIT_ATTR char *buf )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+
+    if( cfg->rburst )
+	return snprintf(buf,PAGE_SIZE,"on");
+    else
+	return snprintf(buf,PAGE_SIZE,"off");    
+
+}
+
+static ssize_t
+store_rburst( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+    u8 cfg_bt;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+    
+    if( !size )	return 0;
+    
+    switch(buf[0]){
+    case '1':
+	if( cfg->rburst )
+    	    break;
+	cfg->rburst=1;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRB)) | RDBE;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRB));
+	break;
+    case '0':
+	if( !(cfg->rburst) )
+	    break;
+	cfg->rburst=0;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRB)) & ~RDBE;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRB));
+	break;
+    }	
+
+    return size;	
+}
+
+static ssize_t
+show_wburst( struct device *dev, ADDIT_ATTR char *buf ) 
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+
+    if( cfg->wburst )
+	return snprintf(buf,PAGE_SIZE,"on");
+    else
+	return snprintf(buf,PAGE_SIZE,"off");    
+}
+
+static ssize_t
+store_wburst( struct device *dev, ADDIT_ATTR const char *buf, size_t size )
+{
+    struct net_device *ndev=(struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);
+    struct hdlc_config *cfg=&(nl->hdlc_cfg);
+    u8 cfg_bt;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+    
+    if( !size )	return 0;
+
+    switch(buf[0]){
+    case '1':
+	if( cfg->wburst )
+    	    break;
+	cfg->wburst=1;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRB)) | WTBE;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRB));
+	break;
+    case '0':
+	if( !(cfg->wburst) )
+	    break;
+	cfg->wburst=0;
+	cfg_bt=ioread8( (iotype)&(nl->regs->CRB)) & ~WTBE;
+	iowrite8( cfg_bt,(iotype)&(nl->regs->CRB));
+	break;
+    }	
+
+    return size;	
+}
+
+/* MAC address less significant value */
+static ssize_t
+store_maddr( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_device *ndev= (struct net_device *)dev_get_drvdata(dev);
+    u16 tmp;
+    char *endp;
+
+    if( ndev->flags & IFF_UP )
+	return size;
+
+    if( !size ) return 0;
+
+    tmp=simple_strtoul( buf,&endp,16) & 0xfff;
+    *(u16 *)ndev->dev_addr = htons( 0x00ff ),
+    *(u32 *)(ndev->dev_addr + 2) = htonl( 0x014aa000 | tmp );     
+
+    return size;
+}
+
+/* Statistic */
+
+static ssize_t
+show_dev_state( struct device *dev, ADDIT_ATTR char *buf ) 
+{
+    struct net_device *ndev= (struct net_device *)dev_get_drvdata(dev);
+    struct net_local *nl=(struct net_local *)netdev_priv(ndev);    
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;    
+    u8 stat_1,stat_3;
+    char ret_ad[30];
+    
+    stat_1=ioread8((iotype)( (u8*)p+0x3c0) );
+    stat_3=ioread8((iotype)( (u8*)p+0x3c2) );
+    switch( (stat_1 >> 6) ) {
+    case  0 :
+	*ret_ad=0;
+	switch( stat_3 & 0x0f ) {
+	case  1 :	
+	    snprintf(ret_ad,30,"(Bad NMR)" );
+	    break;
+	case  2 :	
+	    snprintf(ret_ad,30, "(Frequency lock failed)" );	
+	    break;
+	case  3 :
+	    snprintf(ret_ad,30, "(Pre-activation failed)" );
+	    break;
+	case  4 :
+	    snprintf(ret_ad,30, "(Sync word detect failed)" );
+	    break;
+	}
+	return snprintf(buf,42,"not ready %s",ret_ad);
+    case  1 :
+	return snprintf(buf,PAGE_SIZE,"online");    
+    default:
+	return snprintf(buf,PAGE_SIZE,"offline");    
+    } 
+    return 0;
+}
+
+static ssize_t
+show_statistic( struct device *dev, ADDIT_ATTR char *buf ) 
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    struct sg16_stats *sb_stat=&(nl->in_stats);
+    struct dsl_stats ds;
+
+    if( shdsl_get_stat(nl,&ds) )
+	return snprintf(buf,PAGE_SIZE,"err");
+    
+    return snprintf(buf,PAGE_SIZE,
+			"%u %u %u %u  %u %u %u %u  %u %u",
+			sb_stat->sent_pkts,sb_stat->rcvd_pkts,
+			sb_stat->crc_errs,
+			ds.atmpt,ds.all_atmpt,
+			ds.losw,
+			ds.crc,	ds.attenuat,
+			ds.nmr,	sb_stat->last_time );
+    
+}
+
+static ssize_t
+store_statistic( struct device *dev, ADDIT_ATTR const char *buf, size_t size ) 
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    
+    if( !size )	return size;
+
+    if( buf[0]=='1')
+	shdsl_clr_stat(nl);
+    return size;
+}
+
+/* debug */
+static u8 mem_ret[PAGE_SIZE]="";
+
+static ssize_t
+show_debug( struct device *dev, ADDIT_ATTR char *buf ) 
+{
+    strncat(buf,mem_ret,PAGE_SIZE);
+    return strlen(buf);
+}
+
+static ssize_t
+store_debug( struct device *dev, ADDIT_ATTR const char *buff, size_t size )
+{
+    struct net_local *nl=(struct net_local *)netdev_priv(dev_get_drvdata(dev));
+    volatile struct cx28975_cmdarea  *p = nl->cmdp;    
+    u8 cmd,args[200],tmp1;
+    u16 len;
+    int i=0;
+    char *endp,*ptr,bf[PAGE_SIZE];
+    
+
+    if( !size )	return size;
+    
+    len= (PAGE_SIZE-1 > size) ? size : PAGE_SIZE-1;
+    strncpy(bf,buff,len);
+    bf[len]=0;
+
+    ptr=bf;
+    cmd=simple_strtoul( ptr,&endp,16);
+    PDEBUG("DEBUG: cmd=%x",cmd);    
+    PDEBUG("DEBUG: endp=%x",endp);    
+
+    while( ( ptr-bf < len) && *endp ){
+	ptr=endp;
+	while( (ptr-bf <len) && ( *ptr<'0' || *ptr>'9')  )
+	    ptr++;
+	if( (ptr-bf)>=len )
+	    break;
+	args[i]=(u8)simple_strtoul( ptr,&endp,16);
+	PDEBUG("DEBUG: args[i]=%x",args[i]);    	
+	i++;
+    }
+    PDEBUG("DEBUG: i=%d",i);    		
+    if( shdsl_issue_cmd(nl,cmd,args,i) ){
+	sprintf(mem_ret,"cmd: error");
+	return size;
+    }
+    
+    sprintf(mem_ret,"cmd: %x",cmd);
+    for( i=0;i<(p->out_length)+1;i++){
+	tmp1 = ioread8( (iotype)&(p->out_data) +i );
+	sprintf(bf," %x",tmp1);
+	strcat(mem_ret,bf);
+    }
+    return size;
+}
Index: linux/drivers/net/sg16lan/Makefile
===================================================================
--- linux/drivers/net/sg16lan/Makefile	(.../linux)	(revision 0)
+++ linux/drivers/net/sg16lan/Makefile	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,2 @@
+
+obj-y	+= sg16lan.o
Index: linux/drivers/net/adm5120sw.c
===================================================================
--- linux/drivers/net/adm5120sw.c	(.../linux)	(revision 0)
+++ linux/drivers/net/adm5120sw.c	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,1261 @@
+/*
+ *	ADM5120 ethernet switch driver
+ *	
+ *	Based on original ADMTEK 2.4.18 driver, copyright ADMtek Inc.
+ *	daniel@admtek.com.tw
+ *	
+ *	Port to 2.4.31 kernel and modified to able to load as module
+ *	by Joco, rjoco77@kezdionline.ro
+ *	
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ 
+	
+	V1.0 Successful compile on 2.4.31 as module
+	V1.1 Modify promisc mode to work on bridge mode
+	V1.2 Added module param (vlan_mx) for modify vlan struct and ethernet
+	     interfaces.
+	     ex: vlan_mx="0x41,0x42,0x44,0x48,0x50,0x60"     -> 5 eth
+	         vlan_mx="0x5E,0x41,0,0,0,0"		     -> 2 eth Edimax layout
+	V1.3 Read MAC from Edimax type config partition
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h> 	
+#include <linux/slab.h>		
+#include <linux/gfp.h>		
+#include <linux/errno.h>	
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+
+#include <asm/checksum.h>
+#define ADM5120_DEBUG
+#define DEBUG_DEF 6
+#include <asm/am5120/debug.h>
+#include <linux/debug_net.h>
+#include <linux/delay.h>
+
+#include "adm5120sw.h"
+
+#define NUM_TX_H_DESC           24      /* Number of the Transmitting descriptor */
+#define NUM_TX_L_DESC           128 /*128      Number of the Transmitting descriptor */
+#define NUM_RX_H_DESC           24      /* Number of the Receiving descriptors */
+#define NUM_RX_L_DESC           128    /* 128      Number of the Receiving descriptors */
+
+#define SW_IRQ			9
+
+int adm5120sw_init(struct net_device *dev);
+
+static int unit = 0;
+static int timeout = 5;
+
+PSW_CONTEXT_T sw_context;
+
+static int vlan_mx[] = { 0x41,0x42,0x44,0x48,0x50,0x60 };
+static struct device *adm5120_dev;
+
+MODULE_DESCRIPTION("ADM5120 switch ethernet driver");
+MODULE_AUTHOR("Joco (rjoco77@kezdionline.ro)");
+MODULE_LICENSE("GPL");
+
+struct net_device adm5120sw_devs[MAX_VLAN_GROUP] = {
+    { name: "eth0", init:adm5120sw_init },
+    { name: "eth1", init:adm5120sw_init },
+    { name: "eth2", init:adm5120sw_init },
+    { name: "eth3", init:adm5120sw_init },
+//    { name: "eth4", init:adm5120sw_init },
+//    { name: "eth5", init:adm5120sw_init }
+};
+
+int adm5120_get_nrif (char * vlan_matrix)
+{
+    int i,nr = 0;
+    for ( i = 0; i < MAX_VLAN_GROUP; i++)
+	    if (vlan_matrix[i] & 0x40) nr++;
+    return nr;
+}
+
+
+/* ------------------------------------------------------
+		    Switch driver init    	
+  ------------------------------------------------------*/
+
+// InitTxDesc 
+static void InitTxDesc(PTX_ENG_T pTxEng)
+{
+	int num = pTxEng->numDesc;
+	
+	pTxEng->hwDesc[--num].buf1cntl |= END_OF_RING;
+	pTxEng->idxHead = pTxEng->idxTail = 0;
+}
+
+// InitRxDesc 
+static void InitRxDesc(PRX_ENG_T pRxEng)
+{
+	PRX_DRV_DESC_T drvDesc = pRxEng->drvDesc;
+	int i;
+	
+	for (i = 0; i < pRxEng->numDesc; i++, drvDesc++)
+	{
+		drvDesc->skb = dev_alloc_skb(DEF_RX_BUF_SIZE+16);
+		if (!drvDesc->skb)
+		{
+			printk("Init rx skb : low on mem\n");
+			return;
+		}
+		skb_reserve(drvDesc->skb, 2); /* align IP on 16B boundary */
+	}
+	
+	drvDesc = pRxEng->drvDesc;
+	
+	for (i = 0; i < pRxEng->numDesc; i++)
+	{
+		pRxEng->hwDesc[i].buf2cntl = pRxEng->hwDesc[i].status = 0;
+		pRxEng->hwDesc[i].buf1len = DEF_RX_BUF_SIZE;
+		pRxEng->hwDesc[i].buf1cntl =
+			((unsigned long)pRxEng->drvDesc[i].skb->data &
+			BUF_ADDR_MASK) | OWN_BIT;
+	}
+	
+	pRxEng->hwDesc[--i].buf1cntl |= END_OF_RING;
+	pRxEng->idx = 0;
+		
+}
+
+// Switch driver init    	
+int adm5120swdrv_init (void)
+{
+	int i;
+	char *rxBufPool;
+	
+	/* Allocate the switch driver context */
+	if ((sw_context = (PSW_CONTEXT_T)kmalloc(sizeof(SW_CONTEXT_T), GFP_KERNEL)) == NULL)
+		return (-1);
+	
+	memset((char *)sw_context, 0, sizeof(SW_CONTEXT_T));
+	
+	/* Allocate the Tx/Rx hardware descriptor pool */
+	i = HWDESC_ALIGN + sizeof(RXDESC_T) * (NUM_RX_H_DESC + NUM_RX_L_DESC)
+		+ sizeof(TXDESC_T) * (NUM_TX_H_DESC + NUM_TX_L_DESC);
+	
+	if ((sw_context->hwDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->hwDescPool, 0, i);
+	
+	/* Allocate the tx driver descriptor */
+	i = sizeof(TX_DRV_DESC_T) * (NUM_TX_H_DESC + NUM_TX_L_DESC);
+	
+	if ((sw_context->txDrvDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->txDrvDescPool, 0, i);
+	
+	/* Allocate the rx driver descriptor */
+	i = sizeof(RX_DRV_DESC_T) * (NUM_RX_H_DESC + NUM_RX_L_DESC);
+	
+	if ((sw_context->rxDrvDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->rxDrvDescPool, 0, i);
+	
+	/*
+	 *!! Note: The Hardware Tx/Rx descriptors should be allocated at non-
+		   cached memory and aligned 16 bytes boundry!!!!!
+	 */
+	 
+	/* assign hardware descriptor to txH pool */
+	if (((unsigned long)sw_context->hwDescPool) & (HWDESC_ALIGN - 1))
+	{
+		sw_context->txH.hwDesc = (PTXDESC_T)MIPS_KSEG1A((unsigned long)(sw_context->hwDescPool
+				+ HWDESC_ALIGN - 1) & ~(HWDESC_ALIGN - 1));
+	}
+	else
+		sw_context->txH.hwDesc = (PTXDESC_T)MIPS_KSEG1A(sw_context->hwDescPool);
+	
+	sw_context->txH.numDesc = NUM_TX_H_DESC;
+	sw_context->txH.txTrig = SEND_TRIG_HIGH;
+	InitTxDesc(&sw_context->txH);
+	sw_context->txH.drvDesc = (PTX_DRV_DESC_T)sw_context->txDrvDescPool;
+	
+	/* assign hardware descriptor to txL pool */
+	sw_context->txL.hwDesc = &sw_context->txH.hwDesc[NUM_TX_H_DESC];
+	sw_context->txL.numDesc = NUM_TX_L_DESC;
+	sw_context->txL.txTrig = SEND_TRIG_LOW;
+	InitTxDesc(&sw_context->txL);
+	sw_context->txL.drvDesc = (PTX_DRV_DESC_T)(sw_context->txDrvDescPool +
+		(sizeof(TX_DRV_DESC_T) * NUM_TX_H_DESC));
+		
+	/* assign hardware descriptor to rxH pool */
+	sw_context->rxH.hwDesc = (PRXDESC_T)&sw_context->txL.hwDesc[NUM_TX_L_DESC];
+	sw_context->rxH.numDesc = NUM_RX_H_DESC;
+	sw_context->rxH.drvDesc = (PRX_DRV_DESC_T)sw_context->rxDrvDescPool;
+	InitRxDesc(&sw_context->rxH);
+
+	/* assign hardware descriptor to rxL pool */
+	sw_context->rxL.hwDesc = &sw_context->rxH.hwDesc[NUM_RX_H_DESC];
+	sw_context->rxL.numDesc = NUM_RX_L_DESC;
+	rxBufPool += NUM_RX_H_DESC * RX_BUF_SIZE;
+	sw_context->rxL.drvDesc = (PRX_DRV_DESC_T)(sw_context->rxDrvDescPool +
+				(sizeof(RX_DRV_DESC_T) * NUM_RX_H_DESC));
+	InitRxDesc(&sw_context->rxL);
+	
+	for (i = 0; i < MAX_VLAN_GROUP; i++)
+		sw_context->vlanGrp[i] = vlan_mx[i] & 0x7F;
+	
+	/* disable cpu port, CRC padding from cpu and no send unknown packet
+	   from port0 to port5 to cpu */
+	ADM5120_SW_REG(CPUp_conf_REG) = DEF_CPUPORT_CFG ;
+	
+	/* Disable all port, enable BP & MC */
+	ADM5120_SW_REG(Port_conf0_REG) = DEF_PORTS_CFG;
+	
+	/* Wait until switch enter idle state */
+	for (i = 0 ; i < 500000; i++);
+	
+	/* Put Phys to normal mode */
+	ADM5120_SW_REG(PHY_cntl2_REG) |= SW_PHY_AN_MASK | SW_PHY_NORMAL_MASK;
+	
+	ADM5120_SW_REG(PHY_cntl3_REG) |= 0x400;
+	
+	/* Disable Switch Interrupts */
+	ADM5120_SW_REG(SW_Int_mask_REG) = SWITCH_INT_MASK;
+	
+	/* Clear the Interrupt status */
+	ADM5120_SW_REG(SW_Int_st_REG) = SWITCH_INT_MASK;
+	
+	/* Initialize the adm5120 Desc */
+	ADM5120_SW_REG(Send_HBaddr_REG) = (unsigned long)sw_context->txH.hwDesc;
+	ADM5120_SW_REG(Send_LBaddr_REG) = (unsigned long)sw_context->txL.hwDesc;
+	ADM5120_SW_REG(Recv_HBaddr_REG) = (unsigned long)sw_context->rxH.hwDesc;
+	ADM5120_SW_REG(Recv_LBaddr_REG) = (unsigned long)sw_context->rxL.hwDesc;
+	
+	/* Clear all vlan setting */
+	ADM5120_SW_REG(VLAN_G1_REG) = 0;
+	ADM5120_SW_REG(VLAN_G2_REG) = 0;
+	
+	/* Update link status */
+	sw_context->linkStatus = 0;
+	
+	sw_context->intMask = RX_H_INT | RX_L_INT | TX_H_INT | TX_L_INT | PORT0_QUE_FULL_INT |
+				PORT1_QUE_FULL_INT | PORT2_QUE_FULL_INT | PORT3_QUE_FULL_INT |
+				PORT4_QUE_FULL_INT | PORT5_QUE_FULL_INT | CPU_QUE_FULL_INT |
+				CPU_HOLD_INT | SEND_DESC_ERR_INT | RX_DESC_ERR_INT;
+
+	ADM5120_SW_REG(CPUp_conf_REG) &= ~SW_CPU_PORT_DISABLE;
+	
+	spin_lock_init(&sw_context->lock);
+	
+	return (0);
+	
+ErrRes:
+	/* Free all resources */
+	if (sw_context->hwDescPool != NULL)
+		kfree(sw_context->hwDescPool);
+	
+	if (sw_context->txDrvDescPool != NULL)
+		kfree(sw_context->txDrvDescPool);
+		
+	if (sw_context->rxDrvDescPool != NULL);
+		kfree(sw_context->rxDrvDescPool);
+		
+	kfree(sw_context);
+	
+	return (-1);	
+}
+
+/* ------------------------------------------------------
+    			Interrupts
+  ------------------------------------------------------*/
+
+void ProcessRxInt(PRX_ENG_T rxEng)
+{
+	struct net_device *rdev;
+	PSW_PRIV_T priv = 0;
+	PRXDESC_T rxDesc = 0;
+	PRX_DRV_DESC_T drvDesc = 0;
+	int unit;
+	int srcPort;
+	int idx;
+	int len;
+	idx = rxEng->idx;
+	rxDesc = &rxEng->hwDesc[idx];
+	while (!(rxDesc->buf1cntl & OWN_BIT))
+	{ 
+		drvDesc = &rxEng->drvDesc[idx];
+		if (drvDesc->skb == 0)
+			goto get_desc;
+
+		srcPort = (rxDesc->status & RX_SRC_PORT_MASK) >> RX_SRC_PORT_SHIFT;
+    		unit = sw_context->port[srcPort].ifUnit;
+		rdev = &adm5120sw_devs[unit];
+		priv = (PSW_PRIV_T)rdev->priv;
+
+		len = ((rxDesc->status & PKT_LEN_MASK) >> PKT_LEN_SHIFT) - ETH_CRC_LEN;
+		if (len <= 0 || (rxDesc->status & RX_PKT_IPSUM_ERR))
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_length_errors++;
+			goto next;
+		}
+		
+		skb_put(drvDesc->skb, len);
+			
+		/* Write metadata, and then pass to the receive level */
+		drvDesc->skb->dev = rdev;
+		drvDesc->skb->protocol = eth_type_trans(drvDesc->skb, rdev);
+		drvDesc->skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
+
+		if (netif_rx(drvDesc->skb) == NET_RX_DROP)
+		{
+			priv->stats.rx_dropped++;
+		}
+		else
+		{
+			rdev->last_rx = jiffies;
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += drvDesc->skb->len;
+		}
+
+get_desc:
+
+		drvDesc->skb = dev_alloc_skb(DEF_RX_BUF_SIZE+16);
+
+		if (drvDesc->skb) 
+		{
+			skb_reserve(drvDesc->skb, 2); /* align IP on 16B boundary */
+next:
+			rxDesc->buf2cntl = rxDesc->status = 0;
+			rxDesc->buf1len = DEF_RX_BUF_SIZE;
+			rxDesc->buf1cntl = (rxDesc->buf1cntl & END_OF_RING) | OWN_BIT
+							| (((unsigned long)drvDesc->skb->data)& BUF_ADDR_MASK);
+		}
+		else
+			printk("Init rx skb : low on mem\n");
+			
+		if (++idx == rxEng->numDesc)
+			idx = 0;
+		
+		rxDesc = &rxEng->hwDesc[idx];
+	}
+	rxEng->idx = idx;
+    return;
+}
+
+void ProcessTxInt(PTX_ENG_T txEng)
+{
+	PTX_DRV_DESC_T drvDesc;
+	int idx;
+	idx = txEng->idxTail;
+
+	while (!(txEng->hwDesc[idx].buf1cntl & OWN_BIT) && (idx != txEng->idxHead))
+	{
+		drvDesc = &txEng->drvDesc[idx];
+		dev_kfree_skb_irq(drvDesc->skb);
+
+		drvDesc->skb = 0;
+
+		if (++idx == txEng->numDesc)
+			idx = 0;
+	}
+
+	txEng->idxTail = idx;
+}
+
+irqreturn_t swdrv_ProcessInt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long intReg;
+	
+	spin_lock(&sw_context->lock);
+	
+	
+	/* disable switch interrupt */
+	ADM5120_SW_REG(SW_Int_mask_REG) |= sw_context->intMask;
+	
+	/* recording the current interrupts in the context. */
+	intReg = ADM5120_SW_REG(SW_Int_st_REG);
+	
+	/* acknowledge  all interrupts */
+	ADM5120_SW_REG(SW_Int_st_REG ) = intReg;
+	
+	/* receive one high priority packet to cpu */
+	if (intReg & RX_H_INT)
+		ProcessRxInt(&sw_context->rxH);
+	
+	/* receive one normal priority packet to cpu */
+	if (intReg & RX_L_INT)
+		ProcessRxInt(&sw_context->rxL);
+	
+	/* transmit one high priority packet to cpu */
+	if (intReg & TX_H_INT)
+		ProcessTxInt(&sw_context->txH);
+		
+	/* transmit one normal priority packet from cpu */
+	if (intReg & TX_L_INT)
+		ProcessTxInt(&sw_context->txL);
+
+
+	ADM5120_SW_REG(SW_Int_mask_REG) &= ~sw_context->intMask;
+	
+	spin_unlock(&sw_context->lock);		
+        return IRQ_HANDLED;
+}
+
+
+/*------------------------------------------------------
+    			PROC FS
+  ------------------------------------------------------*/
+#define MAX_PROC_STR 256
+#define PFS_ENTS  4
+#define PFS_VLAN0 0
+#define PFS_VLAN1 1
+#define PFS_VLAN2 2
+#define PFS_VLAN3 3
+char adm5120_procdir[]="sys/net/adm5120sw";
+struct proc_dir_entry *adm5120_entry;
+struct proc_dir_entry *vlan_entry;
+
+struct dev_entrie{
+	char *name;
+        int mark;
+	struct proc_dir_entry *pent;
+	mode_t mode;
+	read_proc_t *fread;
+	write_proc_t *fwrite;
+};
+
+static int
+store_vlan2port(struct file *file,const char *buffer,unsigned long count,void *data);
+
+
+static struct dev_entrie entries[PFS_ENTS]={
+        { "eth0", PFS_VLAN0, NULL, 400, NULL, store_vlan2port },
+	{ "eth1", PFS_VLAN1, NULL, 400, NULL, store_vlan2port },
+	{ "eth2", PFS_VLAN2, NULL, 400, NULL, store_vlan2port },
+	{ "eth3", PFS_VLAN3, NULL, 400, NULL, store_vlan2port },
+};
+
+static int init_adm5120_in_procfs(void);
+static void del_adm5120_from_procfs(void);
+
+
+static int
+set_entry(struct proc_dir_entry *ent,read_proc_t *fread,
+            write_proc_t *fwrite,int mark)
+{
+	short *mk;
+	
+	if( !( mk=(short *)kmalloc( sizeof( short ),GFP_KERNEL ) ) )
+	        return -1;
+	*mk=mark;
+	ent->data=(void *)mk;
+	ent->owner=THIS_MODULE;
+	ent->read_proc=fread;
+	ent->write_proc=fwrite;
+	return 0;
+}
+							
+							
+static int
+init_adm5120_in_procfs(void)
+{
+	int i,j;
+        adm5120_entry=proc_mkdir(adm5120_procdir,NULL);
+	if( adm5120_entry==NULL )
+    		return -ENOMEM;
+	PDEBUG(5,"creating entries");
+	for(i=0;i<PFS_ENTS;i++){
+    		if( !(entries[i].pent=
+		    create_proc_entry(entries[i].name,entries[i].mode,adm5120_entry) ) )
+			goto err1;
+		PDEBUG(5,"file \"%s\" created successfuly",entries[i].name);			
+    		if( set_entry(	entries[i].pent,entries[i].fread,
+				entries[i].fwrite,entries[i].mark) )
+			goto err1;
+		PDEBUG(5,"parameters of \"%s\" setted",entries[i].name);
+	}
+	return 0;
+
+err1:
+	PDEBUG(5,"eror creating \"%s\", abort",entries[i].name);
+	for(j=0;j<=i;j++)
+        	if( entries[j].pent->data )
+	                kfree(entries[j].pent->data);
+	for(j=0;j<=i;j++)
+		remove_proc_entry(entries[j].name,adm5120_entry);
+        remove_proc_entry("",adm5120_entry);
+	return -1;
+}        
+
+static void
+del_adm5120_from_procfs(void)
+{
+	int j;
+	for(j=0;j<PFS_ENTS;j++)
+        	if( entries[j].pent->data )
+	                kfree(entries[j].pent->data);
+	for(j=0;j<=PFS_ENTS;j++)
+		remove_proc_entry(entries[j].name,adm5120_entry);
+        remove_proc_entry("",adm5120_entry);
+}        
+
+/*
+static int
+show_vlan(char* page, char** start, off_t off, int count, int* eof, void* data)
+{
+}
+*/
+static int
+skip_blanks(char **ptr,int cnt)
+{
+	int i;
+	PDEBUG(5,"start ptr=%x",*ptr);
+	for(i=0;i<cnt;i++,(*ptr)++)
+		if( (**ptr)!=' ')
+			break;
+	PDEBUG(5,"end ptr=%x,num of blanks=%d",*ptr,i);			
+	return i;
+}
+
+static int
+store_vlan2port(struct file *file,const char *buffer,unsigned long count,void *data)
+{
+	int i;
+	char *ptr=(char*)buffer;
+	u8 cport,vnum;
+	int vlan_val=0;
+
+
+	PDEBUG(5,"start store vlan to port mapping\nstr=%s",buffer);	
+	// check for correct symbols
+	for(i=0;i<count;i++)
+		if( ( buffer[i]<'0' || buffer[i]>'9' ) 
+		    && buffer[i]!=' ' && buffer[i]!='\0'
+		    && buffer[i]!='\n'){
+			PDEBUG(5,"error: bad symbol: i=%d, sym=(%c,%d)",i,buffer[i],buffer[i]);			
+			goto err_ext;
+		}
+	PDEBUG(5,"all characters are ok");
+	// parse input string
+	i=skip_blanks(&ptr,count);
+	while( (ptr-buffer)<count && ( *ptr>='0' && *ptr<='9' ) ){
+		cport=*ptr-'0';
+		if( ( cport>0 && cport<=ETH_PORT_NUM ) )
+			vlan_val |= (cport==1) ? 1 : 1<<(cport-1);
+		ptr++;
+	}
+	
+	PDEBUG(5,"commit changes: vlan[%d]=%x",*(short*)data,vlan_val);
+	sw_context->vlanGrp[*(short*)data] &= 1<<CPU_PORT;
+	sw_context->vlanGrp[*(short*)data] |= vlan_val & 0x7F;
+
+err_ext:
+	return count;
+}
+
+/*
+static int
+store_vlan_sw(struct file *file,const char *buffer,unsigned long count,void *data)
+{
+        int i,j;
+	char str[3],*ptr=(char*)buffer;
+	int vlan_mx_tmp[6]={0,0,0,0,0,0};
+	u8 vnum=0,sw_en;
+
+	PDEBUG(5,"start store vlan to port mapping\nstr=%s",buffer);	
+	// check for correct symbols
+	for(i=0;i<count;i++)
+		if( ( buffer[i]<'0' || buffer[i]>'1' ) 
+		    && buffer[i]!=' ' && buffer[i]!='\0'
+		    && buffer[i]!='\n'){
+			PDEBUG(5,"error: bad symbol: i=%d, sym=(%c,%d)",i,buffer[i],buffer[i]);			
+			goto err_ext;
+		}
+	PDEBUG(5,"all characters are ok");
+	// parse input string
+	i=skip_blanks(&ptr,count);
+	while( i<count && pnum<MAX_VLAN_GROUP ){
+		sw_en=ptr[0]-'0';
+		// set vlan_mx
+		vlan_mx_tmp[vnum]|= (1<<CPU_PORT);
+		PDEBUG(5,"swich=%d on at vlan#%d",sw_en,vnum);
+		pnum++;
+		ptr++;
+		j=skip_blanks(&ptr,count-i);
+		if( !j && pnum<ETH_PORT_NUM)
+			goto err_ext;
+		i+=j;
+	}
+	
+	PDEBUG(5,"commit changes:");
+	for (i = 0; i < MAX_VLAN_GROUP; i++){
+		sw_context->vlanGrp[i] &= 1<<CPU_PORT;
+		sw_context->vlanGrp[i] |= vlan_mx_tmp[i] & 0x7F;
+	}
+err_ext:
+	return count;
+}
+*/
+
+/*------------------------------------------------------
+    			VLAN
+  ------------------------------------------------------*/
+
+static int SetupVLAN(int unit, unsigned long portmask)
+{
+	unsigned long reg, shiftcnt;
+	
+	if (unit < 0 || unit > 6)
+		return -1;
+	
+	if (unit <= 3)
+	{
+		shiftcnt = 8 * unit;
+		reg = ADM5120_SW_REG(VLAN_G1_REG) & ~(VLAN_PORT_MASK << shiftcnt);
+		reg |= (portmask & VLAN_PORT_MASK) << shiftcnt;
+		ADM5120_SW_REG(VLAN_G1_REG) = reg;
+	}
+	else
+	{
+		shiftcnt = 8 * (unit - 4);
+		reg = ADM5120_SW_REG(VLAN_G2_REG) & ~(VLAN_PORT_MASK << shiftcnt);
+		reg |= (portmask & VLAN_PORT_MASK) << shiftcnt;
+		ADM5120_SW_REG(VLAN_G2_REG) = reg;	
+	}
+	
+	return 0;
+}
+
+int ProgramVlanMac(int vlan, char *Mac, int clear)
+{
+	unsigned long Reg0, Reg1;
+	
+	if (vlan < 0 || vlan >= MAX_VLAN_GROUP)
+		return -1;
+		
+	Reg0 = (((unsigned char)Mac[1] << 24) | ((unsigned char)Mac[0] << 16)) | (vlan << SW_MAC_VLANID_SHIFT)
+			| SW_MAC_WRITE | SW_MAC_VLANID_EN;
+	
+	if (!clear)
+		Reg0 |= SW_MAC_AGE_VALID;
+	
+	Reg1 = ((unsigned char)Mac[5] << 24) | ((unsigned char)Mac[4] << 16) |
+		((unsigned char)Mac[3] << 8) | (unsigned char)Mac[2];
+		
+	ADM5120_SW_REG(MAC_wt1_REG) = Reg1;
+	ADM5120_SW_REG(MAC_wt0_REG) = Reg0;
+	
+	while (!(ADM5120_SW_REG(MAC_wt0_REG) & SW_MAC_WRITE_DONE));
+	
+	return 0;
+}
+
+void EnableVlanGroup(int unit, unsigned long vlanGrp)
+{
+	int i;
+	int vlanId = 0x01 << unit;
+	
+	vlanGrp &= SW_DISABLE_PORT_MASK;
+	ADM5120_SW_REG(Port_conf0_REG) &= ~vlanGrp;
+	
+	/* Mark the enabled ports */
+	for (i = 0; i < NUM_IF5120_PORTS; i++)
+	{
+		if (vlanGrp & (0x01 << i))
+		{
+			sw_context->port[i].status = PORT_ENABLED;
+			sw_context->port[i].vlanId = vlanId;
+			sw_context->port[i].ifUnit = unit;
+		}
+	}
+}	
+
+void DisableVlanGroup(int unit, unsigned long vlanGrp)
+{
+	int i;
+	unsigned long reg;
+	
+	vlanGrp &= SW_DISABLE_PORT_MASK;
+	
+	reg = ADM5120_SW_REG(Port_conf0_REG) | vlanGrp;
+	ADM5120_SW_REG(Port_conf0_REG) = reg;
+	
+	/* Mark the disabled ports */
+	for (i = 0; i < NUM_IF5120_PORTS; i++)
+		if (vlanGrp & (0x01<<i))
+			sw_context->port[i].status = PORT_DISABLED;
+}
+
+
+/*------------------------------------------------------
+	    Linux interface related functions
+  ------------------------------------------------------*/
+
+
+int adm5120sw_open(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+
+	int unit = priv->unit;
+		
+	/* setup vlan reg */
+	SetupVLAN(unit, sw_context->vlanGrp[unit]);
+	
+	/* program vlan mac */
+	ProgramVlanMac(unit, dev->dev_addr, SW_MAC_AGE_VALID);
+	
+	/* Enable vlan Group */
+	EnableVlanGroup(unit, (unsigned long)sw_context->vlanGrp[unit]);
+	
+	priv->vlanId = 1 << unit;
+	
+	if (sw_context->actIfCnt == 0)
+	{
+		/* Enable interrupt */
+		ADM5120_SW_REG(SW_Int_mask_REG) = ~sw_context->intMask;
+	}
+	sw_context->actIfCnt++;
+	
+	spin_unlock(&sw_context->lock);
+	
+	dev->irq = SW_IRQ;
+	netif_start_queue(dev);
+	
+	return 0;
+}
+
+
+int adm5120sw_release(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	int unit = priv->unit;
+	
+	netif_stop_queue(dev); /* can't transmit any more */
+	
+	spin_lock(&sw_context->lock);
+	
+	/* Enable vlan Group */
+	DisableVlanGroup(unit, (unsigned long)sw_context->vlanGrp[unit]);
+	
+	if (--sw_context->actIfCnt <= 0)
+	{
+		ADM5120_SW_REG(SW_Int_mask_REG) = SWITCH_INT_MASK;
+	}
+	
+	spin_unlock(&sw_context->lock);
+	
+	return 0;
+}
+
+int adm5120sw_config(struct net_device *dev, struct ifmap *map)
+{
+	/* can't act on a running  interface */
+	if (dev->flags & IFF_UP)
+	return -EBUSY;
+	
+	/* ignore other fields */
+	return 0;
+}
+
+void adm5120sw_set_rx_mode(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	int port = sw_context->vlanGrp[priv->unit] & 0x3F;
+	
+	/* Note do not reorder, GCC is clever about common statements. */
+	if (dev->flags & IFF_PROMISC)
+	{
+//		printk (KERN_NOTICE "%s: Promiscous mode enabled.\n", dev->name);
+/*		If set promisc(Bridge mode) we need to disable te SA so all 
+		data on same vlan will be resend (hub mode)
+		The best way in bridge mode is to set 5 ethernet and put on
+		bridge, disavantage all data will be processed by the bridge.
+		No good, if not set blocking state can't see the bridge mac-s
+*/
+		priv->iflags = IF_PROMISC_MODE;
+		ADM5120_SW_REG(CPUp_conf_REG) &= ~(port  << 9);
+		ADM5120_SW_REG(Port_conf1_REG) |= (port) | (port << 6);//disable sa_learn & blocking state (for bridge)
+	}
+	else
+	{
+//		printk (KERN_NOTICE "%s: Promiscous mode disabled.\n", dev->name);
+		priv->iflags &= ~IF_PROMISC_MODE;
+		ADM5120_SW_REG(CPUp_conf_REG) |= (port  << 9);
+		ADM5120_SW_REG(Port_conf1_REG) &= ~(port ) | ~(port << 6);
+	}
+	
+}
+
+int adm5120sw_set_mac(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	unsigned long flags;
+	spinlock_t *lock = &((PSW_PRIV_T)dev->priv)->lock;
+	
+	spin_lock_irqsave(lock, flags);
+	
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	
+	spin_unlock_irqrestore(lock, flags);
+	
+	return 0;
+}
+
+
+int adm5120sw_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	unsigned long eflags;
+	PTX_ENG_T txEng;
+	PTXDESC_T hdesc;
+	PTX_DRV_DESC_T drvDesc;
+	unsigned long csum = 0;
+	int len;
+	
+	if (skb == NULL) return 0;
+	
+	spin_lock_irqsave(&priv->lock, eflags);
+	
+	dev->trans_start = jiffies; /* save the timestamp */
+	
+	/* get tx engine */
+	if (priv->priority == IF_TX_PRIORITY_H)
+		txEng = &sw_context->txH;
+	else
+		txEng = &sw_context->txL;
+	
+	/* get check sum flag */
+	if (priv->csum_flags)
+		csum = TX_ADD_IPSUM;
+
+	/* get hardware descriptor */
+	hdesc = &txEng->hwDesc[txEng->idxHead];
+	if (hdesc->buf1cntl & OWN_BIT)
+	{
+		dev_kfree_skb(skb);
+		priv->stats.tx_dropped++;
+		return 0;
+	}
+
+	drvDesc = &txEng->drvDesc[txEng->idxHead];
+	drvDesc->skb = skb;
+	
+	hdesc->buf1cntl = (hdesc->buf1cntl & END_OF_RING) | 
+			(((unsigned long)skb->data & BUF_ADDR_MASK) | OWN_BIT);
+		
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	hdesc->pktcntl = (len << PKT_LEN_SHIFT) | priv->vlanId | csum;
+	hdesc->buf1len = len;
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += len;
+
+	if (++txEng->idxHead >= txEng->numDesc)
+		txEng->idxHead = 0;
+	ADM5120_SW_REG(Send_trig_REG) = txEng->txTrig;
+	
+	spin_unlock_irqrestore(&priv->lock, eflags);
+	
+	return 0;
+}
+
+int adm5120sw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return 0;
+}
+
+void adm5120sw_tx_timeout (struct net_device *dev)
+{
+	return;
+}
+
+struct net_device_stats *adm5120sw_stats(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	return &priv->stats;
+}
+
+int adm5120sw_change_mtu(struct net_device *dev, int new_mtu)
+{
+	unsigned long flags;
+	spinlock_t *lock = &((PSW_PRIV_T)dev->priv)->lock;
+	
+	/* check ranges */
+	if ((new_mtu < 68) || (new_mtu > 1500))
+		return -EINVAL;
+	
+	spin_lock_irqsave(lock, flags);
+	dev->mtu = new_mtu;
+	spin_unlock_irqrestore(lock, flags);
+	return 0;
+}
+
+int adm5120sw_rebuild_header(struct sk_buff *skb){return 0;}
+
+int adm5120sw_header(struct sk_buff *skb, struct net_device *dev,
+		unsigned short type, void *daddr, void *saddr,
+		unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);
+	
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);
+	return (dev->hard_header_len);
+}
+	
+int adm5120sw_init(struct net_device *dev)
+{
+	PSW_PRIV_T priv;
+	
+	/* assign some of the fields */
+	ether_setup(dev);
+	
+	dev->open		= adm5120sw_open;
+	dev->stop		= adm5120sw_release;
+	dev->set_config		= adm5120sw_config;
+	dev->set_multicast_list = adm5120sw_set_rx_mode;
+	dev->set_mac_address	= adm5120sw_set_mac;
+	dev->hard_start_xmit	= adm5120sw_tx;
+	dev->do_ioctl		= adm5120sw_ioctl;
+	dev->get_stats		= adm5120sw_stats;
+	dev->change_mtu		= adm5120sw_change_mtu;
+	dev->rebuild_header	= adm5120sw_rebuild_header;
+	dev->hard_header	= adm5120sw_header;
+	dev->tx_timeout		= adm5120sw_tx_timeout;
+	dev->watchdog_timeo	= timeout;
+	
+	set_bit(__LINK_STATE_PRESENT, &dev->state);
+	
+	/*
+	 * Then, allocate the priv field. This encloses the statistics
+	 * and few private fields.
+	 */
+	dev->priv = kmalloc(sizeof(SW_PRIV_T), GFP_KERNEL);
+	if (dev->priv == NULL)
+		return (-ENOMEM);
+		
+	memset(dev->priv, 0, sizeof(SW_PRIV_T));
+	
+	priv = (PSW_PRIV_T)dev->priv;
+	priv->unit = unit++;
+	
+	spin_lock_init(&priv->lock);
+	
+	return 0;
+}
+
+
+
+
+/* ------------------------------------------------------
+    		Driver initialisation
+  ------------------------------------------------------*/
+
+
+static int __init adm5120switch_init (void)
+{
+	int result, i, device_present = 0;
+	BOARD_CFG_T boardCfg = {0};
+	
+	printk("ADM5120 Switch Module Init V1.3\n");
+	if (adm5120swdrv_init() != 0)
+		return (-ENODEV);
+		
+	sw_context->nr_if = adm5120_get_nrif(sw_context->vlanGrp);
+
+	memcpy((char *)&boardCfg, (char *)PA2VA(ADM5120SW_BOARD_CFG_ADDR), sizeof (boardCfg));
+	if (boardCfg.macmagic != MAC_MAGIC)
+	{
+	    printk("ADM5120 Config partition invalid, using default,");
+	    memmove(&boardCfg.mac[0][0], ADM5120SW_DEFAULT_MAC , 6);
+	}
+	printk("ADM5120 MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
+		    boardCfg.mac[0][0],boardCfg.mac[0][1],
+		    boardCfg.mac[0][2],boardCfg.mac[0][3],
+		    boardCfg.mac[0][4],boardCfg.mac[0][5]);
+	
+	for (i = 0; i < sw_context->nr_if; i++) {
+	    memcpy( adm5120sw_devs[i].dev_addr, &boardCfg.mac[0][0], 6);
+	    adm5120sw_devs[i].dev_addr[5] += i;
+	    
+	    if ((result = register_netdev(adm5120sw_devs + i ))) {
+		printk("am5120sw: error %i registering device \"%s\"\n",
+		    result, adm5120sw_devs[i].name);
+	    } else
+		device_present++;
+	}
+        result = request_irq(SW_IRQ, swdrv_ProcessInt,SA_SHIRQ,"adm5120_sw",&sw_context);
+        if (result)
+            return -ENODEV;
+								
+									
+	if (device_present != sw_context->nr_if)
+	    return (-ENODEV);
+
+	init_adm5120_in_procfs();
+	    
+	return 0;
+		
+}
+
+static void __exit adm5120switch_cleanup(void)
+{
+	int i;
+	
+	free_irq( SW_IRQ , &sw_context );	
+	for ( i = 0; i < sw_context->nr_if; i++)
+	{
+
+	    kfree(adm5120sw_devs[i].priv);
+	    unregister_netdev(adm5120sw_devs + i);
+	}
+	del_adm5120_from_procfs();
+}
+
+module_init(adm5120switch_init);
+module_exit(adm5120switch_cleanup);
+
+
+/*----------------DEBUG------------------------------------------
+
+char adm5120_procdir[]="net/adm5120sw";
+struct proc_dir_entry *adm5120_entry;
+struct proc_dir_entry *sw_state,*phy_state,*nf_time;
+static char *buffer=NULL;
+
+static int init_adm5120_in_procfs(void);
+static void del_adm5120_from_procfs(void);
+static int show_switch_state(char *,char **,off_t,int ,int *,void *);
+static int show_switch_PHY_ctl4(char *,char **,off_t,int ,int *,void *);
+
+static int show_irq_num(char *,char **,off_t,int ,int *,void *);
+static int clear_irq_num(struct file *file,const char *buffer,unsigned long count,void *data);
+
+static int show_nf_time(char *,char **,off_t,int ,int *,void *);
+static int clear_nf_time(struct file *file,const char *buffer,unsigned long count,void *data);
+
+static int
+set_entry(struct proc_dir_entry *ent,read_proc_t *fread,write_proc_t *fwrite)
+{
+    ent->owner=THIS_MODULE;
+    ent->read_proc=fread;
+    ent->write_proc=fwrite;
+    return 0;
+}
+							
+
+static int
+init_adm5120_in_procfs(void){
+
+    adm5120_entry=proc_mkdir(adm5120_procdir,NULL);
+    if( adm5120_entry==NULL )
+        return -ENOMEM;
+    if( !(sw_state=create_proc_entry("switch_state",444,adm5120_entry) ) )
+	return -ENOMEM;
+    set_entry(sw_state,show_switch_state,NULL);
+			
+    if( !(phy_state=create_proc_entry("irq_num",444,adm5120_entry) ) )
+	return -ENOMEM;
+    if( set_entry(phy_state,show_irq_num,clear_irq_num) )
+        return -ENOMEM;
+
+    if( !(nf_time=create_proc_entry("nf_time",444,adm5120_entry) ) )
+	return -ENOMEM;
+    if( set_entry(nf_time,show_nf_time,clear_nf_time) )
+        return -ENOMEM;
+
+
+    return 0;
+}        
+
+static void
+del_adm5120_from_procfs(void){
+
+    remove_proc_entry("switch_state",adm5120_entry);
+    remove_proc_entry("irq_num",adm5120_entry);    
+    remove_proc_entry("nf_time",adm5120_entry);    
+    remove_proc_entry("",adm5120_entry);    
+
+    if( buffer!=NULL )
+	kfree(buffer);
+}        
+
+		
+char *get_switch_status(int *len)
+{
+    char *buf=kmalloc(2*PAGE_SIZE,GFP_KERNEL);
+    PRXDESC_T RxDesc=sw_context->rxL.hwDesc;
+    PTXDESC_T TxDesc=sw_context->txL.hwDesc;
+ 
+    PTX_DRV_DESC_T tdrvDesc=sw_context->txL.drvDesc;
+    PRX_DRV_DESC_T rdrvDesc=sw_context->rxL.drvDesc;
+
+    
+    int ind=0;
+    int i;
+    ind+=sprintf(buf+ind,"PHY_ST:%08x\n",(unsigned int)ADM5120_SW_REG(PHY_st_REG));
+    ind+=sprintf(buf+ind,"Port_conf2:%08x\n",(unsigned int)ADM5120_SW_REG(Port_conf2_REG));
+    ind+=sprintf(buf+ind,"PHY_ctl2:%08x\n",(unsigned int)ADM5120_SW_REG(PHY_cntl1_REG));    
+    ind+=sprintf(buf+ind,"PHY_ctl3:%08x\n",(unsigned int)ADM5120_SW_REG(PHY_cntl3_REG));        
+
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+//    ind+=sprintf("PHY_ST:%08x ",ADM5120_SW_REG(PHY_st_REG));    
+
+    ind+=sprintf(buf+ind,"TX_DESC:\n");
+    for(i=0;i<NUM_TX_L_DESC;i++)
+	ind+=sprintf(buf+ind,"%d: %08x %08x skb=%08x\n",i,(unsigned int)(TxDesc+i)->buf1cntl,
+		    (unsigned int)(TxDesc+i)->pktcntl,(unsigned int)(tdrvDesc+i)->skb );
+
+    ind+=sprintf(buf+ind,"RX_DESC:\n");
+    for(i=0;i<NUM_RX_L_DESC;i++)
+	ind+=sprintf(buf+ind,"%d: %08x skb=%08x, skb->data=%08x\n",i,
+		    (unsigned int)(RxDesc+i)->buf1cntl,
+		    (unsigned int)(rdrvDesc+i)->skb,(unsigned int)(rdrvDesc+i)->skb->data );
+    *len=ind;
+    return buf;
+}		    				
+      
+
+
+static int show_switch_state(char* page, char** start, off_t off, int count, int* eof, void* data)
+{
+
+    static int buff_index=0,buff_len=0;
+    int i,j;
+
+    PDEBUG(5,"page=%08x,offset=%d,count=%d",(u32)page,off,count);    
+    if( buffer==NULL ){
+	buffer=get_switch_status(&buff_len);
+	buffer[buff_len]=0;
+	PDEBUG(5,"get string: len=%d",buff_len);    
+    }
+    
+    j=buff_index;
+    for(i=0;i<count && buff_index<=buff_len;i++,buff_index++)
+	page[off+i]=buffer[buff_index];
+
+    PDEBUG(5,"ind before: %d,ind after: %d",j,buff_index);    	        
+    j=buff_index-j;
+    if( buff_index>buff_len){
+	buff_index=0;
+	buff_len=0;
+	kfree(buffer);
+	buffer=NULL;
+	PDEBUG(5,"Read all buffer:");    	
+	*eof=1;
+    }
+    return j;
+}
+
+
+static int
+show_irq_num(char* page, char** start, off_t off, int count, int* eof, void* data)
+{
+    int len;
+    len=snprintf(page,count,"tx_int=%d,tx_req=%d\nrx_int=%d\n",tx_int,tx_req,
+		    rx_int);
+
+    len+=snprintf(page+len,count,"cpuh_int=%d sde_int=%d rde_int=%d\n",
+		cpuh_int,sde_int, rde_int);
+
+    len+=snprintf(page+len,count,"p0qf_int=%d p1qf_int=%d p2qf_int=%d\np3qf_int=%d p4qf_int=%d p5qf_int=%d\n",
+		    p0qf_int,p1qf_int,p2qf_int,p3qf_int,p4qf_int,p5qf_int);
+
+    len+=snprintf(page+len,count,"cpup_int=%d\n",
+		    cpup_int);
+    *eof=1;
+    return len;
+}
+
+static int
+clear_irq_num(struct file *file,const char *buffer,unsigned long count,void *data)
+{
+    tx_int=rx_int=tx_req=0;
+    cpuh_int=sde_int=rde_int=0;
+    p0qf_int=p1qf_int=p2qf_int=0;
+    p3qf_int=p4qf_int=p5qf_int=0;
+    cpup_int=0;
+    
+    return count;
+}
+
+
+static int
+show_nf_time(char* page, char** start, off_t off, int count, int* eof, void* data)
+{
+    int len=0;
+    struct timeval tv;
+    char str[255];
+
+
+    DEBUG_NET_OUTPUT(arp,str);
+    len+=snprintf(page+len,count,"ip_arp:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(igmp,str);    
+    len+=snprintf(page+len,count,"ip_igmp:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(input,str);    
+    len+=snprintf(page+len,count,"ip_input:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(output,str);    
+    len+=snprintf(page+len,count,"ip_output:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(ipmr,str);    
+    len+=snprintf(page+len,count,"ip_ipmr:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(forward,str);    
+    len+=snprintf(page+len,count,"ip_forward:\t%s\n",str);    
+
+    DEBUG_NET_OUTPUT(hook,str);    
+    len+=snprintf(page+len,count,"ip_hook:\t%s\n",str);    
+
+    *eof=1;
+    return len;
+}
+
+static int
+clear_nf_time(struct file *file,const char *buffer,unsigned long count,void *data)
+{
+    return count;
+}
+
+
+
+
+
+/*
+static int show_switch_PHY_ctl4(char *,char **,off_t,int ,int *,void *){
+
+}
+*/
+
+/*----------------DEBUG------------------------------------------*/
Index: linux/drivers/net/adm5120sw.h
===================================================================
--- linux/drivers/net/adm5120sw.h	(.../linux)	(revision 0)
+++ linux/drivers/net/adm5120sw.h	(.../linux-kernel/linux)	(revision 28)
@@ -0,0 +1,289 @@
+/*
+ *	ADM5120 ethernet switch driver
+ *	
+ *	Based on original ADMTEK 2.4.18 driver, copyright ADMtek Inc.
+ *	daniel@admtek.com.tw
+ *	
+ *	Port to 2.4.31 kernel and modified to able to load as module
+ *	by Joco, rjoco77@kezdionline.ro
+ *	
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	
+ */
+
+#ifndef __ADM5120SW_H__
+#define __ADM5120SW_H__
+
+#include <asm/am5120/adm5120.h>
+
+#define ADM5120_DEBUG
+//#define DEBUG_DEF 6
+
+/********************* MII Phy Reg Access ********************/
+#define PHY_ADDR_MASK			0x0000000F
+#define PHY_REG_MASK			0x00001F00
+#define PHY_WRITE_CMD			0x00002000
+#define PHY_READ_CMD			0x00004000
+
+#define PHY_REG_SHIFT			8
+
+#define PHY_WRITE_OK			0x00000001
+#define PHY_READ_OK			0x00000002
+#define PHY_DATA_MASK			0xFFFF0000
+#define PHY_DATA_SHIFT			16
+
+#define MII_PHY_CTRL_REG		0
+#define MII_PHY_STATUS_REG		1
+#define MII_PHY_ID0_REG			2
+#define MII_PHY_ID1_REG			3
+#define MII_PHY_ANAR_REG		4
+#define MII_PHY_ANLPAR_REG		5
+#define MII_PHY_LINK_REG		0x10
+
+#define MII_PHY_FORCE_LINK		0x03
+
+/*************** VLAN *****************/
+#define MAX_VLAN_GROUP			4
+#define VLAN_PORT_MASK			0x7f
+
+// Vlan status
+#define VLAN_NOT_DEFINED		0
+#define VLAN_DISABLED			1
+#define VLAN_ENABLED			2
+
+#define VLAN_NONE			0x00
+#define VLAN0_ID			0x01
+#define VLAN1_ID			0x02
+#define VLAN2_ID			0x04
+#define VLAN3_ID			0x08
+
+/***************** Tx/Rx Desc **********************/
+#define HWDESC_ALIGN			16
+
+//Common
+#define OWN_BIT				0x80000000
+#define END_OF_RING			0x10000000
+#define BUF_ADDR_MASK			0x01FFFFFF
+#define BUF2_EN				0x80000000
+
+#define BUF1_LEN_MASK			0x000007FF
+#define PKT_LEN_MASK			0x07FF0000
+#define PKT_LEN_SHIFT			16
+
+// RxDesc Only
+#define RX_SRC_PORT_MASK		0x00007000
+#define RX_SRC_PORT_SHIFT		12
+
+#define RX_FRAME_TYPE_MASK		0x00000030
+#define RX_FRAME_UC			0
+#define RX_FRAME_MC			0x00000010
+#define RX_FRAME_BC			0x00000020
+
+#define RX_PKT_IPSUM_ERR		0x00000008
+#define RX_PKT_VLAN_TAG			0x00000004
+
+#define RX_PKT_TYPE_MASK		0x00000003
+#define RX_PKT_IP			0x00000000
+#define RX_PKT_PPPOE			0x00000001
+
+#define RX_PKT_FLAG_MASK		0x0000007F
+
+// TxDesc Only
+#define TX_ADD_IPSUM			0x80000000
+#define TX_DEST_VLAN_MASK		0x0000003F
+#define TX_DEST_PORT_MASK		0x00003F00
+/******************* Interrupts *********************/
+#define RX_H_INT			(RX_H_DONE_INT | RX_H_DESC_FULL_INT)
+#define RX_L_INT			(RX_L_DONE_INT | RX_L_DESC_FULL_INT)
+#define TX_H_INT			SEND_H_DONE_INT
+#define TX_L_INT			SEND_L_DONE_INT
+#define LINK_INT			PORT_STATUS_CHANGE_INT
+
+#define PORT_INT			PORT_STATUS_CHANGE_INT
+#define WATCHDOG0_INT			WATCHDOG0_EXPR_INT
+#define WATCHDOG1_INT			WATCHDOG1_EXPR_INT
+
+/******************* Switch ports *****************/
+#define ETH_PORT_NUM			4
+#define CPU_PORT			6
+#define CPU_PORT_MASK			(0x1 << CPU_PORT)
+#define GMII_PORT			5
+#define IF5120_LAST_PORT		GMII_PORT
+#define NUM_IF5120_PORTS		(IF5120_LAST_PORT+1)  //Excluding the cpu port
+#define IF5120_PORT_MASK		0x3f
+#define PORT_VLAN_MASK			0x3f
+#define IF5120_PORT_NUM			7
+
+/* Port status */
+#define PORT_DISABLED			0
+#define PORT_ENABLED			1
+
+/************************ Switch config ***************************/
+#define DEF_CPUPORT_CFG			(SW_CPU_PORT_DISABLE | SW_PADING_CRC | SW_DIS_UN_MASK)
+#define DEF_PORTS_CFG			(SW_EN_BP_MASK | SW_EN_MC_MASK | SW_DISABLE_PORT_MASK)
+
+/***********************************************************/
+#define ETH_MAC_LEN			6
+#define ETH_VLANTAG_LEN			4
+#define ETH_CRC_LEN			4		// Ethernet CRC Length
+
+#define TX_SMALL_BUF_SIZE		256
+#define TX_LARGE_BUF_SIZE		1536
+#define TX_BUF_SIZE			1536
+
+#define RX_BUF_SIZE			1680
+#define RX_BUF_REV_SIZE			130
+#define DEF_RX_BUF_SIZE			(RX_BUF_SIZE - RX_BUF_REV_SIZE)
+
+#define SMALL_PKT_LEN			TX_SMALL_BUF_SIZE
+#define MAX_PKT_LEN			1514
+
+#define MIN_ETH_FRAME_LEN		60
+
+/****************** PSEUDO-NIC Control Flags ********************/
+#define IF_TX_PRIORITY_H		0x0001
+#define IF_PROMISC_MODE			0x0002
+#define IF_ATTACH_BRIDGE		0x0010
+#define IF_BRIDGE_HOSTIF		0x0020
+#define IF_CTRL_FLAG_MASK		0x0033
+#define IF_MAC_ALIAS			0x0100
+
+/**************************************************************/
+#define MEM_KSEG0_BASE			0x80000000
+#define MEM_KSEG1_BASE			0xA0000000
+#define MEM_SEG_MASK			0xE0000000
+#define KVA2PA(_addr)			((unsigned long)(_addr) & ~MEM_SEG_MASK)
+
+#define MIPS_KSEG0A(_addr)		(KVA2PA(_addr) | MEM_KSEG0_BASE)
+#define MIPS_KSEG1A(_addr)		(KVA2PA(_addr) | MEM_KSEG1_BASE)
+
+#define PA2VA(_addr)			(KVA2PA(_addr) | MEM_KSEG1_BASE)
+#define PA2CACHEVA(_addr)		(KVA2PA(_addr) | MEM_KSEG0_BASE)
+
+#define ADM5120SW_BOARD_CFG_ADDR	0x1FC08000
+#define ADM5120SW_DEFAULT_MAC		"\x00\x11\x22\x33\x44\x55"
+
+/* tx driver descriptor */
+typedef struct adm5120sw_tx_drv_desc_s
+{
+	struct sk_buff *skb;
+} TX_DRV_DESC_T, *PTX_DRV_DESC_T;
+
+/* rx driver descriptor */
+typedef struct adm5120sw_rx_drv_desc_s
+{
+	struct sk_buff *skb;
+} RX_DRV_DESC_T, *PRX_DRV_DESC_T;
+
+/* tx descriptor */
+typedef struct adm5120sw_tx_desc_s
+{
+	unsigned long buf1cntl;
+	unsigned long buf2cntl;
+	unsigned long buf1len;
+	unsigned long pktcntl;
+} TXDESC_T, *PTXDESC_T;
+
+/* rx descriptor */
+typedef struct adm5120sw_rx_desc_s
+{
+	unsigned long buf1cntl;
+	unsigned long buf2cntl;
+	unsigned long buf1len;
+	unsigned long status;
+} RXDESC_T, *PRXDESC_T;
+
+/* Rx engine */
+typedef struct adm5120sw_rx_eng_s
+{
+	PRXDESC_T hwDesc;
+	PRX_DRV_DESC_T drvDesc;
+	int numDesc;
+	int idx;
+} RX_ENG_T, *PRX_ENG_T;
+
+/* Tx engine */
+typedef struct adm5120sw_tx_eng_s
+{
+	PTXDESC_T hwDesc;
+	PTX_DRV_DESC_T drvDesc;
+	int numDesc;
+	int idxHead;
+	int idxTail;
+	unsigned long txTrig;
+} TX_ENG_T, *PTX_ENG_T;
+
+/* port status */
+typedef struct port_status_s
+{
+	unsigned long status;
+	unsigned long vlanId;
+	unsigned long ifUnit;
+} PORT_CFG_T, *PPORT_CFG_T;
+
+typedef struct adm5120sw_context_s {
+	TX_ENG_T txH, txL;
+	RX_ENG_T rxH, rxL;
+	
+	PORT_CFG_T port[NUM_IF5120_PORTS];
+	
+	/* Vlan group of IF unit */
+//	unsigned long vlanGrp[MAX_VLAN_GROUP];
+	unsigned char vlanGrp[MAX_VLAN_GROUP];
+	unsigned char nr_if;
+	
+	unsigned long intMask;
+	unsigned long intStatus;
+	unsigned long linkStatus;
+	
+	int ifCnt;
+	int actIfCnt;
+	
+	/* tx drv descriptor pool */
+	unsigned char *txDrvDescPool;
+	
+	/* rx drv descriptor pool */
+	unsigned char *rxDrvDescPool;
+	
+	/* Hardware descriptor pool */
+	unsigned char *hwDescPool;
+	
+	spinlock_t lock;
+
+} SW_CONTEXT_T, *PSW_CONTEXT_T;
+
+/* net device private data */
+typedef struct adm5120sw_priv_s
+{
+	struct net_device_stats stats;
+	
+	spinlock_t lock;
+	
+	/* interface unit */
+	int unit;
+	
+	int status;
+	int priority;
+	int csum_flags;
+	
+	/* interface flags */
+	int iflags;
+	
+	/* for fill tx descriptor */
+	unsigned long vlanId;
+	
+} SW_PRIV_T, *PSW_PRIV_T;
+
+#endif
+
Index: linux/drivers/pcmcia/yenta_socket.c
===================================================================
--- linux/drivers/pcmcia/yenta_socket.c	(.../linux)	(revision 5)
+++ linux/drivers/pcmcia/yenta_socket.c	(.../linux-kernel/linux)	(revision 28)
@@ -27,11 +27,12 @@
 #include "yenta_socket.h"
 #include "i82365.h"
 
-static int disable_clkrun;
+static int disable_clkrun=1;
+/*
 module_param(disable_clkrun, bool, 0444);
 MODULE_PARM_DESC(disable_clkrun, "If PC card doesn't function properly, please try this option");
-
-static int isa_probe = 1;
+*/
+static int isa_probe = 0;
 module_param(isa_probe, bool, 0444);
 MODULE_PARM_DESC(isa_probe, "If set ISA interrupts are probed (default). Set to N to disable probing");
 
@@ -895,6 +896,7 @@
 	u8 csc;
         u32 cb_event;
 
+printk(KERN_NOTICE"%s:\n",__FUNCTION__);
 	/* Clear interrupt status for the event */
 	cb_event = cb_readl(socket, CB_SOCKET_EVENT);
 	cb_writel(socket, CB_SOCKET_EVENT, -1);
Index: linux/drivers/base/firmware_class.c
===================================================================
--- linux/drivers/base/firmware_class.c	(.../linux)	(revision 5)
+++ linux/drivers/base/firmware_class.c	(.../linux-kernel/linux)	(revision 28)
@@ -18,6 +18,7 @@
 #include <asm/semaphore.h>
 
 #include <linux/firmware.h>
+#include <linux/delay.h>
 #include "base.h"
 
 MODULE_AUTHOR("Manuel Estrada Sainz <ranty@debian.org>");
@@ -251,6 +252,7 @@
 	struct firmware *fw;
 	ssize_t retval;
 
+        mdelay(2);
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 

Property changes on: linux
___________________________________________________________________
Name: svn:ignore
   + .tmp_System.map
.kernelrelease
.config.old
.version
.tmp_kallsyms1.S
.kconfig.d
.tmp_kallsyms2.S
.tmp_vmlinux1
log
.tmp_vmlinux2
Module.symvers
System.map
vmlinux
vmlinuz
.tmp_versions
vmlinux.bin
kernel/config_data.gz


