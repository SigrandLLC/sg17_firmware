diff -urN linux.dev/drivers/char/Config.in linux.dev2/drivers/char/Config.in
--- linux.dev/drivers/char/Config.in	2005-10-21 17:02:20.199991500 +0200
+++ linux.dev2/drivers/char/Config.in	2005-10-21 18:03:44.541778750 +0200
@@ -133,6 +133,10 @@
       fi
    fi
 fi
+if [ "$CONFIG_AR7" = "y" ]; then
+   bool  'Enable LED support' CONFIG_AR7_LED
+fi
+
 if [ "$CONFIG_EXPERIMENTAL" = "y" -a "$CONFIG_ZORRO" = "y" ]; then
    tristate 'Commodore A2232 serial support (EXPERIMENTAL)' CONFIG_A2232
 fi
diff -urN linux.dev/drivers/char/Makefile linux.dev2/drivers/char/Makefile
--- linux.dev/drivers/char/Makefile	2005-10-21 17:02:20.199991500 +0200
+++ linux.dev2/drivers/char/Makefile	2005-10-21 18:03:44.541778750 +0200
@@ -190,6 +190,12 @@
   obj-$(CONFIG_PCI) += keyboard.o $(KEYMAP)
 endif
 
+#
+# Texas Intruments LED driver
+# 
+obj-$(CONFIG_AR7_LED) += avalanche_led/avalanche_led.o
+subdir-$(CONFIG_AR7_LED) += avalanche_led
+
 obj-$(CONFIG_HIL) += hp_keyb.o
 obj-$(CONFIG_MAGIC_SYSRQ) += sysrq.o
 obj-$(CONFIG_ATARI_DSP56K) += dsp56k.o
diff -urN linux.dev/drivers/char/avalanche_led/Makefile linux.dev2/drivers/char/avalanche_led/Makefile
--- linux.dev/drivers/char/avalanche_led/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/drivers/char/avalanche_led/Makefile	2005-10-21 18:03:44.513777000 +0200
@@ -0,0 +1,23 @@
+# File: drivers/char/avalanche_led/Makefile
+#
+# Makefile for the Linux LED device driver.
+#
+
+
+O_TARGET := avalanche_led.o
+obj-m := avalanche_led.o
+list-multi      := avalanche_led.o
+
+EXTRA_CFLAGS := -I$(TOPDIR)/include/asm/ar7
+
+export-objs := ledmod.o leds.o
+
+avalanche_led-objs := ledmod.o gpio.o uartled.o leds.o
+
+include $(TOPDIR)/Rules.make
+
+avalanche_led.o:      $(avalanche_led-objs)
+	$(LD) -r -o $@ $(avalanche_led-objs)
+
+clean:
+	rm -f core *.o *.a *.s
diff -urN linux.dev/drivers/char/avalanche_led/gpio.c linux.dev2/drivers/char/avalanche_led/gpio.c
--- linux.dev/drivers/char/avalanche_led/gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/drivers/char/avalanche_led/gpio.c	2005-10-21 18:03:44.513777000 +0200
@@ -0,0 +1,382 @@
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+
+#include <asm/ar7/tnetd73xx_err.h>
+#include <asm/ar7/tnetd73xx_misc.h>
+#include <asm/ar7/ledapp.h>
+
+#define TRUE 1
+#define FALSE 0
+
+#if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+
+#define AR7_RESET_FILE "led_mod/ar7reset"
+#define AR7_VERSION_FILE "led_mod/hardware_version"
+#define AR7_RESET_GPIO 11
+#define RESET_POLL_TIME 1
+#define RESET_HOLD_TIME 4
+#define NO_OF_LEDS	
+
+static struct proc_dir_entry *reset_file;
+static int res_state = 0;
+static int count;
+static struct timer_list *pTimer = NULL;
+static ssize_t proc_read_reset_fops(struct file *filp,
+                                    char *buf,size_t count , loff_t *offp);
+
+static ssize_t proc_read_hwversion_fops(struct file *filp,
+                                    char *buf,size_t count , loff_t *offp);
+
+struct file_operations reset_fops = {
+                                     read: proc_read_reset_fops
+                                   };
+struct file_operations hardware_version_fops = {
+                                     read: proc_read_hwversion_fops
+                                   };
+#endif
+
+static spinlock_t	device_lock;
+led_reg_t temp[15];
+
+static void gpio_led_on( unsigned long param )
+{
+	unsigned int flags;
+
+	spin_lock_irqsave(&device_lock, flags);
+
+	tnetd73xx_gpio_out(param,FALSE);
+	spin_unlock_irqrestore(&device_lock, flags);
+}
+
+static void gpio_led_off ( unsigned long param )
+{
+	unsigned int flags = 0x00;
+
+ 	spin_lock_irqsave(&device_lock, flags);
+
+	tnetd73xx_gpio_out(param,TRUE);
+	spin_unlock_irqrestore(&device_lock, flags);
+}
+
+static void gpio_led_init( unsigned long param)
+{
+	tnetd73xx_gpio_ctrl(param,GPIO_PIN,GPIO_OUTPUT_PIN);
+}
+
+static void board_gpio_reset(void)
+{
+	/* Initialize the link mask */
+	device_lock = SPIN_LOCK_UNLOCKED;
+	return;
+}
+
+#if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+
+static ssize_t proc_read_hwversion_fops(struct file *filp, char *buf, 
+					size_t count, loff_t *offp)
+{
+	char line[8];
+  	int len = 0;
+  	if( *offp != 0 )
+  		return 0;
+
+	len = sprintf(line,  "%d%d.%d%d%d%d\n", tnetd73xx_gpio_in(20),
+			tnetd73xx_gpio_in(21), tnetd73xx_gpio_in(22),
+			tnetd73xx_gpio_in(23), tnetd73xx_gpio_in(24),
+		        tnetd73xx_gpio_in(25));
+  	
+	copy_to_user(buf, line, len);
+	*offp = len;
+	return len;
+}	
+
+static ssize_t proc_read_reset_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp)
+{
+  char * pdata = NULL;
+  char line[3];
+  int len = 0;
+  if( *offp != 0 )
+  	return 0;
+
+  pdata = buf;
+	len = sprintf(line,"%d\n", res_state );
+//wwzh
+//  res_state = 0;
+  copy_to_user(buf,line,len );
+	*offp = len;
+	return len;
+}
+
+static void reset_timer_func(unsigned long data)
+{
+//wwzh
+#if 0
+  	count = (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0) ? count + 1: 0;
+        if( count >= RESET_HOLD_TIME/RESET_POLL_TIME )
+#endif
+	if (tnetd73xx_gpio_in(AR7_RESET_GPIO) == 0)
+    		res_state = 1;
+	else
+		res_state = 0;
+	pTimer->expires = jiffies + HZ*RESET_POLL_TIME;
+	add_timer (pTimer);
+  return;
+}
+
+static void hardware_version_init(void)
+{
+   	static struct proc_dir_entry *hardware_version_file;
+  	hardware_version_file = create_proc_entry(AR7_VERSION_FILE, 0777, NULL);
+  	if(hardware_version_file == NULL)
+   		 return;
+  	
+	hardware_version_file->owner = THIS_MODULE;
+  	hardware_version_file->proc_fops = &hardware_version_fops;
+
+  	tnetd73xx_gpio_ctrl(20,GPIO_PIN,GPIO_INPUT_PIN);
+  	tnetd73xx_gpio_ctrl(21,GPIO_PIN,GPIO_INPUT_PIN);
+  	tnetd73xx_gpio_ctrl(22,GPIO_PIN,GPIO_INPUT_PIN);
+  	tnetd73xx_gpio_ctrl(23,GPIO_PIN,GPIO_INPUT_PIN);
+  	tnetd73xx_gpio_ctrl(24,GPIO_PIN,GPIO_INPUT_PIN);
+  	tnetd73xx_gpio_ctrl(25,GPIO_PIN,GPIO_INPUT_PIN);
+	
+	return;
+}
+
+static void reset_init(void)
+{
+  /* Create board reset proc file */
+  reset_file = create_proc_entry( AR7_RESET_FILE, 0777, NULL);
+  if( reset_file == NULL)
+    goto reset_file;
+  reset_file->owner = THIS_MODULE;
+  reset_file->proc_fops = &reset_fops;
+
+  /* Initialise GPIO 11 for input */
+  tnetd73xx_gpio_ctrl(AR7_RESET_GPIO,GPIO_PIN,GPIO_INPUT_PIN);
+
+  /* Create a timer which fires every seconds */
+  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+	init_timer( pTimer );
+	pTimer->function = reset_timer_func;
+	pTimer->data = 0;
+  /* Start the timer */
+  reset_timer_func(0);
+  return ;
+
+  reset_file:
+    remove_proc_entry("AR7_RESET_FILE",NULL);
+	return;
+}
+#endif
+/*************wwzh****************/
+#if 1
+extern unsigned int sys_mod_state;
+extern unsigned int  wan_mod_state;
+extern unsigned int wlan_mod_state;
+void sys_led_init(void)
+{
+	tnetd73xx_gpio_ctrl(4, GPIO_PIN, GPIO_OUTPUT_PIN);
+	tnetd73xx_gpio_ctrl(5, GPIO_PIN, GPIO_OUTPUT_PIN);
+	tnetd73xx_gpio_ctrl(8, GPIO_PIN, GPIO_OUTPUT_PIN);
+
+	tnetd73xx_gpio_out(4, FALSE);
+	tnetd73xx_gpio_out(5, TRUE);
+	tnetd73xx_gpio_out(8, TRUE);
+	
+
+	sys_mod_state = 2;
+
+}
+void wan_led_init(void)
+{
+	
+	tnetd73xx_gpio_ctrl(2, GPIO_PIN, GPIO_OUTPUT_PIN);
+	tnetd73xx_gpio_ctrl(3, GPIO_PIN, GPIO_OUTPUT_PIN);
+	
+	tnetd73xx_gpio_out(2, FALSE);
+	tnetd73xx_gpio_out(3, FALSE);
+
+	wan_mod_state = 1;
+}
+//wwzh wireless
+#if 0
+void wlan_led_init(void)
+{
+	//unsigned long i = 0;	
+	tnetd73xx_gpio_ctrl(12, GPIO_PIN, GPIO_OUTPUT_PIN);
+	tnetd73xx_gpio_ctrl(13, GPIO_PIN, GPIO_OUTPUT_PIN);
+	
+	tnetd73xx_gpio_out(12, FALSE);
+	tnetd73xx_gpio_out(13, TRUE);
+	//for (i = 0; i < 0x20000000; i++);
+	wlan_mod_state = 1;
+}
+#endif
+
+#endif
+/*************end ****************/
+
+void board_gpio_init(void)
+{
+
+	board_gpio_reset();
+/**************wwzh*************/
+	sys_led_init();
+	wan_led_init();
+
+	//junzhao 2004.3.15
+	hardware_version_init();
+	
+	//wlan_led_init();
+
+  	/* Register Device MAX_LED_ID + 1 for reset to factory default */
+	 temp[0].param = 0;
+ 	 temp[0].init = reset_init;
+  	 temp[0].onfunc = 0;
+ 	 temp[0].offfunc = 0;
+	 register_led_drv( MAX_LED_ID + 1 , &temp[0]);
+//wwzh for wireless led  
+#if 1
+  /* Register led 12 WiFi 6 */
+  temp[1].param = 6;
+  temp[1].init = gpio_led_init;
+  temp[1].onfunc = gpio_led_on;
+  temp[1].offfunc = gpio_led_off;
+  register_led_drv( 12 , &temp[1]);
+
+#endif
+
+#if 0
+/**************end ************/
+#if defined(CONFIG_AR5D01)
+  /* Register led 1 GPIO0 */
+  temp[0].param = GPIO_0;
+  temp[0].init = gpio_led_init;
+  temp[0].onfunc = gpio_led_on;
+  temp[0].offfunc = gpio_led_off;
+	register_led_drv( 1 , &temp[0]);
+
+  /* Register led 2 EINT1 */
+  temp[1].param = EINT_1;
+  temp[1].init = gpio_led_init;
+  temp[1].onfunc = gpio_led_on;
+  temp[1].offfunc = gpio_led_off;
+	register_led_drv( 2 , &temp[1]);
+
+  /* Register led 5 EINT1 */
+  temp[2].param = GPIO_1;
+  temp[2].init = gpio_led_init;
+  temp[2].onfunc = gpio_led_on;
+  temp[2].offfunc = gpio_led_off;
+	register_led_drv( 5 , &temp[2]);
+#endif
+
+#if defined(CONFIG_AR5W01)
+  /* Register led 5 GPIO_1 */
+  temp[0].param = GPIO_1;
+  temp[0].init = gpio_led_init;
+  temp[0].onfunc = gpio_led_on;
+  temp[0].offfunc = gpio_led_off;
+	register_led_drv( 5 , &temp[0]);
+
+  /* Register led 7 GPIO_0 */
+  temp[1].param = GPIO_0;
+  temp[1].init = gpio_led_init;
+  temp[1].onfunc = gpio_led_on;
+  temp[1].offfunc = gpio_led_off;
+	register_led_drv( 7 , &temp[1]);
+#endif
+
+//wwzh #if defined(CONFIG_AR7RD)
+#if defined CONFIG_AR7WRD || defined CONFIG_AR7RD
+  /* Register led 5 Green PPPOE GPIO 13 */
+  temp[0].param = 13;
+  temp[0].init = gpio_led_init;
+  temp[0].onfunc = gpio_led_on;
+  temp[0].offfunc = gpio_led_off;
+	register_led_drv( 5 , &temp[0]);
+
+  /* Register led 7 Green USB GPIO 12 */
+  temp[1].param = 12;
+  temp[1].init = gpio_led_init;
+  temp[1].onfunc = gpio_led_on;
+  temp[1].offfunc = gpio_led_off;
+	register_led_drv( 7 , &temp[1]);
+
+  /* Register Device MAX_LED_ID + 1 for reset to factory default */
+  temp[2].param = 0;
+  temp[2].init = reset_init;
+  temp[2].onfunc = 0;
+  temp[2].offfunc = 0;
+	register_led_drv( MAX_LED_ID + 1 , &temp[2]);
+
+  /* Register led 8 RED DSL GPIO 10 */
+  temp[3].param = 10;
+  temp[3].init = gpio_led_init;
+  temp[3].onfunc = gpio_led_on;
+  temp[3].offfunc = gpio_led_off;
+	register_led_drv( 8 , &temp[3]);
+
+  /* Register led 9 RED PPPoE down GPIO 9 */
+  temp[4].param = 9;
+  temp[4].init = gpio_led_init;
+  temp[4].onfunc = gpio_led_on;
+  temp[4].offfunc = gpio_led_off;
+	register_led_drv( 9 , &temp[4]);
+
+  /* Register led 10 DSL down GPIO 8 */
+  temp[5].param = 8;
+  temp[5].init = gpio_led_init;
+  temp[5].onfunc = gpio_led_on;
+  temp[5].offfunc = gpio_led_off;
+	register_led_drv( 10 , &temp[5]);
+
+  /* Register led 11 Power GPIO 7 */
+  temp[6].param = 7;
+  temp[6].init = gpio_led_init;
+  temp[6].onfunc = gpio_led_on;
+  temp[6].offfunc = gpio_led_off;
+	register_led_drv( 11 , &temp[6]);
+
+  /* Register led 12 WiFi 6 */
+  temp[7].param = 6;
+  temp[7].init = gpio_led_init;
+  temp[7].onfunc = gpio_led_on;
+  temp[7].offfunc = gpio_led_off;
+	register_led_drv( 12 , &temp[7]);
+
+  /* Register led 13 ELINK(AA1313) GPIO 15 */
+  temp[8].param = 15;
+  temp[8].init = gpio_led_init;
+  temp[8].onfunc = gpio_led_on;
+  temp[8].offfunc = gpio_led_off;
+	register_led_drv( 13 , &temp[8]);
+
+  /* Register led 14 EACT(Y13) GPIO 16 */
+  temp[9].param = 16;
+  temp[9].init = gpio_led_init;
+  temp[9].onfunc = gpio_led_on;
+  temp[9].offfunc = gpio_led_off;
+	register_led_drv( 14 , &temp[9]);
+
+#endif
+/**************wwzh**************/
+#endif
+/**************end **************/
+  return;
+}
+
+
+
+
+
+
+
+
diff -urN linux.dev/drivers/char/avalanche_led/ledmod.c linux.dev2/drivers/char/avalanche_led/ledmod.c
--- linux.dev/drivers/char/avalanche_led/ledmod.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/drivers/char/avalanche_led/ledmod.c	2005-10-21 18:03:44.513777000 +0200
@@ -0,0 +1,1116 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <asm/ar7/avalanche_regs.h>
+#include <asm/ar7/ledapp.h>
+#include <linux/module.h>
+
+#define LED_ON  		1
+#define LED_OFF 		2
+#define LED_BLINK   3
+#define LED_FLASH		4
+
+#define LED_BLINK_UP   		5
+#define LED_BLINK_DOWN   	6
+
+extern void avalanche_leds_init(void);
+
+/***********wwzh**************/
+unsigned int sys_mod_state;
+unsigned int wan_mod_state;
+unsigned int wlan_mod_state;
+
+struct timer_list *pWanTimer = NULL;
+struct timer_list *pWlanTimer = NULL;
+/***********end **************/
+
+typedef struct state_entry{
+  unsigned char mode;
+  unsigned char led;
+	void (*handler)(struct state_entry *pState);
+  unsigned long param;
+}state_entry_t;
+
+typedef struct mod_entry{
+  state_entry_t *states[MAX_STATE_ID];
+}mod_entry_t;
+
+static mod_entry_t *modArr[MAX_MOD_ID];
+static struct proc_dir_entry *led_proc_dir,*led_file;
+
+/* index of the array is the led number HARDWARE SPECIFIC*/
+typedef struct led_data{
+	led_reg_t *led;
+  int				state;
+	struct timer_list *pTimer;
+	unsigned char timer_running;
+  unsigned long param;
+}led_data_t;
+
+led_data_t led_arr[MAX_LED_ID + 1];
+/*!!! The last device is actually being used for ar7 reset to factory default */
+
+
+static spinlock_t	config_lock;
+
+static void board_led_link_up( state_entry_t *pState );
+static void board_led_link_down( state_entry_t *pState );
+static void board_led_activity_on( state_entry_t *pState );
+static void board_led_activity_off( state_entry_t *pState );
+static void led_timer_func(unsigned long data);
+
+extern void board_gpio_init(void);
+extern void uart_led_init(void);
+
+static ssize_t proc_read_led_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp);
+static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+                                                      size_t count , loff_t *offp);
+static int config_led( unsigned long y);
+
+struct file_operations led_fops = {
+                                     read: proc_read_led_fops,
+                                     write: proc_write_led_fops,
+                                   };
+
+static int led_atoi( char *name)
+{
+	int val = 0;
+  for(;;name++)
+	{
+		switch(*name)
+		{
+			case '0'...'9':
+				val = val*10+(*name - '0');
+				break;
+			default:
+				return val;
+		}
+	}
+}
+
+static int free_memory(void)
+{
+  int i, j;
+
+  for( i = 0; i < MAX_MOD_ID ; i++)
+	{
+		if( modArr[i] != NULL )
+		{
+			for( j = 0; j < MAX_STATE_ID ; j++ )
+			{
+				if( modArr[i]->states[j] != NULL )
+					kfree( modArr[i]->states[j]);
+			}
+			kfree(modArr[i]);
+      modArr[i] = NULL;
+		}
+	}
+  return 0;
+}
+
+static int led_on( state_entry_t *pState )
+{
+	if( led_arr[pState->led].led == NULL)
+		return -1;
+  led_arr[pState->led].led->onfunc( led_arr[pState->led].led->param);
+  return 0;
+}
+
+static int led_off( state_entry_t *pState )
+{
+	if( led_arr[pState->led].led == NULL)
+		return -1;
+  led_arr[pState->led].led->offfunc( led_arr[pState->led].led->param);
+  return 0;
+}
+
+static void board_led_link_up( state_entry_t *pState )
+{
+  led_arr[pState->led].state = LED_ON;
+  if( led_arr[pState->led].timer_running == 0 )
+  	led_on(pState);
+  return;
+}
+
+static void board_led_link_down( state_entry_t *pState )
+{
+	led_arr[pState->led].state = LED_OFF;
+  if( led_arr[pState->led].timer_running == 0 )
+  	led_off(pState);
+  return;
+}
+
+static void add_led_timer(state_entry_t *pState)
+{
+	led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+  led_arr[pState->led].param = pState->param;
+  led_arr[pState->led].pTimer->data = pState;
+	add_timer (led_arr[pState->led].pTimer);
+}
+
+static void board_led_activity_on(state_entry_t *pState)
+{
+  if(led_arr[pState->led].timer_running == 0)
+	{
+		led_on(pState);
+		add_led_timer(pState);
+	  led_arr[pState->led].timer_running = 1;
+	  led_arr[pState->led].state = LED_BLINK_UP;
+	}
+	else if( led_arr[pState->led].timer_running > 0xF0)
+	{
+	  led_arr[pState->led].state = LED_BLINK_UP;
+		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+  	led_arr[pState->led].param = pState->param;
+  	led_arr[pState->led].pTimer->data = pState;
+	}
+	return;
+}
+
+static void board_led_activity_off(state_entry_t *pState)
+{
+  if(led_arr[pState->led].timer_running == 0)
+	{
+		led_off(pState);
+		add_led_timer(pState);
+	  led_arr[pState->led].timer_running = 1;
+	  led_arr[pState->led].state = LED_BLINK_UP;
+	}
+	else if( led_arr[pState->led].timer_running > 0xF0)
+	{
+	  led_arr[pState->led].state = LED_BLINK_UP;
+		led_arr[pState->led].pTimer->expires = jiffies + HZ*(pState->param)/1000;
+  	led_arr[pState->led].param = pState->param;
+  	led_arr[pState->led].pTimer->data = pState;
+	}
+	return;
+}
+
+static void board_led_link_flash(state_entry_t *pState)
+{
+  if(led_on(pState))
+		return;
+  if(led_arr[pState->led].timer_running == 0)
+		add_led_timer(pState);
+	else
+    led_arr[pState->led].param = pState->param;
+  led_arr[pState->led].timer_running = 0xFF;
+	led_arr[pState->led].state = LED_FLASH;
+	return;
+}
+
+static void led_timer_func(unsigned long data)
+{
+	state_entry_t *pState = NULL;
+  mod_entry_t *pMod = NULL;
+	unsigned int flags;
+
+	spin_lock_irqsave(&config_lock, flags);
+
+  pState = (state_entry_t *)data;
+
+  if( led_arr[pState->led].state == LED_BLINK_DOWN )
+	{
+		led_arr[pState->led].timer_running = 0;
+		if( pState->mode == 2 )
+			led_arr[pState->led].state = LED_OFF;
+		else
+			led_arr[pState->led].state = LED_ON;
+	}
+  else if( led_arr[pState->led].state == LED_BLINK_UP )
+	{
+    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+  	led_arr[pState->led].pTimer->data = pState;
+		add_timer (led_arr[pState->led].pTimer);
+		if( pState->mode == 2 )
+		{
+  		led_off(pState);
+			led_arr[pState->led].state = LED_BLINK_DOWN;
+		}
+		else
+		{
+  		led_on(pState);
+			led_arr[pState->led].state = LED_BLINK_DOWN;
+		}
+		led_arr[pState->led].timer_running = 1;
+	}
+  else if( led_arr[pState->led].state == LED_FLASH )
+	{
+    led_arr[pState->led].pTimer->expires = jiffies + HZ*(led_arr[pState->led].param)/1000;
+  	led_arr[pState->led].pTimer->data = pState;
+		add_timer (led_arr[pState->led].pTimer);
+
+		if( led_arr[pState->led].timer_running == 0xFF )
+		{
+  		led_off(pState);
+			led_arr[pState->led].timer_running--;
+		}
+		else
+		{
+  		led_on(pState);
+			led_arr[pState->led].timer_running++;
+		}
+		spin_unlock_irqrestore(&config_lock, flags);
+    return;
+	}
+  else if(led_arr[pState->led].state == LED_OFF)
+	{
+  	led_off(pState);
+    led_arr[pState->led].timer_running = 0;
+	}
+	else if( led_arr[pState->led].state == LED_ON )
+	{
+  	led_on(pState);
+    led_arr[pState->led].timer_running = 0;
+	}
+	spin_unlock_irqrestore(&config_lock, flags);
+  return;
+}
+/************wwzh*****************/
+#if 0
+/************end *****************/
+static ssize_t proc_read_led_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp)
+{
+  char * pdata = NULL;
+  int i = 0, j = 0, len = 0, totallen = 0;
+  char line[255];
+
+  if( *offp != 0 )
+  	return 0;
+
+  pdata = buf;
+  len += sprintf(line,"LEDS Registered for use are:");
+  for( i = 0; i< MAX_LED_ID; i++)
+		if( led_arr[i].led != NULL )
+			len += sprintf(&line[len]," %d ", i );
+  line[len++] = '\n';
+
+  copy_to_user(pdata, line,len );
+  pdata += len;
+  totallen += len;
+  len = 0;
+  len = sprintf(line,"USER MODULE INFORMATION:\n");
+  copy_to_user(pdata, line,len );
+  pdata += len;
+  totallen += len;
+  len = 0;
+  for( i = 0; i< MAX_MOD_ID; i++)
+	{
+		if( modArr[i] != NULL )
+		{
+			len = sprintf(line,"  Module ID = %d \n" , i);
+  		copy_to_user(pdata, line,len );
+      pdata += len;
+  		totallen += len;
+  		len = 0;
+ 			for( j = 0; j < MAX_STATE_ID; j++)
+			{
+				if( modArr[i]->states[j] != NULL)
+				{
+					len = sprintf(line ,
+                		"    State = %d , Led = %d," , j , modArr[i]->states[j]->led);
+  				copy_to_user(pdata, line,len );
+          pdata += len;
+  				totallen += len;
+
+  				len = 0;
+          switch( modArr[i]->states[j]->mode )
+					{
+						case 1:
+									len = sprintf(line ," Mode = OFF\n");
+									break;
+						case 2:
+									len = sprintf(line ," Mode = BLINK_ON , On Time(ms) = %d\n" ,
+                                       (unsigned int)modArr[i]->states[j]->param);
+									break;
+						case 3:
+									len = sprintf(line ," Mode = BLINK_OFF , Off Time(ms) = %d\n" ,
+                                       (unsigned int)modArr[i]->states[j]->param);
+									break;
+						case 4:
+									len = sprintf(line ," Mode = ON \n");
+									break;
+						case 5:
+									len = sprintf(line ," Mode = FLASH , Time Period(ms) = %d\n" ,
+                                       (unsigned int)modArr[i]->states[j]->param);
+									break;
+						default:
+							break;
+
+					}
+  				copy_to_user(pdata, line,len );
+          pdata += len;
+  				totallen += len;
+
+  				len = 0;
+				}
+			}
+		}
+	}
+  /* Return with configuration information for LEDs */
+	*offp = totallen;
+	return totallen;
+}
+static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+                                                      size_t count , loff_t *offp)
+{
+  char *pdata = NULL, *ptemp = NULL;
+  char line[10],temp[10];
+  int i = 0;
+  int mod = 0xFFFF , state = 0xFFFF;
+  int flag = 0;
+
+  /* Check if this write is for configuring stuff */
+  if( *(int *)(buffer) == 0xFFEEDDCC )
+	{
+    printk("<1>proc write:Calling Configuration\n");
+		config_led((unsigned long)(buffer + sizeof(int)) );
+		return count;
+	}
+
+  if( count >= 10)
+	{
+    printk("<1>proc write:Input too long,max length = %d\n",10);
+    return count;
+	}
+  memset( temp, 0x00 , 10);
+  memset( line, 0x00 , 10);
+  copy_from_user(line,buffer,count);
+  line[count] = 0x00;
+  pdata = line;
+  ptemp = temp;
+  while( flag == 0)
+  {
+		if( i > 10 )
+			break;
+		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+		{	
+			*ptemp = *pdata ;
+			ptemp++;
+		}	
+		else if( (*pdata) == ',' )
+		{
+      *ptemp = 0x00;
+			flag = 1;
+		}	
+		pdata++;
+		i++;
+  };
+	if( flag == 1)
+  	mod = led_atoi( temp);
+	else
+		return count;
+		
+  ptemp = temp;
+  *ptemp = 0x00;
+  flag = 0;
+  while( flag == 0)
+  {
+		if( i > 10 )
+			break;
+		if( ((*pdata) >= '0' ) && ((*pdata) <= '9') )
+		{	
+			*ptemp = *pdata ;
+			ptemp++;
+		}	
+		else if( (*pdata) == 0x00 )
+		{
+      *ptemp = 0x00;
+			flag = 1;
+		}	
+		pdata++;
+    i++;
+  };
+	if( flag == 1)
+  	state = led_atoi( temp);
+	else
+		return count;
+  if( (mod == 0xFFFF) || (state == 0xFFFF))
+		return count;
+  else
+    led_operation( mod , state );
+  return count;
+}
+
+/************wwzh*******************/
+#else
+
+#define TRUE 1
+#define FALSE 0
+#define FLICK_TIME (HZ*100/1000)
+static unsigned int wan_txrx_state = 0;
+static unsigned int wlan_txrx_state = 0;
+
+void led_operation( int mod , int state)
+{
+
+	unsigned int flags;
+
+	spin_lock_irqsave(&config_lock, flags);
+
+	if( (mod >= MAX_MOD_ID) || ( state >= MAX_STATE_ID) )
+	{
+	  spin_unlock_irqrestore(&config_lock, flags);
+		return;
+	}
+ 	if ( modArr[mod] == NULL )
+	{
+	  spin_unlock_irqrestore(&config_lock, flags);
+		return;
+	}
+	if( modArr[mod]->states[state] == NULL )
+	{
+	  spin_unlock_irqrestore(&config_lock, flags);
+		return;
+	}
+  /* Call the function handler  */
+  modArr[mod]->states[state]->handler(modArr[mod]->states[state]);
+
+	spin_unlock_irqrestore(&config_lock, flags);
+}
+
+static void wan_led_func(unsigned long data)
+{
+	if (wan_txrx_state == 0)
+	{
+		tnetd73xx_gpio_out(2, TRUE);
+		tnetd73xx_gpio_out(3, FALSE);
+		wan_txrx_state = 1;
+	}
+	else
+	{
+		tnetd73xx_gpio_out(2, FALSE);
+		tnetd73xx_gpio_out(3, FALSE);
+		wan_txrx_state = 0;
+	}
+	pWanTimer->expires = jiffies + FLICK_TIME;
+	add_timer(pWanTimer);
+}
+//wwzh for wireless
+#if 0
+static void wlan_led_func(unsigned long data)
+{
+	if (wlan_txrx_state == 0)
+	{
+		tnetd73xx_gpio_out(12, TRUE);
+		tnetd73xx_gpio_out(13, FALSE);
+		wlan_txrx_state = 1;
+	}
+	else
+	{
+		tnetd73xx_gpio_out(12, FALSE);
+		tnetd73xx_gpio_out(13, FALSE);
+		wlan_txrx_state = 0;
+		
+	}
+	pWlanTimer->expires = jiffies + FLICK_TIME;
+	add_timer(pWlanTimer);
+}
+#endif
+
+void led_active(int mod, int state)
+{
+	unsigned int flags = 0;
+
+//printk("mod = %d state = %d\n", mod, state);
+	spin_lock_irqsave(&config_lock, flags);
+	if ((mod >= 5) || (state >= 5))
+	{
+		spin_unlock_irqrestore(&config_lock, flags);
+		return;
+	}
+	
+	switch (mod)
+	{
+		case 2: /*system led */
+			sys_mod_state = state;
+			switch (state)
+			{
+				case 1:	
+					break;
+				case 2:  /*sys led flashing green */
+					tnetd73xx_gpio_out(4, FALSE);
+					tnetd73xx_gpio_out(5, TRUE);
+					tnetd73xx_gpio_out(8, TRUE);
+					break;
+				case 3: /*sys led solid green */
+					tnetd73xx_gpio_out(4, TRUE);
+					tnetd73xx_gpio_out(5, TRUE);
+					tnetd73xx_gpio_out(8, TRUE);
+					
+					break;
+				case 4: /*sys fail red */
+					tnetd73xx_gpio_out(4, TRUE);
+					tnetd73xx_gpio_out(5, FALSE);
+					tnetd73xx_gpio_out(8, FALSE);
+					break;
+				default:
+					break;
+			}
+			break;
+		case 3: /*wan led */
+			wan_mod_state = state;
+			switch (state)
+			{
+				case 1: /*no wan interface*/
+					if (pWanTimer)
+					{
+						del_timer(pWanTimer);
+						kfree(pWanTimer);
+						pWanTimer = NULL;
+					}
+					tnetd73xx_gpio_out(2, FALSE);
+					tnetd73xx_gpio_out(3, FALSE);
+					break;
+				case 2: /*wan connected */
+					if (pWanTimer)
+					{
+						del_timer(pWanTimer);
+						kfree(pWanTimer);
+						pWanTimer = NULL;
+					}
+					tnetd73xx_gpio_out(2, TRUE);
+					tnetd73xx_gpio_out(3, FALSE);
+					break;
+				case 3: /*rx/tx activity */
+					if (pWanTimer != NULL)
+						break;	
+				
+					pWanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+					init_timer(pWanTimer);
+					
+					pWanTimer->function = wan_led_func;
+					pWanTimer->data = 0;
+					pWanTimer->expires = jiffies + FLICK_TIME;
+					tnetd73xx_gpio_out(2, FALSE);
+					tnetd73xx_gpio_out(3, FALSE);
+					wan_txrx_state = 0;
+					add_timer(pWanTimer);
+
+					break;
+				case 4: /*no ipaddress */
+					if (pWanTimer)
+					{
+						del_timer(pWanTimer);
+						kfree(pWanTimer);
+						pWanTimer = NULL;
+					}
+					tnetd73xx_gpio_out(2, FALSE);
+					tnetd73xx_gpio_out(3, TRUE);
+					break;
+				default:
+					if (pWanTimer)
+					{	
+						del_timer(pWanTimer);
+						kfree(pWanTimer);
+						pWanTimer = NULL;
+					}
+					break;
+			}
+			break;
+	//wwzh for wireless 
+	#if 0
+		case 4: /*wlan led */
+			wlan_mod_state = state;
+			switch (state)
+			{
+				case 1: /* wlan off */
+					if (pWlanTimer)
+					{
+						del_timer(pWlanTimer);
+						kfree(pWlanTimer);
+						pWlanTimer = NULL;
+					}
+					tnetd73xx_gpio_out(12, FALSE);
+					tnetd73xx_gpio_out(13, FALSE);
+					break;
+				case 2: /* wlan ready */
+					if (pWlanTimer)
+					{
+						del_timer(pWlanTimer);
+						kfree(pWlanTimer);
+						pWlanTimer = NULL;
+					}
+					tnetd73xx_gpio_out(12, TRUE);
+					tnetd73xx_gpio_out(13, FALSE);
+					break;
+				case 3: /* wlan rx/tx activity */
+					if (pWlanTimer != NULL)
+						break;
+					
+					pWlanTimer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+					init_timer(pWlanTimer);
+					
+					pWlanTimer->function = wlan_led_func;
+					pWlanTimer->data = 0;
+					pWlanTimer->expires = jiffies + FLICK_TIME;
+					tnetd73xx_gpio_out(12, FALSE);
+					tnetd73xx_gpio_out(13, FALSE);
+					wlan_txrx_state = 0;
+					add_timer(pWlanTimer);
+					
+					break;
+				default:
+					if (pWlanTimer)
+					{
+						del_timer(pWlanTimer);
+						kfree(pWlanTimer);
+						pWlanTimer = NULL;
+					}
+					
+					break;
+			}
+			break;
+	#endif //for wireless
+		default:
+			break;
+	}
+	spin_unlock_irqrestore(&config_lock, flags);
+}
+static ssize_t proc_read_led_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp)
+{
+	char *pdata = NULL;
+	int i = 0, j = 0, len = 0, totallen = 0;
+	char line[255];
+	
+	if (*offp != 0)
+		return 0;
+	pdata = buf;
+	len = sprintf(line, "USER MODULE INFORMATION:\n");
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+	
+	//*******add Module 1 , this Module is ADSL ********/
+	for (i = 0; i < MAX_MOD_ID; i++)
+	{
+		if (modArr[i] != NULL)
+		{
+			len = sprintf(line, " Module ID = %d\n", i);
+			copy_to_user(pdata, line, len);
+			pdata += len;
+			totallen += len;
+			len = 0;
+			for(j = 0; j < MAX_STATE_ID; j++)
+			{
+				if (modArr[i]->states[j] != NULL)
+				{
+					len = sprintf(line, "State =%d, Led = %d,", j, modArr[i]->states[j]->led);
+					copy_to_user(pdata, line, len);
+					pdata += len;
+					totallen += len;
+					len = 0;
+					switch(modArr[i]->states[j]->mode)
+					{
+					  case 1:
+				            len = sprintf(line, "Mode = OFF\n");
+					    break;
+					  case 2:
+					    len = sprintf(line, "Mode = BLINK_ON, On Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);	
+					    break;
+					  case 3:
+					    len = sprintf(line, "Mode = BLINK_OFF, Off Time(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+					    break;
+					  case 4:
+					    len = sprintf(line, "Mode = On\n");
+					    break;
+					  case 5:
+					    len = sprintf(line, "Mode = FLASH, Time Period(ms) = %d\n", (unsigned int)modArr[i]->states[j]->param);
+					    break;
+					  default:
+					    break;		
+					}
+					copy_to_user(pdata, line, len);
+					pdata += len;
+					totallen += len;
+					len = 0;
+				}
+			} 
+		}
+
+	}
+
+	len = sprintf(line, "Module ID = 2(system led)\n");
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+	switch(sys_mod_state)
+	{
+		case 1:
+			len = sprintf(line, "State = OFF\n");
+			break;
+		case 2:	
+			len = sprintf(line, "State = Booting\n");
+			break;
+		case 3:
+			len = sprintf(line, "State = System Ready\n");
+			break;
+		case 4:
+			len = sprintf(line, "State = System Failure\n");
+			break;
+		default:
+			break;
+	}
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+	
+	len = sprintf(line, "Module ID = 3(WAN led)\n");
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+	switch(wan_mod_state)
+	{
+		case 1:
+			len = sprintf(line, "State = OFF\n");
+			break;
+		case 2:
+			len = sprintf(line, "State = Wan Connected\n");
+			break;
+		case 3:
+			len = sprintf(line, "State = Wan Tx/Rx Activity\n");
+			break;
+		case 4:
+			len = sprintf(line, "State = Wan Connect Failure\n");
+			break;
+		default:
+			break;
+	}
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+
+//wwzh for wireless
+#if 0
+	len = sprintf(line, "Module ID = 4(WLAN led)\n");
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+	switch(wlan_mod_state)
+	{
+		case 1:
+			len = sprintf(line, "State = OFF\n");
+			break;
+		case 2:
+			len = sprintf(line, "State = wlan Ready\n");
+			break;
+		case 3:
+			len = sprintf(line, "State = wlan rx/tx activity\n");
+			break;
+		default:
+			break; 
+	}
+	copy_to_user(pdata, line, len);
+	pdata += len;
+	totallen += len;
+	len = 0;
+#endif //for wireless
+	
+	*offp = totallen;
+	return totallen;
+}
+static ssize_t proc_write_led_fops(struct file *filp,const char *buffer,
+                                               size_t count , loff_t *offp)
+{
+	char *pdata = NULL, *ptemp = NULL;
+	char line[10], temp[10];
+	int i = 0;
+	int mod = 0xffff, state = 0xffff;
+	int flag = 0;
+
+ 	 /* Check if this write is for configuring ADSL */
+  	if( *(int *)(buffer) == 0xFFEEDDCC )
+	{
+   		 printk("<1>proc write:Calling Configuration\n");
+		 config_led((unsigned long)(buffer + sizeof(int)) );
+		 return count;
+	}
+
+	if (count > 10)
+	{
+		printk("<1> proc write: Input too long, max length = 10\n");
+		return count;
+	}
+	memset(temp, 0x00, 10);
+	memset(line, 0x00, 10);
+	copy_from_user(line, buffer, count);
+	line[count] = 0x00;
+	pdata = line;
+	ptemp = temp;	
+	
+	while (flag == 0)
+	{
+		if (i > 10)
+			break;
+		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+		{
+			*ptemp = *pdata;
+			ptemp++;
+		}
+		else if ((*pdata) == ',')
+		{
+			*ptemp = 0x00;
+			flag = 1;
+		}
+		pdata++;
+		i++;
+	}
+	if (flag == 1)
+		mod = led_atoi(temp);
+	else
+		return count;
+	
+	ptemp = temp;
+	*ptemp = 0x00;
+	flag = 0;
+	
+	while(flag == 0)
+	{
+		if (i > 10)
+			break;
+		if (((*pdata) >= '0') && ((*pdata) <= '9'))
+		{
+			*ptemp = *pdata;
+			ptemp++;
+		}
+		else if ((*pdata) == 0x00)
+		{
+			*ptemp = 0x00;
+			flag = 1;
+		}
+		pdata++;
+		i++;
+	}
+	if (flag == 1)
+		state = led_atoi(temp);
+	else
+		return count;
+	if ((mod == 0xFFFF) || (state == 0xFFFF))
+		return count;
+	else
+	{
+		if (mod != 4)
+			led_active(mod, state);	
+		else 
+			led_operation(mod, state);
+	} 
+	return 1;
+}
+#endif
+/************end *******************/
+static int config_led(unsigned long y)
+{
+  config_elem_t *pcfg = NULL;
+  char *pdata = NULL;
+  int i;
+  int length = 0 , number = 0;
+	unsigned int flags;
+
+	spin_lock_irqsave(&config_lock, flags);
+
+    /* ioctl to configure */
+    length =  *((int*)y);
+    pdata = (char *)y + sizeof(int);
+    number =  (length - sizeof(int))/sizeof(config_elem_t);
+    pcfg = (config_elem_t *)(pdata);
+
+    /* Check if an earlier configuration exists IF yes free it up */
+    free_memory();
+
+    for ( i = 0 ; i < number ; i++ )
+    {
+			/* If no structure has been allocated for the module do so */
+      if ( modArr[pcfg->name] == NULL )
+			{
+					printk("<1>module =  %d\n",pcfg->name);
+        if( pcfg->name >= MAX_MOD_ID)
+				{
+					printk("<1>Exiting Configuration: Module ID too large %d\n",pcfg->name);
+					free_memory();
+					spin_unlock_irqrestore(&config_lock, flags);
+					return -1;
+				}
+        modArr[pcfg->name] = kmalloc(sizeof(mod_entry_t),GFP_KERNEL);
+        if(modArr[pcfg->name] == NULL)
+				{
+					printk("<1>Exiting Configuration: Error in allocating memory\n");
+					free_memory();
+					spin_unlock_irqrestore(&config_lock, flags);
+					return -1;
+				}
+				memset( modArr[pcfg->name], 0x00, sizeof(mod_entry_t));
+			}
+
+      /* if no structure is allocated previously for this state
+         allocate a structure, if it's already there fill it up */
+			if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+			{
+					printk("<1>STATE =  %d\n",pcfg->state);
+				if( pcfg->state >= MAX_STATE_ID)
+				{
+					printk("<1>Exiting Configuration: State ID too large\n");
+					free_memory();
+					spin_unlock_irqrestore(&config_lock, flags);
+					return -1;
+				}
+				modArr[pcfg->name]->states[pcfg->state] =
+                        kmalloc(sizeof(state_entry_t),GFP_KERNEL);
+				if( modArr[pcfg->name]->states[pcfg->state] == NULL)
+				{
+					free_memory();
+					spin_unlock_irqrestore(&config_lock, flags);
+					return -1;
+				}
+				memset( modArr[pcfg->name]->states[pcfg->state], 0x00, sizeof(state_entry_t));
+			}
+			/* Fill up the fields of the state */
+      if( pcfg->led >= MAX_LED_ID)
+			{
+				printk("<1>led =  %d\n",pcfg->led);
+				free_memory();
+				spin_unlock_irqrestore(&config_lock, flags);
+				return -1;
+			}
+      modArr[pcfg->name]->states[pcfg->state]->led = pcfg->led;
+      modArr[pcfg->name]->states[pcfg->state]->mode = pcfg->mode;
+      modArr[pcfg->name]->states[pcfg->state]->param = pcfg->param;
+			switch(pcfg->mode)
+			{
+				case 1:
+      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_down;
+					break;
+				case 2:
+				case 3:
+				case 5:
+					if( pcfg->mode == 2 )
+						modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_on;
+					else if( pcfg->mode == 3)
+      			modArr[pcfg->name]->states[pcfg->state]->handler = board_led_activity_off;
+					else
+		        modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_flash;
+					break;
+				case 4:
+      		modArr[pcfg->name]->states[pcfg->state]->handler = board_led_link_up;
+					break;
+				default:
+				  printk("<1>Exiting Configuration: Unknown LED Mode\n");
+					free_memory();
+					spin_unlock_irqrestore(&config_lock, flags);
+					return -1;
+			}
+			pcfg++;			
+    }
+	spin_unlock_irqrestore(&config_lock, flags);
+  return 0;
+}
+
+
+int __init led_init(void)
+{
+
+  /* Clear our memory */
+  memset(modArr,0x00,sizeof(mod_entry_t *)*MAX_MOD_ID);
+  memset(led_arr,0x00,sizeof(led_data_t *)*MAX_LED_ID);
+
+	/* Create spin lock for config data structure */
+	config_lock=SPIN_LOCK_UNLOCKED;
+
+  /* Create directory */
+  led_proc_dir = proc_mkdir("led", NULL);
+  if( led_proc_dir == NULL )
+    goto out;
+
+  /* Create adsl file */
+  led_file = create_proc_entry("led", 0777, led_proc_dir);
+  if( led_file == NULL)
+    goto led_file;
+  led_file->owner = THIS_MODULE;
+  led_file->proc_fops = &led_fops;
+
+  memset( modArr , 0x00 , sizeof(mod_entry_t *) * MAX_MOD_ID);
+	/* Reset the GPIO pins  */
+  board_gpio_init();
+
+	/* Register the UART controlled LEDS  */
+  uart_led_init();
+  /* Create the usb proc file */
+	avalanche_leds_init();
+  return 0;
+
+  led_file:
+    remove_proc_entry("led",led_proc_dir);
+  out:
+    return 0;
+
+}
+
+void led_exit()
+{
+	remove_proc_entry("led", led_proc_dir);
+}
+
+module_init(led_init);
+module_exit(led_exit);
+
+void register_led_drv( int device , led_reg_t *pInfo)
+{
+	unsigned int flags;
+	struct timer_list *pTimer = NULL;
+
+	spin_lock_irqsave(&config_lock, flags);
+
+	led_arr[device].led = pInfo;
+	if( led_arr[device].led->init != 0x00)
+      led_arr[device].led->init(led_arr[device].led->param);
+	if( led_arr[device].led->offfunc != 0x00)
+      led_arr[device].led->offfunc(led_arr[device].led->param);
+
+	/* Create a timer for blinking   */
+  pTimer = kmalloc(sizeof(struct timer_list),GFP_KERNEL);
+	init_timer( pTimer );
+	pTimer->function = led_timer_func;
+	pTimer->data = 0;
+  led_arr[device].pTimer = pTimer;
+  led_arr[device].timer_running = 0;
+
+	spin_unlock_irqrestore(&config_lock, flags);
+
+  return;
+}
+
+void deregister_led_drv( int device)
+{
+	unsigned int flags;
+
+	spin_lock_irqsave(&config_lock, flags);
+	led_arr[device].led = NULL;
+
+	if( led_arr[device].pTimer != NULL)
+	{
+		del_timer(led_arr[device].pTimer);
+		kfree(led_arr[device].pTimer);
+	}
+	spin_unlock_irqrestore(&config_lock, flags);
+
+  return;
+}
+
+EXPORT_SYMBOL_NOVERS(led_operation);
+EXPORT_SYMBOL_NOVERS(register_led_drv);
+EXPORT_SYMBOL_NOVERS(deregister_led_drv);
+
diff -urN linux.dev/drivers/char/avalanche_led/leds.c linux.dev2/drivers/char/avalanche_led/leds.c
--- linux.dev/drivers/char/avalanche_led/leds.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/drivers/char/avalanche_led/leds.c	2005-10-21 18:03:44.513777000 +0200
@@ -0,0 +1,133 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/ar7/avalanche_regs.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+
+#include <asm/ar7/ledapp.h>
+
+#if defined(CONFIG_AR5D01) || defined(CONFIG_AR5W01) || defined(CONFIG_AR7)
+
+#define ETH_MASK 0x01
+#define USB_MASK 0x02
+
+static struct proc_dir_entry *usb_file;
+static ssize_t proc_read_usb_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp);
+struct file_operations usb_fops = {read: proc_read_usb_fops};
+
+typedef struct mod_states{
+  int module;
+  int activity;
+  int linkup;
+  int idle;
+}mod_states_t;
+
+mod_states_t state_arr[] = {
+                          	{ MOD_ETH,DEF_ETH_ACTIVITY,DEF_ETH_LINK_UP,DEF_ETH_IDLE },
+                          	{ MOD_USB,DEF_USB_ACTIVITY,DEF_USB_LINK_UP,DEF_USB_IDLE },
+                          	{ MOD_LAN,DEF_LAN_ACTIVITY,DEF_LAN_LINK_UP,DEF_LAN_IDLE }
+                        	};
+
+unsigned char	device_links = 0;	/* Bitmask with the devices that are up */
+
+
+void avalanche_led_activity_pulse(unsigned long device)
+{
+	/* If device link is not up return */
+  if( !(device_links & (unsigned char)(1 << device)))
+		return;
+#ifdef MULTIPLEX_LED
+	led_operation( state_arr[2].module, state_arr[2].activity);
+#else
+	led_operation( state_arr[device].module, state_arr[device].activity);
+#endif
+}
+
+void avalanche_led_link_up( unsigned long device )
+{
+	
+  /* If already UP ignore */
+  if( device_links & (unsigned char)(1 << device))
+		return;
+  /* Turn on the bit for the device */
+	device_links |= (unsigned char)(1 << device);
+#ifdef MULTIPLEX_LED
+	led_operation( state_arr[2].module, state_arr[2].linkup);
+#else
+	led_operation( state_arr[device].module, state_arr[device].linkup);
+#endif
+}
+
+void avalanche_led_link_down ( unsigned long device )
+{
+
+  /* If already DOWN ignore */
+  if( !(device_links & (unsigned char)(1 << device)))
+		return;
+
+	/* Turn off the bit for the device */
+	device_links &= ~(unsigned char)(1 << device);
+#ifdef MULTIPLEX_LED
+	/* If no links, then shut the LED off  */
+	if(!device_links)
+		led_operation( state_arr[2].module, state_arr[2].idle);
+#else
+	led_operation( state_arr[device].module, state_arr[device].idle);
+#endif
+}
+
+static ssize_t proc_read_usb_fops(struct file *filp,
+                                 char *buf,size_t count , loff_t *offp)
+{
+  char * pdata = NULL;
+  char line[3];
+  if( *offp != 0 )
+  	return 0;
+  pdata = buf;
+  if( device_links & USB_MASK)
+  	sprintf(line,"%s\n","1");
+  else
+  	sprintf(line,"%s\n","0");
+  copy_to_user(pdata,line,2);
+	*offp = 2;
+	return 2;
+}
+
+
+void avalanche_leds_init(void)
+{
+  /* Create usb link proc file */
+  usb_file = create_proc_entry("avalanche/usb_link", 0444, NULL);
+  if( usb_file == NULL)
+    return;
+  usb_file->owner = THIS_MODULE;
+  usb_file->proc_fops = &usb_fops;
+	return;
+}
+
+EXPORT_SYMBOL(avalanche_led_activity_pulse);
+EXPORT_SYMBOL(avalanche_led_link_up);
+EXPORT_SYMBOL(avalanche_led_link_down);
+
+#else
+/* We make a dummy init routine for the platforms that do not support this led
+   API
+*/
+
+void avalanche_leds_init(void)
+{
+}
+
+#endif
+
+
+
+
+
diff -urN linux.dev/drivers/char/avalanche_led/uartled.c linux.dev2/drivers/char/avalanche_led/uartled.c
--- linux.dev/drivers/char/avalanche_led/uartled.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/drivers/char/avalanche_led/uartled.c	2005-10-21 18:03:44.529778000 +0200
@@ -0,0 +1,55 @@
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/spinlock.h>
+#include <asm/ar7/avalanche_regs.h>
+#include <asm/ar7/ledapp.h>
+
+#define UART_LED_REG  (*(volatile unsigned int *)(UARTA_BASE + 0x10))
+
+static spinlock_t	device_lock;
+led_reg_t temp1[2];
+
+static void uart_led_on(unsigned long param)
+{
+  unsigned long flags;
+
+  spin_lock_irqsave(&device_lock,flags);
+  UART_LED_REG &= 0xFFFD;
+  spin_unlock_irqrestore(&device_lock, flags);
+}
+
+static void uart_led_off ( unsigned long param )
+{
+   unsigned int flags = 0x00;
+   spin_lock_irqsave(&device_lock, flags);
+   UART_LED_REG |= 0x02;
+	spin_unlock_irqrestore(&device_lock, flags);
+}
+
+void uart_led_init(void)
+{
+
+#if defined(CONFIG_AR5D01)
+  /* Register led 6 UART Pin 1 */
+  temp1[0].param = 0;
+  temp1[0].init = NULL;
+  temp1[0].onfunc = uart_led_on;
+  temp1[0].offfunc = uart_led_off;
+	register_led_drv( 6 , &temp1[0]);
+#endif
+
+#if defined(CONFIG_AR5W01)
+  /* Register led 8 UART Pin 1 */
+  temp1[0].param = 0;
+  temp1[0].init = NULL;
+  temp1[0].onfunc = uart_led_on;
+  temp1[0].offfunc = uart_led_off;
+	register_led_drv( 8 , &temp1[0]);
+#endif
+
+	/* Initialize the link mask */
+	device_lock = SPIN_LOCK_UNLOCKED;
+
+  return;
+}
+
diff -urN linux.dev/include/asm-mips/ar7/led_config.h linux.dev2/include/asm-mips/ar7/led_config.h
--- linux.dev/include/asm-mips/ar7/led_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/include/asm-mips/ar7/led_config.h	2005-10-21 17:02:25.568327000 +0200
@@ -0,0 +1,55 @@
+/******************************************************************************    
+ * FILE PURPOSE:     - LED config Header                                       
+ ******************************************************************************    
+ * FILE NAME:     led_config.h                                                        
+ *                                                                                 
+ * DESCRIPTION:  Header file for LED configuration parameters
+ *               and data structures                                                 
+ *                                                                                 
+ * REVISION HISTORY:                                                               
+ * 11 Oct 03 - PSP TII                                                             
+ *                                                                                 
+ * (C) Copyright 2002, Texas Instruments, Inc                                      
+ *******************************************************************************/  
+                                                                                   
+
+#ifndef __LED_CONFIG__
+#define __LED_CONFIG__
+
+/* LED config parameters */
+#define  MAX_GPIO_PIN_NUM           64
+#define  MAX_GPIOS_PER_STATE         5
+#define  MAX_MODULE_ENTRIES         25
+#define  MAX_MODULE_INSTANCES        4
+#define  MAX_STATE_ENTRIES          25
+#define  MAX_LED_ENTRIES            25
+
+
+/* LED modes */
+#define LED_OFF                    0
+#define LED_ON                     1
+#define LED_ONESHOT_OFF            2
+#define LED_ONESHOT_ON             3
+#define LED_FLASH                  4
+#define LED_BLINK_CODE0            5    /*--- param1: on time, param2: blink nr , (param2 > 100 blink off) ---*/
+#define LED_BLINK_CODE1            6 
+#define LED_BLINK_CODE2            7 
+
+#define NUM_LED_MODES              8
+
+
+
+/* Data structure for LED configuration */
+typedef struct led_config{
+    unsigned char name[80];
+    unsigned int instance;
+    unsigned int state;
+    unsigned int gpio[MAX_GPIOS_PER_STATE];
+    unsigned int mode[MAX_GPIOS_PER_STATE];
+    unsigned int gpio_num;
+    unsigned int param1;
+    unsigned int param2;
+}LED_CONFIG_T;
+
+
+#endif /* __LED_CONFIG__ */
diff -urN linux.dev/include/asm-mips/ar7/led_hal.h linux.dev2/include/asm-mips/ar7/led_hal.h
--- linux.dev/include/asm-mips/ar7/led_hal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/include/asm-mips/ar7/led_hal.h	2005-10-21 17:02:25.568327000 +0200
@@ -0,0 +1,30 @@
+/******************************************************************************
+ * FILE PURPOSE:     - LED HAL module Header
+ ******************************************************************************
+ * FILE NAME:     led_hal.h
+ *
+ * DESCRIPTION:    LED HAL API's.
+ *
+ * REVISION HISTORY:
+ * 11 Oct 03 - PSP TII
+ *
+ * (C) Copyright 2002, Texas Instruments, Inc
+ *******************************************************************************/
+
+#ifndef __LED_HAL__
+#define __LED_HAL__
+
+/* Interface prototypes */
+#include "led_config.h"
+
+int avalanche_led_hal_init (int *gpio_off_value, int num_gpio_pins);
+int avalanche_led_config_set (LED_CONFIG_T * led_cfg);
+int avalanche_led_config_get (LED_CONFIG_T *led_cfg,int module_id,int instance, int state);
+void *avalanche_led_register (const char *module_name, int instance_num);
+void  avalanche_led_action (void *handle, int state_id);
+void avalanche_led_late_actions(void);
+int avalanche_led_unregister (void *handle);
+void avalanche_led_free_all(void);
+void avalanche_led_hal_exit (void);
+
+#endif /*__LED_HAL__ */
diff -urN linux.dev/include/asm-mips/ar7/ledapp.h linux.dev2/include/asm-mips/ar7/ledapp.h
--- linux.dev/include/asm-mips/ar7/ledapp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev2/include/asm-mips/ar7/ledapp.h	2005-10-21 18:03:44.573780750 +0200
@@ -0,0 +1,59 @@
+#ifndef __LED_APP__
+#define __LED_APP__
+
+#define CONF_FILE		"/etc/led.conf"
+#define LED_PROC_FILE		"/proc/led_mod/led"
+
+#define CONFIG_LED_MODULE
+
+#define MAX_MOD_ID        25
+#define MAX_STATE_ID   	  25
+#define MAX_LED_ID 	  25
+
+#define MOD_ADSL 1
+#define DEF_ADSL_IDLE     1
+#define DEF_ADSL_TRAINING 2
+#define DEF_ADSL_SYNC     3
+#define DEF_ADSL_ACTIVITY 4
+
+#define MOD_WAN  2
+#define DEF_WAN_IDLE      1
+#define DEF_WAN_NEGOTIATE 2
+#define DEF_WAN_SESSION   3
+
+#define MOD_LAN  3
+#define DEF_LAN_IDLE		  1
+#define DEF_LAN_LINK_UP   2
+#define DEF_LAN_ACTIVITY  3
+
+#define MOD_WLAN 4
+#define DEF_WLAN_IDLE     1
+#define DEF_WLAN_LINK_UP  2
+#define DEF_WLAN_ACTIVITY 3
+
+#define MOD_USB  5
+#define DEF_USB_IDLE		  1
+#define DEF_USB_LINK_UP   2
+#define DEF_USB_ACTIVITY  3
+
+#define MOD_ETH  6
+#define DEF_ETH_IDLE		  1
+#define DEF_ETH_LINK_UP   2
+#define DEF_ETH_ACTIVITY  3
+
+typedef struct config_elem{
+  unsigned char name;
+  unsigned char state;
+  unsigned char mode;
+  unsigned char led;
+            int param;
+}config_elem_t;
+
+typedef struct led_reg{
+	unsigned int param;
+  void (*init)(unsigned long param);
+  void (*onfunc)(unsigned long param);
+  void (*offfunc)(unsigned long param);
+}led_reg_t;
+
+#endif
