diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/bcmsrom.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/bcmsrom.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/bcmsrom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/bcmsrom.c	2006-03-21 09:30:59.000000000 +0100
@@ -0,0 +1,481 @@
+/*
+ *  Misc useful routines to access NIC SROM/OTP .
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmsrom.h>
+#include <bcmdevs.h>
+#include <bcmendian.h>
+#include <pcicfg.h>
+#include <sbutils.h>
+
+#include <proto/ethernet.h>	/* for sprom content groking */
+
+#define	VARS_MAX	4096	/* should be reduced */
+
+#define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
+#define WRITE_WORD_DELAY	20	/* 20 ms between each word write */
+
+static int initvars_srom_pci(void *sbh, void *curmap, char **vars, int *count);
+static int sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc);
+
+static int initvars_table(osl_t *osh, char *start, char *end, char **vars, uint *count);
+
+/*
+ * Initialize local vars from the right source for this platform.
+ * Return 0 on success, nonzero on error.
+ */
+int
+srom_var_init(void *sbh, uint bustype, void *curmap, osl_t *osh, char **vars, int *count)
+{
+	ASSERT(bustype == BUSTYPE(bustype));
+	if (vars == NULL || count == NULL)
+		return (0);
+
+	switch (BUSTYPE(bustype)) {
+
+	case PCI_BUS:
+		ASSERT(curmap);	/* can not be NULL */
+		return initvars_srom_pci(sbh, curmap, vars, count);
+
+	default:
+		return 0;
+	}
+	return (-1);
+}
+
+/* support only 16-bit word read from srom */
+int
+srom_read(uint bustype, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
+{
+	void *srom;
+	uint off, nw;
+
+	ASSERT(bustype == BUSTYPE(bustype));
+
+	/* check input - 16-bit access only */
+	if (byteoff & 1 || nbytes & 1 || (byteoff + nbytes) > (SPROM_SIZE * 2))
+		return 1;
+
+	off = byteoff / 2;
+	nw = nbytes / 2;
+
+	if (BUSTYPE(bustype) == PCI_BUS) {
+		if (!curmap)
+			return 1;
+		srom = (uchar*)curmap + PCI_BAR0_SPROM_OFFSET;
+		if (sprom_read_pci(srom, off, buf, nw, FALSE))
+			return 1;
+	} else {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* support only 16-bit word write into srom */
+int
+srom_write(uint bustype, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf)
+{
+	uint16 *srom;
+	uint i, off, nw, crc_range;
+	uint16 image[SPROM_SIZE], *p;
+	uint8 crc;
+	volatile uint32 val32;
+
+	ASSERT(bustype == BUSTYPE(bustype));
+
+	/* check input - 16-bit access only */
+	if (byteoff & 1 || nbytes & 1 || (byteoff + nbytes) > (SPROM_SIZE * 2))
+		return 1;
+
+	crc_range = (((BUSTYPE(bustype) == SDIO_BUS)) ? SPROM_SIZE : SPROM_CRC_RANGE) * 2;
+
+	/* if changes made inside crc cover range */
+	if (byteoff < crc_range) {
+		nw = (((byteoff + nbytes) > crc_range) ? byteoff + nbytes : crc_range) / 2;
+		/* read data including entire first 64 words from srom */
+		if (srom_read(bustype, curmap, osh, 0, nw * 2, image))
+			return 1;
+		/* make changes */
+		bcopy((void*)buf, (void*)&image[byteoff / 2], nbytes);
+		/* calculate crc */
+		htol16_buf(image, crc_range);
+		crc = ~hndcrc8((uint8 *)image, crc_range - 1, CRC8_INIT_VALUE);
+		ltoh16_buf(image, crc_range);
+		image[(crc_range / 2) - 1] = (crc << 8) | (image[(crc_range / 2) - 1] & 0xff);
+		p = image;
+		off = 0;
+	} else {
+		p = buf;
+		off = byteoff / 2;
+		nw = nbytes / 2;
+	}
+
+	if (BUSTYPE(bustype) == PCI_BUS) {
+		srom = (uint16*)((uchar*)curmap + PCI_BAR0_SPROM_OFFSET);
+		/* enable writes to the SPROM */
+		val32 = OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32));
+		val32 |= SPROM_WRITEEN;
+		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32);
+		bcm_mdelay(WRITE_ENABLE_DELAY);
+		/* write srom */
+		for (i = 0; i < nw; i++) {
+			W_REG(&srom[off + i], p[i]);
+			bcm_mdelay(WRITE_WORD_DELAY);
+		}
+		/* disable writes to the SPROM */
+		OSL_PCI_WRITE_CONFIG(osh, PCI_SPROM_CONTROL, sizeof(uint32), val32 & ~SPROM_WRITEEN);
+	} else {
+		return 1;
+	}
+
+	bcm_mdelay(WRITE_ENABLE_DELAY);
+	return 0;
+}
+
+
+/*
+ * Read in and validate sprom.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+sprom_read_pci(uint16 *sprom, uint wordoff, uint16 *buf, uint nwords, bool check_crc)
+{
+	int err = 0;
+	uint i;
+
+	/* read the sprom */
+	for (i = 0; i < nwords; i++)
+		buf[i] = R_REG(&sprom[wordoff + i]);
+
+	if (check_crc) {
+		/* fixup the endianness so crc8 will pass */
+		htol16_buf(buf, nwords * 2);
+		if (hndcrc8((uint8*)buf, nwords * 2, CRC8_INIT_VALUE) != CRC8_GOOD_VALUE)
+			err = 1;
+		/* now correct the endianness of the byte array */
+		ltoh16_buf(buf, nwords * 2);
+	}
+	
+	return err;
+}	
+
+/*
+* Create variable table from memory.
+* Return 0 on success, nonzero on error.
+*/
+static int
+initvars_table(osl_t *osh, char *start, char *end, char **vars, uint *count)
+{
+	int c = (int)(end - start);
+
+	/* do it only when there is more than just the null string */
+	if (c > 1) {
+		char *vp = MALLOC(osh, c);
+		ASSERT(vp);
+		if (!vp)
+			return BCME_NOMEM;
+		bcopy(start, vp, c);
+		*vars = vp;
+		*count = c;
+	}
+	else {
+		*vars = NULL;
+		*count = 0;
+	}
+	
+	return 0;
+}
+
+/*
+ * Initialize nonvolatile variable table from sprom.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+initvars_srom_pci(void *sbh, void *curmap, char **vars, int *count)
+{
+	uint16 w, b[64];
+	uint8 sromrev;
+	struct ether_addr ea;
+	char eabuf[32];		     
+	uint32 w32;
+	int woff, i;
+	char *vp, *base;
+	osl_t *osh = sb_osh(sbh);
+	int err;
+
+	/*
+	* Apply CRC over SROM content regardless SROM is present or not,
+	* and use variable <devpath>sromrev's existance in flash to decide
+	* if we should return an error when CRC fails or read SROM variables
+	* from flash.
+	*/
+	sprom_read_pci((void*)((int8*)curmap + PCI_BAR0_SPROM_OFFSET), 0, b, sizeof(b)/sizeof(b[0]), TRUE);
+
+	/* top word of sprom contains version and crc8 */
+	sromrev = b[63] & 0xff;
+	/* bcm4401 sroms misprogrammed */
+	if (sromrev == 0x10)
+		sromrev = 1;
+	
+	/* srom version check */
+	if (sromrev > 3)
+		return (-2);
+
+	ASSERT(vars);
+	ASSERT(count);
+
+	base = vp = MALLOC(osh, VARS_MAX);
+	ASSERT(vp);
+	if (!vp)
+		return -2;
+
+	vp += sprintf(vp, "sromrev=%d", sromrev);
+	vp++;
+
+	if (sromrev >= 3) {
+		/* New section takes over the 3th hardware function space */
+
+		/* Words 22+23 are 11a (mid) ofdm power offsets */
+		w32 = ((uint32)b[23] << 16) | b[22];
+		vp += sprintf(vp, "ofdmapo=%d", w32);
+		vp++;
+
+		/* Words 24+25 are 11a (low) ofdm power offsets */
+		w32 = ((uint32)b[25] << 16) | b[24];
+		vp += sprintf(vp, "ofdmalpo=%d", w32);
+		vp++;
+
+		/* Words 26+27 are 11a (high) ofdm power offsets */
+		w32 = ((uint32)b[27] << 16) | b[26];
+		vp += sprintf(vp, "ofdmahpo=%d", w32);
+		vp++;
+
+		/*GPIO LED Powersave duty cycle (oncount >> 24) (offcount >> 8)*/
+		w32 = ((uint32)b[43] << 24) | ((uint32)b[42] << 8);
+		vp += sprintf(vp, "gpiotimerval=%d", w32);
+
+		/*GPIO LED Powersave duty cycle (oncount >> 24) (offcount >> 8)*/
+		w32 = ((uint32)((unsigned char)(b[21] >> 8) & 0xFF) << 24) |  /* oncount*/
+			((uint32)((unsigned char)(b[21] & 0xFF)) << 8); /* offcount */
+		vp += sprintf(vp, "gpiotimerval=%d", w32);
+
+		vp++;
+	}
+
+	if (sromrev >= 2) {
+		/* New section takes over the 4th hardware function space */
+
+		/* Word 29 is max power 11a high/low */
+		w = b[29];
+		vp += sprintf(vp, "pa1himaxpwr=%d", w & 0xff);
+		vp++;
+		vp += sprintf(vp, "pa1lomaxpwr=%d", (w >> 8) & 0xff);
+		vp++;
+
+		/* Words 30-32 set the 11alow pa settings,
+		 * 33-35 are the 11ahigh ones.
+		 */
+		for (i = 0; i < 3; i++) {
+			vp += sprintf(vp, "pa1lob%d=%d", i, b[30 + i]);
+			vp++;
+			vp += sprintf(vp, "pa1hib%d=%d", i, b[33 + i]);
+			vp++;
+		}
+		w = b[59];
+		if (w == 0)
+			vp += sprintf(vp, "ccode=");
+		else
+			vp += sprintf(vp, "ccode=%c%c", (w >> 8), (w & 0xff));
+		vp++;
+
+	}
+
+	/* parameter section of sprom starts at byte offset 72 */
+	woff = 72/2;
+
+	/* first 6 bytes are il0macaddr */
+	ea.octet[0] = (b[woff] >> 8) & 0xff;
+	ea.octet[1] = b[woff] & 0xff;
+	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
+	ea.octet[3] = b[woff+1] & 0xff;
+	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
+	ea.octet[5] = b[woff+2] & 0xff;
+	woff += ETHER_ADDR_LEN/2 ;
+	bcm_ether_ntoa((uchar*)&ea, eabuf);
+	vp += sprintf(vp, "il0macaddr=%s", eabuf);
+	vp++;
+
+	/* next 6 bytes are et0macaddr */
+	ea.octet[0] = (b[woff] >> 8) & 0xff;
+	ea.octet[1] = b[woff] & 0xff;
+	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
+	ea.octet[3] = b[woff+1] & 0xff;
+	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
+	ea.octet[5] = b[woff+2] & 0xff;
+	woff += ETHER_ADDR_LEN/2 ;
+	bcm_ether_ntoa((uchar*)&ea, eabuf);
+	vp += sprintf(vp, "et0macaddr=%s", eabuf);
+	vp++;
+
+	/* next 6 bytes are et1macaddr */
+	ea.octet[0] = (b[woff] >> 8) & 0xff;
+	ea.octet[1] = b[woff] & 0xff;
+	ea.octet[2] = (b[woff+1] >> 8) & 0xff;
+	ea.octet[3] = b[woff+1] & 0xff;
+	ea.octet[4] = (b[woff+2] >> 8) & 0xff;
+	ea.octet[5] = b[woff+2] & 0xff;
+	woff += ETHER_ADDR_LEN/2 ;
+	bcm_ether_ntoa((uchar*)&ea, eabuf);
+	vp += sprintf(vp, "et1macaddr=%s", eabuf);
+	vp++;
+
+	/*
+	 * Enet phy settings one or two singles or a dual
+	 * Bits 4-0 : MII address for enet0 (0x1f for not there)
+	 * Bits 9-5 : MII address for enet1 (0x1f for not there)
+	 * Bit 14   : Mdio for enet0
+	 * Bit 15   : Mdio for enet1
+	 */
+	w = b[woff];
+	vp += sprintf(vp, "et0phyaddr=%d", (w & 0x1f));
+	vp++;
+	vp += sprintf(vp, "et1phyaddr=%d", ((w >> 5) & 0x1f));
+	vp++;
+	vp += sprintf(vp, "et0mdcport=%d", ((w >> 14) & 0x1));
+	vp++;
+	vp += sprintf(vp, "et1mdcport=%d", ((w >> 15) & 0x1));
+	vp++;
+
+	/* Word 46 has board rev, antennas 0/1 & Country code/control */
+	w = b[46];
+	vp += sprintf(vp, "boardrev=%d", w & 0xff);
+	vp++;
+
+	if (sromrev > 1)
+		vp += sprintf(vp, "cctl=%d", (w >> 8) & 0xf);
+	else
+		vp += sprintf(vp, "cc=%d", (w >> 8) & 0xf);
+	vp++;
+
+	vp += sprintf(vp, "aa0=%d", (w >> 12) & 0x3);
+	vp++;
+
+	vp += sprintf(vp, "aa1=%d", (w >> 14) & 0x3);
+	vp++;
+
+	/* Words 47-49 set the (wl) pa settings */
+	woff = 47;
+
+	for (i = 0; i < 3; i++) {
+		vp += sprintf(vp, "pa0b%d=%d", i, b[woff+i]);
+		vp++;
+		vp += sprintf(vp, "pa1b%d=%d", i, b[woff+i+6]);
+		vp++;
+	}
+
+	/*
+	 * Words 50-51 set the customer-configured wl led behavior.
+	 * 8 bits/gpio pin.  High bit:  activehi=0, activelo=1;
+	 * LED behavior values defined in wlioctl.h .
+	 */
+	w = b[50];
+	if ((w != 0) && (w != 0xffff)) {
+		/* gpio0 */
+		vp += sprintf(vp, "wl0gpio0=%d", (w & 0xff));
+		vp++;
+
+		/* gpio1 */
+		vp += sprintf(vp, "wl0gpio1=%d", (w >> 8) & 0xff);
+		vp++;
+	}
+	w = b[51];
+	if ((w != 0) && (w != 0xffff)) {
+		/* gpio2 */
+		vp += sprintf(vp, "wl0gpio2=%d", w & 0xff);
+		vp++;
+
+		/* gpio3 */
+		vp += sprintf(vp, "wl0gpio3=%d", (w >> 8) & 0xff);
+		vp++;
+	}
+	
+	/* Word 52 is max power 0/1 */
+	w = b[52];
+	vp += sprintf(vp, "pa0maxpwr=%d", w & 0xff);
+	vp++;
+	vp += sprintf(vp, "pa1maxpwr=%d", (w >> 8) & 0xff);
+	vp++;
+
+	/* Word 56 is idle tssi target 0/1 */
+	w = b[56];
+	vp += sprintf(vp, "pa0itssit=%d", w & 0xff);
+	vp++;
+	vp += sprintf(vp, "pa1itssit=%d", (w >> 8) & 0xff);
+	vp++;
+
+	/* Word 57 is boardflags, if not programmed make it zero */
+	w32 = (uint32)b[57];
+	if (w32 == 0xffff) w32 = 0;
+	if (sromrev > 1) {
+		/* Word 28 is the high bits of boardflags */
+		w32 |= (uint32)b[28] << 16;
+	}
+	vp += sprintf(vp, "boardflags=%d", w32);
+	vp++;
+
+	/* Word 58 is antenna gain 0/1 */
+	w = b[58];
+	vp += sprintf(vp, "ag0=%d", w & 0xff);
+	vp++;
+
+	vp += sprintf(vp, "ag1=%d", (w >> 8) & 0xff);
+	vp++;
+
+	if (sromrev == 1) {
+		/* set the oem string */
+		vp += sprintf(vp, "oem=%02x%02x%02x%02x%02x%02x%02x%02x",
+			      ((b[59] >> 8) & 0xff), (b[59] & 0xff),
+			      ((b[60] >> 8) & 0xff), (b[60] & 0xff),
+			      ((b[61] >> 8) & 0xff), (b[61] & 0xff),
+			      ((b[62] >> 8) & 0xff), (b[62] & 0xff));
+		vp++;
+	} else if (sromrev == 2) {
+		/* Word 60 OFDM tx power offset from CCK level */
+		/* OFDM Power Offset - opo */
+		vp += sprintf(vp, "opo=%d", b[60] & 0xff);
+		vp++;
+	} else {
+		/* Word 60: cck power offsets */
+		vp += sprintf(vp, "cckpo=%d", b[60]);
+		vp++;
+
+		/* Words 61+62: 11g ofdm power offsets */
+		w32 = ((uint32)b[62] << 16) | b[61];
+		vp += sprintf(vp, "ofdmgpo=%d", w32);
+		vp++;
+	}
+
+	/* final nullbyte terminator */
+	*vp++ = '\0';
+
+	ASSERT((vp - base) <= VARS_MAX);
+	
+	err = initvars_table(osh, base, vp, vars, count);
+	
+	MFREE(osh, base, VARS_MAX);
+	return err;
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/bcmutils.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/bcmutils.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/bcmutils.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/bcmutils.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,356 @@
+/*
+ * Misc useful OS-independent routines.
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <bcmnvram.h>
+#include <bcmutils.h>
+#include <bcmendian.h>
+#include <bcmdevs.h>
+
+unsigned char bcm_ctype[] = {
+	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 0-7 */
+	_BCM_C,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C|_BCM_S,_BCM_C,_BCM_C,		/* 8-15 */
+	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 16-23 */
+	_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,_BCM_C,			/* 24-31 */
+	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 32-39 */
+	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 40-47 */
+	_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,_BCM_D,			/* 48-55 */
+	_BCM_D,_BCM_D,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 56-63 */
+	_BCM_P,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U|_BCM_X,_BCM_U,	/* 64-71 */
+	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 72-79 */
+	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,			/* 80-87 */
+	_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,			/* 88-95 */
+	_BCM_P,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L|_BCM_X,_BCM_L,	/* 96-103 */
+	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 104-111 */
+	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,			/* 112-119 */
+	_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_C,			/* 120-127 */
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
+	_BCM_S|_BCM_SP,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,   /* 160-175 */
+	_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,_BCM_P,       /* 176-191 */
+	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,       /* 192-207 */
+	_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_P,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_U,_BCM_L,       /* 208-223 */
+	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,       /* 224-239 */
+	_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_P,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L,_BCM_L        /* 240-255 */
+};
+
+uchar
+bcm_toupper(uchar c)
+{
+	if (bcm_islower(c))
+		c -= 'a'-'A';
+	return (c);
+}
+
+ulong
+bcm_strtoul(char *cp, char **endp, uint base)
+{
+	ulong result, value;
+	bool minus;
+	
+	minus = FALSE;
+
+	while (bcm_isspace(*cp))
+		cp++;
+	
+	if (cp[0] == '+')
+		cp++;
+	else if (cp[0] == '-') {
+		minus = TRUE;
+		cp++;
+	}
+	
+	if (base == 0) {
+		if (cp[0] == '0') {
+			if ((cp[1] == 'x') || (cp[1] == 'X')) {
+				base = 16;
+				cp = &cp[2];
+			} else {
+				base = 8;
+				cp = &cp[1];
+			}
+		} else
+			base = 10;
+	} else if (base == 16 && (cp[0] == '0') && ((cp[1] == 'x') || (cp[1] == 'X'))) {
+		cp = &cp[2];
+	}
+		   
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value = bcm_isdigit(*cp) ? *cp-'0' : bcm_toupper(*cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong)(result * -1);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+
+uint
+bcm_atoi(char *s)
+{
+	uint n;
+
+	n = 0;
+
+	while (bcm_isdigit(*s))
+		n = (n * 10) + *s++ - '0';
+	return (n);
+}
+
+/* return pointer to location of substring 'needle' in 'haystack' */
+char*
+bcmstrstr(char *haystack, char *needle)
+{
+	int len, nlen;
+	int i;
+
+	if ((haystack == NULL) || (needle == NULL))
+		return (haystack);
+
+	nlen = strlen(needle);
+	len = strlen(haystack) - nlen + 1;
+
+	for (i = 0; i < len; i++)
+		if (bcmp(needle, &haystack[i], nlen) == 0)
+			return (&haystack[i]);
+	return (NULL);
+}
+
+char*
+bcmstrcat(char *dest, const char *src)
+{
+	strcpy(&dest[strlen(dest)], src);
+	return (dest);
+}
+
+
+char*
+bcm_ether_ntoa(char *ea, char *buf)
+{
+	sprintf(buf,"%02x:%02x:%02x:%02x:%02x:%02x",
+		(uchar)ea[0]&0xff, (uchar)ea[1]&0xff, (uchar)ea[2]&0xff,
+		(uchar)ea[3]&0xff, (uchar)ea[4]&0xff, (uchar)ea[5]&0xff);
+	return (buf);
+}
+
+/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
+int
+bcm_ether_atoe(char *p, char *ea)
+{
+	int i = 0;
+
+	for (;;) {
+		ea[i++] = (char) bcm_strtoul(p, &p, 16);
+		if (!*p++ || i == 6)
+			break;
+	}
+
+	return (i == 6);
+}
+
+void
+bcm_mdelay(uint ms)
+{
+	uint i;
+
+	for (i = 0; i < ms; i++) {
+		OSL_DELAY(1000);
+	}
+}
+
+/*
+ * Search the name=value vars for a specific one and return its value.
+ * Returns NULL if not found.
+ */
+char*
+getvar(char *vars, char *name)
+{
+	char *s;
+	int len;
+
+	len = strlen(name);
+
+	/* first look in vars[] */
+	for (s = vars; s && *s; ) {
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len+1]);
+
+		while (*s++)
+			;
+	}
+
+	/* then query nvram */
+	return (BCMINIT(nvram_get)(name));
+}
+
+/*
+ * Search the vars for a specific one and return its value as
+ * an integer. Returns 0 if not found.
+ */
+int
+getintvar(char *vars, char *name)
+{
+	char *val;
+
+	if ((val = getvar(vars, name)) == NULL)
+		return (0);
+
+	return (bcm_strtoul(val, NULL, 0));
+}
+
+
+/* Search for token in comma separated token-string */
+static int
+findmatch(char *string, char *name)
+{
+	uint len;
+	char *c;
+
+	len = strlen(name);
+	while ((c = strchr(string, ',')) != NULL) {
+		if (len == (uint)(c - string) && !strncmp(string, name, len))
+			return 1;
+		string = c + 1;
+	}
+
+	return (!strcmp(string, name));
+}
+
+/* Return gpio pin number assigned to the named pin */
+/*
+* Variable should be in format:
+*
+*	gpio<N>=pin_name,pin_name
+*
+* This format allows multiple features to share the gpio with mutual
+* understanding.
+*
+* 'def_pin' is returned if a specific gpio is not defined for the requested functionality 
+* and if def_pin is not used by others.
+*/
+uint
+getgpiopin(char *vars, char *pin_name, uint def_pin)
+{
+	char name[] = "gpioXXXX";
+	char *val;
+	uint pin;
+
+	/* Go thru all possibilities till a match in pin name */
+	for (pin = 0; pin < GPIO_NUMPINS; pin ++) {
+		sprintf(name, "gpio%d", pin);
+		val = getvar(vars, name);
+		if (val && findmatch(val, pin_name))
+			return pin;
+	}
+
+	if (def_pin != GPIO_PIN_NOTDEFINED) {
+		/* make sure the default pin is not used by someone else */
+		sprintf(name, "gpio%d", def_pin);
+		if (getvar(vars, name)) {
+			def_pin =  GPIO_PIN_NOTDEFINED;
+		}
+	}
+
+	return def_pin;
+}
+
+
+/*******************************************************************************
+ * crc8
+ *
+ * Computes a crc8 over the input data using the polynomial:
+ *
+ *       x^8 + x^7 +x^6 + x^4 + x^2 + 1
+ *
+ * The caller provides the initial value (either CRC8_INIT_VALUE
+ * or the previous returned value) to allow for processing of 
+ * discontiguous blocks of data.  When generating the CRC the
+ * caller is responsible for complementing the final return value
+ * and inserting it into the byte stream.  When checking, a final
+ * return value of CRC8_GOOD_VALUE indicates a valid CRC.
+ *
+ * Reference: Dallas Semiconductor Application Note 27
+ *   Williams, Ross N., "A Painless Guide to CRC Error Detection Algorithms", 
+ *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
+ *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
+ *
+ ******************************************************************************/
+
+static uint8 crc8_table[256] = {
+    0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
+    0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
+    0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
+    0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
+    0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
+    0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
+    0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
+    0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
+    0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
+    0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
+    0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
+    0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
+    0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
+    0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
+    0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
+    0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
+    0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
+    0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
+    0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
+    0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
+    0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
+    0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
+    0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
+    0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
+    0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
+    0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
+    0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
+    0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
+    0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
+    0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
+    0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
+    0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F
+};
+
+#define CRC_INNER_LOOP(n, c, x) \
+    (c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
+
+uint8
+hndcrc8(
+	uint8 *pdata,	/* pointer to array of data to process */
+	uint  nbytes,	/* number of input data bytes to process */
+	uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
+)
+{
+	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
+	 * to avoid the undefined and unnecessary (uint8 >> 8) operation. */
+	while (nbytes-- > 0)
+		crc = crc8_table[(crc ^ *pdata++) & 0xff];
+
+	return crc;
+}
+
+#ifdef notdef
+#define CLEN 	1499
+#define CBUFSIZ 	(CLEN+4)
+#define CNBUFS		5
+
+#endif
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/cfe_env.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/cfe_env.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/cfe_env.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/cfe_env.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,234 @@
+/*
+ * NVRAM variable manipulation (Linux kernel half)
+ *
+ * Copyright 2001-2003, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmendian.h>
+#include <bcmutils.h>
+
+#define NVRAM_SIZE       (0x1ff0)
+static char _nvdata[NVRAM_SIZE] __initdata;
+static char _valuestr[256] __initdata;
+
+/*
+ * TLV types.  These codes are used in the "type-length-value"
+ * encoding of the items stored in the NVRAM device (flash or EEPROM)
+ *
+ * The layout of the flash/nvram is as follows:
+ *
+ * <type> <length> <data ...> <type> <length> <data ...> <type_end>
+ *
+ * The type code of "ENV_TLV_TYPE_END" marks the end of the list.
+ * The "length" field marks the length of the data section, not
+ * including the type and length fields.
+ *
+ * Environment variables are stored as follows:
+ *
+ * <type_env> <length> <flags> <name> = <value>
+ *
+ * If bit 0 (low bit) is set, the length is an 8-bit value.
+ * If bit 0 (low bit) is clear, the length is a 16-bit value
+ * 
+ * Bit 7 set indicates "user" TLVs.  In this case, bit 0 still
+ * indicates the size of the length field.  
+ *
+ * Flags are from the constants below:
+ *
+ */
+#define ENV_LENGTH_16BITS	0x00	/* for low bit */
+#define ENV_LENGTH_8BITS	0x01
+
+#define ENV_TYPE_USER		0x80
+
+#define ENV_CODE_SYS(n,l) (((n)<<1)|(l))
+#define ENV_CODE_USER(n,l) ((((n)<<1)|(l)) | ENV_TYPE_USER)
+
+/*
+ * The actual TLV types we support
+ */
+
+#define ENV_TLV_TYPE_END	0x00	
+#define ENV_TLV_TYPE_ENV	ENV_CODE_SYS(0,ENV_LENGTH_8BITS)
+
+/*
+ * Environment variable flags 
+ */
+
+#define ENV_FLG_NORMAL		0x00	/* normal read/write */
+#define ENV_FLG_BUILTIN		0x01	/* builtin - not stored in flash */
+#define ENV_FLG_READONLY	0x02	/* read-only - cannot be changed */
+
+#define ENV_FLG_MASK		0xFF	/* mask of attributes we keep */
+#define ENV_FLG_ADMIN		0x100	/* lets us internally override permissions */
+
+
+/*  *********************************************************************
+    *  _nvram_read(buffer,offset,length)
+    *  
+    *  Read data from the NVRAM device
+    *  
+    *  Input parameters: 
+    *  	   buffer - destination buffer
+    *  	   offset - offset of data to read
+    *  	   length - number of bytes to read
+    *  	   
+    *  Return value:
+    *  	   number of bytes read, or <0 if error occured
+    ********************************************************************* */
+static int
+_nvram_read(unsigned char *nv_buf, unsigned char *buffer, int offset, int length)
+{
+    int i;
+    if (offset > NVRAM_SIZE)
+	return -1; 
+
+    for ( i = 0; i < length; i++) {
+	buffer[i] = ((volatile unsigned char*)nv_buf)[offset + i];
+    }
+    return length;
+}
+
+
+static char*
+_strnchr(const char *dest,int c,size_t cnt)
+{
+	while (*dest && (cnt > 0)) {
+	if (*dest == c) return (char *) dest;
+	dest++;
+	cnt--;
+	}
+	return NULL;
+}
+
+
+
+/*
+ * Core support API: Externally visible.
+ */
+
+/*
+ * Get the value of an NVRAM variable
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+
+char* 
+cfe_env_get(unsigned char *nv_buf, char* name)
+{
+    int size;
+    unsigned char *buffer;
+    unsigned char *ptr;
+    unsigned char *envval;
+    unsigned int reclen;
+    unsigned int rectype;
+    int offset;
+    int flg;
+    
+    size = NVRAM_SIZE;
+    buffer = &_nvdata[0];
+
+    ptr = buffer;
+    offset = 0;
+
+    /* Read the record type and length */
+    if (_nvram_read(nv_buf, ptr,offset,1) != 1) {
+	goto error;
+    }
+    
+    while ((*ptr != ENV_TLV_TYPE_END)  && (size > 1)) {
+
+	/* Adjust pointer for TLV type */
+	rectype = *(ptr);
+	offset++;
+	size--;
+
+	/* 
+	 * Read the length.  It can be either 1 or 2 bytes
+	 * depending on the code 
+	 */
+	if (rectype & ENV_LENGTH_8BITS) {
+	    /* Read the record type and length - 8 bits */
+	    if (_nvram_read(nv_buf, ptr,offset,1) != 1) {
+		goto error;
+	    }
+	    reclen = *(ptr);
+	    size--;
+	    offset++;
+	}
+	else {
+	    /* Read the record type and length - 16 bits, MSB first */
+	    if (_nvram_read(nv_buf, ptr,offset,2) != 2) {
+		goto error;
+	    }
+	    reclen = (((unsigned int) *(ptr)) << 8) + (unsigned int) *(ptr+1);
+	    size -= 2;
+	    offset += 2;
+	}
+
+	if (reclen > size)
+	    break;	/* should not happen, bad NVRAM */
+
+	switch (rectype) {
+	    case ENV_TLV_TYPE_ENV:
+		/* Read the TLV data */
+		if (_nvram_read(nv_buf, ptr,offset,reclen) != reclen)
+		    goto error;
+		flg = *ptr++;
+		envval = (unsigned char *) _strnchr(ptr,'=',(reclen-1));
+		if (envval) {
+		    *envval++ = '\0';
+		    memcpy(_valuestr,envval,(reclen-1)-(envval-ptr));
+		    _valuestr[(reclen-1)-(envval-ptr)] = '\0';
+#if 0			
+		    printk(KERN_INFO "NVRAM:%s=%s\n", ptr, _valuestr);
+#endif
+		    if(!strcmp(ptr, name)){
+			return _valuestr;
+		    }
+		    if((strlen(ptr) > 1) && !strcmp(&ptr[1], name))
+			return _valuestr;
+		}
+		break;
+		
+	    default: 
+		/* Unknown TLV type, skip it. */
+		break;
+	    }
+
+	/*
+	 * Advance to next TLV 
+	 */
+		
+	size -= (int)reclen;
+	offset += reclen;
+
+	/* Read the next record type */
+	ptr = buffer;
+	if (_nvram_read(nv_buf, ptr,offset,1) != 1)
+	    goto error;
+	}
+
+error:
+    return NULL;
+
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/linux_osl.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/linux_osl.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/linux_osl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/linux_osl.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ * Linux OS Independent Layer
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#define LINUX_OSL
+
+#include <typedefs.h>
+#include <bcmendian.h>
+#include <linux/module.h>
+#include <linuxver.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <linux/delay.h>
+#ifdef mips
+#include <asm/paccess.h>
+#endif
+#include <pcicfg.h>
+
+#define PCI_CFG_RETRY 		10	
+
+#define OS_HANDLE_MAGIC		0x1234abcd
+#define BCM_MEM_FILENAME_LEN 	24
+
+typedef struct bcm_mem_link {
+	struct bcm_mem_link *prev;
+	struct bcm_mem_link *next;
+	uint	size;
+	int	line;
+	char	file[BCM_MEM_FILENAME_LEN];
+} bcm_mem_link_t;
+
+struct os_handle {
+	uint magic;
+	void *pdev;
+	uint malloced;
+	uint failed;
+	bcm_mem_link_t *dbgmem_list;
+};
+
+uint32
+osl_pci_read_config(osl_t *osh, uint offset, uint size)
+{
+	uint val;
+	uint retry=PCI_CFG_RETRY;	 
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	/* only 4byte access supported */
+	ASSERT(size == 4);
+
+	do {
+		pci_read_config_dword(osh->pdev, offset, &val);
+		if (val != 0xffffffff)
+			break;
+	} while (retry--);
+
+
+	return (val);
+}
+
+void
+osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val)
+{
+	uint retry=PCI_CFG_RETRY;	 
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	/* only 4byte access supported */
+	ASSERT(size == 4);
+
+	do {
+		pci_write_config_dword(osh->pdev, offset, val);
+		if (offset!=PCI_BAR0_WIN)
+			break;
+		if (osl_pci_read_config(osh,offset,size) == val) 
+			break;
+	} while (retry--);
+
+}
+
+void
+osl_delay(uint usec)
+{
+	uint d;
+
+	while (usec > 0) {
+		d = MIN(usec, 1000);
+		udelay(d);
+		usec -= d;
+	}
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/Makefile linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/Makefile
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/Makefile	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the BCM47xx specific kernel interface routines
+# under Linux.
+#
+ 
+obj-y	:= sbutils.o linux_osl.o bcmsrom.o bcmutils.o sbmips.o sbpci.o sflash.o nvram.o cfe_env.o
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/nvram.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/nvram.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/nvram.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/nvram.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,192 @@
+/*
+ * NVRAM variable manipulation (Linux kernel half)
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <typedefs.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <bcmutils.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <sbutils.h>
+#include <sbmips.h>
+#include <sflash.h>
+
+/* In BSS to minimize text size and page aligned so it can be mmap()-ed */
+static char nvram_buf[NVRAM_SPACE] __attribute__((aligned(PAGE_SIZE)));
+
+/* Global SB handle */
+extern void *sbh;
+extern spinlock_t bcm947xx_sbh_lock;
+static int cfe_env;
+
+extern char *cfe_env_get(char *nv_buf, const char *name);
+		
+
+/* Convenience */
+#define sbh_lock bcm947xx_sbh_lock
+#define KB * 1024
+#define MB * 1024 * 1024
+
+/* Probe for NVRAM header */
+static void __init
+early_nvram_init(void)
+{
+	struct nvram_header *header;
+	chipcregs_t *cc;
+	struct sflash *info = NULL;
+	int i;
+	uint32 base, off, lim;
+	u32 *src, *dst;
+
+	cfe_env = 0;
+	if ((cc = sb_setcore(sbh, SB_CC, 0)) != NULL) {
+		base = KSEG1ADDR(SB_FLASH2);
+		switch (readl(&cc->capabilities) & CAP_FLASH_MASK) {
+		case PFLASH:
+			lim = SB_FLASH2_SZ;
+			break;
+
+		case SFLASH_ST:
+		case SFLASH_AT:
+			if ((info = sflash_init(cc)) == NULL)
+				return;
+			lim = info->size;
+			break;
+
+		case FLASH_NONE:
+		default:
+			return;
+		}
+	} else {
+		/* extif assumed, Stop at 4 MB */
+		base = KSEG1ADDR(SB_FLASH1);
+		lim = SB_FLASH1_SZ;
+	}
+
+	/* XXX: hack for supporting the CFE environment stuff on WGT634U */
+	src = (u32 *) KSEG1ADDR(base + 8 * 1024 * 1024 - 0x2000);
+	dst = (u32 *) nvram_buf;
+	if ((lim == 0x02000000) && ((*src & 0xff00ff) == 0x000001)) {
+		printk("early_nvram_init: WGT634U NVRAM found.\n");
+
+		for (i = 0; i < 0x1ff0; i++) {
+			if (*src == 0xFFFFFFFF)
+				break;
+			*dst++ = *src++;
+		}
+		cfe_env = 1;
+		return;
+	}
+
+	off = FLASH_MIN;
+	while (off <= lim) {
+		/* Windowed flash access */
+		header = (struct nvram_header *) KSEG1ADDR(base + off - NVRAM_SPACE);
+		if (header->magic == NVRAM_MAGIC)
+			goto found;
+		off <<= 1;
+	}
+
+	/* Try embedded NVRAM at 4 KB and 1 KB as last resorts */
+	header = (struct nvram_header *) KSEG1ADDR(base + 4 KB);
+	if (header->magic == NVRAM_MAGIC)
+		goto found;
+	
+	header = (struct nvram_header *) KSEG1ADDR(base + 1 KB);
+	if (header->magic == NVRAM_MAGIC)
+		goto found;
+	
+	return;
+
+found:
+	src = (u32 *) header;
+	dst = (u32 *) nvram_buf;
+	for (i = 0; i < sizeof(struct nvram_header); i += 4)
+		*dst++ = *src++;
+	for (; i < header->len && i < NVRAM_SPACE; i += 4)
+		*dst++ = ltoh32(*src++);
+}
+
+/* Early (before mm or mtd) read-only access to NVRAM */
+char * __init early_nvram_get(const char *name)
+{
+	char *var, *value, *end, *eq;
+
+	if (!name)
+		return NULL;
+
+	/* Too early? */
+	if (sbh == NULL)
+		return NULL;
+
+	if (!nvram_buf[0])
+		early_nvram_init();
+
+	if (cfe_env)
+		return cfe_env_get(nvram_buf, name);
+
+	/* Look for name=value and return value */
+	var = &nvram_buf[sizeof(struct nvram_header)];
+	end = nvram_buf + sizeof(nvram_buf) - 2;
+	end[0] = end[1] = '\0';
+	for (; *var; var = value + strlen(value) + 1) {
+		if (!(eq = strchr(var, '=')))
+			break;
+		value = eq + 1;
+		if ((eq - var) == strlen(name) && strncmp(var, name, (eq - var)) == 0)
+			return value;
+	}
+
+	return NULL;
+}
+
+char *nvram_get(const char *name)
+{
+	char *var, *value, *end, *eq;
+
+	if (!name)
+		return NULL;
+
+	if (!nvram_buf[0])
+		return NULL;
+	
+	/* Look for name=value and return value */
+	var = &nvram_buf[sizeof(struct nvram_header)];
+	end = nvram_buf + sizeof(nvram_buf) - 2;
+	end[0] = end[1] = '\0';
+	for (; *var; var = value + strlen(value) + 1) {
+		if (!(eq = strchr(var, '=')))
+			break;
+		value = eq + 1;
+		if ((eq - var) == strlen(name) && strncmp(var, name, (eq - var)) == 0)
+			return value;
+	}
+	
+	return NULL;
+}
+
+EXPORT_SYMBOL(nvram_get);
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/sbmips.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbmips.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/sbmips.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbmips.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,1055 @@
+/*
+ * BCM47XX Sonics SiliconBackplane MIPS core routines
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <bcmdevs.h>
+#include <bcmnvram.h>
+#include <bcmutils.h>
+#include <hndmips.h>
+#include <sbconfig.h>
+#include <sbextif.h>
+#include <sbchipc.h>
+#include <sbmemc.h>
+#include <mipsinc.h>
+#include <sbutils.h>
+
+/*
+ * Returns TRUE if an external UART exists at the given base
+ * register.
+ */
+static bool
+BCMINITFN(serial_exists)(uint8 *regs)
+{
+	uint8 save_mcr, status1;
+
+	save_mcr = R_REG(&regs[UART_MCR]);
+	W_REG(&regs[UART_MCR], UART_MCR_LOOP | 0x0a);
+	status1 = R_REG(&regs[UART_MSR]) & 0xf0;
+	W_REG(&regs[UART_MCR], save_mcr);
+
+	return (status1 == 0x90);
+}
+
+/*
+ * Initializes UART access. The callback function will be called once
+ * per found UART.
+ */
+void
+BCMINITFN(sb_serial_init)(sb_t *sbh, void (*add)(void *regs, uint irq, uint baud_base, uint reg_shift))
+{
+	void *regs;
+	ulong base;
+	uint irq;
+	int i, n;
+
+	if ((regs = sb_setcore(sbh, SB_EXTIF, 0))) {
+		extifregs_t *eir = (extifregs_t *) regs;
+		sbconfig_t *sb;
+
+		/* Determine external UART register base */
+		sb = (sbconfig_t *)((ulong) eir + SBCONFIGOFF);
+		base = EXTIF_CFGIF_BASE(sb_base(R_REG(&sb->sbadmatch1)));
+
+		/* Determine IRQ */
+		irq = sb_irq(sbh);
+
+		/* Disable GPIO interrupt initially */
+		W_REG(&eir->gpiointpolarity, 0);
+		W_REG(&eir->gpiointmask, 0);
+
+		/* Search for external UARTs */
+		n = 2;
+		for (i = 0; i < 2; i++) {
+			regs = (void *) REG_MAP(base + (i * 8), 8);
+			if (BCMINIT(serial_exists)(regs)) {
+				/* Set GPIO 1 to be the external UART IRQ */
+				W_REG(&eir->gpiointmask, 2);
+				if (add)
+					add(regs, irq, 13500000, 0);
+			}
+		}
+
+		/* Add internal UART if enabled */
+		if (R_REG(&eir->corecontrol) & CC_UE)
+			if (add)
+				add((void *) &eir->uartdata, irq, sb_clock(sbh), 2);
+	} else if ((regs = sb_setcore(sbh, SB_CC, 0))) {
+		chipcregs_t *cc = (chipcregs_t *) regs;
+		uint32 rev, cap, pll, baud_base, div;
+
+		/* Determine core revision and capabilities */
+		rev = sb_corerev(sbh);
+		cap = R_REG(&cc->capabilities);
+		pll = cap & CAP_PLL_MASK;
+
+		/* Determine IRQ */
+		irq = sb_irq(sbh);
+
+		if (pll == PLL_TYPE1) {
+			/* PLL clock */
+			baud_base = sb_clock_rate(pll,
+						  R_REG(&cc->clockcontrol_n),
+						  R_REG(&cc->clockcontrol_m2));
+			div = 1;
+		} else {
+			if (rev >= 11) {
+				/* Fixed ALP clock */
+				baud_base = 20000000;
+				div = 1;
+				/* Set the override bit so we don't divide it */
+				W_REG(&cc->corecontrol, CC_UARTCLKO);
+			} else if (rev >= 3) {
+				/* Internal backplane clock */
+				baud_base = sb_clock(sbh);
+				div = 2;	/* Minimum divisor */
+				W_REG(&cc->clkdiv,
+				      ((R_REG(&cc->clkdiv) & ~CLKD_UART) | div));
+			} else {
+				/* Fixed internal backplane clock */
+				baud_base = 88000000;
+				div = 48;
+			}
+
+			/* Clock source depends on strapping if UartClkOverride is unset */
+			if ((rev > 0) &&
+			    ((R_REG(&cc->corecontrol) & CC_UARTCLKO) == 0)) {
+				if ((cap & CAP_UCLKSEL) == CAP_UINTCLK) {
+					/* Internal divided backplane clock */
+					baud_base /= div;
+				} else {
+					/* Assume external clock of 1.8432 MHz */
+					baud_base = 1843200;
+				}
+			}
+		}
+
+		/* Add internal UARTs */
+		n = cap & CAP_UARTS_MASK;
+		for (i = 0; i < n; i++) {
+			/* Register offset changed after revision 0 */
+			if (rev)
+				regs = (void *)((ulong) &cc->uart0data + (i * 256));
+			else
+				regs = (void *)((ulong) &cc->uart0data + (i * 8));
+
+			if (add)
+				add(regs, irq, baud_base, 0);
+		}
+	}
+}
+
+/*
+ * Initialize jtag master and return handle for
+ * jtag_rwreg. Returns NULL on failure.
+ */
+void *
+sb_jtagm_init(sb_t *sbh, uint clkd, bool exttap)
+{
+	void *regs;
+
+	if ((regs = sb_setcore(sbh, SB_CC, 0)) != NULL) {
+		chipcregs_t *cc = (chipcregs_t *) regs;
+		uint32 tmp;
+
+		/*
+		 * Determine jtagm availability from
+		 * core revision and capabilities.
+		 */
+		tmp = sb_corerev(sbh);
+		/*
+		 * Corerev 10 has jtagm, but the only chip
+		 * with it does not have a mips, and
+		 * the layout of the jtagcmd register is
+		 * different. We'll only accept >= 11.
+		 */
+		if (tmp < 11)
+			return (NULL);
+
+		tmp = R_REG(&cc->capabilities);
+		if ((tmp & CAP_JTAGP) == 0)
+			return (NULL);
+
+		/* Set clock divider if requested */
+		if (clkd != 0) {
+			tmp = R_REG(&cc->clkdiv);
+			tmp = (tmp & ~CLKD_JTAG) |
+				((clkd << CLKD_JTAG_SHIFT) & CLKD_JTAG);
+			W_REG(&cc->clkdiv, tmp);
+		}
+
+		/* Enable jtagm */
+		tmp = JCTRL_EN | (exttap ? JCTRL_EXT_EN : 0);
+		W_REG(&cc->jtagctrl, tmp);
+	}
+
+	return (regs);
+}
+
+void
+sb_jtagm_disable(void *h)
+{
+	chipcregs_t *cc = (chipcregs_t *)h;
+
+	W_REG(&cc->jtagctrl, R_REG(&cc->jtagctrl) & ~JCTRL_EN);
+}
+
+/*
+ * Read/write a jtag register. Assumes a target with
+ * 8 bit IR and 32 bit DR.
+ */
+#define	IRWIDTH		8
+#define	DRWIDTH		32
+uint32
+jtag_rwreg(void *h, uint32 ir, uint32 dr)
+{
+	chipcregs_t *cc = (chipcregs_t *) h;
+	uint32 tmp;
+
+	W_REG(&cc->jtagir, ir);
+	W_REG(&cc->jtagdr, dr);
+	tmp = JCMD_START | JCMD_ACC_IRDR |
+		((IRWIDTH - 1) << JCMD_IRW_SHIFT) |
+		(DRWIDTH - 1);
+	W_REG(&cc->jtagcmd, tmp);
+	while (((tmp = R_REG(&cc->jtagcmd)) & JCMD_BUSY) == JCMD_BUSY) {
+		/* OSL_DELAY(1); */
+	}
+
+	tmp = R_REG(&cc->jtagdr);
+	return (tmp);
+}
+
+/* Returns the SB interrupt flag of the current core. */
+uint32
+sb_flag(sb_t *sbh)
+{
+	void *regs;
+	sbconfig_t *sb;
+
+	regs = sb_coreregs(sbh);
+	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	return (R_REG(&sb->sbtpsflag) & SBTPS_NUM0_MASK);
+}
+
+static const uint32 sbips_int_mask[] = {
+	0,
+	SBIPS_INT1_MASK,
+	SBIPS_INT2_MASK,
+	SBIPS_INT3_MASK,
+	SBIPS_INT4_MASK
+};
+
+static const uint32 sbips_int_shift[] = {
+	0,
+	0,
+	SBIPS_INT2_SHIFT,
+	SBIPS_INT3_SHIFT,
+	SBIPS_INT4_SHIFT
+};
+
+/*
+ * Returns the MIPS IRQ assignment of the current core. If unassigned,
+ * 0 is returned.
+ */
+uint
+sb_irq(sb_t *sbh)
+{
+	uint idx;
+	void *regs;
+	sbconfig_t *sb;
+	uint32 flag, sbipsflag;
+	uint irq = 0;
+
+	flag = sb_flag(sbh);
+
+	idx = sb_coreidx(sbh);
+
+	if ((regs = sb_setcore(sbh, SB_MIPS, 0)) ||
+	    (regs = sb_setcore(sbh, SB_MIPS33, 0))) {
+		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+		/* sbipsflag specifies which core is routed to interrupts 1 to 4 */
+		sbipsflag = R_REG(&sb->sbipsflag);
+		for (irq = 1; irq <= 4; irq++) {
+			if (((sbipsflag & sbips_int_mask[irq]) >> sbips_int_shift[irq]) == flag)
+				break;
+		}
+		if (irq == 5)
+			irq = 0;
+	}
+
+	sb_setcoreidx(sbh, idx);
+
+	return irq;
+}
+
+/* Clears the specified MIPS IRQ. */
+static void
+BCMINITFN(sb_clearirq)(sb_t *sbh, uint irq)
+{
+	void *regs;
+	sbconfig_t *sb;
+
+	if (!(regs = sb_setcore(sbh, SB_MIPS, 0)) &&
+	    !(regs = sb_setcore(sbh, SB_MIPS33, 0)))
+		ASSERT(regs);
+	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	if (irq == 0)
+		W_REG(&sb->sbintvec, 0);
+	else
+		OR_REG(&sb->sbipsflag, sbips_int_mask[irq]);
+}
+
+/*
+ * Assigns the specified MIPS IRQ to the specified core. Shared MIPS
+ * IRQ 0 may be assigned more than once.
+ */
+static void
+BCMINITFN(sb_setirq)(sb_t *sbh, uint irq, uint coreid, uint coreunit)
+{
+	void *regs;
+	sbconfig_t *sb;
+	uint32 flag;
+
+	regs = sb_setcore(sbh, coreid, coreunit);
+	ASSERT(regs);
+	flag = sb_flag(sbh);
+
+	if (!(regs = sb_setcore(sbh, SB_MIPS, 0)) &&
+	    !(regs = sb_setcore(sbh, SB_MIPS33, 0)))
+		ASSERT(regs);
+	sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+	if (irq == 0)
+		OR_REG(&sb->sbintvec, 1 << flag);
+	else {
+		flag <<= sbips_int_shift[irq];
+		ASSERT(!(flag & ~sbips_int_mask[irq]));
+		flag |= R_REG(&sb->sbipsflag) & ~sbips_int_mask[irq];
+		W_REG(&sb->sbipsflag, flag);
+	}
+}
+
+/*
+ * Initializes clocks and interrupts. SB and NVRAM access must be
+ * initialized prior to calling.
+ */
+void
+BCMINITFN(sb_mips_init)(sb_t *sbh)
+{
+	ulong hz, ns, tmp;
+	extifregs_t *eir;
+	chipcregs_t *cc;
+	char *value;
+	uint irq;
+
+	/* Figure out current SB clock speed */
+	if ((hz = sb_clock(sbh)) == 0)
+		hz = 100000000;
+	ns = 1000000000 / hz;
+
+	/* Setup external interface timing */
+	if ((eir = sb_setcore(sbh, SB_EXTIF, 0))) {
+		/* Initialize extif so we can get to the LEDs and external UART */
+		W_REG(&eir->prog_config, CF_EN);
+
+		/* Set timing for the flash */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
+
+		/* Set programmable interface timing for external uart */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
+		tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
+		tmp = tmp | CEIL(120, ns);		/* W0 = 120nS */
+		W_REG(&eir->prog_waitcount, tmp);	/* 0x01020a0c for a 100Mhz clock */
+	} else if ((cc = sb_setcore(sbh, SB_CC, 0))) {
+		/* set register for external IO to control LED. */
+                W_REG(&cc->prog_config, 0x11);
+                tmp = CEIL(10, ns) << FW_W3_SHIFT;      /* W3 = 10nS */
+                tmp = tmp | (CEIL(40, ns) << FW_W1_SHIFT); /* W1 = 40nS */
+                tmp = tmp | CEIL(240, ns);              /* W0 = 120nS */
+                W_REG(&cc->prog_waitcount, tmp);        /* 0x01020a0c for a 100Mhz clock */
+
+		/* Set timing for the flash */
+		tmp = CEIL(10, ns) << FW_W3_SHIFT;	/* W3 = 10nS */
+		tmp |= CEIL(10, ns) << FW_W1_SHIFT;	/* W1 = 10nS */
+		tmp |= CEIL(120, ns);			/* W0 = 120nS */
+		
+		// Added by Chen-I for 5365
+		if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
+		{
+			W_REG(&cc->flash_waitcount, tmp);
+			W_REG(&cc->pcmcia_memwait, tmp);
+		}
+		else
+		{
+			if (sb_corerev(sbh) < 9)
+				W_REG(&cc->flash_waitcount, tmp);
+
+			if ((sb_corerev(sbh) < 9) ||
+		   	 ((BCMINIT(sb_chip)(sbh) == BCM5350_DEVICE_ID) && BCMINIT(sb_chiprev)(sbh) == 0)) {
+				W_REG(&cc->pcmcia_memwait, tmp);
+			}
+		}
+		// Added by Chen-I & Yen for enabling 5350 EXTIF
+		if (BCMINIT(sb_chip)(sbh) == BCM5350_DEVICE_ID) 
+		{
+			/* Set programmable interface timing for external uart */
+			tmp = CEIL(10, ns) << FW_W3_SHIFT;      /* W3 = 10nS */
+			tmp = tmp | (CEIL(20, ns) << FW_W2_SHIFT); /* W2 = 20nS */
+			tmp = tmp | (CEIL(100, ns) << FW_W1_SHIFT); /* W1 = 100nS */
+			tmp = tmp | CEIL(120, ns);              /* W0 = 120nS */
+			W_REG(&cc->prog_waitcount, tmp);       /* 0x01020a0c for a 100Mhz clock */
+		}
+	}
+
+	/* Chip specific initialization */
+	switch (BCMINIT(sb_chip)(sbh)) {
+	case BCM4710_DEVICE_ID:
+		/* Clear interrupt map */
+		for (irq = 0; irq <= 4; irq++)
+			BCMINIT(sb_clearirq)(sbh, irq);
+		BCMINIT(sb_setirq)(sbh, 0, SB_CODEC, 0);
+		BCMINIT(sb_setirq)(sbh, 0, SB_EXTIF, 0);
+		BCMINIT(sb_setirq)(sbh, 2, SB_ENET, 1);
+		BCMINIT(sb_setirq)(sbh, 3, SB_ILINE20, 0);
+		BCMINIT(sb_setirq)(sbh, 4, SB_PCI, 0);
+		ASSERT(eir);
+		value = BCMINIT(early_nvram_get)("et0phyaddr");
+		if (value && !strcmp(value, "31")) {
+			/* Enable internal UART */
+			W_REG(&eir->corecontrol, CC_UE);
+			/* Give USB its own interrupt */
+			BCMINIT(sb_setirq)(sbh, 1, SB_USB, 0);
+		} else {
+			/* Disable internal UART */
+			W_REG(&eir->corecontrol, 0);
+			/* Give Ethernet its own interrupt */
+			BCMINIT(sb_setirq)(sbh, 1, SB_ENET, 0);
+			BCMINIT(sb_setirq)(sbh, 0, SB_USB, 0);
+		}
+		break;
+	case BCM5350_DEVICE_ID:
+		/* Clear interrupt map */
+		for (irq = 0; irq <= 4; irq++)
+			BCMINIT(sb_clearirq)(sbh, irq);
+		BCMINIT(sb_setirq)(sbh, 0, SB_CC, 0);
+		BCMINIT(sb_setirq)(sbh, 1, SB_D11, 0);
+		BCMINIT(sb_setirq)(sbh, 2, SB_ENET, 0);
+		BCMINIT(sb_setirq)(sbh, 3, SB_PCI, 0);
+		BCMINIT(sb_setirq)(sbh, 4, SB_USB, 0);
+		break;
+	}
+}
+
+uint32
+BCMINITFN(sb_mips_clock)(sb_t *sbh)
+{
+	extifregs_t *eir;
+	chipcregs_t *cc;
+	uint32 n, m;
+	uint idx;
+	uint32 pll_type, rate = 0;
+
+	/* get index of the current core */
+	idx = sb_coreidx(sbh);
+	pll_type = PLL_TYPE1;
+
+	/* switch to extif or chipc core */
+	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
+		n = R_REG(&eir->clockcontrol_n);
+		m = R_REG(&eir->clockcontrol_sb);
+	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
+		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
+		n = R_REG(&cc->clockcontrol_n);
+		if ((pll_type == PLL_TYPE2) ||
+		    (pll_type == PLL_TYPE4) ||
+		    (pll_type == PLL_TYPE6) ||
+		    (pll_type == PLL_TYPE7))
+			m = R_REG(&cc->clockcontrol_mips);
+		else if (pll_type == PLL_TYPE5) {
+			rate = 200000000;
+			goto out;
+		}
+		else if (pll_type == PLL_TYPE3) {
+			if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID) { /* 5365 is also type3 */
+				rate = 200000000;
+				goto out;
+			} else
+				m = R_REG(&cc->clockcontrol_m2); /* 5350 uses m2 to control mips */
+		} else
+			m = R_REG(&cc->clockcontrol_sb);
+	} else
+		goto out;
+
+	// Added by Chen-I for 5365 
+	if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
+		rate = 100000000;
+	else
+		/* calculate rate */
+		rate = sb_clock_rate(pll_type, n, m);
+
+	if (pll_type == PLL_TYPE6)
+		rate = SB2MIPS_T6(rate);
+
+out:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return rate;
+}
+
+#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4)
+
+static void
+BCMINITFN(handler)(void)
+{
+	/* Step 11 */
+	__asm__ (
+		".set\tmips32\n\t"
+		"ssnop\n\t"
+		"ssnop\n\t"
+	/* Disable interrupts */
+	/*	MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~(ALLINTS | STO_IE)); */
+		"mfc0 $15, $12\n\t"
+	/* Just a Hack to not to use reg 'at' which was causing problems on 4704 A2 */
+		"li $14, -31746\n\t"
+		"and $15, $15, $14\n\t"
+		"mtc0 $15, $12\n\t"
+		"eret\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set\tmips0"
+	);
+}
+
+/* The following MUST come right after handler() */
+static void
+BCMINITFN(afterhandler)(void)
+{
+}
+
+/*
+ * Set the MIPS, backplane and PCI clocks as closely as possible.
+ */
+bool
+BCMINITFN(sb_mips_setclock)(sb_t *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock)
+{
+	extifregs_t *eir = NULL;
+	chipcregs_t *cc = NULL;
+	mipsregs_t *mipsr = NULL;
+	volatile uint32 *clockcontrol_n, *clockcontrol_sb, *clockcontrol_pci, *clockcontrol_m2;
+	uint32 orig_n, orig_sb, orig_pci, orig_m2, orig_mips, orig_ratio_parm, orig_ratio_cfg;
+	uint32 pll_type, sync_mode;
+	uint ic_size, ic_lsize;
+	uint idx, i;
+	typedef struct {
+		uint32 mipsclock;
+		uint16 n;
+		uint32 sb;
+		uint32 pci33;
+		uint32 pci25;
+	} n3m_table_t;
+	static n3m_table_t BCMINITDATA(type1_table)[] = {
+		{  96000000, 0x0303, 0x04020011, 0x11030011, 0x11050011 }, /*  96.000 32.000 24.000 */
+		{ 100000000, 0x0009, 0x04020011, 0x11030011, 0x11050011 }, /* 100.000 33.333 25.000 */
+		{ 104000000, 0x0802, 0x04020011, 0x11050009, 0x11090009 }, /* 104.000 31.200 24.960 */
+		{ 108000000, 0x0403, 0x04020011, 0x11050009, 0x02000802 }, /* 108.000 32.400 24.923 */
+		{ 112000000, 0x0205, 0x04020011, 0x11030021, 0x02000403 }, /* 112.000 32.000 24.889 */
+		{ 115200000, 0x0303, 0x04020009, 0x11030011, 0x11050011 }, /* 115.200 32.000 24.000 */
+		{ 120000000, 0x0011, 0x04020011, 0x11050011, 0x11090011 }, /* 120.000 30.000 24.000 */
+		{ 124800000, 0x0802, 0x04020009, 0x11050009, 0x11090009 }, /* 124.800 31.200 24.960 */
+		{ 128000000, 0x0305, 0x04020011, 0x11050011, 0x02000305 }, /* 128.000 32.000 24.000 */
+		{ 132000000, 0x0603, 0x04020011, 0x11050011, 0x02000305 }, /* 132.000 33.000 24.750 */
+		{ 136000000, 0x0c02, 0x04020011, 0x11090009, 0x02000603 }, /* 136.000 32.640 24.727 */
+		{ 140000000, 0x0021, 0x04020011, 0x11050021, 0x02000c02 }, /* 140.000 30.000 24.706 */
+		{ 144000000, 0x0405, 0x04020011, 0x01020202, 0x11090021 }, /* 144.000 30.857 24.686 */
+		{ 150857142, 0x0605, 0x04020021, 0x02000305, 0x02000605 }, /* 150.857 33.000 24.000 */
+		{ 152000000, 0x0e02, 0x04020011, 0x11050021, 0x02000e02 }, /* 152.000 32.571 24.000 */
+		{ 156000000, 0x0802, 0x04020005, 0x11050009, 0x11090009 }, /* 156.000 31.200 24.960 */
+		{ 160000000, 0x0309, 0x04020011, 0x11090011, 0x02000309 }, /* 160.000 32.000 24.000 */
+		{ 163200000, 0x0c02, 0x04020009, 0x11090009, 0x02000603 }, /* 163.200 32.640 24.727 */
+		{ 168000000, 0x0205, 0x04020005, 0x11030021, 0x02000403 }, /* 168.000 32.000 24.889 */
+		{ 176000000, 0x0602, 0x04020003, 0x11050005, 0x02000602 }, /* 176.000 33.000 24.000 */
+	};
+	typedef struct {
+		uint32 mipsclock;
+		uint16 n;
+		uint32 m2; /* that is the clockcontrol_m2 */
+	} type3_table_t;
+	static type3_table_t type3_table[] = { /* for 5350, mips clock is always double sb clock */
+		{ 150000000, 0x311, 0x4020005 },
+		{ 200000000, 0x311, 0x4020003 },
+	};
+	typedef struct {
+		uint32 mipsclock;
+		uint32 sbclock;
+		uint16 n;
+		uint32 sb;
+		uint32 pci33;
+		uint32 m2;
+		uint32 m3;
+		uint32 ratio_cfg;
+		uint32 ratio_parm;
+	} n4m_table_t;
+
+	static n4m_table_t BCMINITDATA(type2_table)[] = {
+		{ 180000000,  80000000, 0x0403, 0x01010000, 0x01020300, 0x01020600, 0x05000100,	 8, 0x012a00a9 },
+		{ 180000000,  90000000, 0x0403, 0x01000100, 0x01020300, 0x01000100, 0x05000100, 11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0x0303, 0x02010000, 0x02040001, 0x02010000, 0x06000001, 11, 0x0aaa0555 },
+		{ 211200000, 105600000, 0x0902, 0x01000200, 0x01030400, 0x01000200, 0x05000200, 11, 0x0aaa0555 },
+		{ 220800000, 110400000, 0x1500, 0x01000200, 0x01030400, 0x01000200, 0x05000200, 11, 0x0aaa0555 },
+		{ 230400000, 115200000, 0x0604, 0x01000200, 0x01020600, 0x01000200, 0x05000200, 11, 0x0aaa0555 },
+		{ 234000000, 104000000, 0x0b01, 0x01010000, 0x01010700, 0x01020600, 0x05000100,  8, 0x012a00a9 },
+		{ 240000000, 120000000,	0x0803,	0x01000200, 0x01020600,	0x01000200, 0x05000200, 11, 0x0aaa0555 },
+		{ 252000000, 126000000,	0x0504,	0x01000100, 0x01020500,	0x01000100, 0x05000100, 11, 0x0aaa0555 },
+		{ 264000000, 132000000, 0x0903, 0x01000200, 0x01020700, 0x01000200, 0x05000200, 11, 0x0aaa0555 },
+		{ 270000000, 120000000, 0x0703, 0x01010000, 0x01030400, 0x01020600, 0x05000100,  8, 0x012a00a9 },
+		{ 276000000, 122666666, 0x1500, 0x01010000, 0x01030400, 0x01020600, 0x05000100,  8, 0x012a00a9 },
+		{ 280000000, 140000000, 0x0503, 0x01000000, 0x01010600, 0x01000000, 0x05000000, 11, 0x0aaa0555 },
+		{ 288000000, 128000000, 0x0604, 0x01010000, 0x01030400, 0x01020600, 0x05000100,  8, 0x012a00a9 },
+		{ 288000000, 144000000, 0x0404, 0x01000000, 0x01010600, 0x01000000, 0x05000000, 11, 0x0aaa0555 },
+		{ 300000000, 133333333, 0x0803, 0x01010000, 0x01020600, 0x01020600, 0x05000100,  8, 0x012a00a9 },
+		{ 300000000, 150000000, 0x0803, 0x01000100, 0x01020600, 0x01000100, 0x05000100, 11, 0x0aaa0555 }
+	};
+
+	static n4m_table_t BCMINITDATA(type4_table)[] = {
+		{ 192000000,  96000000, 0x0702,	0x04000011, 0x11030011, 0x04000011, 0x04000003, 11, 0x0aaa0555 },
+		{ 198000000,  99000000, 0x0603,	0x11020005, 0x11030011, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0x0009,	0x04020011, 0x11030011, 0x04020011, 0x04020003, 11, 0x0aaa0555 },
+		{ 204000000, 102000000, 0x0c02, 0x11020005, 0x01030303, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 208000000, 104000000, 0x0802, 0x11030002, 0x11090005, 0x11030002, 0x04000003, 11, 0x0aaa0555 },
+		{ 210000000, 105000000, 0x0209, 0x11020005, 0x01030303, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 216000000, 108000000, 0x0111, 0x11020005, 0x01030303, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 224000000, 112000000, 0x0205, 0x11030002, 0x02002103, 0x11030002, 0x04000003, 11, 0x0aaa0555 },
+		{ 228000000, 101333333, 0x0e02, 0x11030003, 0x11210005, 0x01030305, 0x04000005,  8, 0x012a00a9 },
+		{ 228000000, 114000000, 0x0e02, 0x11020005, 0x11210005, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 240000000, 102857143,	0x0109,	0x04000021, 0x01050203,	0x11030021, 0x04000003, 13, 0x254a14a9 },
+		{ 240000000, 120000000,	0x0109,	0x11030002, 0x01050203,	0x11030002, 0x04000003, 11, 0x0aaa0555 },
+		{ 252000000, 100800000,	0x0203,	0x04000009, 0x11050005,	0x02000209, 0x04000002,  9, 0x02520129 },
+		{ 252000000, 126000000,	0x0203,	0x04000005, 0x11050005,	0x04000005, 0x04000002, 11, 0x0aaa0555 },
+		{ 264000000, 132000000, 0x0602, 0x04000005, 0x11050005, 0x04000005, 0x04000002, 11, 0x0aaa0555 },
+		{ 272000000, 116571428, 0x0c02, 0x04000021, 0x02000909, 0x02000221, 0x04000003, 13, 0x254a14a9 },
+		{ 280000000, 120000000, 0x0209, 0x04000021, 0x01030303, 0x02000221, 0x04000003, 13, 0x254a14a9 },
+		{ 288000000, 123428571, 0x0111, 0x04000021, 0x01030303, 0x02000221, 0x04000003, 13, 0x254a14a9 },
+		{ 300000000, 120000000, 0x0009, 0x04000009, 0x01030203, 0x02000902, 0x04000002,  9, 0x02520129 },
+		{ 300000000, 150000000, 0x0009, 0x04000005, 0x01030203, 0x04000005, 0x04000002, 11, 0x0aaa0555 }
+	};
+
+	static n4m_table_t BCMINITDATA(type7_table)[] = {
+		{ 183333333,  91666666, 0x0605,	0x04000011, 0x11030011, 0x04000011, 0x04000003, 11, 0x0aaa0555 },
+		{ 187500000,  93750000, 0x0a03,	0x04000011, 0x11030011, 0x04000011, 0x04000003, 11, 0x0aaa0555 },
+		{ 196875000,  98437500, 0x1003, 0x11020005, 0x11050011, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0x0311, 0x04000011, 0x11030011, 0x04000009, 0x04000003, 11, 0x0aaa0555 },
+		{ 200000000, 100000000, 0x0311, 0x04020011, 0x11030011, 0x04020011, 0x04020003, 11, 0x0aaa0555 },
+		{ 206250000, 103125000, 0x1103, 0x11020005, 0x11050011, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 212500000, 106250000,	0x0c05,	0x11020005, 0x01030303,	0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 215625000, 107812500,	0x1203,	0x11090009, 0x11050005,	0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 216666666, 108333333, 0x0805, 0x11020003, 0x11030011, 0x11020003, 0x04000003, 11, 0x0aaa0555 },
+		{ 225000000, 112500000, 0x0d03, 0x11020003, 0x11030011, 0x11020003, 0x04000003, 11, 0x0aaa0555 },
+		{ 233333333, 116666666, 0x0905, 0x11020003, 0x11030011, 0x11020003, 0x04000003, 11, 0x0aaa0555 },
+		{ 237500000, 118750000, 0x0e05, 0x11020005, 0x11210005, 0x11020005, 0x04000005, 11, 0x0aaa0555 },
+		{ 240000000, 120000000, 0x0b11, 0x11020009, 0x11210009, 0x11020009, 0x04000009, 11, 0x0aaa0555 },
+		{ 250000000, 125000000, 0x0f03, 0x11020003, 0x11210003, 0x11020003, 0x04000003, 11, 0x0aaa0555 }
+	};
+
+	ulong start, end, dst;
+	bool ret = FALSE;
+
+	/* get index of the current core */
+	idx = sb_coreidx(sbh);
+	clockcontrol_m2 = NULL;
+
+	/* switch to extif or chipc core */
+	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
+		pll_type = PLL_TYPE1;
+		clockcontrol_n = &eir->clockcontrol_n;
+		clockcontrol_sb = &eir->clockcontrol_sb;
+		clockcontrol_pci = &eir->clockcontrol_pci;
+		clockcontrol_m2 = &cc->clockcontrol_m2;
+	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
+		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
+		if (pll_type == PLL_TYPE6) {
+			clockcontrol_n = NULL;
+			clockcontrol_sb = NULL;
+			clockcontrol_pci = NULL;
+		} else {
+			clockcontrol_n = &cc->clockcontrol_n;
+			clockcontrol_sb = &cc->clockcontrol_sb;
+			clockcontrol_pci = &cc->clockcontrol_pci;
+			clockcontrol_m2 = &cc->clockcontrol_m2;
+		}
+	} else
+		goto done;
+
+	if (pll_type == PLL_TYPE6) {
+		/* Silence compilers */
+		orig_n = orig_sb = orig_pci = 0;
+	} else {
+		/* Store the current clock register values */
+		orig_n = R_REG(clockcontrol_n);
+		orig_sb = R_REG(clockcontrol_sb);
+		orig_pci = R_REG(clockcontrol_pci);
+	}
+
+	if (pll_type == PLL_TYPE1) {
+		/* Keep the current PCI clock if not specified */
+		if (pciclock == 0) {
+			pciclock = sb_clock_rate(pll_type, R_REG(clockcontrol_n), R_REG(clockcontrol_pci));
+			pciclock = (pciclock <= 25000000) ? 25000000 : 33000000;
+		}
+
+		/* Search for the closest MIPS clock less than or equal to a preferred value */
+		for (i = 0; i < ARRAYSIZE(BCMINIT(type1_table)); i++) {
+			ASSERT(BCMINIT(type1_table)[i].mipsclock ==
+			       sb_clock_rate(pll_type, BCMINIT(type1_table)[i].n, BCMINIT(type1_table)[i].sb));
+			if (BCMINIT(type1_table)[i].mipsclock > mipsclock)
+				break;
+		}
+		if (i == 0) {
+			ret = FALSE;
+			goto done;
+		} else {
+			ret = TRUE;
+			i--;
+		}
+		ASSERT(BCMINIT(type1_table)[i].mipsclock <= mipsclock);
+
+		/* No PLL change */
+		if ((orig_n == BCMINIT(type1_table)[i].n) &&
+		    (orig_sb == BCMINIT(type1_table)[i].sb) &&
+		    (orig_pci == BCMINIT(type1_table)[i].pci33))
+			goto done;
+
+		/* Set the PLL controls */
+		W_REG(clockcontrol_n, BCMINIT(type1_table)[i].n);
+		W_REG(clockcontrol_sb, BCMINIT(type1_table)[i].sb);
+		if (pciclock == 25000000)
+			W_REG(clockcontrol_pci, BCMINIT(type1_table)[i].pci25);
+		else
+			W_REG(clockcontrol_pci, BCMINIT(type1_table)[i].pci33);
+
+		/* Reset */
+		sb_watchdog(sbh, 1);
+
+		while (1);
+	} else if ((pll_type == PLL_TYPE3) &&
+		   (BCMINIT(sb_chip)(sbh) != BCM5365_DEVICE_ID)) {
+		/* 5350 */
+		/* Search for the closest MIPS clock less than or equal to a preferred value */
+
+		for (i = 0; i < ARRAYSIZE(type3_table); i++) {
+			if (type3_table[i].mipsclock > mipsclock)
+				break;
+		}
+		if (i == 0) {
+			ret = FALSE;
+			goto done;
+		} else {
+			ret = TRUE;
+			i--;
+		}
+		ASSERT(type3_table[i].mipsclock <= mipsclock);
+
+		/* No PLL change */
+		orig_m2 = R_REG(&cc->clockcontrol_m2);
+		if ((orig_n == type3_table[i].n) &&
+		    (orig_m2 == type3_table[i].m2)) {
+			goto done;
+		}
+
+		/* Set the PLL controls */
+		W_REG(clockcontrol_n, type3_table[i].n);
+		W_REG(clockcontrol_m2, type3_table[i].m2);
+
+		/* Reset */
+		sb_watchdog(sbh, 1);
+		while (1);
+	} else if ((pll_type == PLL_TYPE2) ||
+		   (pll_type == PLL_TYPE4) ||
+		   (pll_type == PLL_TYPE6) ||
+		   (pll_type == PLL_TYPE7)) {
+		n4m_table_t *table = NULL, *te;
+		uint tabsz = 0;
+
+		ASSERT(cc);
+
+		orig_mips = R_REG(&cc->clockcontrol_mips);
+
+		if (pll_type == PLL_TYPE6) {
+			uint32 new_mips = 0;
+
+			ret = TRUE;
+			if (mipsclock <= SB2MIPS_T6(CC_T6_M1))
+				new_mips = CC_T6_MMASK;
+
+			if (orig_mips == new_mips)
+				goto done;
+
+			W_REG(&cc->clockcontrol_mips, new_mips);
+			goto end_fill;
+		}
+
+		if (pll_type == PLL_TYPE2) {
+			table = BCMINIT(type2_table);
+			tabsz = ARRAYSIZE(BCMINIT(type2_table));
+		} else if (pll_type == PLL_TYPE4) {
+			table = BCMINIT(type4_table);
+			tabsz = ARRAYSIZE(BCMINIT(type4_table));
+		} else if (pll_type == PLL_TYPE7) {
+			table = BCMINIT(type7_table);
+			tabsz = ARRAYSIZE(BCMINIT(type7_table));
+		} else
+			ASSERT("No table for plltype" == NULL);
+
+		/* Store the current clock register values */
+		orig_m2 = R_REG(&cc->clockcontrol_m2);
+		orig_ratio_parm = 0;
+		orig_ratio_cfg = 0;
+
+		/* Look up current ratio */
+		for (i = 0; i < tabsz; i++) {
+			if ((orig_n == table[i].n) &&
+			    (orig_sb == table[i].sb) &&
+			    (orig_pci == table[i].pci33) &&
+			    (orig_m2 == table[i].m2) &&
+			    (orig_mips == table[i].m3)) {
+				orig_ratio_parm = table[i].ratio_parm;
+				orig_ratio_cfg = table[i].ratio_cfg;
+				break;
+			}
+		}
+
+		/* Search for the closest MIPS clock greater or equal to a preferred value */
+		for (i = 0; i < tabsz; i++) {
+			ASSERT(table[i].mipsclock ==
+			       sb_clock_rate(pll_type, table[i].n, table[i].m3));
+			if ((mipsclock <= table[i].mipsclock) &&
+			    ((sbclock == 0) || (sbclock <= table[i].sbclock)))
+				break;
+		}
+		if (i == tabsz) {
+			ret = FALSE;
+			goto done;
+		} else {
+			te = &table[i];
+			ret = TRUE;
+		}
+
+		/* No PLL change */
+		if ((orig_n == te->n) &&
+		    (orig_sb == te->sb) &&
+		    (orig_pci == te->pci33) &&
+		    (orig_m2 == te->m2) &&
+		    (orig_mips == te->m3))
+			goto done;
+
+		/* Set the PLL controls */
+		W_REG(clockcontrol_n, te->n);
+		W_REG(clockcontrol_sb, te->sb);
+		W_REG(clockcontrol_pci, te->pci33);
+		W_REG(&cc->clockcontrol_m2, te->m2);
+		W_REG(&cc->clockcontrol_mips, te->m3);
+
+		/* Set the chipcontrol bit to change mipsref to the backplane divider if needed */
+		if ((pll_type == PLL_TYPE7) &&
+		    (te->sb != te->m2) &&
+		    (sb_clock_rate(pll_type, te->n, te->m2) == 120000000))
+			W_REG(&cc->chipcontrol, R_REG(&cc->chipcontrol) | 0x100);
+
+		/* No ratio change */
+		if (orig_ratio_parm == te->ratio_parm)
+			goto end_fill;
+
+		icache_probe(MFC0(C0_CONFIG, 1), &ic_size, &ic_lsize);
+
+		/* Preload the code into the cache */
+		start = ((ulong) &&start_fill) & ~(ic_lsize - 1);
+		end = ((ulong) &&end_fill + (ic_lsize - 1)) & ~(ic_lsize - 1);
+		while (start < end) {
+			cache_op(start, Fill_I);
+			start += ic_lsize;
+		}
+
+		/* Copy the handler */
+		start = (ulong) &BCMINIT(handler);
+		end = (ulong) &BCMINIT(afterhandler);
+		dst = KSEG1ADDR(0x180);
+		for (i = 0; i < (end - start); i += 4)
+			*((ulong *)(dst + i)) = *((ulong *)(start + i));
+
+		/* Preload handler into the cache one line at a time */
+		for (i = 0; i < (end - start); i += 4)
+			cache_op(dst + i, Fill_I);
+
+		/* Clear BEV bit */
+		MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) & ~ST0_BEV);
+
+		/* Enable interrupts */
+		MTC0(C0_STATUS, 0, MFC0(C0_STATUS, 0) | (ALLINTS | ST0_IE));
+
+		/* Enable MIPS timer interrupt */
+		if (!(mipsr = sb_setcore(sbh, SB_MIPS, 0)) &&
+		    !(mipsr = sb_setcore(sbh, SB_MIPS33, 0)))
+			ASSERT(mipsr);
+		W_REG(&mipsr->intmask, 1);
+
+	start_fill:
+		/* step 1, set clock ratios */
+		MTC0(C0_BROADCOM, 3, te->ratio_parm);
+		MTC0(C0_BROADCOM, 1, te->ratio_cfg);
+
+		/* step 2: program timer intr */
+		W_REG(&mipsr->timer, 100);
+		(void) R_REG(&mipsr->timer);
+
+		/* step 3, switch to async */
+		sync_mode = MFC0(C0_BROADCOM, 4);
+		MTC0(C0_BROADCOM, 4, 1 << 22);
+
+		/* step 4, set cfg active */
+		MTC0(C0_BROADCOM, 2, 0x9);
+
+
+		/* steps 5 & 6 */
+		__asm__ __volatile__ (
+			".set\tmips3\n\t"
+			"wait\n\t"
+			".set\tmips0"
+		);
+
+		/* step 7, clear cfg_active */
+		MTC0(C0_BROADCOM, 2, 0);
+
+		/* Additional Step: set back to orig sync mode */
+		MTC0(C0_BROADCOM, 4, sync_mode);
+
+		/* step 8, fake soft reset */
+		MTC0(C0_BROADCOM, 5, MFC0(C0_BROADCOM, 5) | 4);
+
+	end_fill:
+		/* step 9 set watchdog timer */
+		sb_watchdog(sbh, 20);
+		(void) R_REG(&cc->chipid);
+
+		/* step 11 */
+		__asm__ __volatile__ (
+			".set\tmips3\n\t"
+			"sync\n\t"
+			"wait\n\t"
+			".set\tmips0"
+		);
+		while (1);
+	}
+
+done:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
+/*
+ *  This also must be run from the cache on 47xx
+ *  so there are no mips core BIU ops in progress
+ *  when the PFC is enabled.
+ */
+
+static void
+BCMINITFN(_enable_pfc)(uint32 mode)
+{
+	/* write range */
+	*(volatile uint32 *)PFC_CR1 = 0xffff0000;
+
+	/* enable */
+	*(volatile uint32 *)PFC_CR0 = mode;
+}
+
+void
+BCMINITFN(enable_pfc)(uint32 mode)
+{
+	ulong start, end;
+	int i;
+
+	/* If auto then choose the correct mode for this
+	   platform, currently we only ever select one mode */
+	if (mode == PFC_AUTO)
+		mode = PFC_INST;
+
+	/* enable prefetch cache if available */
+	if (MFC0(C0_BROADCOM, 0) & BRCM_PFC_AVAIL) {
+		start = (ulong) &BCMINIT(_enable_pfc);
+		end = (ulong) &BCMINIT(enable_pfc);
+
+		/* Preload handler into the cache one line at a time */
+		for (i = 0; i < (end - start); i += 4)
+			cache_op(start + i, Fill_I);
+
+		BCMINIT(_enable_pfc)(mode);
+	}
+}
+
+/* returns the ncdl value to be programmed into sdram_ncdl for calibration */
+uint32
+BCMINITFN(sb_memc_get_ncdl)(sb_t *sbh)
+{
+	sbmemcregs_t *memc;
+	uint32 ret = 0;
+	uint32 config, rd, wr, misc, dqsg, cd, sm, sd;
+	uint idx, rev;
+
+	idx = sb_coreidx(sbh);
+
+	memc = (sbmemcregs_t *)sb_setcore(sbh, SB_MEMC, 0);
+	if (memc == 0)
+		goto out;
+
+	rev = sb_corerev(sbh);
+
+	config = R_REG(&memc->config);
+	wr = R_REG(&memc->wrncdlcor);
+	rd = R_REG(&memc->rdncdlcor);
+	misc = R_REG(&memc->miscdlyctl);
+	dqsg = R_REG(&memc->dqsgatencdl);
+
+	rd &= MEMC_RDNCDLCOR_RD_MASK;
+	wr &= MEMC_WRNCDLCOR_WR_MASK;
+	dqsg &= MEMC_DQSGATENCDL_G_MASK;
+
+	if (config & MEMC_CONFIG_DDR) {
+		ret = (wr << 16) | (rd << 8) | dqsg;
+	} else {
+		if (rev > 0)
+			cd = rd;
+		else
+			cd = (rd == MEMC_CD_THRESHOLD) ? rd : (wr + MEMC_CD_THRESHOLD);
+		sm = (misc & MEMC_MISC_SM_MASK) >> MEMC_MISC_SM_SHIFT;
+		sd = (misc & MEMC_MISC_SD_MASK) >> MEMC_MISC_SD_SHIFT;
+		ret = (sm << 16) | (sd << 8) | cd;
+	}
+
+out:
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	return ret;
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/sbpci.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbpci.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/sbpci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbpci.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,534 @@
+/*
+ * Low-Level PCI and SB support for BCM47xx
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <pcicfg.h>
+#include <bcmdevs.h>
+#include <sbconfig.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <sbpci.h>
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <bcmnvram.h>
+#include <hndmips.h>
+
+/* Can free sbpci_init() memory after boot */
+#ifndef linux
+#define __init
+#endif
+
+/* Emulated configuration space */
+static pci_config_regs sb_config_regs[SB_MAXCORES];
+
+/* Banned cores */
+static uint16 pci_ban[32] = { 0 };
+static uint pci_banned = 0;
+
+/* CardBus mode */
+static bool cardbus = FALSE;
+
+/* Disable PCI host core */
+static bool pci_disabled = FALSE;
+
+/*
+ * Functions for accessing external PCI configuration space
+ */
+
+/* Assume one-hot slot wiring */
+#define PCI_SLOT_MAX 16
+
+static uint32
+config_cmd(sb_t *sbh, uint bus, uint dev, uint func, uint off)
+{
+	uint coreidx;
+	sbpciregs_t *regs;
+	uint32 addr = 0;
+
+	/* CardBusMode supports only one device */
+	if (cardbus && dev > 1)
+		return 0;
+
+	coreidx = sb_coreidx(sbh);
+	regs = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0);
+
+	/* Type 0 transaction */
+	if (bus == 1) {
+		/* Skip unwired slots */
+		if (dev < PCI_SLOT_MAX) {
+			/* Slide the PCI window to the appropriate slot */
+			W_REG(&regs->sbtopci1, SBTOPCI_CFG0 | ((1 << (dev + 16)) & SBTOPCI1_MASK));
+			addr = SB_PCI_CFG | ((1 << (dev + 16)) & ~SBTOPCI1_MASK) |
+				(func << 8) | (off & ~3);
+		}
+	}
+
+	/* Type 1 transaction */
+	else {
+		W_REG(&regs->sbtopci1, SBTOPCI_CFG1);
+		addr = SB_PCI_CFG | (bus << 16) | (dev << 11) | (func << 8) | (off & ~3);
+	}
+
+	sb_setcoreidx(sbh, coreidx);
+
+	return addr;
+}
+
+static int
+extpci_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	uint32 addr, *reg = NULL, val;
+	int ret = 0;
+
+	if (pci_disabled ||
+	    !(addr = config_cmd(sbh, bus, dev, func, off)) ||
+	    !(reg = (uint32 *) REG_MAP(addr, len)) ||
+	    BUSPROBE(val, reg))
+		val = 0xffffffff;
+
+	val >>= 8 * (off & 3);
+	if (len == 4)
+		*((uint32 *) buf) = val;
+	else if (len == 2)
+		*((uint16 *) buf) = (uint16) val;
+	else if (len == 1)
+		*((uint8 *) buf) = (uint8) val;
+	else
+		ret = -1;
+
+	if (reg)
+		REG_UNMAP(reg);
+
+	return ret;
+}
+
+static int
+extpci_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	uint32 addr, *reg = NULL, val;
+	int ret = 0;
+
+	if (pci_disabled ||
+	    !(addr = config_cmd(sbh, bus, dev, func, off)) ||
+	    !(reg = (uint32 *) REG_MAP(addr, len)) ||
+	    BUSPROBE(val, reg))
+		goto done;
+
+	if (len == 4)
+		val = *((uint32 *) buf);
+	else if (len == 2) {
+		val &= ~(0xffff << (8 * (off & 3)));
+		val |= *((uint16 *) buf) << (8 * (off & 3));
+	} else if (len == 1) {
+		val &= ~(0xff << (8 * (off & 3)));
+		val |= *((uint8 *) buf) << (8 * (off & 3));
+	} else
+		ret = -1;
+
+	W_REG(reg, val);
+
+ done:
+	if (reg)
+		REG_UNMAP(reg);
+
+	return ret;
+}
+
+/*
+ * Functions for accessing translated SB configuration space
+ */
+
+static int
+sb_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	pci_config_regs *cfg;
+
+	if (dev >= SB_MAXCORES || (off + len) > sizeof(pci_config_regs))
+		return -1;
+	cfg = &sb_config_regs[dev];
+
+	ASSERT(ISALIGNED(off, len));
+	ASSERT(ISALIGNED((uintptr)buf, len));
+
+	if (len == 4)
+		*((uint32 *) buf) = ltoh32(*((uint32 *)((ulong) cfg + off)));
+	else if (len == 2)
+		*((uint16 *) buf) = ltoh16(*((uint16 *)((ulong) cfg + off)));
+	else if (len == 1)
+		*((uint8 *) buf) = *((uint8 *)((ulong) cfg + off));
+	else
+		return -1;
+
+	return 0;
+}
+
+static int
+sb_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	uint coreidx, n;
+	void *regs;
+	sbconfig_t *sb;
+	pci_config_regs *cfg;
+
+	if (dev >= SB_MAXCORES || (off + len) > sizeof(pci_config_regs))
+		return -1;
+	cfg = &sb_config_regs[dev];
+
+	ASSERT(ISALIGNED(off, len));
+	ASSERT(ISALIGNED((uintptr)buf, len));
+
+	/* Emulate BAR sizing */
+	if (off >= OFFSETOF(pci_config_regs, base[0]) && off <= OFFSETOF(pci_config_regs, base[3]) &&
+	    len == 4 && *((uint32 *) buf) == ~0) {
+		coreidx = sb_coreidx(sbh);
+		if ((regs = sb_setcoreidx(sbh, dev))) {
+			sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+			/* Highest numbered address match register */
+			n = (R_REG(&sb->sbidlow) & SBIDL_AR_MASK) >> SBIDL_AR_SHIFT;
+			if (off == OFFSETOF(pci_config_regs, base[0]))
+				cfg->base[0] = ~(sb_size(R_REG(&sb->sbadmatch0)) - 1);
+#if 0
+			else if (off == OFFSETOF(pci_config_regs, base[1]) && n >= 1)
+				cfg->base[1] = ~(sb_size(R_REG(&sb->sbadmatch1)) - 1);
+			else if (off == OFFSETOF(pci_config_regs, base[2]) && n >= 2)
+				cfg->base[2] = ~(sb_size(R_REG(&sb->sbadmatch2)) - 1);
+			else if (off == OFFSETOF(pci_config_regs, base[3]) && n >= 3)
+				cfg->base[3] = ~(sb_size(R_REG(&sb->sbadmatch3)) - 1);
+#endif
+		}
+		sb_setcoreidx(sbh, coreidx);
+		return 0;
+	}
+
+	if (len == 4)
+		*((uint32 *)((ulong) cfg + off)) = htol32(*((uint32 *) buf));
+	else if (len == 2)
+		*((uint16 *)((ulong) cfg + off)) = htol16(*((uint16 *) buf));
+	else if (len == 1)
+		*((uint8 *)((ulong) cfg + off)) = *((uint8 *) buf);
+	else
+		return -1;
+
+	return 0;
+}
+
+int
+sbpci_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	if (bus == 0)
+		return sb_read_config(sbh, bus, dev, func, off, buf, len);
+	else
+		return extpci_read_config(sbh, bus, dev, func, off, buf, len);
+}
+
+int
+sbpci_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len)
+{
+	if (bus == 0)
+		return sb_write_config(sbh, bus, dev, func, off, buf, len);
+	else
+		return extpci_write_config(sbh, bus, dev, func, off, buf, len);
+}
+
+void
+sbpci_ban(uint16 core)
+{
+	if (pci_banned < ARRAYSIZE(pci_ban))
+		pci_ban[pci_banned++] = core;
+}
+
+static int
+sbpci_init_pci(sb_t *sbh)
+{
+	uint chip, chiprev, chippkg, host;
+	uint32 boardflags;
+	sbpciregs_t *pci;
+	sbconfig_t *sb;
+	uint32 val;
+
+	chip = sb_chip(sbh);
+	chiprev = sb_chiprev(sbh);
+	chippkg = sb_chippkg(sbh);
+
+	if (!(pci = (sbpciregs_t *) sb_setcore(sbh, SB_PCI, 0))) {
+		printf("PCI: no core\n");
+		pci_disabled = TRUE;
+		return -1;
+	}
+	sb_core_reset(sbh, 0);
+
+	boardflags = (uint32) getintvar(NULL, "boardflags");
+
+	if ((chip == BCM4310_DEVICE_ID) && (chiprev == 0))
+		pci_disabled = TRUE;
+
+	/*
+	 * The 200-pin BCM4712 package does not bond out PCI. Even when
+	 * PCI is bonded out, some boards may leave the pins
+	 * floating.
+	 */
+	if (((chip == BCM4712_DEVICE_ID) &&
+	     ((chippkg == BCM4712SMALL_PKG_ID) ||
+	      (chippkg == BCM4712MID_PKG_ID))) ||
+		(chip == BCM5350_DEVICE_ID) ||
+	    (boardflags & BFL_NOPCI))
+		pci_disabled = TRUE;
+
+	/*
+	 * If the PCI core should not be touched (disabled, not bonded
+	 * out, or pins floating), do not even attempt to access core
+	 * registers. Otherwise, try to determine if it is in host
+	 * mode.
+	 */
+	if (pci_disabled)
+		host = 0;
+	else
+		host = !BUSPROBE(val, &pci->control);
+
+	if (!host) {
+		/* Disable PCI interrupts in client mode */
+		sb = (sbconfig_t *)((ulong) pci + SBCONFIGOFF);
+		W_REG(&sb->sbintvec, 0);
+
+		/* Disable the PCI bridge in client mode */
+		sbpci_ban(SB_PCI);
+		printf("PCI: Disabled\n");
+	} else {
+		/* Reset the external PCI bus and enable the clock */
+		W_REG(&pci->control, 0x5);		/* enable the tristate drivers */
+		W_REG(&pci->control, 0xd);		/* enable the PCI clock */
+		OSL_DELAY(150);				/* delay > 100 us */
+		W_REG(&pci->control, 0xf);		/* deassert PCI reset */
+		W_REG(&pci->arbcontrol, PCI_INT_ARB);	/* use internal arbiter */
+		OSL_DELAY(1);				/* delay 1 us */
+
+		/* Enable CardBusMode */
+		cardbus = nvram_match("cardbus", "1");
+		if (cardbus) {
+			printf("PCI: Enabling CardBus\n");
+			/* GPIO 1 resets the CardBus device on bcm94710ap */
+			sb_gpioout(sbh, 1, 1, GPIO_DRV_PRIORITY);
+			sb_gpioouten(sbh, 1, 1, GPIO_DRV_PRIORITY);
+			W_REG(&pci->sprom[0], R_REG(&pci->sprom[0]) | 0x400);
+		}
+
+		/* 64 MB I/O access window */
+		W_REG(&pci->sbtopci0, SBTOPCI_IO);
+		/* 64 MB configuration access window */
+		W_REG(&pci->sbtopci1, SBTOPCI_CFG0);
+		/* 1 GB memory access window */
+		W_REG(&pci->sbtopci2, SBTOPCI_MEM | SB_PCI_DMA);
+
+		/* Enable PCI bridge BAR0 prefetch and burst */
+		val = 6;
+		sbpci_write_config(sbh, 1, 0, 0, PCI_CFG_CMD, &val, sizeof(val));
+
+		/* Enable PCI interrupts */
+		W_REG(&pci->intmask, PCI_INTA);
+	}
+	
+	return 0;
+}
+
+static int
+sbpci_init_cores(sb_t *sbh)
+{
+	uint chip, chiprev, chippkg, coreidx, i;
+	sbconfig_t *sb;
+	pci_config_regs *cfg;
+	void *regs;
+	char varname[8];
+	uint wlidx = 0;
+	uint16 vendor, core;
+	uint8 class, subclass, progif;
+	uint32 val;
+	uint32 sbips_int_mask[] = { 0, SBIPS_INT1_MASK, SBIPS_INT2_MASK, SBIPS_INT3_MASK, SBIPS_INT4_MASK };
+	uint32 sbips_int_shift[] = { 0, 0, SBIPS_INT2_SHIFT, SBIPS_INT3_SHIFT, SBIPS_INT4_SHIFT };
+
+	chip = sb_chip(sbh);
+	chiprev = sb_chiprev(sbh);
+	chippkg = sb_chippkg(sbh);
+	coreidx = sb_coreidx(sbh);
+
+	/* Scan the SB bus */
+	bzero(sb_config_regs, sizeof(sb_config_regs));
+	for (cfg = sb_config_regs; cfg < &sb_config_regs[SB_MAXCORES]; cfg++) {
+		cfg->vendor = 0xffff;
+		if (!(regs = sb_setcoreidx(sbh, cfg - sb_config_regs)))
+			continue;
+		sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+
+		/* Read ID register and parse vendor and core */
+		val = R_REG(&sb->sbidhigh);
+		vendor = (val & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT;
+		core = (val & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT;
+		progif = 0;
+
+		/* Check if this core is banned */
+		for (i = 0; i < pci_banned; i++)
+			if (core == pci_ban[i])
+				break;
+		if (i < pci_banned)
+			continue;
+
+		/* Known vendor translations */
+		switch (vendor) {
+		case SB_VEND_BCM:
+			vendor = VENDOR_BROADCOM;
+			break;
+		}
+
+		/* Determine class based on known core codes */
+		switch (core) {
+		case SB_ILINE20:
+			class = PCI_CLASS_NET;
+			subclass = PCI_NET_ETHER;
+			core = BCM47XX_ILINE_ID;
+			break;
+		case SB_ILINE100:
+			class = PCI_CLASS_NET;
+			subclass = PCI_NET_ETHER;
+			core = BCM4610_ILINE_ID;
+			break;
+		case SB_ENET:
+			class = PCI_CLASS_NET;
+			subclass = PCI_NET_ETHER;
+			core = BCM47XX_ENET_ID;
+			break;
+		case SB_SDRAM:
+		case SB_MEMC:
+			class = PCI_CLASS_MEMORY;
+			subclass = PCI_MEMORY_RAM;
+			break;
+		case SB_PCI:
+#if 0
+			class = PCI_CLASS_BRIDGE;
+			subclass = PCI_BRIDGE_PCI;
+			break;
+#endif
+		case SB_MIPS:
+		case SB_MIPS33:
+			class = PCI_CLASS_CPU;
+			subclass = PCI_CPU_MIPS;
+			break;
+		case SB_CODEC:
+			class = PCI_CLASS_COMM;
+			subclass = PCI_COMM_MODEM;
+			core = BCM47XX_V90_ID;
+			break;
+		case SB_USB:
+			class = PCI_CLASS_SERIAL;
+			subclass = PCI_SERIAL_USB;
+			progif = 0x10; /* OHCI */
+			core = BCM47XX_USB_ID;
+			break;
+		case SB_USB11H:
+			class = PCI_CLASS_SERIAL;
+			subclass = PCI_SERIAL_USB;
+			progif = 0x10; /* OHCI */
+			core = BCM47XX_USBH_ID;
+			break;
+		case SB_USB11D:
+			class = PCI_CLASS_SERIAL;
+			subclass = PCI_SERIAL_USB;
+			core = BCM47XX_USBD_ID;
+			break;
+		case SB_IPSEC:
+			class = PCI_CLASS_CRYPT;
+			subclass = PCI_CRYPT_NETWORK;
+			core = BCM47XX_IPSEC_ID;
+			break;
+		case SB_ROBO:
+			class = PCI_CLASS_NET;
+			subclass = PCI_NET_OTHER;
+			core = BCM47XX_ROBO_ID;
+			break;
+		case SB_EXTIF:
+		case SB_CC:
+			class = PCI_CLASS_MEMORY;
+			subclass = PCI_MEMORY_FLASH;
+			break;
+		case SB_D11:
+			class = PCI_CLASS_NET;
+			subclass = PCI_NET_OTHER;
+			/* Let an nvram variable override this */
+			sprintf(varname, "wl%did", wlidx);
+			wlidx++;
+			if ((core = getintvar(NULL, varname)) == 0) {
+				if (chip == BCM4712_DEVICE_ID) {
+					if (chippkg == BCM4712SMALL_PKG_ID)
+						core = BCM4306_D11G_ID;
+					else
+						core = BCM4306_D11DUAL_ID;
+				} else {
+					/* 4310 */
+					core = BCM4310_D11B_ID;
+				}
+			}
+			break;
+
+		default:
+			class = subclass = progif = 0xff;
+			break;
+		}
+
+		/* Supported translations */
+		cfg->vendor = htol16(vendor);
+		cfg->device = htol16(core);
+		cfg->rev_id = chiprev;
+		cfg->prog_if = progif;
+		cfg->sub_class = subclass;
+		cfg->base_class = class;
+		cfg->base[0] = htol32(sb_base(R_REG(&sb->sbadmatch0)));
+		cfg->base[1] = 0;//htol32(sb_base(R_REG(&sb->sbadmatch1)));
+		cfg->base[2] = 0;//htol32(sb_base(R_REG(&sb->sbadmatch2)));
+		cfg->base[3] = 0;//htol32(sb_base(R_REG(&sb->sbadmatch3)));
+		cfg->base[4] = 0;
+		cfg->base[5] = 0;
+		if (class == PCI_CLASS_BRIDGE && subclass == PCI_BRIDGE_PCI)
+			cfg->header_type = PCI_HEADER_BRIDGE;
+		else
+			cfg->header_type = PCI_HEADER_NORMAL;
+		/* Save core interrupt flag */
+		cfg->int_pin = R_REG(&sb->sbtpsflag) & SBTPS_NUM0_MASK;
+		/* Default to MIPS shared interrupt 0 */
+		cfg->int_line = 0;
+		/* MIPS sbipsflag maps core interrupt flags to interrupts 1 through 4 */
+		if ((regs = sb_setcore(sbh, SB_MIPS, 0)) ||
+		    (regs = sb_setcore(sbh, SB_MIPS33, 0))) {
+			sb = (sbconfig_t *)((ulong) regs + SBCONFIGOFF);
+			val = R_REG(&sb->sbipsflag);
+			for (cfg->int_line = 1; cfg->int_line <= 4; cfg->int_line++) {
+				if (((val & sbips_int_mask[cfg->int_line]) >> sbips_int_shift[cfg->int_line]) == cfg->int_pin)
+					break;
+			}
+			if (cfg->int_line > 4)
+				cfg->int_line = 0;
+		}
+		/* Emulated core */
+		*((uint32 *) &cfg->sprom_control) = 0xffffffff;
+	}
+
+	sb_setcoreidx(sbh, coreidx);
+	return 0;
+}
+
+int __init
+sbpci_init(sb_t *sbh)
+{
+	sbpci_init_pci(sbh);
+	sbpci_init_cores(sbh);
+	return 0;
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/sbutils.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbutils.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/sbutils.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sbutils.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,2370 @@
+/*
+ * Misc utility routines for accessing chip-specific features
+ * of the SiliconBackplane-based Broadcom chips.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <sbpci.h>
+#include <pcicfg.h>
+#include <sbextif.h>
+#include <bcmsrom.h>
+
+/* debug/trace */
+#define	SB_ERROR(args)
+
+
+typedef uint32 (*sb_intrsoff_t)(void *intr_arg);
+typedef void (*sb_intrsrestore_t)(void *intr_arg, uint32 arg);
+typedef bool (*sb_intrsenabled_t)(void *intr_arg);
+
+/* misc sb info needed by some of the routines */
+typedef struct sb_info {
+
+	struct sb_pub  	sb;			/* back plane public state(must be first field of sb_info */
+
+	void	*osh;			/* osl os handle */
+	void	*sdh;			/* bcmsdh handle */
+
+	void	*curmap;		/* current regs va */
+	void	*regs[SB_MAXCORES];	/* other regs va */
+
+	uint	curidx;			/* current core index */
+	uint	dev_coreid;		/* the core provides driver functions */
+
+	uint	gpioidx;		/* gpio control core index */
+	uint	gpioid;			/* gpio control coretype */
+
+	uint	numcores;		/* # discovered cores */
+	uint	coreid[SB_MAXCORES];	/* id of each core */
+
+	void	*intr_arg;		/* interrupt callback function arg */
+	sb_intrsoff_t		intrsoff_fn;		/* function turns chip interrupts off */
+	sb_intrsrestore_t	intrsrestore_fn;	/* function restore chip interrupts */
+	sb_intrsenabled_t	intrsenabled_fn;	/* function to check if chip interrupts are enabled */
+
+} sb_info_t;
+
+/* local prototypes */
+static sb_info_t * BCMINIT(sb_doattach)(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+	uint bustype, void *sdh, char **vars, int *varsz);
+static void BCMINIT(sb_scan)(sb_info_t *si);
+static uint sb_corereg(sb_info_t *si, uint coreidx, uint regoff, uint mask, uint val);
+static uint _sb_coreidx(sb_info_t *si);
+static uint sb_findcoreidx(sb_info_t *si, uint coreid, uint coreunit);
+static uint BCMINIT(sb_pcidev2chip)(uint pcidev);
+static uint BCMINIT(sb_chip2numcores)(uint chip);
+static int sb_pci_fixcfg(sb_info_t *si);
+
+/* delay needed between the mdio control/ mdiodata register data access */
+#define PR28829_DELAY() OSL_DELAY(10)
+
+
+/* global variable to indicate reservation/release of gpio's*/
+static uint32 sb_gpioreservation = 0;
+
+#define	SB_INFO(sbh)	(sb_info_t*)sbh
+#define	SET_SBREG(sbh, r, mask, val)	W_SBREG((sbh), (r), ((R_SBREG((sbh), (r)) & ~(mask)) | (val)))
+#define	GOODCOREADDR(x)	(((x) >= SB_ENUM_BASE) && ((x) <= SB_ENUM_LIM) && ISALIGNED((x), SB_CORE_SIZE))
+#define	GOODREGS(regs)	((regs) && ISALIGNED((uintptr)(regs), SB_CORE_SIZE))
+#define	REGS2SB(va)	(sbconfig_t*) ((int8*)(va) + SBCONFIGOFF)
+#define	GOODIDX(idx)	(((uint)idx) < SB_MAXCORES)
+#define	BADIDX		(SB_MAXCORES+1)
+#define	NOREV		-1
+
+#define PCI(si)		((BUSTYPE(si->sb.bustype) == PCI_BUS) && (si->sb.buscoretype == SB_PCI)) 
+
+/* sonicsrev */
+#define	SONICS_2_2	(SBIDL_RV_2_2 >> SBIDL_RV_SHIFT)
+#define	SONICS_2_3	(SBIDL_RV_2_3 >> SBIDL_RV_SHIFT)
+
+#define	R_SBREG(sbh, sbr)	sb_read_sbreg((sbh), (sbr))
+#define	W_SBREG(sbh, sbr, v)	sb_write_sbreg((sbh), (sbr), (v))
+#define	AND_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) & (v)))
+#define	OR_SBREG(sbh, sbr, v)	W_SBREG((sbh), (sbr), (R_SBREG((sbh), (sbr)) | (v)))
+
+/*
+ * Macros to disable/restore function core(D11, ENET, ILINE20, etc) interrupts before/
+ * after core switching to avoid invalid register accesss inside ISR.
+ */
+#define INTR_OFF(si, intr_val) \
+	if ((si)->intrsoff_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		intr_val = (*(si)->intrsoff_fn)((si)->intr_arg); }
+#define INTR_RESTORE(si, intr_val) \
+	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
+
+/* dynamic clock control defines */
+#define	LPOMINFREQ	25000			/* low power oscillator min */
+#define	LPOMAXFREQ	43000			/* low power oscillator max */
+#define	XTALMINFREQ	19800000		/* 20 MHz - 1% */
+#define	XTALMAXFREQ	20200000		/* 20 MHz + 1% */
+#define	PCIMINFREQ	25000000		/* 25 MHz */
+#define	PCIMAXFREQ	34000000		/* 33 MHz + fudge */
+
+#define	ILP_DIV_5MHZ	0			/* ILP = 5 MHz */
+#define	ILP_DIV_1MHZ	4			/* ILP = 1 MHz */
+
+#define MIN_DUMPBUFLEN  32	/* debug */
+
+/* GPIO Based LED powersave defines */
+#define DEFAULT_GPIO_ONTIME	10
+#define DEFAULT_GPIO_OFFTIME	90
+
+#define DEFAULT_GPIOTIMERVAL  ((DEFAULT_GPIO_ONTIME << GPIO_ONTIME_SHIFT) | DEFAULT_GPIO_OFFTIME)
+
+static uint32
+sb_read_sbreg(sb_info_t *si, volatile uint32 *sbr)
+{
+	uint32 val = R_REG(sbr);
+
+	return (val);
+}
+
+static void
+sb_write_sbreg(sb_info_t *si, volatile uint32 *sbr, uint32 v)
+{
+	W_REG(sbr, v);
+}
+
+/* Using sb_kattach depends on SB_BUS support, either implicit  */
+/* no limiting BCMBUSTYPE value) or explicit (value is SB_BUS). */
+#if !defined(BCMBUSTYPE) || (BCMBUSTYPE == SB_BUS)
+
+/* global kernel resource */
+static sb_info_t ksi;
+
+/* generic kernel variant of sb_attach() */
+sb_t * 
+BCMINITFN(sb_kattach)()
+{
+	uint32 *regs;
+
+	if (ksi.curmap == NULL) {
+		uint32 cid;
+
+		regs = (uint32 *)REG_MAP(SB_ENUM_BASE, SB_CORE_SIZE);
+		cid = R_REG((uint32 *)regs);
+		if (((cid & CID_ID_MASK) == BCM4712_DEVICE_ID) &&
+		    ((cid & CID_PKG_MASK) != BCM4712LARGE_PKG_ID) &&
+		    ((cid & CID_REV_MASK) <= (3 << CID_REV_SHIFT))) {
+			uint32 *scc, val;
+
+			scc = (uint32 *)((uchar*)regs + OFFSETOF(chipcregs_t, slow_clk_ctl));
+			val = R_REG(scc);
+			SB_ERROR(("    initial scc = 0x%x\n", val));
+			val |= SCC_SS_XTAL;
+			W_REG(scc, val);
+		}
+
+		if (BCMINIT(sb_doattach)(&ksi, BCM4710_DEVICE_ID, NULL, (void*)regs,
+			SB_BUS, NULL, NULL, NULL) == NULL) {
+			return NULL;
+		}
+	}
+
+	return (sb_t *)&ksi;
+}
+#endif
+
+static sb_info_t  * 
+BCMINITFN(sb_doattach)(sb_info_t *si, uint devid, osl_t *osh, void *regs,
+	uint bustype, void *sdh, char **vars, int *varsz)
+{
+	uint origidx;
+	chipcregs_t *cc;
+	sbconfig_t *sb;
+	uint32 w;
+
+	ASSERT(GOODREGS(regs));
+
+	bzero((uchar*)si, sizeof (sb_info_t));
+
+	si->sb.buscoreidx = si->gpioidx = BADIDX;
+
+	si->osh = osh;
+	si->curmap = regs;
+	si->sdh = sdh;
+
+	/* check to see if we are a sb core mimic'ing a pci core */
+	if (bustype == PCI_BUS) {
+		if (OSL_PCI_READ_CONFIG(osh, PCI_SPROM_CONTROL, sizeof (uint32)) == 0xffffffff)
+			bustype = SB_BUS;
+		else
+			bustype = PCI_BUS;
+	}
+
+	si->sb.bustype = bustype;
+	if (si->sb.bustype != BUSTYPE(si->sb.bustype)) {
+		SB_ERROR(("sb_doattach: bus type %d does not match configured bus type %d\n",
+			  si->sb.bustype, BUSTYPE(si->sb.bustype)));
+		return NULL;
+	}
+
+	/* kludge to enable the clock on the 4306 which lacks a slowclock */
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS)
+		sb_clkctl_xtal(&si->sb, XTAL|PLL, ON);
+
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		w = OSL_PCI_READ_CONFIG(osh, PCI_BAR0_WIN, sizeof (uint32));
+		if (!GOODCOREADDR(w))
+			OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, sizeof (uint32), SB_ENUM_BASE);
+	}
+
+	/* initialize current core index value */
+	si->curidx = _sb_coreidx(si);
+
+	if (si->curidx == BADIDX) {
+		SB_ERROR(("sb_doattach: bad core index\n"));
+		return NULL;
+	}
+
+	/* get sonics backplane revision */
+	sb = REGS2SB(si->curmap);
+	si->sb.sonicsrev = (R_SBREG(si, &(sb)->sbidlow) & SBIDL_RV_MASK) >> SBIDL_RV_SHIFT;
+
+	/* keep and reuse the initial register mapping */
+	origidx = si->curidx;
+	if (BUSTYPE(si->sb.bustype) == SB_BUS)
+		si->regs[origidx] = regs;
+
+	/* is core-0 a chipcommon core? */
+	si->numcores = 1;
+	cc = (chipcregs_t*) sb_setcoreidx(&si->sb, 0);
+	if (sb_coreid(&si->sb) != SB_CC)
+		cc = NULL;
+
+	/* determine chip id and rev */
+	if (cc) {
+		/* chip common core found! */
+		si->sb.chip = R_REG(&cc->chipid) & CID_ID_MASK;
+		si->sb.chiprev = (R_REG(&cc->chipid) & CID_REV_MASK) >> CID_REV_SHIFT;
+		si->sb.chippkg = (R_REG(&cc->chipid) & CID_PKG_MASK) >> CID_PKG_SHIFT;
+	} else {
+		/* no chip common core -- must convert device id to chip id */
+		if ((si->sb.chip = BCMINIT(sb_pcidev2chip)(devid)) == 0) {
+			SB_ERROR(("sb_doattach: unrecognized device id 0x%04x\n", devid));
+			sb_setcoreidx(&si->sb, origidx);
+			return NULL;
+		}
+	}
+
+	/* get chipcommon rev */
+	si->sb.ccrev = cc ? (int)sb_corerev(&si->sb) : NOREV;
+
+	/* determine numcores */
+	if (cc && ((si->sb.ccrev == 4) || (si->sb.ccrev >= 6)))
+		si->numcores = (R_REG(&cc->chipid) & CID_CC_MASK) >> CID_CC_SHIFT;
+	else
+		si->numcores = BCMINIT(sb_chip2numcores)(si->sb.chip);
+
+	/* return to original core */
+	sb_setcoreidx(&si->sb, origidx);
+
+	/* sanity checks */
+	ASSERT(si->sb.chip);
+
+	/* scan for cores */
+	BCMINIT(sb_scan)(si);
+
+	/* fixup necessary chip/core configurations */
+	if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+		if (sb_pci_fixcfg(si)) {
+			SB_ERROR(("sb_doattach: sb_pci_fixcfg failed\n"));
+			return NULL;
+		}
+	}
+	
+	/* srom_var_init() depends on sb_scan() info */
+	if (srom_var_init(si, si->sb.bustype, si->curmap, osh, vars, varsz)) {
+		SB_ERROR(("sb_doattach: srom_var_init failed: bad srom\n"));
+		return (NULL);
+	}
+	
+	if (cc == NULL) {
+		/*
+		 * The chip revision number is hardwired into all
+		 * of the pci function config rev fields and is
+		 * independent from the individual core revision numbers.
+		 * For example, the "A0" silicon of each chip is chip rev 0.
+		 */
+		if (BUSTYPE(si->sb.bustype) == PCI_BUS) {
+			w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_REV, sizeof (uint32));
+			si->sb.chiprev = w & 0xff;
+		} else
+			si->sb.chiprev = 0;
+	}
+
+	/* gpio control core is required */
+	if (!GOODIDX(si->gpioidx)) {
+		SB_ERROR(("sb_doattach: gpio control core not found\n"));
+		return NULL;
+	}
+
+	/* get boardtype and boardrev */
+	switch (BUSTYPE(si->sb.bustype)) {
+	case PCI_BUS:
+		/* do a pci config read to get subsystem id and subvendor id */
+		w = OSL_PCI_READ_CONFIG(osh, PCI_CFG_SVID, sizeof (uint32));
+		si->sb.boardvendor = w & 0xffff;
+		si->sb.boardtype = (w >> 16) & 0xffff;
+		break;
+
+	case SB_BUS:
+	case JTAG_BUS:
+		si->sb.boardvendor = VENDOR_BROADCOM;
+		if ((si->sb.boardtype = getintvar(NULL, "boardtype")) == 0)
+			si->sb.boardtype = 0xffff;
+		break;
+	}
+
+	if (si->sb.boardtype == 0) {
+		SB_ERROR(("sb_doattach: unknown board type\n"));
+		ASSERT(si->sb.boardtype);
+	}
+
+	/* setup the GPIO based LED powersave register */
+	if (si->sb.ccrev >= 16) {
+		w = getintvar(*vars, "gpiotimerval");
+		if (!w)
+			w = DEFAULT_GPIOTIMERVAL; 
+		sb_corereg(si, 0, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+	}
+
+
+	return (si);
+}
+
+uint
+sb_coreid(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	return ((R_SBREG(si, &(sb)->sbidhigh) & SBIDH_CC_MASK) >> SBIDH_CC_SHIFT);
+}
+
+uint
+sb_coreidx(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->curidx);
+}
+
+/* return current index of core */
+static uint
+_sb_coreidx(sb_info_t *si)
+{
+	sbconfig_t *sb;
+	uint32 sbaddr = 0;
+
+	ASSERT(si);
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case SB_BUS:
+		sb = REGS2SB(si->curmap);
+		sbaddr = sb_base(R_SBREG(si, &sb->sbadmatch0));
+		break;
+
+	case PCI_BUS:
+		sbaddr = OSL_PCI_READ_CONFIG(si->osh, PCI_BAR0_WIN, sizeof (uint32));
+		break;
+
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		sbaddr = (uint32)si->curmap;
+		break;
+#endif	/* BCMJTAG */
+
+	default:
+		ASSERT(0);
+	}
+
+	if (!GOODCOREADDR(sbaddr))
+		return BADIDX;
+
+	return ((sbaddr - SB_ENUM_BASE) / SB_CORE_SIZE);
+}
+
+uint
+sb_corevendor(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	return ((R_SBREG(si, &(sb)->sbidhigh) & SBIDH_VC_MASK) >> SBIDH_VC_SHIFT);
+}
+
+uint
+sb_corerev(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint sbidh;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+	sbidh = R_SBREG(si, &(sb)->sbidhigh);
+
+	return (SBCOREREV(sbidh));
+}
+
+void *
+sb_osh(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return si->osh;
+}
+
+#define	SBTML_ALLOW	(SBTML_PE | SBTML_FGC | SBTML_FL_MASK)
+
+/* set/clear sbtmstatelow core-specific flags */
+uint32
+sb_coreflags(sb_t *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint32 w;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	ASSERT((val & ~mask) == 0);
+	ASSERT((mask & ~SBTML_ALLOW) == 0);
+
+	/* mask and set */
+	if (mask || val) {
+		w = (R_SBREG(si, &sb->sbtmstatelow) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatelow, w);
+	}
+
+	/* return the new value */
+	return (R_SBREG(si, &sb->sbtmstatelow) & SBTML_ALLOW);
+}
+
+/* set/clear sbtmstatehigh core-specific flags */
+uint32
+sb_coreflagshi(sb_t *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	uint32 w;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	ASSERT((val & ~mask) == 0);
+	ASSERT((mask & ~SBTMH_FL_MASK) == 0);
+
+	/* mask and set */
+	if (mask || val) {
+		w = (R_SBREG(si, &sb->sbtmstatehigh) & ~mask) | val;
+		W_SBREG(si, &sb->sbtmstatehigh, w);
+	}
+
+	/* return the new value */
+	return (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_FL_MASK);
+}
+
+/* caller needs to take care of core-specific bist hazards */
+int
+sb_corebist(sb_t *sbh, uint coreid, uint coreunit)
+{
+	uint32 sblo;
+	uint coreidx;
+	sb_info_t *si;
+	int result = 0;
+
+	si = SB_INFO(sbh);
+
+	coreidx = sb_findcoreidx(si, coreid, coreunit);
+	if (!GOODIDX(coreidx))
+		result = BCME_ERROR;
+	else {
+		sblo = sb_corereg(si, coreidx, SBCONFIGOFF + OFFSETOF(sbconfig_t, sbtmstatelow), 0, 0);
+		sb_corereg(si, coreidx, SBCONFIGOFF + OFFSETOF(sbconfig_t, sbtmstatelow), ~0, (sblo | SBTML_FGC | SBTML_BE));
+		
+		SPINWAIT(((sb_corereg(si, coreidx, SBCONFIGOFF + OFFSETOF(sbconfig_t, sbtmstatehigh), 0, 0) & SBTMH_BISTD) == 0), 100000);
+	
+		if (sb_corereg(si, coreidx, SBCONFIGOFF + OFFSETOF(sbconfig_t, sbtmstatehigh), 0, 0) & SBTMH_BISTF)
+			result = BCME_ERROR;
+
+		sb_corereg(si, coreidx, SBCONFIGOFF + OFFSETOF(sbconfig_t, sbtmstatelow), ~0, sblo);
+	}
+
+	return result;
+}
+
+bool
+sb_iscoreup(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+	sb = REGS2SB(si->curmap);
+
+	return ((R_SBREG(si, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ_MASK | SBTML_CLK)) == SBTML_CLK);
+}
+
+/*
+ * Switch to 'coreidx', issue a single arbitrary 32bit register mask&set operation,
+ * switch back to the original core, and return the new value.
+ */
+static uint
+sb_corereg(sb_info_t *si, uint coreidx, uint regoff, uint mask, uint val)
+{
+	uint origidx;
+	uint32 *r;
+	uint w;
+	uint intr_val = 0;
+
+	ASSERT(GOODIDX(coreidx));
+	ASSERT(regoff < SB_CORE_SIZE);
+	ASSERT((val & ~mask) == 0);
+
+	INTR_OFF(si, intr_val);
+
+	/* save current core index */
+	origidx = sb_coreidx(&si->sb);
+
+	/* switch core */
+	r = (uint32*) ((uchar*) sb_setcoreidx(&si->sb, coreidx) + regoff);
+
+	/* mask and set */
+	if (mask || val) {
+		if (regoff >= SBCONFIGOFF) {
+			w = (R_SBREG(si, r) & ~mask) | val;
+			W_SBREG(si, r, w);
+		} else {
+			w = (R_REG(r) & ~mask) | val;
+			W_REG(r, w);
+		}
+	}
+
+	/* readback */
+	if (regoff >= SBCONFIGOFF)
+		w = R_SBREG(si, r);
+	else
+		w = R_REG(r);
+
+	/* restore core index */
+	if (origidx != coreidx)
+		sb_setcoreidx(&si->sb, origidx);
+
+	INTR_RESTORE(si, intr_val);
+	return (w);
+}
+
+#define DWORD_ALIGN(x)  (x & ~(0x03))
+#define BYTE_POS(x) (x & 0x3)
+#define WORD_POS(x) (x & 0x1)
+
+#define BYTE_SHIFT(x)  (8 * BYTE_POS(x))
+#define WORD_SHIFT(x)  (16 * WORD_POS(x))
+
+#define BYTE_VAL(a, x) ((a >> BYTE_SHIFT(x)) & 0xFF)
+#define WORD_VAL(a, x) ((a >> WORD_SHIFT(x)) & 0xFFFF)
+
+#define read_pci_cfg_byte(a) \
+	(BYTE_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xff)
+
+#define read_pci_cfg_write(a) \
+	(WORD_VAL(OSL_PCI_READ_CONFIG(si->osh, DWORD_ALIGN(a), 4), a) & 0xffff)
+
+
+/* scan the sb enumerated space to identify all cores */
+static void
+BCMINITFN(sb_scan)(sb_info_t *si)
+{
+	uint origidx;
+	uint i;
+	bool pci;
+	uint pciidx;
+	uint pcirev;
+
+
+
+	/* numcores should already be set */
+	ASSERT((si->numcores > 0) && (si->numcores <= SB_MAXCORES));
+
+	/* save current core index */
+	origidx = sb_coreidx(&si->sb);
+
+	si->sb.buscorerev = NOREV;
+	si->sb.buscoreidx = BADIDX;
+
+	si->gpioidx = BADIDX;
+
+	pci = FALSE;
+	pcirev = NOREV;
+	pciidx = BADIDX;
+
+	for (i = 0; i < si->numcores; i++) {
+		sb_setcoreidx(&si->sb, i);
+		si->coreid[i] = sb_coreid(&si->sb);
+
+		if (si->coreid[i] == SB_PCI) { 
+			pciidx = i;
+			pcirev = sb_corerev(&si->sb);
+			pci = TRUE;
+		}
+	}
+	if (pci) {
+		si->sb.buscoretype = SB_PCI;
+		si->sb.buscorerev = pcirev; 
+		si->sb.buscoreidx = pciidx; 
+	}
+
+	/*
+	 * Find the gpio "controlling core" type and index.
+	 * Precedence:
+	 * - if there's a chip common core - use that
+	 * - else if there's a pci core (rev >= 2) - use that
+	 * - else there had better be an extif core (4710 only)
+	 */
+	if (GOODIDX(sb_findcoreidx(si, SB_CC, 0))) {
+		si->gpioidx = sb_findcoreidx(si, SB_CC, 0);
+		si->gpioid = SB_CC;
+	} else if (PCI(si) && (si->sb.buscorerev >= 2)) {
+		si->gpioidx = si->sb.buscoreidx;
+		si->gpioid = SB_PCI;
+	} else if (sb_findcoreidx(si, SB_EXTIF, 0)) {
+		si->gpioidx = sb_findcoreidx(si, SB_EXTIF, 0);
+		si->gpioid = SB_EXTIF;
+	} else
+		ASSERT(si->gpioidx != BADIDX);
+
+	/* return to original core index */
+	sb_setcoreidx(&si->sb, origidx);
+}
+
+/* may be called with core in reset */
+void
+sb_detach(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	if (si == NULL)
+		return;
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS)
+		for (idx = 0; idx < SB_MAXCORES; idx++)
+			if (si->regs[idx]) {
+				REG_UNMAP(si->regs[idx]);
+				si->regs[idx] = NULL;
+			}
+
+	if (si != &ksi)
+		MFREE(si->osh, si, sizeof (sb_info_t));
+}
+
+/* use pci dev id to determine chip id for chips not having a chipcommon core */
+static uint
+BCMINITFN(sb_pcidev2chip)(uint pcidev)
+{
+	if ((pcidev >= BCM4710_DEVICE_ID) && (pcidev <= BCM47XX_USB_ID))
+		return (BCM4710_DEVICE_ID);
+	if ((pcidev >= BCM4402_DEVICE_ID) && (pcidev <= BCM4402_V90_ID))
+		return (BCM4402_DEVICE_ID);
+	if (pcidev == BCM4401_ENET_ID)
+		return (BCM4402_DEVICE_ID);
+	if ((pcidev >= BCM4307_V90_ID) && (pcidev <= BCM4307_D11B_ID))
+		return (BCM4307_DEVICE_ID);
+	if (pcidev == BCM4301_DEVICE_ID)
+		return (BCM4301_DEVICE_ID);
+
+	return (0);
+}
+
+/* convert chip number to number of i/o cores */
+static uint
+BCMINITFN(sb_chip2numcores)(uint chip)
+{
+	if (chip == BCM4710_DEVICE_ID)
+		return (9);
+	if (chip == BCM4402_DEVICE_ID)
+		return (3);
+	if ((chip == BCM4301_DEVICE_ID) || (chip == BCM4307_DEVICE_ID))
+		return (5);
+	if (chip == BCM4306_DEVICE_ID)	/* < 4306c0 */
+		return (6);
+	if (chip == BCM4704_DEVICE_ID)
+		return (9);
+	if (chip == BCM5365_DEVICE_ID)
+		return (7);
+
+	SB_ERROR(("sb_chip2numcores: unsupported chip 0x%x\n", chip));
+	ASSERT(0);
+	return (1);
+}
+
+/* return index of coreid or BADIDX if not found */
+static uint
+sb_findcoreidx( sb_info_t *si, uint coreid, uint coreunit)
+{
+	uint found;
+	uint i;
+
+	found = 0;
+
+	for (i = 0; i < si->numcores; i++)
+		if (si->coreid[i] == coreid) {
+			if (found == coreunit)
+				return (i);
+			found++;
+		}
+
+	return (BADIDX);
+}
+
+/* 
+ * this function changes logical "focus" to the indiciated core, 
+ * must be called with interrupt off.
+ * Moreover, callers should keep interrupts off during switching out of and back to d11 core
+ */
+void*
+sb_setcoreidx(sb_t *sbh, uint coreidx)
+{
+	sb_info_t *si;
+	uint32 sbaddr;
+
+	si = SB_INFO(sbh);
+
+	if (coreidx >= si->numcores)
+		return (NULL);
+	
+	/*
+	 * If the user has provided an interrupt mask enabled function,
+	 * then assert interrupts are disabled before switching the core.
+	 */
+	ASSERT((si->intrsenabled_fn == NULL) || !(*(si)->intrsenabled_fn)((si)->intr_arg));
+
+	sbaddr = SB_ENUM_BASE + (coreidx * SB_CORE_SIZE);
+
+	switch (BUSTYPE(si->sb.bustype)) {
+	case SB_BUS:
+		/* map new one */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void*)REG_MAP(sbaddr, SB_CORE_SIZE);
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		si->curmap = si->regs[coreidx];
+		break;
+
+	case PCI_BUS:
+		/* point bar0 window */
+		OSL_PCI_WRITE_CONFIG(si->osh, PCI_BAR0_WIN, 4, sbaddr);
+		break;
+
+#ifdef BCMJTAG
+	case JTAG_BUS:
+		/* map new one */
+		if (!si->regs[coreidx]) {
+			si->regs[coreidx] = (void *)sbaddr;
+			ASSERT(GOODREGS(si->regs[coreidx]));
+		}
+		si->curmap = si->regs[coreidx];
+		break;
+#endif	/* BCMJTAG */
+	}
+
+	si->curidx = coreidx;
+
+	return (si->curmap);
+}
+
+/* 
+ * this function changes logical "focus" to the indiciated core, 
+ * must be called with interrupt off.
+ * Moreover, callers should keep interrupts off during switching out of and back to d11 core
+ */
+void*
+sb_setcore(sb_t *sbh, uint coreid, uint coreunit)
+{
+	sb_info_t *si;
+	uint idx;
+
+	si = SB_INFO(sbh);
+	idx = sb_findcoreidx(si, coreid, coreunit);
+	if (!GOODIDX(idx))
+		return (NULL);
+
+	return (sb_setcoreidx(sbh, idx));
+}
+
+/* return chip number */
+uint
+BCMINITFN(sb_chip)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.chip);
+}
+
+/* return chip revision number */
+uint
+BCMINITFN(sb_chiprev)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.chiprev);
+}
+
+/* return chip common revision number */
+uint
+BCMINITFN(sb_chipcrev)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.ccrev);
+}
+
+/* return chip package option */
+uint
+BCMINITFN(sb_chippkg)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.chippkg);
+}
+
+/* return PCI core rev. */
+uint
+BCMINITFN(sb_pcirev)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.buscorerev);
+}
+
+bool
+BCMINITFN(sb_war16165)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	return (PCI(si) && (si->sb.buscorerev <= 10));
+}
+
+/* return board vendor id */
+uint
+BCMINITFN(sb_boardvendor)(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.boardvendor);
+}
+
+/* return boardtype */
+uint
+BCMINITFN(sb_boardtype)(sb_t *sbh)
+{
+	sb_info_t *si;
+	char *var;
+
+	si = SB_INFO(sbh);
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS && si->sb.boardtype == 0xffff) {
+		/* boardtype format is a hex string */
+		si->sb.boardtype = getintvar(NULL, "boardtype");
+
+		/* backward compatibility for older boardtype string format */
+		if ((si->sb.boardtype == 0) && (var = getvar(NULL, "boardtype"))) {
+			if (!strcmp(var, "bcm94710dev"))
+				si->sb.boardtype = BCM94710D_BOARD;
+			else if (!strcmp(var, "bcm94710ap"))
+				si->sb.boardtype = BCM94710AP_BOARD;
+			else if (!strcmp(var, "bu4710"))
+				si->sb.boardtype = BU4710_BOARD;
+			else if (!strcmp(var, "bcm94702mn"))
+				si->sb.boardtype = BCM94702MN_BOARD;
+			else if (!strcmp(var, "bcm94710r1"))
+				si->sb.boardtype = BCM94710R1_BOARD;
+			else if (!strcmp(var, "bcm94710r4"))
+				si->sb.boardtype = BCM94710R4_BOARD;
+			else if (!strcmp(var, "bcm94702cpci"))
+				si->sb.boardtype = BCM94702CPCI_BOARD;
+			else if (!strcmp(var, "bcm95380_rr"))
+				si->sb.boardtype = BCM95380RR_BOARD;
+		}
+	}
+
+	return (si->sb.boardtype);
+}
+
+/* return bus type of sbh device */
+uint
+sb_bus(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	return (si->sb.bustype);
+}
+
+/* return bus core type */
+uint
+sb_buscoretype(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	return (si->sb.buscoretype);
+}
+
+/* return bus core revision */
+uint
+sb_buscorerev(sb_t *sbh)
+{
+	sb_info_t *si;
+	si = SB_INFO(sbh);
+
+	return (si->sb.buscorerev);
+}
+
+/* return list of found cores */
+uint
+sb_corelist(sb_t *sbh, uint coreid[])
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	bcopy((uchar*)si->coreid, (uchar*)coreid, (si->numcores * sizeof (uint)));
+	return (si->numcores);
+}
+
+/* return current register mapping */
+void *
+sb_coreregs(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	ASSERT(GOODREGS(si->curmap));
+
+	return (si->curmap);
+}
+
+
+/* do buffered registers update */
+void
+sb_commit(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	uint intr_val = 0;
+
+	si = SB_INFO(sbh);
+
+	origidx = si->curidx;
+	ASSERT(GOODIDX(origidx));
+
+	INTR_OFF(si, intr_val);
+
+	/* switch over to chipcommon core if there is one, else use pci */
+	if (si->sb.ccrev != NOREV) {
+		chipcregs_t *ccregs = (chipcregs_t *)sb_setcore(sbh, SB_CC, 0);
+
+		/* do the buffer registers update */
+		W_REG(&ccregs->broadcastaddress, SB_COMMIT);
+		W_REG(&ccregs->broadcastdata, 0x0);
+	} else if (PCI(si)) {
+		sbpciregs_t *pciregs = (sbpciregs_t *)sb_setcore(sbh, SB_PCI, 0);
+
+		/* do the buffer registers update */
+		W_REG(&pciregs->bcastaddr, SB_COMMIT);
+		W_REG(&pciregs->bcastdata, 0x0);
+	} else
+		ASSERT(0);
+
+	/* restore core index */
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+}
+
+/* reset and re-enable a core */
+void
+sb_core_reset(sb_t *sbh, uint32 bits)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	volatile uint32 dummy;
+
+	si = SB_INFO(sbh);
+	ASSERT(GOODREGS(si->curmap));
+	sb = REGS2SB(si->curmap);
+
+	/*
+	 * Must do the disable sequence first to work for arbitrary current core state.
+	 */
+	sb_core_disable(sbh, bits);
+
+	/*
+	 * Now do the initialization sequence.
+	 */
+
+	/* set reset while enabling the clock and forcing them on throughout the core */
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | SBTML_RESET | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
+	OSL_DELAY(1);
+
+	if (R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_SERR) {
+		W_SBREG(si, &sb->sbtmstatehigh, 0);
+	}
+	if ((dummy = R_SBREG(si, &sb->sbimstate)) & (SBIM_IBE | SBIM_TO)) {
+		AND_SBREG(si, &sb->sbimstate, ~(SBIM_IBE | SBIM_TO));
+	}
+
+	/* clear reset and allow it to propagate throughout the core */
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_FGC | SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
+	OSL_DELAY(1);
+
+	/* leave clock enabled */
+	W_SBREG(si, &sb->sbtmstatelow, (SBTML_CLK | bits));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
+	OSL_DELAY(1);
+}
+
+void
+sb_core_tofixup(sb_t *sbh)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+
+	if ( (BUSTYPE(si->sb.bustype) != PCI_BUS) || (PCI(si) && (si->sb.buscorerev >= 5)) )
+		return;
+
+	ASSERT(GOODREGS(si->curmap));
+	sb = REGS2SB(si->curmap);
+
+	if (BUSTYPE(si->sb.bustype) == SB_BUS) {
+		SET_SBREG(si, &sb->sbimconfiglow,
+			  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
+			  (0x5 << SBIMCL_RTO_SHIFT) | 0x3);
+	} else {
+		if (sb_coreid(sbh) == SB_PCI) {
+			SET_SBREG(si, &sb->sbimconfiglow,
+				  SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
+				  (0x3 << SBIMCL_RTO_SHIFT) | 0x2);
+		} else {
+			SET_SBREG(si, &sb->sbimconfiglow, (SBIMCL_RTO_MASK | SBIMCL_STO_MASK), 0);
+		}
+	}
+
+	sb_commit(sbh);
+}
+
+/*
+ * Set the initiator timeout for the "master core".
+ * The master core is defined to be the core in control
+ * of the chip and so it issues accesses to non-memory
+ * locations (Because of dma *any* core can access memeory).
+ *
+ * The routine uses the bus to decide who is the master:
+ *	SB_BUS => mips
+ *	JTAG_BUS => chipc
+ *	PCI_BUS => pci
+ *
+ * This routine exists so callers can disable initiator
+ * timeouts so accesses to very slow devices like otp
+ * won't cause an abort. The routine allows arbitrary
+ * settings of the service and request timeouts, though.
+ *
+ * Returns the timeout state before changing it or -1
+ * on error.
+ */
+
+#define	TO_MASK	(SBIMCL_RTO_MASK | SBIMCL_STO_MASK)
+
+uint32
+sb_set_initiator_to(sb_t *sbh, uint32 to)
+{
+	sb_info_t *si;
+	uint origidx, idx;
+	uint intr_val = 0;
+	uint32 tmp, ret = 0xffffffff;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+
+	if ((to & ~TO_MASK) != 0)
+		return ret;
+
+	/* Figure out the master core */
+	idx = BADIDX;
+	switch (BUSTYPE(si->sb.bustype)) {
+	case PCI_BUS:
+		idx = si->sb.buscoreidx; 
+		break;
+	case JTAG_BUS:
+		idx = SB_CC_IDX;
+		break;
+	case SB_BUS:
+		if ((idx = sb_findcoreidx(si, SB_MIPS33, 0)) == BADIDX)
+			idx = sb_findcoreidx(si, SB_MIPS, 0);
+		break;
+	default:
+		ASSERT(0);
+	}
+	if (idx == BADIDX)
+		return ret;
+
+	INTR_OFF(si, intr_val);
+	origidx = sb_coreidx(sbh);
+
+	sb = REGS2SB(sb_setcoreidx(sbh, idx));
+
+	tmp = R_SBREG(si, &sb->sbimconfiglow);
+	ret = tmp & TO_MASK;
+	W_SBREG(si, &sb->sbimconfiglow, (tmp & ~TO_MASK) | to);
+
+	sb_commit(sbh);
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return ret;
+}
+
+void
+sb_core_disable(sb_t *sbh, uint32 bits)
+{
+	sb_info_t *si;
+	volatile uint32 dummy;
+	uint32 rej;
+	sbconfig_t *sb;
+
+	si = SB_INFO(sbh);
+
+	ASSERT(GOODREGS(si->curmap));
+	sb = REGS2SB(si->curmap);
+
+	/* if core is already in reset, just return */
+	if (R_SBREG(si, &sb->sbtmstatelow) & SBTML_RESET)
+		return;
+
+	/* reject value changed between sonics 2.2 and 2.3 */
+	if (si->sb.sonicsrev == SONICS_2_2)
+		rej = (1 << SBTML_REJ_SHIFT);
+	else
+		rej = (2 << SBTML_REJ_SHIFT);
+
+	/* if clocks are not enabled, put into reset and return */
+	if ((R_SBREG(si, &sb->sbtmstatelow) & SBTML_CLK) == 0)
+		goto disable;
+
+	/* set target reject and spin until busy is clear (preserve core-specific bits) */
+	OR_SBREG(si, &sb->sbtmstatelow, rej);
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
+	OSL_DELAY(1);
+	SPINWAIT((R_SBREG(si, &sb->sbtmstatehigh) & SBTMH_BUSY), 100000);
+
+ 	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT) {
+		OR_SBREG(si, &sb->sbimstate, SBIM_RJ);
+		dummy = R_SBREG(si, &sb->sbimstate);
+		OSL_DELAY(1);
+		SPINWAIT((R_SBREG(si, &sb->sbimstate) & SBIM_BY), 100000);
+	}
+
+	/* set reset and reject while enabling the clocks */
+	W_SBREG(si, &sb->sbtmstatelow, (bits | SBTML_FGC | SBTML_CLK | rej | SBTML_RESET));
+	dummy = R_SBREG(si, &sb->sbtmstatelow);
+	OSL_DELAY(10);
+
+	/* don't forget to clear the initiator reject bit */
+	if (R_SBREG(si, &sb->sbidlow) & SBIDL_INIT)
+		AND_SBREG(si, &sb->sbimstate, ~SBIM_RJ);
+
+disable:
+	/* leave reset and reject asserted */
+	W_SBREG(si, &sb->sbtmstatelow, (bits | rej | SBTML_RESET));
+	OSL_DELAY(1);
+}
+
+/* set chip watchdog reset timer to fire in 'ticks' backplane cycles */
+void
+sb_watchdog(sb_t *sbh, uint ticks)
+{
+	sb_info_t *si = SB_INFO(sbh);
+
+	/* instant NMI */
+	switch (si->gpioid) {
+	case SB_CC:
+		sb_corereg(si, 0, OFFSETOF(chipcregs_t, watchdog), ~0, ticks);
+		break;
+	case SB_EXTIF:
+		sb_corereg(si, si->gpioidx, OFFSETOF(extifregs_t, watchdog), ~0, ticks);
+		break;
+	}
+}
+
+
+/*
+ * Configure the pci core for pci client (NIC) action
+ * coremask is the bitvec of cores by index to be enabled.
+ */
+void
+sb_pci_setup(sb_t *sbh, uint coremask)
+{
+	sb_info_t *si;
+	sbconfig_t *sb;
+	sbpciregs_t *pciregs;
+	uint32 sbflag;
+	uint32 w;
+	uint idx;
+
+	si = SB_INFO(sbh);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(si->sb.bustype) != PCI_BUS)
+		return;
+
+	ASSERT(PCI(si));
+	ASSERT(si->sb.buscoreidx != BADIDX);
+
+	/* get current core index */
+	idx = si->curidx;
+
+	/* we interrupt on this backplane flag number */
+	ASSERT(GOODREGS(si->curmap));
+	sb = REGS2SB(si->curmap);
+	sbflag = R_SBREG(si, &sb->sbtpsflag) & SBTPS_NUM0_MASK;
+
+	/* switch over to pci core */
+	pciregs = (sbpciregs_t*) sb_setcoreidx(sbh, si->sb.buscoreidx);
+	sb = REGS2SB(pciregs);
+
+	/*
+	 * Enable sb->pci interrupts.  Assume
+	 * PCI rev 2.3 support was added in pci core rev 6 and things changed..
+	 */
+	if ((PCI(si) && ((si->sb.buscorerev) >= 6))) {
+		/* pci config write to set this core bit in PCIIntMask */
+		w = OSL_PCI_READ_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32));
+		w |= (coremask << PCI_SBIM_SHIFT);
+		OSL_PCI_WRITE_CONFIG(si->osh, PCI_INT_MASK, sizeof(uint32), w);
+	} else {
+		/* set sbintvec bit for our flag number */
+		OR_SBREG(si, &sb->sbintvec, (1 << sbflag));
+	}
+
+	if (PCI(si)) {
+		OR_REG(&pciregs->sbtopci2, (SBTOPCI_PREF|SBTOPCI_BURST));
+		if (si->sb.buscorerev >= 11)
+			OR_REG(&pciregs->sbtopci2, SBTOPCI_RC_READMULTI);
+		if (si->sb.buscorerev < 5) {
+			SET_SBREG(si, &sb->sbimconfiglow, SBIMCL_RTO_MASK | SBIMCL_STO_MASK,
+				(0x3 << SBIMCL_RTO_SHIFT) | 0x2);
+			sb_commit(sbh);
+		}
+	}
+
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+}
+
+uint32
+sb_base(uint32 admatch)
+{
+	uint32 base;
+	uint type;
+
+	type = admatch & SBAM_TYPE_MASK;
+	ASSERT(type < 3);
+
+	base = 0;
+
+	if (type == 0) {
+		base = admatch & SBAM_BASE0_MASK;
+	} else if (type == 1) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		base = admatch & SBAM_BASE1_MASK;
+	} else if (type == 2) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		base = admatch & SBAM_BASE2_MASK;
+	}
+
+	return (base);
+}
+
+uint32
+sb_size(uint32 admatch)
+{
+	uint32 size;
+	uint type;
+
+	type = admatch & SBAM_TYPE_MASK;
+	ASSERT(type < 3);
+
+	size = 0;
+
+	if (type == 0) {
+		size = 1 << (((admatch & SBAM_ADINT0_MASK) >> SBAM_ADINT0_SHIFT) + 1);
+	} else if (type == 1) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		size = 1 << (((admatch & SBAM_ADINT1_MASK) >> SBAM_ADINT1_SHIFT) + 1);
+	} else if (type == 2) {
+		ASSERT(!(admatch & SBAM_ADNEG));	/* neg not supported */
+		size = 1 << (((admatch & SBAM_ADINT2_MASK) >> SBAM_ADINT2_SHIFT) + 1);
+	}
+
+	return (size);
+}
+
+/* return the core-type instantiation # of the current core */
+uint
+sb_coreunit(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint idx;
+	uint coreid;
+	uint coreunit;
+	uint i;
+
+	si = SB_INFO(sbh);
+	coreunit = 0;
+
+	idx = si->curidx;
+
+	ASSERT(GOODREGS(si->curmap));
+	coreid = sb_coreid(sbh);
+
+	/* count the cores of our type */
+	for (i = 0; i < idx; i++)
+		if (si->coreid[i] == coreid)
+			coreunit++;
+
+	return (coreunit);
+}
+
+static INLINE uint32
+factor6(uint32 x)
+{
+	switch (x) {
+	case CC_F6_2:	return 2;
+	case CC_F6_3:	return 3;
+	case CC_F6_4:	return 4;
+	case CC_F6_5:	return 5;
+	case CC_F6_6:	return 6;
+	case CC_F6_7:	return 7;
+	default:	return 0;
+	}
+}
+
+/* calculate the speed the SB would run at given a set of clockcontrol values */
+uint32
+sb_clock_rate(uint32 pll_type, uint32 n, uint32 m)
+{
+	uint32 n1, n2, clock, m1, m2, m3, mc;
+
+	n1 = n & CN_N1_MASK;
+	n2 = (n & CN_N2_MASK) >> CN_N2_SHIFT;
+
+	if (pll_type == PLL_TYPE6) {
+		if (m & CC_T6_MMASK)
+			return CC_T6_M1;
+		else
+			return CC_T6_M0;
+	} else if ((pll_type == PLL_TYPE1) ||
+		   (pll_type == PLL_TYPE3) ||
+		   (pll_type == PLL_TYPE4) ||
+		   (pll_type == PLL_TYPE7)) {
+		n1 = factor6(n1);
+		n2 += CC_F5_BIAS;
+	} else if (pll_type == PLL_TYPE2) {
+		n1 += CC_T2_BIAS;
+		n2 += CC_T2_BIAS;
+		ASSERT((n1 >= 2) && (n1 <= 7));
+		ASSERT((n2 >= 5) && (n2 <= 23));
+	} else if (pll_type == PLL_TYPE5) {
+		return (100000000);
+	} else
+		ASSERT(0);
+	/* PLL types 3 and 7 use BASE2 (25Mhz) */
+	if ((pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE7)) { 
+		clock =  CC_CLOCK_BASE2 * n1 * n2;
+	}
+	else 
+		clock = CC_CLOCK_BASE1 * n1 * n2;
+
+	if (clock == 0)
+		return 0;
+
+	m1 = m & CC_M1_MASK;
+	m2 = (m & CC_M2_MASK) >> CC_M2_SHIFT;
+	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
+	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;
+
+	if ((pll_type == PLL_TYPE1) ||
+	    (pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE4) ||
+	    (pll_type == PLL_TYPE7)) {
+		m1 = factor6(m1);
+		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
+			m2 += CC_F5_BIAS;
+		else
+			m2 = factor6(m2);
+		m3 = factor6(m3);
+
+		switch (mc) {
+		case CC_MC_BYPASS:	return (clock);
+		case CC_MC_M1:		return (clock / m1);
+		case CC_MC_M1M2:	return (clock / (m1 * m2));
+		case CC_MC_M1M2M3:	return (clock / (m1 * m2 * m3));
+		case CC_MC_M1M3:	return (clock / (m1 * m3));
+		default:		return (0);
+		}
+	} else {
+		ASSERT(pll_type == PLL_TYPE2);
+
+		m1 += CC_T2_BIAS;
+		m2 += CC_T2M2_BIAS;
+		m3 += CC_T2_BIAS;
+		ASSERT((m1 >= 2) && (m1 <= 7));
+		ASSERT((m2 >= 3) && (m2 <= 10));
+		ASSERT((m3 >= 2) && (m3 <= 7));
+
+		if ((mc & CC_T2MC_M1BYP) == 0)
+			clock /= m1;
+		if ((mc & CC_T2MC_M2BYP) == 0)
+			clock /= m2;
+		if ((mc & CC_T2MC_M3BYP) == 0)
+			clock /= m3;
+
+		return(clock);
+	}
+}
+
+/* returns the current speed the SB is running at */
+uint32
+sb_clock(sb_t *sbh)
+{
+	sb_info_t *si;
+	extifregs_t *eir;
+	chipcregs_t *cc;
+	uint32 n, m;
+	uint idx;
+	uint32 pll_type, rate;
+	uint intr_val = 0;
+
+	si = SB_INFO(sbh);
+	idx = si->curidx;
+	pll_type = PLL_TYPE1;
+
+	INTR_OFF(si, intr_val);
+
+	/* switch to extif or chipc core */
+	if ((eir = (extifregs_t *) sb_setcore(sbh, SB_EXTIF, 0))) {
+		n = R_REG(&eir->clockcontrol_n);
+		m = R_REG(&eir->clockcontrol_sb);
+	} else if ((cc = (chipcregs_t *) sb_setcore(sbh, SB_CC, 0))) {
+		pll_type = R_REG(&cc->capabilities) & CAP_PLL_MASK;
+		n = R_REG(&cc->clockcontrol_n);
+		if (pll_type == PLL_TYPE6)
+			m = R_REG(&cc->clockcontrol_mips);
+		else if (pll_type == PLL_TYPE3)
+		{
+			// Added by Chen-I for 5365 
+			if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID) 	
+				m = R_REG(&cc->clockcontrol_sb);
+			else
+				m = R_REG(&cc->clockcontrol_m2);
+		}
+		else
+			m = R_REG(&cc->clockcontrol_sb);
+	} else {
+		INTR_RESTORE(si, intr_val);
+		return 0;
+	}
+
+	// Added by Chen-I for 5365 
+	if (BCMINIT(sb_chip)(sbh) == BCM5365_DEVICE_ID)
+	{
+		rate = 100000000;
+	}
+	else
+	{	
+		/* calculate rate */
+		rate = sb_clock_rate(pll_type, n, m);
+		if (pll_type == PLL_TYPE3)
+			rate = rate / 2;
+	}
+
+	/* switch back to previous core */
+	sb_setcoreidx(sbh, idx);
+
+	INTR_RESTORE(si, intr_val);
+
+	return rate;
+}
+
+/* change logical "focus" to the gpio core for optimized access */
+void*
+sb_gpiosetcore(sb_t *sbh)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	return (sb_setcoreidx(sbh, si->gpioidx));
+}
+
+/* mask&set gpiocontrol bits */
+uint32
+sb_gpiocontrol(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+		break;
+
+	case SB_PCI:
+		regoff = OFFSETOF(sbpciregs_t, gpiocontrol);
+		break;
+
+	case SB_EXTIF:
+		return (0);
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio output enable bits */
+uint32
+sb_gpioouten(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioouten);
+		break;
+
+	case SB_PCI:
+		regoff = OFFSETOF(sbpciregs_t, gpioouten);
+		break;
+
+	case SB_EXTIF:
+		regoff = OFFSETOF(extifregs_t, gpio[0].outen);
+		break;
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio output bits */
+uint32
+sb_gpioout(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioout);
+		break;
+
+	case SB_PCI:
+		regoff = OFFSETOF(sbpciregs_t, gpioout);
+		break;
+
+	case SB_EXTIF:
+		regoff = OFFSETOF(extifregs_t, gpio[0].out);
+		break;
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, mask, val));
+}
+
+/* reserve one gpio */
+uint32
+sb_gpioreserve(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* only cores on SB_BUS share GPIO's and only applcation users need to reserve/release GPIO */
+	if ( (BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
+
+	/* already reserved */
+	if (sb_gpioreservation & gpio_bitmask)
+		return -1;
+	/* set reservation */
+	sb_gpioreservation |= gpio_bitmask;
+
+	return sb_gpioreservation;
+}
+
+/* release one gpio */
+/* 
+ * releasing the gpio doesn't change the current value on the GPIO last write value 
+ * persists till some one overwrites it
+*/
+
+uint32
+sb_gpiorelease(sb_t *sbh, uint32 gpio_bitmask, uint8 priority)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* only cores on SB_BUS share GPIO's and only applcation users need to reserve/release GPIO */
+	if ( (BUSTYPE(si->sb.bustype) != SB_BUS) || (!priority))  {
+		ASSERT((BUSTYPE(si->sb.bustype) == SB_BUS) && (priority));
+		return -1;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask) && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return -1;
+	}
+	
+	/* already released */
+	if (!(sb_gpioreservation & gpio_bitmask))
+		return -1;
+
+	/* clear reservation */
+	sb_gpioreservation &= ~gpio_bitmask;
+
+	return sb_gpioreservation;
+}
+
+/* return the current gpioin register value */
+uint32
+sb_gpioin(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpioin);
+		break;
+
+	case SB_PCI:
+		regoff = OFFSETOF(sbpciregs_t, gpioin);
+		break;
+
+	case SB_EXTIF:
+		regoff = OFFSETOF(extifregs_t, gpioin);
+		break;
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, 0, 0));
+}
+
+/* mask&set gpio interrupt polarity bits */
+uint32
+sb_gpiointpolarity(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
+		break;
+
+	case SB_PCI:
+		/* pci gpio implementation does not support interrupt polarity */
+		ASSERT(0);
+		break;
+
+	case SB_EXTIF:
+		regoff = OFFSETOF(extifregs_t, gpiointpolarity);
+		break;
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, mask, val));
+}
+
+/* mask&set gpio interrupt mask bits */
+uint32
+sb_gpiointmask(sb_t *sbh, uint32 mask, uint32 val, uint8 priority)
+{
+	sb_info_t *si;
+	uint regoff;
+
+	si = SB_INFO(sbh);
+	regoff = 0;
+
+	priority = GPIO_DRV_PRIORITY; /* compatibility hack */
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(si->sb.bustype) == SB_BUS) && (val || mask)) {
+		mask = priority ? (sb_gpioreservation & mask) :
+			((sb_gpioreservation | mask) & ~(sb_gpioreservation));
+		val &= mask;
+	}
+
+	switch (si->gpioid) {
+	case SB_CC:
+		regoff = OFFSETOF(chipcregs_t, gpiointmask);
+		break;
+
+	case SB_PCI:
+		/* pci gpio implementation does not support interrupt mask */
+		ASSERT(0);
+		break;
+
+	case SB_EXTIF:
+		regoff = OFFSETOF(extifregs_t, gpiointmask);
+		break;
+	}
+
+	return (sb_corereg(si, si->gpioidx, regoff, mask, val));
+}
+
+/* assign the gpio to an led */
+uint32
+sb_gpioled(sb_t *sbh, uint32 mask, uint32 val)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	if (si->sb.ccrev < 16)
+		return -1;
+
+	/* gpio led powersave reg */
+	return(sb_corereg(si, 0, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask, val));
+}
+
+/* mask&set gpio timer val */
+uint32 
+sb_gpiotimerval(sb_t *sbh, uint32 mask, uint32 gpiotimerval)
+{
+	sb_info_t *si;
+	si = SB_INFO(sbh);
+
+	if (si->sb.ccrev < 16)
+		return -1;
+
+	return(sb_corereg(si, 0, OFFSETOF(chipcregs_t, gpiotimerval), mask, gpiotimerval));
+}
+
+
+/* return the slow clock source - LPO, XTAL, or PCI */
+static uint
+sb_slowclk_src(sb_info_t *si)
+{
+	chipcregs_t *cc;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	if (si->sb.ccrev < 6) {
+		if ((BUSTYPE(si->sb.bustype) == PCI_BUS)
+			&& (OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32)) & PCI_CFG_GPIO_SCS))
+			return (SCC_SS_PCI);
+		else
+			return (SCC_SS_XTAL);
+	} else if (si->sb.ccrev < 10) {
+		cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+		return (R_REG(&cc->slow_clk_ctl) & SCC_SS_MASK);
+	} else	/* Insta-clock */
+		return (SCC_SS_XTAL);
+}
+
+/* return the ILP (slowclock) min or max frequency */
+static uint
+sb_slowclk_freq(sb_info_t *si, bool max)
+{
+	chipcregs_t *cc;
+	uint32 slowclk;
+	uint div;
+
+
+	ASSERT(sb_coreid(&si->sb) == SB_CC);
+
+	cc = (chipcregs_t*) sb_setcoreidx(&si->sb, si->curidx);
+
+	/* shouldn't be here unless we've established the chip has dynamic clk control */
+	ASSERT(R_REG(&cc->capabilities) & CAP_PWR_CTL);
+
+	slowclk = sb_slowclk_src(si);
+	if (si->sb.ccrev < 6) {
+		if (slowclk == SCC_SS_PCI)
+			return (max? (PCIMAXFREQ/64) : (PCIMINFREQ/64));
+		else
+			return (max? (XTALMAXFREQ/32) : (XTALMINFREQ/32));
+	} else if (si->sb.ccrev < 10) {
+		div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
+		if (slowclk == SCC_SS_LPO)
+			return (max? LPOMAXFREQ : LPOMINFREQ);
+		else if (slowclk == SCC_SS_XTAL)
+			return (max? (XTALMAXFREQ/div) : (XTALMINFREQ/div));
+		else if (slowclk == SCC_SS_PCI)
+			return (max? (PCIMAXFREQ/div) : (PCIMINFREQ/div));
+		else
+			ASSERT(0);
+	} else {
+		/* Chipc rev 10 is InstaClock */
+		div = R_REG(&cc->system_clk_ctl) >> SYCC_CD_SHIFT;
+		div = 4 * (div + 1);
+		return (max ? XTALMAXFREQ : (XTALMINFREQ/div));
+	}
+	return (0);
+}
+
+static void
+sb_clkctl_setdelay(sb_info_t *si, void *chipcregs)
+{
+	chipcregs_t * cc;
+	uint slowmaxfreq, pll_delay, slowclk;
+	uint pll_on_delay, fref_sel_delay;
+
+	pll_delay = PLL_DELAY;
+
+	/* If the slow clock is not sourced by the xtal then add the xtal_on_delay
+	 * since the xtal will also be powered down by dynamic clk control logic.
+	 */
+	slowclk = sb_slowclk_src(si);
+	if (slowclk != SCC_SS_XTAL)
+		pll_delay += XTAL_ON_DELAY;
+
+	/* Starting with 4318 it is ILP that is used for the delays */
+	slowmaxfreq = sb_slowclk_freq(si, (si->sb.ccrev >= 10) ? FALSE : TRUE);
+
+	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
+	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
+
+	cc = (chipcregs_t *)chipcregs;
+	W_REG(&cc->pll_on_delay, pll_on_delay);
+	W_REG(&cc->fref_sel_delay, fref_sel_delay);
+}
+
+int
+sb_pwrctl_slowclk(void *sbh, bool set, uint *div)
+{
+	sb_info_t *si;
+	uint origidx;
+	chipcregs_t *cc;
+	uint intr_val = 0;
+	uint err = 0;
+	
+	si = SB_INFO(sbh);
+
+	/* chipcommon cores prior to rev6 don't support slowclkcontrol */
+	if (si->sb.ccrev < 6)
+		return 1;
+
+	/* chipcommon cores rev10 are a whole new ball game */
+	if (si->sb.ccrev >= 10)
+		return 1;
+
+	if (set && ((*div % 4) || (*div < 4)))
+		return 2;
+	
+	INTR_OFF(si, intr_val);
+	origidx = si->curidx;
+	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc != NULL);
+	
+	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL)) {
+		err = 3;
+		goto done;
+	}
+
+	if (set) {
+		SET_REG(&cc->slow_clk_ctl, SCC_CD_MASK, ((*div / 4 - 1) << SCC_CD_SHIFT));
+		sb_clkctl_setdelay(sbh, (void *)cc);
+	} else
+		*div = 4 * (((R_REG(&cc->slow_clk_ctl) & SCC_CD_MASK) >> SCC_CD_SHIFT) + 1);
+
+done:
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return err;
+}
+
+/* initialize power control delay registers */
+void sb_clkctl_init(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	chipcregs_t *cc;
+
+	si = SB_INFO(sbh);
+
+	origidx = si->curidx;
+
+	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
+		return;
+
+	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+		goto done;
+
+	/* set all Instaclk chip ILP to 1 MHz */
+	if (si->sb.ccrev >= 10)
+		SET_REG(&cc->system_clk_ctl, SYCC_CD_MASK, (ILP_DIV_1MHZ << SYCC_CD_SHIFT));
+	
+	sb_clkctl_setdelay(si, (void *)cc);
+
+done:
+	sb_setcoreidx(sbh, origidx);
+}
+void sb_pwrctl_init(sb_t *sbh)
+{
+sb_clkctl_init(sbh);
+}
+/* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
+uint16
+sb_clkctl_fast_pwrup_delay(sb_t *sbh)
+{
+	sb_info_t *si;
+	uint origidx;
+	chipcregs_t *cc;
+	uint slowminfreq;
+	uint16 fpdelay;
+	uint intr_val = 0;
+
+	si = SB_INFO(sbh);
+	fpdelay = 0;
+	origidx = si->curidx;
+
+	INTR_OFF(si, intr_val);
+
+	if ((cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0)) == NULL)
+		goto done;
+
+	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+		goto done;
+
+	slowminfreq = sb_slowclk_freq(si, FALSE);
+	fpdelay = (((R_REG(&cc->pll_on_delay) + 2) * 1000000) + (slowminfreq - 1)) / slowminfreq;
+
+done:
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return (fpdelay);
+}
+uint16 sb_pwrctl_fast_pwrup_delay(sb_t *sbh)
+{
+return sb_clkctl_fast_pwrup_delay(sbh);
+}
+/* turn primary xtal and/or pll off/on */
+int
+sb_clkctl_xtal(sb_t *sbh, uint what, bool on)
+{
+	sb_info_t *si;
+	uint32 in, out, outen;
+
+	si = SB_INFO(sbh);
+
+	switch (BUSTYPE(si->sb.bustype)) {
+		case PCI_BUS:
+
+			in = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_IN, sizeof (uint32));
+			out = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32));
+			outen = OSL_PCI_READ_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32));
+
+			/*
+			 * Avoid glitching the clock if GPRS is already using it.
+			 * We can't actually read the state of the PLLPD so we infer it
+			 * by the value of XTAL_PU which *is* readable via gpioin.
+			 */
+			if (on && (in & PCI_CFG_GPIO_XTAL))
+				return (0);
+
+			if (what & XTAL)
+				outen |= PCI_CFG_GPIO_XTAL;
+			if (what & PLL)
+				outen |= PCI_CFG_GPIO_PLL;
+
+			if (on) {
+				/* turn primary xtal on */
+				if (what & XTAL) {
+					out |= PCI_CFG_GPIO_XTAL;
+					if (what & PLL)
+						out |= PCI_CFG_GPIO_PLL;
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+					OSL_DELAY(XTAL_ON_DELAY);
+				}
+
+				/* turn pll on */
+				if (what & PLL) {
+					out &= ~PCI_CFG_GPIO_PLL;
+					OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
+					OSL_DELAY(2000);
+				}
+			} else {
+				if (what & XTAL)
+					out &= ~PCI_CFG_GPIO_XTAL;
+				if (what & PLL)
+					out |= PCI_CFG_GPIO_PLL;
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUT, sizeof (uint32), out);
+				OSL_PCI_WRITE_CONFIG(si->osh, PCI_GPIO_OUTEN, sizeof (uint32), outen);
+			}
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
+
+int sb_pwrctl_xtal(sb_t *sbh, uint what, bool on)
+{
+return sb_clkctl_xtal(sbh,what,on);
+}
+
+/* set dynamic clk control mode (forceslow, forcefast, dynamic) */
+/*   returns true if ignore pll off is set and false if it is not */
+bool
+sb_clkctl_clk(sb_t *sbh, uint mode)
+{
+	sb_info_t *si;
+	uint origidx;
+	chipcregs_t *cc;
+	uint32 scc;
+	bool forcefastclk=FALSE;
+	uint intr_val = 0;
+
+	si = SB_INFO(sbh);
+
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (si->sb.ccrev < 6)
+		return (FALSE);
+
+	/* chipcommon cores rev10 are a whole new ball game */
+	if (si->sb.ccrev >= 10)
+		return (FALSE);
+
+	INTR_OFF(si, intr_val);
+
+	origidx = si->curidx;
+
+	cc = (chipcregs_t*) sb_setcore(sbh, SB_CC, 0);
+	ASSERT(cc != NULL);
+
+	if (!(R_REG(&cc->capabilities) & CAP_PWR_CTL))
+		goto done;
+
+	switch (mode) {
+	case CLK_FAST:	/* force fast (pll) clock */
+		/* don't forget to force xtal back on before we clear SCC_DYN_XTAL.. */
+		sb_clkctl_xtal(&si->sb, XTAL, ON);
+
+		SET_REG(&cc->slow_clk_ctl, (SCC_XC | SCC_FS | SCC_IP), SCC_IP);
+		break;
+
+	case CLK_DYNAMIC:	/* enable dynamic clock control */
+		scc = R_REG(&cc->slow_clk_ctl);
+		scc &= ~(SCC_FS | SCC_IP | SCC_XC);
+		if ((scc & SCC_SS_MASK) != SCC_SS_XTAL)
+			scc |= SCC_XC;
+		W_REG(&cc->slow_clk_ctl, scc);
+
+		/* for dynamic control, we have to release our xtal_pu "force on" */
+		if (scc & SCC_XC)
+			sb_clkctl_xtal(&si->sb, XTAL, OFF);
+		break;
+
+	default:
+		ASSERT(0);
+	}
+
+	/* Is the h/w forcing the use of the fast clk */
+	forcefastclk = (bool)((R_REG(&cc->slow_clk_ctl) & SCC_IP) == SCC_IP);
+
+done:
+	sb_setcoreidx(sbh, origidx);
+	INTR_RESTORE(si, intr_val);
+	return (forcefastclk);
+}
+
+bool sb_pwrctl_clk(sb_t *sbh, uint mode)
+{
+return sb_clkctl_clk(sbh, mode);
+}
+/* register driver interrupt disabling and restoring callback functions */
+void
+sb_register_intr_callback(sb_t *sbh, void *intrsoff_fn, void *intrsrestore_fn, void *intrsenabled_fn, void *intr_arg)
+{
+	sb_info_t *si;
+
+	si = SB_INFO(sbh);
+	si->intr_arg = intr_arg;
+	si->intrsoff_fn = (sb_intrsoff_t)intrsoff_fn;
+	si->intrsrestore_fn = (sb_intrsrestore_t)intrsrestore_fn;
+	si->intrsenabled_fn = (sb_intrsenabled_t)intrsenabled_fn;
+	/* save current core id.  when this function called, the current core
+	 * must be the core which provides driver functions(il, et, wl, etc.)
+	 */
+	si->dev_coreid = si->coreid[si->curidx];
+}
+
+
+void
+sb_corepciid(sb_t *sbh, uint16 *pcivendor, uint16 *pcidevice, 
+	uint8 *pciclass, uint8 *pcisubclass, uint8 *pciprogif)
+{
+	uint vendor, core, unit;
+	uint chip, chippkg;
+	char varname[8];
+	uint8 class, subclass, progif;
+	
+	vendor = sb_corevendor(sbh);
+	core = sb_coreid(sbh);
+	unit = sb_coreunit(sbh);
+
+	chip = BCMINIT(sb_chip)(sbh);
+	chippkg = BCMINIT(sb_chippkg)(sbh);
+
+	progif = 0;
+	
+	/* Known vendor translations */
+	switch (vendor) {
+	case SB_VEND_BCM:
+		vendor = VENDOR_BROADCOM;
+		break;
+	}
+
+	/* Determine class based on known core codes */
+	switch (core) {
+	case SB_ILINE20:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		core = BCM47XX_ILINE_ID;
+		break;
+	case SB_ENET:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_ETHER;
+		core = BCM47XX_ENET_ID;
+		break;
+	case SB_SDRAM:
+	case SB_MEMC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_RAM;
+		break;
+	case SB_PCI:
+		class = PCI_CLASS_BRIDGE;
+		subclass = PCI_BRIDGE_PCI;
+		break;
+	case SB_MIPS:
+	case SB_MIPS33:
+		class = PCI_CLASS_CPU;
+		subclass = PCI_CPU_MIPS;
+		break;
+	case SB_CODEC:
+		class = PCI_CLASS_COMM;
+		subclass = PCI_COMM_MODEM;
+		core = BCM47XX_V90_ID;
+		break;
+	case SB_USB:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		core = BCM47XX_USB_ID;
+		break;
+	case SB_USB11H:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		progif = 0x10; /* OHCI */
+		core = BCM47XX_USBH_ID;
+		break;
+	case SB_USB11D:
+		class = PCI_CLASS_SERIAL;
+		subclass = PCI_SERIAL_USB;
+		core = BCM47XX_USBD_ID;
+		break;
+	case SB_IPSEC:
+		class = PCI_CLASS_CRYPT;
+		subclass = PCI_CRYPT_NETWORK;
+		core = BCM47XX_IPSEC_ID;
+		break;
+	case SB_ROBO:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		core = BCM47XX_ROBO_ID;
+		break;
+	case SB_EXTIF:
+	case SB_CC:
+		class = PCI_CLASS_MEMORY;
+		subclass = PCI_MEMORY_FLASH;
+		break;
+	case SB_D11:
+		class = PCI_CLASS_NET;
+		subclass = PCI_NET_OTHER;
+		/* Let an nvram variable override this */
+		sprintf(varname, "wl%did", unit);
+		if ((core = getintvar(NULL, varname)) == 0) {
+			if (chip == BCM4712_DEVICE_ID) {
+				if (chippkg == BCM4712SMALL_PKG_ID)
+					core = BCM4306_D11G_ID;
+				else
+					core = BCM4306_D11DUAL_ID;
+			}
+		}
+		break;
+
+	default:
+		class = subclass = progif = 0xff;
+		break;
+	}
+
+	*pcivendor = (uint16)vendor;
+	*pcidevice = (uint16)core;
+	*pciclass = class;
+	*pcisubclass = subclass;
+	*pciprogif = progif;
+}
+
+/* Fix chip's configuration. The current core may be changed upon return */
+static int
+sb_pci_fixcfg(sb_info_t *si)
+{
+	uint origidx, pciidx;
+	sbpciregs_t *pciregs;
+	uint16 val16, *reg16;
+
+	ASSERT(BUSTYPE(si->sb.bustype) == PCI_BUS);
+
+	/* Fix PCI(e) SROM shadow area */
+	/* save the current index */
+	origidx = sb_coreidx(&si->sb);
+
+	if (si->sb.buscoretype == SB_PCI) {
+		pciregs = (sbpciregs_t *)sb_setcore(&si->sb, SB_PCI, 0);
+		ASSERT(pciregs);
+		reg16 = &pciregs->sprom[SRSH_PI_OFFSET];
+	}
+	else {
+		ASSERT(0);
+		return -1;
+	}
+	pciidx = sb_coreidx(&si->sb);
+	val16 = R_REG(reg16);
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16)pciidx) {
+		val16 = (uint16)(pciidx << SRSH_PI_SHIFT) | (val16 & ~SRSH_PI_MASK);
+		W_REG(reg16, val16);
+	}
+
+	/* restore the original index */
+	sb_setcoreidx(&si->sb, origidx);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(sb_boardtype);
+EXPORT_SYMBOL(sb_boardvendor);
+EXPORT_SYMBOL(sb_gpiocontrol);
+EXPORT_SYMBOL(sb_gpioin);
+EXPORT_SYMBOL(sb_gpiointmask);
+EXPORT_SYMBOL(sb_gpiointpolarity);
+EXPORT_SYMBOL(sb_gpioled);
+EXPORT_SYMBOL(sb_gpioout);
+EXPORT_SYMBOL(sb_gpioouten);
+EXPORT_SYMBOL(sb_gpiorelease);
+EXPORT_SYMBOL(sb_gpioreserve);
+EXPORT_SYMBOL(sb_gpiosetcore);
+EXPORT_SYMBOL(sb_gpiotimerval);
+EXPORT_SYMBOL(sb_watchdog);
diff -Nur linux-2.6.16/arch/mips/bcm947xx/broadcom/sflash.c linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sflash.c
--- linux-2.6.16/arch/mips/bcm947xx/broadcom/sflash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/broadcom/sflash.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,418 @@
+/*
+ * Broadcom SiliconBackplane chipcommon serial flash interface
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * $Id$
+ */
+
+#include <osl.h>
+#include <typedefs.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <mipsinc.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <sflash.h>
+
+/* Private global state */
+static struct sflash sflash;
+
+/* Issue a serial flash command */
+static INLINE void
+sflash_cmd(chipcregs_t *cc, uint opcode)
+{
+	W_REG(&cc->flashcontrol, SFLASH_START | opcode);
+	while (R_REG(&cc->flashcontrol) & SFLASH_BUSY);
+}
+
+/* Initialize serial flash access */
+struct sflash *
+sflash_init(chipcregs_t *cc)
+{
+	uint32 id, id2;
+
+	bzero(&sflash, sizeof(sflash));
+
+	sflash.type = R_REG(&cc->capabilities) & CAP_FLASH_MASK;
+
+	switch (sflash.type) {
+	case SFLASH_ST:
+		/* Probe for ST chips */
+		sflash_cmd(cc, SFLASH_ST_DP);
+		sflash_cmd(cc, SFLASH_ST_RES);
+		id = R_REG(&cc->flashdata);
+		switch (id) {
+		case 0x11:
+			/* ST M25P20 2 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 4;
+			break;
+		case 0x12:
+			/* ST M25P40 4 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 8;
+			break;
+		case 0x13:
+			/* ST M25P80 8 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 16;
+			break;
+		case 0x14:
+			/* ST M25P16 16 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 32;
+			break;
+		case 0x15:
+			/* ST M25P32 32 Mbit Serial Flash */
+			sflash.blocksize = 64 * 1024;
+			sflash.numblocks = 64;
+			break;
+		case 0xbf:
+			W_REG(&cc->flashaddress, 1);
+			sflash_cmd(cc, SFLASH_ST_RES);
+			id2 = R_REG(&cc->flashdata);
+			if (id2 == 0x44) {
+				/* SST M25VF80 4 Mbit Serial Flash */
+				sflash.blocksize = 64 * 1024;
+				sflash.numblocks = 8;
+			}
+			break;
+		}
+		break;
+
+	case SFLASH_AT:
+		/* Probe for Atmel chips */
+		sflash_cmd(cc, SFLASH_AT_STATUS);
+		id = R_REG(&cc->flashdata) & 0x3c;
+		switch (id) {
+		case 0xc:
+			/* Atmel AT45DB011 1Mbit Serial Flash */
+			sflash.blocksize = 256;
+			sflash.numblocks = 512;
+			break;
+		case 0x14:
+			/* Atmel AT45DB021 2Mbit Serial Flash */
+			sflash.blocksize = 256;
+			sflash.numblocks = 1024;
+			break;
+		case 0x1c:
+			/* Atmel AT45DB041 4Mbit Serial Flash */
+			sflash.blocksize = 256;
+			sflash.numblocks = 2048;
+			break;
+		case 0x24:
+			/* Atmel AT45DB081 8Mbit Serial Flash */
+			sflash.blocksize = 256;
+			sflash.numblocks = 4096;
+			break;
+		case 0x2c:
+			/* Atmel AT45DB161 16Mbit Serial Flash */
+			sflash.blocksize = 512;
+			sflash.numblocks = 4096;
+			break;
+		case 0x34:
+			/* Atmel AT45DB321 32Mbit Serial Flash */
+			sflash.blocksize = 512;
+			sflash.numblocks = 8192;
+			break;
+		case 0x3c:
+			/* Atmel AT45DB642 64Mbit Serial Flash */
+			sflash.blocksize = 1024;
+			sflash.numblocks = 8192;
+			break;
+		}
+		break;
+	}
+
+	sflash.size = sflash.blocksize * sflash.numblocks;
+	return sflash.size ? &sflash : NULL;
+}
+
+/* Read len bytes starting at offset into buf. Returns number of bytes read. */
+int
+sflash_read(chipcregs_t *cc, uint offset, uint len, uchar *buf)
+{
+	int cnt;
+	uint32 *from, *to;
+
+	if (!len)
+		return 0;
+
+	if ((offset + len) > sflash.size)
+		return -22;
+
+	if ((len >= 4) && (offset & 3))
+		cnt = 4 - (offset & 3);
+	else if ((len >= 4) && ((uint32)buf & 3))
+		cnt = 4 - ((uint32)buf & 3);
+	else
+		cnt = len;
+
+	from = (uint32 *)KSEG1ADDR(SB_FLASH2 + offset);
+	to = (uint32 *)buf;
+
+	if (cnt < 4) {
+		bcopy(from, to, cnt);
+		return cnt;
+	}
+
+	while (cnt >= 4) {
+		*to++ = *from++;
+		cnt -= 4;
+	}
+
+	return (len - cnt);
+}
+
+/* Poll for command completion. Returns zero when complete. */
+int
+sflash_poll(chipcregs_t *cc, uint offset)
+{
+	if (offset >= sflash.size)
+		return -22;
+
+	switch (sflash.type) {
+	case SFLASH_ST:
+		/* Check for ST Write In Progress bit */
+		sflash_cmd(cc, SFLASH_ST_RDSR);
+		return R_REG(&cc->flashdata) & SFLASH_ST_WIP;
+	case SFLASH_AT:
+		/* Check for Atmel Ready bit */
+		sflash_cmd(cc, SFLASH_AT_STATUS);
+		return !(R_REG(&cc->flashdata) & SFLASH_AT_READY);
+	}
+
+	return 0;
+}
+
+/* Write len bytes starting at offset into buf. Returns number of bytes
+ * written. Caller should poll for completion.
+ */
+int
+sflash_write(chipcregs_t *cc, uint offset, uint len, const uchar *buf)
+{
+	struct sflash *sfl;
+	int ret = 0;
+	bool is4712b0;
+	uint32 page, byte, mask;
+
+	if (!len)
+		return 0;
+
+	if ((offset + len) > sflash.size)
+		return -22;
+
+	sfl = &sflash;
+	switch (sfl->type) {
+	case SFLASH_ST:
+		mask = R_REG(&cc->chipid);
+		is4712b0 = (((mask & CID_ID_MASK) == BCM4712_DEVICE_ID) &&
+			    ((mask & CID_REV_MASK) == (3 << CID_REV_SHIFT)));
+		/* Enable writes */
+		sflash_cmd(cc, SFLASH_ST_WREN);
+		if (is4712b0) {
+			mask = 1 << 14;
+			W_REG(&cc->flashaddress, offset);
+			W_REG(&cc->flashdata, *buf++);
+			/* Set chip select */
+			OR_REG(&cc->gpioout, mask);
+			/* Issue a page program with the first byte */
+			sflash_cmd(cc, SFLASH_ST_PP);
+			ret = 1;
+			offset++;
+			len--;
+			while (len > 0) {
+				if ((offset & 255) == 0) {
+					/* Page boundary, drop cs and return */
+					AND_REG(&cc->gpioout, ~mask);
+					if (!sflash_poll(cc, offset)) {
+						/* Flash rejected command */
+						return -11;
+					}
+					return ret;
+				} else {
+					/* Write single byte */
+					sflash_cmd(cc, *buf++);
+				}
+				ret++;
+				offset++;
+				len--;
+			}
+			/* All done, drop cs if needed */
+			if ((offset & 255) != 1) {
+				/* Drop cs */
+				AND_REG(&cc->gpioout, ~mask);
+				if (!sflash_poll(cc, offset)) {
+					/* Flash rejected command */
+					return -12;
+				}
+			}
+		} else {
+			ret = 1;
+			W_REG(&cc->flashaddress, offset);
+			W_REG(&cc->flashdata, *buf);
+			/* Page program */
+			sflash_cmd(cc, SFLASH_ST_PP);
+		}
+		break;
+	case SFLASH_AT:
+		mask = sfl->blocksize - 1;
+		page = (offset & ~mask) << 1;
+		byte = offset & mask;
+		/* Read main memory page into buffer 1 */
+		if (byte || len < sfl->blocksize) {
+			W_REG(&cc->flashaddress, page);
+			sflash_cmd(cc, SFLASH_AT_BUF1_LOAD);
+			/* 250 us for AT45DB321B */
+			SPINWAIT(sflash_poll(cc, offset), 1000);
+			ASSERT(!sflash_poll(cc, offset));
+		}
+		/* Write into buffer 1 */
+		for (ret = 0; ret < len && byte < sfl->blocksize; ret++) {
+			W_REG(&cc->flashaddress, byte++);
+			W_REG(&cc->flashdata, *buf++);
+			sflash_cmd(cc, SFLASH_AT_BUF1_WRITE);
+		}
+		/* Write buffer 1 into main memory page */
+		W_REG(&cc->flashaddress, page);
+		sflash_cmd(cc, SFLASH_AT_BUF1_PROGRAM);
+		break;
+	}
+
+	return ret;
+}
+
+/* Erase a region. Returns number of bytes scheduled for erasure.
+ * Caller should poll for completion.
+ */
+int
+sflash_erase(chipcregs_t *cc, uint offset)
+{
+	struct sflash *sfl;
+
+	if (offset >= sflash.size)
+		return -22;
+
+	sfl = &sflash;
+	switch (sfl->type) {
+	case SFLASH_ST:
+		sflash_cmd(cc, SFLASH_ST_WREN);
+		W_REG(&cc->flashaddress, offset);
+		sflash_cmd(cc, SFLASH_ST_SE);
+		return sfl->blocksize;
+	case SFLASH_AT:
+		W_REG(&cc->flashaddress, offset << 1);
+		sflash_cmd(cc, SFLASH_AT_PAGE_ERASE);
+		return sfl->blocksize;
+	}
+
+	return 0;
+}
+
+/*
+ * writes the appropriate range of flash, a NULL buf simply erases
+ * the region of flash
+ */
+int
+sflash_commit(chipcregs_t *cc, uint offset, uint len, const uchar *buf)
+{
+	struct sflash *sfl;
+	uchar *block = NULL, *cur_ptr, *blk_ptr;
+	uint blocksize = 0, mask, cur_offset, cur_length, cur_retlen, remainder;
+	uint blk_offset, blk_len, copied;
+	int bytes, ret = 0;
+
+	/* Check address range */
+	if (len <= 0)
+		return 0;
+
+	sfl = &sflash;
+	if ((offset + len) > sfl->size)
+		return -1;
+
+	blocksize = sfl->blocksize;
+	mask = blocksize - 1;
+
+	/* Allocate a block of mem */
+	if (!(block = MALLOC(NULL, blocksize)))
+		return -1;
+
+	while (len) {
+		/* Align offset */
+		cur_offset = offset & ~mask;
+		cur_length = blocksize;
+		cur_ptr = block;
+
+		remainder = blocksize - (offset & mask);
+		if (len < remainder)
+			cur_retlen = len;
+		else
+			cur_retlen = remainder;
+
+		/* buf == NULL means erase only */
+		if (buf) {
+			/* Copy existing data into holding block if necessary */
+			if ((offset & mask)  || (len < blocksize)) {
+				blk_offset = cur_offset;
+				blk_len = cur_length;
+				blk_ptr = cur_ptr;
+
+				/* Copy entire block */
+				while(blk_len) {
+					copied = sflash_read(cc, blk_offset, blk_len, blk_ptr); 
+					blk_offset += copied;
+					blk_len -= copied;
+					blk_ptr += copied;
+				}
+			}
+
+			/* Copy input data into holding block */
+			memcpy(cur_ptr + (offset & mask), buf, cur_retlen);
+		}
+
+		/* Erase block */
+		if ((ret = sflash_erase(cc, (uint) cur_offset)) < 0)
+			goto done;
+		while (sflash_poll(cc, (uint) cur_offset));
+
+		/* buf == NULL means erase only */
+		if (!buf) {
+			offset += cur_retlen;
+			len -= cur_retlen;
+			continue;
+		}
+
+		/* Write holding block */
+		while (cur_length > 0) {
+			if ((bytes = sflash_write(cc,
+						  (uint) cur_offset,
+						  (uint) cur_length,
+						  (uchar *) cur_ptr)) < 0) {
+				ret = bytes;
+				goto done;
+			}
+			while (sflash_poll(cc, (uint) cur_offset));
+			cur_offset += bytes;
+			cur_length -= bytes;
+			cur_ptr += bytes;
+		}
+
+		offset += cur_retlen;
+		len -= cur_retlen;
+		buf += cur_retlen;
+	}
+
+	ret = len;
+done:
+	if (block)
+		MFREE(NULL, block, blocksize);
+	return ret;
+}
+
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bcmdevs.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmdevs.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bcmdevs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmdevs.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,391 @@
+/*
+ * Broadcom device-specific manifest constants.
+ *
+ * Copyright 2005, Broadcom Corporation   
+ * All Rights Reserved.   
+ *    
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY   
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM   
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS   
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.   
+ * $Id$
+ */
+
+#ifndef	_BCMDEVS_H
+#define	_BCMDEVS_H
+
+
+/* Known PCI vendor Id's */
+#define	VENDOR_EPIGRAM		0xfeda
+#define	VENDOR_BROADCOM		0x14e4
+#define	VENDOR_3COM		0x10b7
+#define	VENDOR_NETGEAR		0x1385
+#define	VENDOR_DIAMOND		0x1092
+#define	VENDOR_DELL		0x1028
+#define	VENDOR_HP		0x0e11
+#define	VENDOR_APPLE		0x106b
+
+/* PCI Device Id's */
+#define	BCM4210_DEVICE_ID	0x1072		/* never used */
+#define	BCM4211_DEVICE_ID	0x4211
+#define	BCM4230_DEVICE_ID	0x1086		/* never used */
+#define	BCM4231_DEVICE_ID	0x4231
+
+#define	BCM4410_DEVICE_ID	0x4410		/* bcm44xx family pci iline */
+#define	BCM4430_DEVICE_ID	0x4430		/* bcm44xx family cardbus iline */
+#define	BCM4412_DEVICE_ID	0x4412		/* bcm44xx family pci enet */
+#define	BCM4432_DEVICE_ID	0x4432		/* bcm44xx family cardbus enet */
+
+#define	BCM3352_DEVICE_ID	0x3352		/* bcm3352 device id */
+#define	BCM3360_DEVICE_ID	0x3360		/* bcm3360 device id */
+
+#define	EPI41210_DEVICE_ID	0xa0fa		/* bcm4210 */
+#define	EPI41230_DEVICE_ID	0xa10e		/* bcm4230 */
+
+#define	BCM47XX_ILINE_ID	0x4711		/* 47xx iline20 */
+#define	BCM47XX_V90_ID		0x4712		/* 47xx v90 codec */
+#define	BCM47XX_ENET_ID		0x4713		/* 47xx enet */
+#define	BCM47XX_EXT_ID		0x4714		/* 47xx external i/f */
+#define	BCM47XX_USB_ID		0x4715		/* 47xx usb */
+#define	BCM47XX_USBH_ID		0x4716		/* 47xx usb host */
+#define	BCM47XX_USBD_ID		0x4717		/* 47xx usb device */
+#define	BCM47XX_IPSEC_ID	0x4718		/* 47xx ipsec */
+#define	BCM47XX_ROBO_ID		0x4719		/* 47xx/53xx roboswitch core */
+#define	BCM47XX_USB20H_ID	0x471a		/* 47xx usb 2.0 host */
+#define	BCM47XX_USB20D_ID	0x471b		/* 47xx usb 2.0 device */
+
+#define	BCM4710_DEVICE_ID	0x4710		/* 4710 primary function 0 */
+
+#define	BCM4610_DEVICE_ID	0x4610		/* 4610 primary function 0 */
+#define	BCM4610_ILINE_ID	0x4611		/* 4610 iline100 */
+#define	BCM4610_V90_ID		0x4612		/* 4610 v90 codec */
+#define	BCM4610_ENET_ID		0x4613		/* 4610 enet */
+#define	BCM4610_EXT_ID		0x4614		/* 4610 external i/f */
+#define	BCM4610_USB_ID		0x4615		/* 4610 usb */
+
+#define	BCM4402_DEVICE_ID	0x4402		/* 4402 primary function 0 */
+#define	BCM4402_ENET_ID		0x4402		/* 4402 enet */
+#define	BCM4402_V90_ID		0x4403		/* 4402 v90 codec */
+#define	BCM4401_ENET_ID		0x170c		/* 4401b0 production enet cards */
+
+#define	BCM4301_DEVICE_ID	0x4301		/* 4301 primary function 0 */
+#define	BCM4301_D11B_ID		0x4301		/* 4301 802.11b */
+
+#define	BCM4307_DEVICE_ID	0x4307		/* 4307 primary function 0 */
+#define	BCM4307_V90_ID		0x4305		/* 4307 v90 codec */
+#define	BCM4307_ENET_ID		0x4306		/* 4307 enet */
+#define	BCM4307_D11B_ID		0x4307		/* 4307 802.11b */
+
+#define	BCM4306_DEVICE_ID	0x4306		/* 4306 chipcommon chipid */
+#define	BCM4306_D11G_ID		0x4320		/* 4306 802.11g */
+#define	BCM4306_D11G_ID2	0x4325		
+#define	BCM4306_D11A_ID		0x4321		/* 4306 802.11a */
+#define	BCM4306_UART_ID		0x4322		/* 4306 uart */
+#define	BCM4306_V90_ID		0x4323		/* 4306 v90 codec */
+#define	BCM4306_D11DUAL_ID	0x4324		/* 4306 dual A+B */
+
+#define	BCM4309_PKG_ID		1		/* 4309 package id */
+
+#define	BCM4303_D11B_ID		0x4303		/* 4303 802.11b */
+#define	BCM4303_PKG_ID		2		/* 4303 package id */
+
+#define	BCM4310_DEVICE_ID	0x4310		/* 4310 chipcommon chipid */
+#define	BCM4310_D11B_ID		0x4311		/* 4310 802.11b */
+#define	BCM4310_UART_ID		0x4312		/* 4310 uart */
+#define	BCM4310_ENET_ID		0x4313		/* 4310 enet */
+#define	BCM4310_USB_ID		0x4315		/* 4310 usb */
+
+#define	BCMGPRS_UART_ID		0x4333		/* Uart id used by 4306/gprs card */
+#define	BCMGPRS2_UART_ID	0x4344		/* Uart id used by 4306/gprs card */
+
+
+#define	BCM4704_DEVICE_ID	0x4704		/* 4704 chipcommon chipid */
+#define	BCM4704_ENET_ID		0x4706		/* 4704 enet (Use 47XX_ENET_ID instead!) */
+
+#define	BCM4317_DEVICE_ID	0x4317		/* 4317 chip common chipid */
+
+#define	BCM4318_DEVICE_ID	0x4318		/* 4318 chip common chipid */
+#define	BCM4318_D11G_ID		0x4318		/* 4318 801.11b/g id */
+#define	BCM4318_D11DUAL_ID	0x4319		/* 4318 801.11a/b/g id */
+#define BCM4318_JTAGM_ID	0x4331		/* 4318 jtagm device id */
+
+#define FPGA_JTAGM_ID		0x4330		/* ??? */
+
+/* Address map */
+#define BCM4710_SDRAM           0x00000000      /* Physical SDRAM */
+#define BCM4710_PCI_MEM         0x08000000      /* Host Mode PCI memory access space (64 MB) */
+#define BCM4710_PCI_CFG         0x0c000000      /* Host Mode PCI configuration space (64 MB) */
+#define BCM4710_PCI_DMA         0x40000000      /* Client Mode PCI memory access space (1 GB) */
+#define BCM4710_SDRAM_SWAPPED   0x10000000      /* Byteswapped Physical SDRAM */
+#define BCM4710_ENUM            0x18000000      /* Beginning of core enumeration space */
+
+/* Core register space */
+#define BCM4710_REG_SDRAM       0x18000000      /* SDRAM core registers */
+#define BCM4710_REG_ILINE20     0x18001000      /* InsideLine20 core registers */
+#define BCM4710_REG_EMAC0       0x18002000      /* Ethernet MAC 0 core registers */
+#define BCM4710_REG_CODEC       0x18003000      /* Codec core registers */
+#define BCM4710_REG_USB         0x18004000      /* USB core registers */
+#define BCM4710_REG_PCI         0x18005000      /* PCI core registers */
+#define BCM4710_REG_MIPS        0x18006000      /* MIPS core registers */
+#define BCM4710_REG_EXTIF       0x18007000      /* External Interface core registers */
+#define BCM4710_REG_EMAC1       0x18008000      /* Ethernet MAC 1 core registers */
+
+#define BCM4710_EXTIF           0x1f000000      /* External Interface base address */
+#define BCM4710_PCMCIA_MEM      0x1f000000      /* External Interface PCMCIA memory access */
+#define BCM4710_PCMCIA_IO       0x1f100000      /* PCMCIA I/O access */
+#define BCM4710_PCMCIA_CONF     0x1f200000      /* PCMCIA configuration */
+#define BCM4710_PROG            0x1f800000      /* Programable interface */
+#define BCM4710_FLASH           0x1fc00000      /* Flash */
+
+#define BCM4710_EJTAG           0xff200000      /* MIPS EJTAG space (2M) */
+
+#define BCM4710_UART            (BCM4710_REG_EXTIF + 0x00000300)
+
+#define BCM4710_EUART           (BCM4710_EXTIF + 0x00800000)
+#define BCM4710_LED             (BCM4710_EXTIF + 0x00900000)
+
+#define	BCM4712_DEVICE_ID	0x4712		/* 4712 chipcommon chipid */
+#define	BCM4712_MIPS_ID		0x4720		/* 4712 base devid */
+#define	BCM4712LARGE_PKG_ID	0		/* 340pin 4712 package id */
+#define	BCM4712SMALL_PKG_ID	1		/* 200pin 4712 package id */
+#define	BCM4712MID_PKG_ID	2		/* 225pin 4712 package id */
+
+#define	SDIOH_FPGA_ID		0x4380		/* sdio host fpga */
+
+#define BCM5365_DEVICE_ID       0x5365          /* 5365 chipcommon chipid */
+#define	BCM5350_DEVICE_ID	0x5350		/* bcm5350 chipcommon chipid */
+#define	BCM5352_DEVICE_ID	0x5352		/* bcm5352 chipcommon chipid */
+
+#define	BCM4320_DEVICE_ID	0x4320		/* bcm4320 chipcommon chipid */
+
+/* PCMCIA vendor Id's */
+
+#define	VENDOR_BROADCOM_PCMCIA	0x02d0
+
+/* SDIO vendor Id's */
+#define	VENDOR_BROADCOM_SDIO	0x00BF
+
+
+/* boardflags */
+#define	BFL_BTCOEXIST		0x0001	/* This board implements Bluetooth coexistance */
+#define	BFL_PACTRL		0x0002	/* This board has gpio 9 controlling the PA */
+#define	BFL_AIRLINEMODE		0x0004	/* This board implements gpio13 radio disable indication */
+#define	BFL_ENETROBO		0x0010	/* This board has robo switch or core */
+#define	BFL_CCKHIPWR		0x0040	/* Can do high-power CCK transmission */
+#define	BFL_ENETADM		0x0080	/* This board has ADMtek switch */
+#define	BFL_ENETVLAN		0x0100	/* This board has vlan capability */
+#define	BFL_AFTERBURNER		0x0200	/* This board supports Afterburner mode */
+#define BFL_NOPCI		0x0400	/* This board leaves PCI floating */
+#define BFL_FEM			0x0800  /* This board supports the Front End Module */
+#define BFL_EXTLNA		0x1000	/* This board has an external LNA */
+#define BFL_HGPA		0x2000	/* This board has a high gain PA */
+#define	BFL_BTCMOD		0x4000	/* This board' BTCOEXIST is in the alternate gpios */
+#define	BFL_ALTIQ		0x8000	/* Alternate I/Q settings */
+
+/* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
+#define BOARD_GPIO_HWRAD_B	0x010	/* bit 4 is HWRAD input on 4301 */
+#define	BOARD_GPIO_BTCMOD_IN	0x010	/* bit 4 is the alternate BT Coexistance Input */
+#define	BOARD_GPIO_BTCMOD_OUT	0x020	/* bit 5 is the alternate BT Coexistance Out */
+#define	BOARD_GPIO_BTC_IN	0x080	/* bit 7 is BT Coexistance Input */
+#define	BOARD_GPIO_BTC_OUT	0x100	/* bit 8 is BT Coexistance Out */
+#define	BOARD_GPIO_PACTRL	0x200	/* bit 9 controls the PA on new 4306 boards */
+#define	PCI_CFG_GPIO_SCS	0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define PCI_CFG_GPIO_HWRAD	0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+/* Bus types */
+#define	SB_BUS			0	/* Silicon Backplane */
+#define	PCI_BUS			1	/* PCI target */
+#define	PCMCIA_BUS		2	/* PCMCIA target */
+#define SDIO_BUS		3	/* SDIO target */
+#define JTAG_BUS		4	/* JTAG */
+
+/* Allows optimization for single-bus support */
+#ifdef BCMBUSTYPE
+#define BUSTYPE(bus) (BCMBUSTYPE)
+#else
+#define BUSTYPE(bus) (bus)
+#endif
+
+/* power control defines */
+#define PLL_DELAY		150		/* us pll on delay */
+#define FREF_DELAY		200		/* us fref change delay */
+#define MIN_SLOW_CLK		32		/* us Slow clock period */
+#define	XTAL_ON_DELAY		1000		/* us crystal power-on delay */
+
+/* Reference Board Types */
+
+#define	BU4710_BOARD		0x0400
+#define	VSIM4710_BOARD		0x0401
+#define	QT4710_BOARD		0x0402
+
+#define	BU4610_BOARD		0x0403
+#define	VSIM4610_BOARD		0x0404
+
+#define	BU4307_BOARD		0x0405
+#define	BCM94301CB_BOARD	0x0406
+#define	BCM94301PC_BOARD	0x0406		/* Pcmcia 5v card */
+#define	BCM94301MP_BOARD	0x0407
+#define	BCM94307MP_BOARD	0x0408
+#define	BCMAP4307_BOARD		0x0409
+
+#define	BU4309_BOARD		0x040a
+#define	BCM94309CB_BOARD	0x040b
+#define	BCM94309MP_BOARD	0x040c
+#define	BCM4309AP_BOARD		0x040d
+
+#define	BCM94302MP_BOARD	0x040e
+
+#define	VSIM4310_BOARD		0x040f
+#define	BU4711_BOARD		0x0410
+#define	BCM94310U_BOARD		0x0411
+#define	BCM94310AP_BOARD	0x0412
+#define	BCM94310MP_BOARD	0x0414
+
+#define	BU4306_BOARD		0x0416
+#define	BCM94306CB_BOARD	0x0417
+#define	BCM94306MP_BOARD	0x0418
+
+#define	BCM94710D_BOARD		0x041a
+#define	BCM94710R1_BOARD	0x041b
+#define	BCM94710R4_BOARD	0x041c
+#define	BCM94710AP_BOARD	0x041d
+
+
+#define	BU2050_BOARD		0x041f
+
+
+#define	BCM94309G_BOARD		0x0421
+
+#define	BCM94301PC3_BOARD	0x0422		/* Pcmcia 3.3v card */
+
+#define	BU4704_BOARD		0x0423
+#define	BU4702_BOARD		0x0424
+
+#define	BCM94306PC_BOARD	0x0425		/* pcmcia 3.3v 4306 card */
+
+#define	BU4317_BOARD		0x0426
+
+
+#define	BCM94702MN_BOARD	0x0428
+
+/* BCM4702 1U CompactPCI Board */
+#define	BCM94702CPCI_BOARD	0x0429
+
+/* BCM4702 with BCM95380 VLAN Router */
+#define	BCM95380RR_BOARD	0x042a
+
+/* cb4306 with SiGe PA */
+#define	BCM94306CBSG_BOARD	0x042b
+
+/* mp4301 with 2050 radio */
+#define	BCM94301MPL_BOARD	0x042c
+
+/* cb4306 with SiGe PA */
+#define	PCSG94306_BOARD		0x042d
+
+/* bu4704 with sdram */
+#define	BU4704SD_BOARD		0x042e
+
+/* Dual 11a/11g Router */
+#define	BCM94704AGR_BOARD	0x042f
+
+/* 11a-only minipci */
+#define	BCM94308MP_BOARD	0x0430
+
+
+
+/* BCM94317 boards */
+#define BCM94317CB_BOARD	0x0440
+#define BCM94317MP_BOARD	0x0441
+#define BCM94317PCMCIA_BOARD	0x0442
+#define BCM94317SDIO_BOARD	0x0443
+
+#define BU4712_BOARD		0x0444
+#define	BU4712SD_BOARD		0x045d
+#define	BU4712L_BOARD		0x045f
+
+/* BCM4712 boards */
+#define BCM94712AP_BOARD	0x0445
+#define BCM94712P_BOARD		0x0446
+
+/* BCM4318 boards */
+#define BU4318_BOARD		0x0447
+#define CB4318_BOARD		0x0448
+#define MPG4318_BOARD		0x0449
+#define MP4318_BOARD		0x044a
+#define SD4318_BOARD		0x044b
+
+/* BCM63XX boards */
+#define BCM96338_BOARD		0x6338
+#define BCM96345_BOARD		0x6345
+#define BCM96348_BOARD		0x6348
+
+/* Another mp4306 with SiGe */
+#define	BCM94306P_BOARD		0x044c
+
+/* CF-like 4317 modules */
+#define	BCM94317CF_BOARD	0x044d
+
+/* mp4303 */
+#define	BCM94303MP_BOARD	0x044e
+
+/* mpsgh4306 */
+#define	BCM94306MPSGH_BOARD	0x044f
+
+/* BRCM 4306 w/ Front End Modules */
+#define BCM94306MPM  		0x0450
+#define BCM94306MPL  		0x0453
+
+/* 4712agr */
+#define	BCM94712AGR_BOARD	0x0451
+
+/* The real CF 4317 board */
+#define	CFI4317_BOARD		0x0452
+
+/* pcmcia 4303 */
+#define	PC4303_BOARD		0x0454
+
+/* 5350K */
+#define	BCM95350K_BOARD		0x0455
+
+/* 5350R */
+#define	BCM95350R_BOARD		0x0456
+
+/* 4306mplna */
+#define	BCM94306MPLNA_BOARD	0x0457
+
+/* 4320 boards */
+#define	BU4320_BOARD		0x0458
+#define	BU4320S_BOARD		0x0459
+#define	BCM94320PH_BOARD	0x045a
+
+/* 4306mph */
+#define	BCM94306MPH_BOARD	0x045b
+
+/* 4306pciv */
+#define	BCM94306PCIV_BOARD	0x045c
+
+#define	BU4712SD_BOARD		0x045d
+
+#define	BCM94320PFLSH_BOARD	0x045e
+
+#define	BU4712L_BOARD		0x045f
+#define	BCM94712LGR_BOARD	0x0460
+#define	BCM94320R_BOARD		0x0461
+
+#define	BU5352_BOARD		0x0462
+
+#define	BCM94318MPGH_BOARD	0x0463
+
+
+#define	BCM95352GR_BOARD	0x0467
+
+/* bcm95351agr */
+#define	BCM95351AGR_BOARD	0x0470
+
+/* # of GPIO pins */
+#define GPIO_NUMPINS		16
+
+#endif /* _BCMDEVS_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bcmendian.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmendian.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bcmendian.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmendian.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,152 @@
+/*
+ * local version of endian.h - byte order defines
+ *
+ * Copyright 2005, Broadcom Corporation   
+ * All Rights Reserved.   
+ *    
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY   
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM   
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS   
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.   
+ *
+ *  $Id$
+*/
+
+#ifndef _BCMENDIAN_H_
+#define _BCMENDIAN_H_
+
+#include <typedefs.h>
+
+/* Byte swap a 16 bit value */
+#define BCMSWAP16(val) \
+	((uint16)( \
+		(((uint16)(val) & (uint16)0x00ffU) << 8) | \
+		(((uint16)(val) & (uint16)0xff00U) >> 8) ))
+	
+/* Byte swap a 32 bit value */
+#define BCMSWAP32(val) \
+	((uint32)( \
+		(((uint32)(val) & (uint32)0x000000ffUL) << 24) | \
+		(((uint32)(val) & (uint32)0x0000ff00UL) <<  8) | \
+		(((uint32)(val) & (uint32)0x00ff0000UL) >>  8) | \
+		(((uint32)(val) & (uint32)0xff000000UL) >> 24) ))
+		
+/* 2 Byte swap a 32 bit value */
+#define BCMSWAP32BY16(val) \
+	((uint32)( \
+		(((uint32)(val) & (uint32)0x0000ffffUL) << 16) | \
+		(((uint32)(val) & (uint32)0xffff0000UL) >> 16) ))
+		
+
+static INLINE uint16
+bcmswap16(uint16 val)
+{
+	return BCMSWAP16(val);
+}
+
+static INLINE uint32
+bcmswap32(uint32 val)
+{
+	return BCMSWAP32(val);
+}
+
+static INLINE uint32
+bcmswap32by16(uint32 val)
+{
+	return BCMSWAP32BY16(val);
+}
+
+/* buf	- start of buffer of shorts to swap */
+/* len  - byte length of buffer */
+static INLINE void
+bcmswap16_buf(uint16 *buf, uint len)
+{
+	len = len/2;
+
+	while(len--){
+		*buf = bcmswap16(*buf);
+		buf++;
+	}
+}
+
+#ifndef hton16
+#ifndef IL_BIGENDIAN
+#define HTON16(i) BCMSWAP16(i)
+#define	hton16(i) bcmswap16(i)
+#define	hton32(i) bcmswap32(i)
+#define	ntoh16(i) bcmswap16(i)
+#define	ntoh32(i) bcmswap32(i)
+#define ltoh16(i) (i)
+#define ltoh32(i) (i)
+#define htol16(i) (i)
+#define htol32(i) (i)
+#else
+#define HTON16(i) (i)
+#define	hton16(i) (i)
+#define	hton32(i) (i)
+#define	ntoh16(i) (i)
+#define	ntoh32(i) (i)
+#define	ltoh16(i) bcmswap16(i)
+#define	ltoh32(i) bcmswap32(i)
+#define htol16(i) bcmswap16(i)
+#define htol32(i) bcmswap32(i)
+#endif
+#endif
+
+#ifndef IL_BIGENDIAN
+#define ltoh16_buf(buf, i)
+#define htol16_buf(buf, i)
+#else
+#define ltoh16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
+#define htol16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
+#endif
+
+/*
+* load 16-bit value from unaligned little endian byte array.
+*/
+static INLINE uint16
+ltoh16_ua(uint8 *bytes)
+{
+	return (bytes[1]<<8)+bytes[0];
+}
+
+/*
+* load 32-bit value from unaligned little endian byte array.
+*/
+static INLINE uint32
+ltoh32_ua(uint8 *bytes)
+{
+	return (bytes[3]<<24)+(bytes[2]<<16)+(bytes[1]<<8)+bytes[0];
+}
+
+/*
+* load 16-bit value from unaligned big(network) endian byte array.
+*/
+static INLINE uint16
+ntoh16_ua(uint8 *bytes)
+{
+	return (bytes[0]<<8)+bytes[1];
+}
+
+/*
+* load 32-bit value from unaligned big(network) endian byte array.
+*/
+static INLINE uint32
+ntoh32_ua(uint8 *bytes)
+{
+	return (bytes[0]<<24)+(bytes[1]<<16)+(bytes[2]<<8)+bytes[3];
+}
+
+#define ltoh_ua(ptr) ( \
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] : \
+	(((uint8 *)ptr)[3]<<24)+(((uint8 *)ptr)[2]<<16)+(((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] \
+)
+
+#define ntoh_ua(ptr) ( \
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[0]<<8)+((uint8 *)ptr)[1] : \
+	(((uint8 *)ptr)[0]<<24)+(((uint8 *)ptr)[1]<<16)+(((uint8 *)ptr)[2]<<8)+((uint8 *)ptr)[3] \
+)
+
+#endif /* _BCMENDIAN_H_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bcmnvram.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmnvram.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bcmnvram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmnvram.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * NVRAM variable manipulation
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef _bcmnvram_h_
+#define _bcmnvram_h_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <typedefs.h>
+
+struct nvram_header {
+	uint32 magic;
+	uint32 len;
+	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+	uint32 config_ncdl;	/* ncdl values for memc */
+};
+
+struct nvram_tuple {
+	char *name;
+	char *value;
+	struct nvram_tuple *next;
+};
+
+/*
+ * Get the value of an NVRAM variable. The pointer returned may be
+ * invalid after a set.
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+extern char * __init early_nvram_get(const char *name);
+
+/*
+ * Get the value of an NVRAM variable. The pointer returned may be
+ * invalid after a set.
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+extern char *nvram_get(const char *name);
+
+/* 
+ * Get the value of an NVRAM variable.
+ * @param	name	name of variable to get
+ * @return	value of variable or NUL if undefined
+ */
+#define nvram_safe_get(name) (BCMINIT(early_nvram_get)(name) ? : "")
+
+/*
+ * Match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is string equal
+ *		to match or FALSE otherwise
+ */
+static inline int
+nvram_match(char *name, char *match) {
+	const char *value = BCMINIT(early_nvram_get)(name);
+	return (value && !strcmp(value, match));
+}
+
+/*
+ * Inversely match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is not string
+ *		equal to invmatch or FALSE otherwise
+ */
+static inline int
+nvram_invmatch(char *name, char *invmatch) {
+	const char *value = BCMINIT(early_nvram_get)(name);
+	return (value && strcmp(value, invmatch));
+}
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define NVRAM_MAGIC		0x48534C46	/* 'FLSH' */
+#define NVRAM_VERSION		1
+#define NVRAM_HEADER_SIZE	20
+#define NVRAM_SPACE		0x8000
+
+#define NVRAM_MAX_VALUE_LEN 255
+#define NVRAM_MAX_PARAM_LEN 64
+
+#endif /* _bcmnvram_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bcmsrom.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmsrom.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bcmsrom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmsrom.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ * Misc useful routines to access NIC local SROM/OTP .
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef	_bcmsrom_h_
+#define	_bcmsrom_h_
+
+extern int srom_var_init(void *sbh, uint bus, void *curmap, osl_t *osh, char **vars, int *count);
+
+extern int srom_read(uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf);
+extern int srom_write(uint bus, void *curmap, osl_t *osh, uint byteoff, uint nbytes, uint16 *buf);
+
+#endif	/* _bcmsrom_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bcmutils.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmutils.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bcmutils.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bcmutils.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,308 @@
+/*
+ * Misc useful os-independent macros and functions.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+/*** driver-only section ***/
+#include <osl.h>
+
+#define _BCM_U	0x01	/* upper */
+#define _BCM_L	0x02	/* lower */
+#define _BCM_D	0x04	/* digit */
+#define _BCM_C	0x08	/* cntrl */
+#define _BCM_P	0x10	/* punct */
+#define _BCM_S	0x20	/* white space (space/lf/tab) */
+#define _BCM_X	0x40	/* hex digit */
+#define _BCM_SP	0x80	/* hard space (0x20) */
+
+#define GPIO_PIN_NOTDEFINED 	0x20 
+
+extern unsigned char bcm_ctype[];
+#define bcm_ismask(x) (bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* generic osl packet queue */
+struct pktq {
+	void *head;	/* first packet to dequeue */
+	void *tail;	/* last packet to dequeue */
+	uint len;	/* number of queued packets */
+	uint maxlen;	/* maximum number of queued packets */
+	bool priority;	/* enqueue by packet priority */
+	uint8 prio_map[MAXPRIO+1]; /* user priority to packet enqueue policy map */
+};
+#define DEFAULT_QLEN	128
+
+#define	pktq_len(q)	((q)->len)
+#define	pktq_avail(q)	((q)->maxlen - (q)->len)
+#define	pktq_head(q)	((q)->head)
+#define	pktq_full(q)	((q)->len >= (q)->maxlen)
+#define	_pktq_pri(q, pri)	((q)->prio_map[pri])
+#define	pktq_tailpri(q)	((q)->tail ? _pktq_pri(q, PKTPRIO((q)->tail)) : _pktq_pri(q, 0))
+
+/* externs */
+/* packet */
+extern uint pktcopy(osl_t *osh, void *p, uint offset, int len, uchar *buf);
+extern uint pkttotlen(osl_t *osh, void *);
+extern void pktq_init(struct pktq *q, uint maxlen, const uint8 prio_map[]);
+extern void pktenq(struct pktq *q, void *p, bool lifo);
+extern void *pktdeq(struct pktq *q);
+extern void *pktdeqtail(struct pktq *q);
+/* string */
+extern uint bcm_atoi(char *s);
+extern uchar bcm_toupper(uchar c);
+extern ulong bcm_strtoul(char *cp, char **endp, uint base);
+extern char *bcmstrstr(char *haystack, char *needle);
+extern char *bcmstrcat(char *dest, const char *src);
+extern ulong wchar2ascii(char *abuf, ushort *wbuf, ushort wbuflen, ulong abuflen);
+/* ethernet address */
+extern char *bcm_ether_ntoa(char *ea, char *buf);
+extern int bcm_ether_atoe(char *p, char *ea);
+/* delay */
+extern void bcm_mdelay(uint ms);
+/* variable access */
+extern char *getvar(char *vars, char *name);
+extern int getintvar(char *vars, char *name);
+extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplogent(buf, idx)	-1
+
+/*** driver/apps-shared section ***/
+
+#define BCME_STRLEN 		64
+#define VALID_BCMERROR(e)  ((e <= 0) && (e >= BCME_LAST))
+
+
+/* 
+ * error codes could be added but the defined ones shouldn't be changed/deleted 
+ * these error codes are exposed to the user code 
+ * when ever a new error code is added to this list 
+ * please update errorstring table with the related error string and 
+ * update osl files with os specific errorcode map   
+*/
+
+#define BCME_ERROR			-1	/* Error generic */
+#define BCME_BADARG			-2	/* Bad Argument */
+#define BCME_BADOPTION			-3	/* Bad option */
+#define BCME_NOTUP			-4	/* Not up */
+#define BCME_NOTDOWN			-5	/* Not down */
+#define BCME_NOTAP			-6	/* Not AP */
+#define BCME_NOTSTA			-7	/* Not STA  */
+#define BCME_BADKEYIDX			-8	/* BAD Key Index */
+#define BCME_RADIOOFF 			-9	/* Radio Off */
+#define BCME_NOTBANDLOCKED		-10	/* Not  bandlocked */
+#define BCME_NOCLK			-11	/* No Clock*/
+#define BCME_BADRATESET			-12	/* BAD RateSet*/
+#define BCME_BADBAND			-13	/* BAD Band */
+#define BCME_BUFTOOSHORT		-14	/* Buffer too short */	
+#define BCME_BUFTOOLONG			-15	/* Buffer too Long */	
+#define BCME_BUSY			-16	/* Busy*/	
+#define BCME_NOTASSOCIATED		-17	/* Not associated*/
+#define BCME_BADSSIDLEN			-18	/* BAD SSID Len */
+#define BCME_OUTOFRANGECHAN		-19	/* Out of Range Channel*/
+#define BCME_BADCHAN			-20	/* BAD Channel */
+#define BCME_BADADDR			-21	/* BAD Address*/
+#define BCME_NORESOURCE			-22	/* No resources*/
+#define BCME_UNSUPPORTED		-23	/* Unsupported*/
+#define BCME_BADLEN			-24	/* Bad Length*/
+#define BCME_NOTREADY			-25	/* Not ready Yet*/
+#define BCME_EPERM			-26	/* Not Permitted */
+#define BCME_NOMEM			-27	/* No Memory */
+#define BCME_ASSOCIATED			-28	/* Associated */
+#define BCME_RANGE			-29	/* Range Error*/
+#define BCME_NOTFOUND			-30	/* Not found */
+#define BCME_LAST			BCME_NOTFOUND	
+
+#ifndef ABS
+#define	ABS(a)			(((a)<0)?-(a):(a))
+#endif
+
+#ifndef MIN
+#define	MIN(a, b)		(((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define	MAX(a, b)		(((a)>(b))?(a):(b))
+#endif
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((a) & ((x)-1)) == 0)
+#define	ISPOWEROF2(x)		((((x)-1)&(x))==0)
+#define VALID_MASK(mask)	!((mask) & ((mask) + 1))
+#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+
+/* bit map related macros */
+#ifndef setbit
+#define	NBBY	8	/* 8 bits per byte */
+#define	setbit(a,i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	(((uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	((((uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif
+
+#define	NBITS(type)	(sizeof(type) * 8)
+#define NBITVAL(bits)	(1 << (bits))
+#define MAXBITVAL(bits)	((1 << (bits)) - 1)
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff		/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f		/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff		/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8		/* Good final CRC16 checksum value */
+#define CRC32_INIT_VALUE 0xffffffff	/* Initial CRC32 checksum value */
+#define CRC32_GOOD_VALUE 0xdebb20e3	/* Good final CRC32 checksum value */
+
+/* bcm_format_flags() bit description structure */
+typedef struct bcm_bit_desc {
+	uint32	bit;
+	char*	name;
+} bcm_bit_desc_t;
+
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+	uint8	id;
+	uint8	len;
+	uint8	data[1];
+} bcm_tlv_t;
+
+/* Check that bcm_tlv_t fits into the given buflen */
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
+
+/* buffer length for ethernet address from bcm_ether_ntoa() */
+#define ETHER_ADDR_STR_LEN	18
+
+/* unaligned load and store macros */
+#ifdef IL_BIGENDIAN
+static INLINE uint32
+load32_ua(uint8 *a)
+{
+	return ((a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]);
+}
+
+static INLINE void
+store32_ua(uint8 *a, uint32 v)
+{
+	a[0] = (v >> 24) & 0xff;
+	a[1] = (v >> 16) & 0xff;
+	a[2] = (v >> 8) & 0xff;
+	a[3] = v & 0xff;
+}
+
+static INLINE uint16
+load16_ua(uint8 *a)
+{
+	return ((a[0] << 8) | a[1]);
+}
+
+static INLINE void
+store16_ua(uint8 *a, uint16 v)
+{
+	a[0] = (v >> 8) & 0xff;
+	a[1] = v & 0xff;
+}
+
+#else
+
+static INLINE uint32
+load32_ua(uint8 *a)
+{
+	return ((a[3] << 24) | (a[2] << 16) | (a[1] << 8) | a[0]);
+}
+
+static INLINE void
+store32_ua(uint8 *a, uint32 v)
+{
+	a[3] = (v >> 24) & 0xff;
+	a[2] = (v >> 16) & 0xff;
+	a[1] = (v >> 8) & 0xff;
+	a[0] = v & 0xff;
+}
+
+static INLINE uint16
+load16_ua(uint8 *a)
+{
+	return ((a[1] << 8) | a[0]);
+}
+
+static INLINE void
+store16_ua(uint8 *a, uint16 v)
+{
+	a[1] = (v >> 8) & 0xff;
+	a[0] = v & 0xff;
+}
+
+#endif
+
+/* externs */
+/* crc */
+extern uint8 hndcrc8(uint8 *p, uint nbytes, uint8 crc);
+/* format/print */
+/* IE parsing */
+extern bcm_tlv_t *bcm_next_tlv(bcm_tlv_t *elt, int *buflen);
+extern bcm_tlv_t *bcm_parse_tlvs(void *buf, int buflen, uint key);
+extern bcm_tlv_t *bcm_parse_ordered_tlvs(void *buf, int buflen, uint key);
+
+/* bcmerror*/
+extern const char *bcmerrorstr(int bcmerror);
+
+/* multi-bool data type: set of bools, mbool is true if any is set */
+typedef uint32 mbool;
+#define mboolset(mb, bit)		(mb |= bit)		/* set one bool */
+#define mboolclr(mb, bit)		(mb &= ~bit)		/* clear one bool */
+#define mboolisset(mb, bit)		((mb & bit) != 0)	/* TRUE if one bool is set */
+#define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
+
+/* power conversion */
+extern uint16 bcm_qdbm_to_mw(uint8 qdbm);
+extern uint8 bcm_mw_to_qdbm(uint16 mw);
+
+/* generic datastruct to help dump routines */
+struct fielddesc {
+	char 	*nameandfmt;
+	uint32 	offset;
+	uint32 	len;
+};
+
+typedef  uint32 (*readreg_rtn)(void *arg0, void *arg1, uint32 offset);
+extern uint bcmdumpfields(readreg_rtn func_ptr, void *arg0, void *arg1, struct fielddesc *str, char *buf, uint32 bufsize);
+
+extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint len);
+
+#endif	/* _bcmutils_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/bitfuncs.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/bitfuncs.h
--- linux-2.6.16/arch/mips/bcm947xx/include/bitfuncs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/bitfuncs.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,85 @@
+/*
+ * bit manipulation utility functions
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ */
+
+#ifndef _BITFUNCS_H
+#define _BITFUNCS_H
+
+#include <typedefs.h>
+
+/* local prototypes */
+static INLINE uint32 find_msbit(uint32 x);
+
+
+/*
+ * find_msbit: returns index of most significant set bit in x, with index
+ *   range defined as 0-31.  NOTE: returns zero if input is zero.
+ */
+
+#if defined(USE_PENTIUM_BSR) && defined(__GNUC__)
+
+/*
+ * Implementation for Pentium processors and gcc.  Note that this
+ * instruction is actually very slow on some processors (e.g., family 5,
+ * model 2, stepping 12, "Pentium 75 - 200"), so we use the generic
+ * implementation instead.
+ */
+static INLINE uint32 find_msbit(uint32 x)
+{
+	uint msbit;
+        __asm__("bsrl %1,%0"
+                :"=r" (msbit)
+                :"r" (x));
+        return msbit;
+}
+
+#else
+
+/*
+ * Generic Implementation
+ */
+
+#define DB_POW_MASK16	0xffff0000
+#define DB_POW_MASK8	0x0000ff00
+#define DB_POW_MASK4	0x000000f0
+#define DB_POW_MASK2	0x0000000c
+#define DB_POW_MASK1	0x00000002
+
+static INLINE uint32 find_msbit(uint32 x)
+{
+	uint32 temp_x = x;
+	uint msbit = 0;
+	if (temp_x & DB_POW_MASK16) {
+		temp_x >>= 16;
+		msbit = 16;
+	}
+	if (temp_x & DB_POW_MASK8) {
+		temp_x >>= 8;
+		msbit += 8;
+	}
+	if (temp_x & DB_POW_MASK4) {
+		temp_x >>= 4;
+		msbit += 4;
+	}
+	if (temp_x & DB_POW_MASK2) {
+		temp_x >>= 2;
+		msbit += 2;
+	}
+	if (temp_x & DB_POW_MASK1) {
+		msbit += 1;
+	}
+	return(msbit);
+}
+
+#endif
+
+#endif /* _BITFUNCS_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/flash.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/flash.h
--- linux-2.6.16/arch/mips/bcm947xx/include/flash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/flash.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,188 @@
+/*
+ * flash.h: Common definitions for flash access.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+/* Types of flashes we know about */
+typedef enum _flash_type {OLD, BSC, SCS, AMD, SST, SFLASH} flash_type_t;
+
+/* Commands to write/erase the flases */
+typedef struct _flash_cmds{
+	flash_type_t	type;
+	bool		need_unlock;
+	uint16		pre_erase;
+	uint16		erase_block;
+	uint16		erase_chip;
+	uint16		write_word;
+	uint16		write_buf;
+	uint16		clear_csr;
+	uint16		read_csr;
+	uint16		read_id;
+	uint16		confirm;
+	uint16		read_array;
+} flash_cmds_t;
+
+#define	UNLOCK_CMD_WORDS	2
+
+typedef struct _unlock_cmd {
+  uint		addr[UNLOCK_CMD_WORDS];
+  uint16	cmd[UNLOCK_CMD_WORDS];
+} unlock_cmd_t;
+
+/* Flash descriptors */
+typedef struct _flash_desc {
+	uint16		mfgid;		/* Manufacturer Id */
+	uint16		devid;		/* Device Id */
+	uint		size;		/* Total size in bytes */
+	uint		width;		/* Device width in bytes */
+	flash_type_t	type;		/* Device type old, S, J */
+	uint		bsize;		/* Block size */
+	uint		nb;		/* Number of blocks */
+	uint		ff;		/* First full block */
+	uint		lf;		/* Last full block */
+	uint		nsub;		/* Number of subblocks */
+	uint		*subblocks;	/* Offsets for subblocks */
+	char		*desc;		/* Description */
+} flash_desc_t;
+
+
+#ifdef	DECLARE_FLASHES
+flash_cmds_t sflash_cmd_t = 
+	{ SFLASH,	0,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00 };
+
+flash_cmds_t flash_cmds[] = {
+/*	  type		needu	preera	eraseb	erasech	write	wbuf	clcsr	rdcsr	rdid	confrm	read */
+	{ BSC,		0,	0x00,	0x20,	0x00,	0x40,	0x00,	0x50,	0x70,	0x90,	0xd0,	0xff },
+	{ SCS,		0,	0x00,	0x20,	0x00,	0x40,	0xe8,	0x50,	0x70,	0x90,	0xd0,	0xff },
+	{ AMD,		1,	0x80,	0x30,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,	0x00,	0xf0 },
+	{ SST,		1,	0x80,	0x50,	0x10,	0xa0,	0x00,	0x00,	0x00,	0x90,	0x00,	0xf0 },
+	{ 0 }
+};
+
+unlock_cmd_t unlock_cmd_amd = {
+#ifdef MIPSEB
+/* addr: */	{ 0x0aa8,	0x0556},
+#else
+/* addr: */	{ 0x0aaa,	0x0554},
+#endif
+/* data: */	{ 0xaa,		0x55}
+};
+
+unlock_cmd_t unlock_cmd_sst = {
+#ifdef MIPSEB
+/* addr: */	{ 0xaaa8,	0x5556},
+#else
+/* addr: */	{ 0xaaaa,	0x5554},
+#endif
+/* data: */	{ 0xaa,		0x55}
+};
+
+#define AMD_CMD 0xaaa
+#define SST_CMD 0xaaaa
+
+/* intel unlock block cmds */
+#define INTEL_UNLOCK1	0x60
+#define INTEL_UNLOCK2	0xD0
+
+/* Just eight blocks of 8KB byte each */
+
+uint blk8x8k[] = { 0x00000000,
+		   0x00002000,
+		   0x00004000,
+		   0x00006000,
+		   0x00008000,
+		   0x0000a000,
+		   0x0000c000,
+		   0x0000e000,
+		   0x00010000
+};
+
+/* Funky AMD arrangement for 29xx800's */
+uint amd800[] = { 0x00000000,		/* 16KB */
+		  0x00004000,		/* 32KB */
+		  0x0000c000,		/* 8KB */
+		  0x0000e000,		/* 8KB */
+		  0x00010000,		/* 8KB */
+		  0x00012000,		/* 8KB */
+		  0x00014000,		/* 32KB */
+		  0x0001c000,		/* 16KB */
+		  0x00020000
+};
+
+/* AMD arrangement for 29xx160's */
+uint amd4112[] = { 0x00000000,		/* 32KB */
+		   0x00008000,		/* 8KB */
+		   0x0000a000,		/* 8KB */
+		   0x0000c000,		/* 16KB */
+		   0x00010000
+};
+uint amd2114[] = { 0x00000000,		/* 16KB */
+		   0x00004000,		/* 8KB */
+		   0x00006000,		/* 8KB */
+		   0x00008000,		/* 32KB */
+		   0x00010000
+};
+
+
+flash_desc_t sflash_desc =  
+	{ 0, 0, 0, 0,	SFLASH, 0, 0,  0, 0,  0, NULL,    "SFLASH" };
+
+flash_desc_t flashes[] = {
+	{ 0x00b0, 0x00d0, 0x0200000, 2,	SCS, 0x10000, 32,  0, 31,  0, NULL,    "Intel 28F160S3/5 1Mx16" },
+	{ 0x00b0, 0x00d4, 0x0400000, 2,	SCS, 0x10000, 64,  0, 63,  0, NULL,    "Intel 28F320S3/5 2Mx16" },
+	{ 0x0089, 0x8890, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k, "Intel 28F160B3 1Mx16 TopB" },
+	{ 0x0089, 0x8891, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k, "Intel 28F160B3 1Mx16 BotB" },
+	{ 0x0089, 0x8896, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k, "Intel 28F320B3 2Mx16 TopB" },
+	{ 0x0089, 0x8897, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Intel 28F320B3 2Mx16 BotB" },
+	{ 0x0089, 0x8898, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k, "Intel 28F640B3 4Mx16 TopB" },
+	{ 0x0089, 0x8899, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k, "Intel 28F640B3 4Mx16 BotB" },
+	{ 0x0089, 0x88C2, 0x0200000, 2,	BSC, 0x10000, 32,  0, 30,  8, blk8x8k, "Intel 28F160C3 1Mx16 TopB" },
+	{ 0x0089, 0x88C3, 0x0200000, 2,	BSC, 0x10000, 32,  1, 31,  8, blk8x8k, "Intel 28F160C3 1Mx16 BotB" },
+	{ 0x0089, 0x88C4, 0x0400000, 2,	BSC, 0x10000, 64,  0, 62,  8, blk8x8k, "Intel 28F320C3 2Mx16 TopB" },
+	{ 0x0089, 0x88C5, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Intel 28F320C3 2Mx16 BotB" },
+	{ 0x0089, 0x88CC, 0x0800000, 2,	BSC, 0x10000, 128, 0, 126, 8, blk8x8k, "Intel 28F640C3 4Mx16 TopB" },
+	{ 0x0089, 0x88CD, 0x0800000, 2,	BSC, 0x10000, 128, 1, 127, 8, blk8x8k, "Intel 28F640C3 4Mx16 BotB" },
+	{ 0x0089, 0x0014, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,    "Intel 28F320J5 2Mx16" },
+	{ 0x0089, 0x0015, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,    "Intel 28F640J5 4Mx16" },
+	{ 0x0089, 0x0016, 0x0400000, 2,	SCS, 0x20000, 32,  0, 31,  0, NULL,    "Intel 28F320J3 2Mx16" },
+	{ 0x0089, 0x0017, 0x0800000, 2,	SCS, 0x20000, 64,  0, 63,  0, NULL,    "Intel 28F640J3 4Mx16" },
+	{ 0x0089, 0x0018, 0x1000000, 2,	SCS, 0x20000, 128, 0, 127, 0, NULL,    "Intel 28F128J3 8Mx16" },
+	{ 0x00b0, 0x00e3, 0x0400000, 2,	BSC, 0x10000, 64,  1, 63,  8, blk8x8k, "Sharp 28F320BJE 2Mx16 BotB" },
+	{ 0x0001, 0x224a, 0x0100000, 2,	AMD, 0x10000, 16,  0, 13,  8, amd800,  "AMD 29DL800BT 512Kx16 TopB" },
+	{ 0x0001, 0x22cb, 0x0100000, 2,	AMD, 0x10000, 16,  2, 15,  8, amd800,  "AMD 29DL800BB 512Kx16 BotB" },
+	{ 0x0001, 0x22c4, 0x0200000, 2,	AMD, 0x10000, 32,  0, 30,  4, amd2114, "AMD 29lv160DT 1Mx16 TopB" },
+	{ 0x0001, 0x2249, 0x0200000, 2,	AMD, 0x10000, 32,  1, 31,  4, amd4112, "AMD 29lv160DB 1Mx16 BotB" },
+	{ 0x0001, 0x22f6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k, "AMD 29lv320DT 2Mx16 TopB" },
+	{ 0x0001, 0x22f9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k, "AMD 29lv320DB 2Mx16 BotB" },
+	{ 0x0001, 0x227e, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  8, blk8x8k, "AMD 29lv320MT 2Mx16 TopB" },
+	{ 0x0001, 0x2200, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  8, blk8x8k, "AMD 29lv320MB 2Mx16 BotB" },
+	{ 0x0020, 0x22CA, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "ST 29w320DT 2Mx16 TopB" },
+	{ 0x0020, 0x22CB, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "ST 29w320DB 2Mx16 BotB" },
+	{ 0x00C2, 0x00A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MX29LV320T 2Mx16 TopB" },
+	{ 0x00C2, 0x00A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MX29LV320B 2Mx16 BotB" },
+	{ 0x0004, 0x22F6, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MBM29LV320TE 2Mx16 TopB" },
+	{ 0x0004, 0x22F9, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MBM29LV320BE 2Mx16 BotB" },
+	{ 0x0098, 0x009A, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "TC58FVT321 2Mx16 TopB" },
+	{ 0x0098, 0x009C, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "TC58FVB321 2Mx16 BotB" }, 
+	{ 0x00C2, 0x22A7, 0x0400000, 2,	AMD, 0x10000, 64,  0, 62,  4, amd4112, "MX29LV320T 2Mx16 TopB" },
+	{ 0x00C2, 0x22A8, 0x0400000, 2,	AMD, 0x10000, 64,  1, 63,  4, amd2114, "MX29LV320B 2Mx16 BotB" },
+	{ 0x00BF, 0x2783, 0x0400000, 2,	SST, 0x10000, 64,  0, 63,  0, NULL,    "SST39VF320 2Mx16" },
+	{ 0,      0,      0,         0,	OLD, 0,       0,   0, 0,   0, NULL,    NULL },
+};
+
+#else
+
+extern flash_cmds_t flash_cmds[];
+extern unlock_cmd_t unlock_cmd;
+extern flash_desc_t flashes[];
+
+#endif
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/flashutl.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/flashutl.h
--- linux-2.6.16/arch/mips/bcm947xx/include/flashutl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/flashutl.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ * BCM47XX FLASH driver interface
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ * $Id$
+ */
+
+#ifndef _flashutl_h_
+#define _flashutl_h_
+
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+int	sysFlashInit(char *flash_str);
+int sysFlashRead(uint off, uchar *dst, uint bytes);
+int sysFlashWrite(uint off, uchar *src, uint bytes);
+void nvWrite(unsigned short *data, unsigned int len);
+
+#endif	/* _LANGUAGE_ASSEMBLY */
+
+#endif /* _flashutl_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/hndmips.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/hndmips.h
--- linux-2.6.16/arch/mips/bcm947xx/include/hndmips.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/hndmips.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,16 @@
+/*
+ * Alternate include file for HND sbmips.h since CFE also ships with
+ * a sbmips.h.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#include "sbmips.h"
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/linux_osl.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/linux_osl.h
--- linux-2.6.16/arch/mips/bcm947xx/include/linux_osl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/linux_osl.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,331 @@
+/*
+ * Linux OS Independent Layer
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef _linux_osl_h_
+#define _linux_osl_h_
+
+#include <typedefs.h>
+
+/* use current 2.4.x calling conventions */
+#include <linuxver.h>
+
+/* assert and panic */
+#ifdef __GNUC__
+#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#if GCC_VERSION > 30100
+#define	ASSERT(exp)		do {} while (0)
+#else
+/* ASSERT could causes segmentation fault on GCC3.1, use empty instead*/
+#define	ASSERT(exp)		
+#endif
+#endif
+
+/* microsecond delay */
+#define	OSL_DELAY(usec)		osl_delay(usec)
+extern void osl_delay(uint usec);
+
+/* PCI configuration space access macros */
+#define	OSL_PCI_READ_CONFIG(osh, offset, size) \
+	osl_pci_read_config((osh), (offset), (size))
+#define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
+	osl_pci_write_config((osh), (offset), (size), (val))
+extern uint32 osl_pci_read_config(osl_t *osh, uint size, uint offset);
+extern void osl_pci_write_config(osl_t *osh, uint offset, uint size, uint val);
+
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
+#define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
+extern uint osl_pci_bus(osl_t *osh);
+extern uint osl_pci_slot(osl_t *osh);
+
+/* OSL initialization */
+extern osl_t *osl_attach(void *pdev);
+extern void osl_detach(osl_t *osh);
+
+/* host/bus architecture-specific byte swap */
+#define BUS_SWAP32(v)		(v)
+
+/* general purpose memory allocation */
+
+#define	MALLOC(osh, size)	kmalloc(size, GFP_ATOMIC)
+#define	MFREE(osh, addr, size)	kfree(addr);
+
+#define	MALLOC_FAILED(osh)	osl_malloc_failed((osh))
+
+extern void *osl_malloc(osl_t *osh, uint size);
+extern void osl_mfree(osl_t *osh, void *addr, uint size);
+extern uint osl_malloced(osl_t *osh);
+extern uint osl_malloc_failed(osl_t *osh);
+
+/* allocate/free shared (dma-able) consistent memory */
+#define	DMA_CONSISTENT_ALIGN	PAGE_SIZE
+#define	DMA_ALLOC_CONSISTENT(osh, size, pap) \
+	osl_dma_alloc_consistent((osh), (size), (pap))
+#define	DMA_FREE_CONSISTENT(osh, va, size, pa) \
+	osl_dma_free_consistent((osh), (void*)(va), (size), (pa))
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap);
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size, ulong pa);
+
+/* map/unmap direction */
+#define	DMA_TX	1
+#define	DMA_RX	2
+
+/* register access macros */
+#if defined(BCMJTAG)
+#include <bcmjtag.h>
+#define	R_REG(r)	bcmjtag_read(NULL, (uint32)(r), sizeof (*(r)))
+#define	W_REG(r, v)	bcmjtag_write(NULL, (uint32)(r), (uint32)(v), sizeof (*(r)))
+#endif
+
+/*
+ * BINOSL selects the slightly slower function-call-based binary compatible osl.
+ * Macros expand to calls to functions defined in linux_osl.c .
+ */
+#ifndef BINOSL
+
+/* string library, kernel mode */
+#define	printf(fmt, args...)	printk(fmt, ## args)
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* register access macros */
+#if !defined(BCMJTAG)
+#ifndef IL_BIGENDIAN   
+#define R_REG(r) ( \
+	sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
+	readl((volatile uint32*)(r)) \
+)
+#define W_REG(r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	writeb((uint8)(v), (volatile uint8*)(r)); break; \
+	case sizeof(uint16):	writew((uint16)(v), (volatile uint16*)(r)); break; \
+	case sizeof(uint32):	writel((uint32)(v), (volatile uint32*)(r)); break; \
+	} \
+} while (0)
+#else	/* IL_BIGENDIAN */
+#define R_REG(r) ({ \
+	__typeof(*(r)) __osl_v; \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	__osl_v = readb((volatile uint8*)((uint32)r^3)); break; \
+	case sizeof(uint16):	__osl_v = readw((volatile uint16*)((uint32)r^2)); break; \
+	case sizeof(uint32):	__osl_v = readl((volatile uint32*)(r)); break; \
+	} \
+	__osl_v; \
+})
+#define W_REG(r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	writeb((uint8)(v), (volatile uint8*)((uint32)r^3)); break; \
+	case sizeof(uint16):	writew((uint16)(v), (volatile uint16*)((uint32)r^2)); break; \
+	case sizeof(uint32):	writel((uint32)(v), (volatile uint32*)(r)); break; \
+	} \
+} while (0)
+#endif
+#endif
+
+#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
+#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+
+/* bcopy, bcmp, and bzero */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+
+/* uncached virtual address */
+#ifdef mips
+#define OSL_UNCACHED(va)	KSEG1ADDR((va))
+#include <asm/addrspace.h>
+#else
+#define OSL_UNCACHED(va)	(va)
+#endif
+
+/* get processor cycle count */
+#if defined(mips)
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count() * 2)
+#elif defined(__i386__)
+#define	OSL_GETCYCLES(x)	rdtscl((x))
+#else
+#define OSL_GETCYCLES(x)	((x) = 0)
+#endif
+
+/* dereference an address that may cause a bus exception */
+#ifdef mips
+#if defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17))
+#define BUSPROBE(val, addr)	panic("get_dbe() will not fixup a bus exception when compiled into a module")
+#else
+#define	BUSPROBE(val, addr)	get_dbe((val), (addr))
+#include <asm/paccess.h>
+#endif
+#else
+#define	BUSPROBE(val, addr)	({ (val) = R_REG((addr)); 0; })
+#endif
+
+/* map/unmap physical to virtual I/O */
+#define	REG_MAP(pa, size)	ioremap_nocache((unsigned long)(pa), (unsigned long)(size))
+#define	REG_UNMAP(va)		iounmap((void *)(va))
+
+/* shared (dma-able) memory access macros */
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	memset((r), '\0', (len))
+
+/* packet primitives */
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len), (send))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((skb))
+#define	PKTDATA(osh, skb)		(((struct sk_buff*)(skb))->data)
+#define	PKTLEN(osh, skb)		(((struct sk_buff*)(skb))->len)
+#define PKTHEADROOM(osh, skb)		(PKTDATA(osh,skb)-(((struct sk_buff*)(skb))->head))
+#define PKTTAILROOM(osh, skb)		((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
+#define	PKTNEXT(osh, skb)		(((struct sk_buff*)(skb))->next)
+#define	PKTSETNEXT(skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
+#define	PKTSETLEN(osh, skb, len)	__skb_trim((struct sk_buff*)(skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	skb_push((struct sk_buff*)(skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	skb_pull((struct sk_buff*)(skb), (bytes))
+#define	PKTDUP(osh, skb)		skb_clone((struct sk_buff*)(skb), GFP_ATOMIC)
+#define	PKTCOOKIE(skb)			((void*)((struct sk_buff*)(skb))->csum)
+#define	PKTSETCOOKIE(skb, x)		(((struct sk_buff*)(skb))->csum = (uint)(x))
+#define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
+#define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
+#define	PKTPRIO(skb)			(((struct sk_buff*)(skb))->priority)
+#define	PKTSETPRIO(skb, x)		(((struct sk_buff*)(skb))->priority = (x))
+extern void *osl_pktget(osl_t *osh, uint len, bool send);
+extern void osl_pktfree(void *skb);
+
+#else	/* BINOSL */                                    
+
+/* string library */
+#ifndef LINUX_OSL
+#undef printf
+#define	printf(fmt, args...)		osl_printf((fmt), ## args)
+#undef sprintf
+#define sprintf(buf, fmt, args...)	osl_sprintf((buf), (fmt), ## args)
+#undef strcmp
+#define	strcmp(s1, s2)			osl_strcmp((s1), (s2))
+#undef strncmp
+#define	strncmp(s1, s2, n)		osl_strncmp((s1), (s2), (n))
+#undef strlen
+#define strlen(s)			osl_strlen((s))
+#undef strcpy
+#define	strcpy(d, s)			osl_strcpy((d), (s))
+#undef strncpy
+#define	strncpy(d, s, n)		osl_strncpy((d), (s), (n))
+#endif
+extern int osl_printf(const char *format, ...);
+extern int osl_sprintf(char *buf, const char *format, ...);
+extern int osl_strcmp(const char *s1, const char *s2);
+extern int osl_strncmp(const char *s1, const char *s2, uint n);
+extern int osl_strlen(const char *s);
+extern char* osl_strcpy(char *d, const char *s);
+extern char* osl_strncpy(char *d, const char *s, uint n);
+
+/* register access macros */
+#if !defined(BCMJTAG)
+#define R_REG(r) ( \
+	sizeof(*(r)) == sizeof(uint8) ? osl_readb((volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? osl_readw((volatile uint16*)(r)) : \
+	osl_readl((volatile uint32*)(r)) \
+)
+#define W_REG(r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	osl_writeb((uint8)(v), (volatile uint8*)(r)); break; \
+	case sizeof(uint16):	osl_writew((uint16)(v), (volatile uint16*)(r)); break; \
+	case sizeof(uint32):	osl_writel((uint32)(v), (volatile uint32*)(r)); break; \
+	} \
+} while (0)
+#endif
+
+#define	AND_REG(r, v)		W_REG((r), R_REG(r) & (v))
+#define	OR_REG(r, v)		W_REG((r), R_REG(r) | (v))
+extern uint8 osl_readb(volatile uint8 *r);
+extern uint16 osl_readw(volatile uint16 *r);
+extern uint32 osl_readl(volatile uint32 *r);
+extern void osl_writeb(uint8 v, volatile uint8 *r);
+extern void osl_writew(uint16 v, volatile uint16 *r);
+extern void osl_writel(uint32 v, volatile uint32 *r);
+
+/* bcopy, bcmp, and bzero */
+extern void bcopy(const void *src, void *dst, int len);
+extern int bcmp(const void *b1, const void *b2, int len);
+extern void bzero(void *b, int len);
+
+/* uncached virtual address */
+#define OSL_UNCACHED(va)	osl_uncached((va))
+extern void *osl_uncached(void *va);
+
+/* get processor cycle count */
+#define OSL_GETCYCLES(x)	((x) = osl_getcycles())
+extern uint osl_getcycles(void);
+
+/* dereference an address that may target abort */
+#define	BUSPROBE(val, addr)	osl_busprobe(&(val), (addr))
+extern int osl_busprobe(uint32 *val, uint32 addr);
+
+/* map/unmap physical to virtual */
+#define	REG_MAP(pa, size)	osl_reg_map((pa), (size))
+#define	REG_UNMAP(va)		osl_reg_unmap((va))
+extern void *osl_reg_map(uint32 pa, uint size);
+extern void osl_reg_unmap(void *va);
+
+/* shared (dma-able) memory access macros */
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	bzero((r), (len))
+
+/* packet primitives */
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len), (send))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((skb))
+#define	PKTDATA(osh, skb)		osl_pktdata((osh), (skb))
+#define	PKTLEN(osh, skb)		osl_pktlen((osh), (skb))
+#define PKTHEADROOM(osh, skb)		osl_pktheadroom((osh), (skb))
+#define PKTTAILROOM(osh, skb)		osl_pkttailroom((osh), (skb))
+#define	PKTNEXT(osh, skb)		osl_pktnext((osh), (skb))
+#define	PKTSETNEXT(skb, x)		osl_pktsetnext((skb), (x))
+#define	PKTSETLEN(osh, skb, len)	osl_pktsetlen((osh), (skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	osl_pktpush((osh), (skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	osl_pktpull((osh), (skb), (bytes))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define	PKTCOOKIE(skb)			osl_pktcookie((skb))
+#define	PKTSETCOOKIE(skb, x)		osl_pktsetcookie((skb), (x))
+#define	PKTLINK(skb)			osl_pktlink((skb))
+#define	PKTSETLINK(skb, x)		osl_pktsetlink((skb), (x))
+#define	PKTPRIO(skb)			osl_pktprio((skb))
+#define	PKTSETPRIO(skb, x)		osl_pktsetprio((skb), (x))
+extern void *osl_pktget(osl_t *osh, uint len, bool send);
+extern void osl_pktfree(void *skb);
+extern uchar *osl_pktdata(osl_t *osh, void *skb);
+extern uint osl_pktlen(osl_t *osh, void *skb);
+extern uint osl_pktheadroom(osl_t *osh, void *skb);
+extern uint osl_pkttailroom(osl_t *osh, void *skb);
+extern void *osl_pktnext(osl_t *osh, void *skb);
+extern void osl_pktsetnext(void *skb, void *x);
+extern void osl_pktsetlen(osl_t *osh, void *skb, uint len);
+extern uchar *osl_pktpush(osl_t *osh, void *skb, int bytes);
+extern uchar *osl_pktpull(osl_t *osh, void *skb, int bytes);
+extern void *osl_pktdup(osl_t *osh, void *skb);
+extern void *osl_pktcookie(void *skb);
+extern void osl_pktsetcookie(void *skb, void *x);
+extern void *osl_pktlink(void *skb);
+extern void osl_pktsetlink(void *skb, void *x);
+extern uint osl_pktprio(void *skb);
+extern void osl_pktsetprio(void *skb, uint x);
+
+#endif	/* BINOSL */
+
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+extern int osl_error(int bcmerror);
+
+/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
+#define	PKTBUFSZ	2048
+
+#endif	/* _linux_osl_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/linuxver.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/linuxver.h
--- linux-2.6.16/arch/mips/bcm947xx/include/linuxver.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/linuxver.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,389 @@
+/*
+ * Linux-specific abstractions to gain some independence from linux kernel versions.
+ * Pave over some 2.2 versus 2.4 versus 2.6 kernel differences.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *   
+ * $Id$
+ */
+
+#ifndef _linuxver_h_
+#define _linuxver_h_
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+/* __NO_VERSION__ must be defined for all linkables except one in 2.2 */
+#ifdef __UNDEF_NO_VERSION__
+#undef __NO_VERSION__
+#else
+#define __NO_VERSION__
+#endif
+#endif
+
+#if defined(MODULE) && defined(MODVERSIONS)
+#include <linux/modversions.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/moduleparam.h>
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) 
+#define module_param(_name_, _type_, _perm_)	MODULE_PARM(_name_, "i")	
+#define module_param_string(_name_, _string_, _size_, _perm_)	MODULE_PARM(_string_, "c" __MODULE_STRING(_size_))
+#endif
+
+/* linux/malloc.h is deprecated, use linux/slab.h instead. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9))
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41))
+#include <linux/workqueue.h>
+#else
+#include <linux/tqueue.h>
+#ifndef work_struct
+#define work_struct tq_struct
+#endif
+#ifndef INIT_WORK
+#define INIT_WORK(_work, _func, _data) INIT_TQUEUE((_work), (_func), (_data))
+#endif
+#ifndef schedule_work
+#define schedule_work(_work) schedule_task((_work))
+#endif
+#ifndef flush_scheduled_work
+#define flush_scheduled_work() flush_scheduled_tasks()
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+/* Some distributions have their own 2.6.x compatibility layers */
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+#else
+typedef irqreturn_t (*FN_ISR) (int irq, void *dev_id, struct pt_regs *ptregs);
+#endif
+
+#ifndef __exit
+#define __exit
+#endif
+#ifndef __devexit
+#define __devexit
+#endif
+#ifndef __devinit
+#define __devinit	__init
+#endif
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+#ifndef __devexit_p
+#define __devexit_p(x)	x
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+
+#define pci_get_drvdata(dev)		(dev)->sysdata
+#define pci_set_drvdata(dev, value)	(dev)->sysdata=(value)
+
+/*
+ * New-style (2.4.x) PCI/hot-pluggable PCI/CardBus registration
+ */
+
+struct pci_device_id {
+	unsigned int vendor, device;		/* Vendor and device ID or PCI_ANY_ID */
+	unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
+	unsigned long driver_data;		/* Data private to the driver */
+};
+
+struct pci_driver {
+	struct list_head node;
+	char *name;
+	const struct pci_device_id *id_table;	/* NULL if wants all devices */
+	int (*probe)(struct pci_dev *dev, const struct pci_device_id *id);	/* New device inserted */
+	void (*remove)(struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
+	void (*suspend)(struct pci_dev *dev);	/* Device suspended */
+	void (*resume)(struct pci_dev *dev);	/* Device woken up */
+};
+
+#define MODULE_DEVICE_TABLE(type, name)
+#define PCI_ANY_ID (~0)
+
+/* compatpci.c */
+#define pci_module_init pci_register_driver
+extern int pci_register_driver(struct pci_driver *drv);
+extern void pci_unregister_driver(struct pci_driver *drv);
+
+#endif /* PCI registration */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,2,18))
+#ifdef MODULE
+#define module_init(x) int init_module(void) { return x(); }
+#define module_exit(x) void cleanup_module(void) { x(); }
+#else
+#define module_init(x)	__initcall(x);
+#define module_exit(x)	__exitcall(x);
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,48))
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,13))
+#define pci_resource_start(dev, bar)	((dev)->base_address[(bar)])
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,44))
+#define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,23))
+#define pci_enable_device(dev) do { } while (0)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,14))
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,42))
+
+/*
+ * DMA mapping
+ *
+ * See linux/Documentation/DMA-mapping.txt
+ */
+
+#ifndef PCI_DMA_TODEVICE
+#define	PCI_DMA_TODEVICE	1
+#define	PCI_DMA_FROMDEVICE	2
+#endif
+
+typedef u32 dma_addr_t;
+
+/* Pure 2^n version of get_order */
+static inline int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size-1) >> (PAGE_SHIFT-1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+static inline void *pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
+					 dma_addr_t *dma_handle)
+{
+	void *ret;
+	int gfp = GFP_ATOMIC | GFP_DMA;
+
+	ret = (void *)__get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		memset(ret, 0, size);
+		*dma_handle = virt_to_bus(ret);
+	}
+	return ret;
+}
+static inline void pci_free_consistent(struct pci_dev *hwdev, size_t size,
+				       void *vaddr, dma_addr_t dma_handle)
+{
+	free_pages((unsigned long)vaddr, get_order(size));
+}
+#ifdef ILSIM
+extern uint pci_map_single(void *dev, void *va, uint size, int direction);
+extern void pci_unmap_single(void *dev, uint pa, uint size, int direction);
+#else
+#define pci_map_single(cookie, address, size, dir)	virt_to_bus(address)
+#define pci_unmap_single(cookie, address, size, dir)
+#endif
+
+#endif /* DMA mapping */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43))
+
+#define dev_kfree_skb_any(a)		dev_kfree_skb(a)
+#define netif_down(dev)			do { (dev)->start = 0; } while(0)
+
+/* pcmcia-cs provides its own netdevice compatibility layer */
+#ifndef _COMPAT_NETDEVICE_H
+
+/*
+ * SoftNet
+ *
+ * For pre-softnet kernels we need to tell the upper layer not to
+ * re-enter start_xmit() while we are in there. However softnet
+ * guarantees not to enter while we are in there so there is no need
+ * to do the netif_stop_queue() dance unless the transmit queue really
+ * gets stuck. This should also improve performance according to tests
+ * done by Aman Singla.
+ */
+
+#define dev_kfree_skb_irq(a)		dev_kfree_skb(a)
+#define netif_wake_queue(dev)		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while(0)
+#define netif_stop_queue(dev)		set_bit(0, &(dev)->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+	dev->tbusy = 0;
+	dev->interrupt = 0;
+	dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	(dev)->tbusy
+#define netif_running(dev)		(dev)->start
+
+#endif /* _COMPAT_NETDEVICE_H */
+
+#define netif_device_attach(dev)	netif_start_queue(dev)
+#define netif_device_detach(dev)	netif_stop_queue(dev)
+
+/* 2.4.x renamed bottom halves to tasklets */
+#define tasklet_struct				tq_struct
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+	queue_task(tasklet, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func)(unsigned long),
+				unsigned long data)
+{
+	tasklet->next = NULL;
+	tasklet->sync = 0;
+	tasklet->routine = (void (*)(void *))func;
+	tasklet->data = (void *)data;
+}
+#define tasklet_kill(tasklet)			{do{} while(0);}
+
+/* 2.4.x introduced del_timer_sync() */
+#define del_timer_sync(timer) del_timer(timer)
+
+#else
+
+#define netif_down(dev)
+
+#endif /* SoftNet */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3))
+
+/*
+ * Emit code to initialise a tq_struct's routine and data pointers
+ */
+#define PREPARE_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		(_tq)->routine = _routine;			\
+		(_tq)->data = _data;				\
+	} while (0)
+
+/*
+ * Emit code to initialise all of a tq_struct
+ */
+#define INIT_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		INIT_LIST_HEAD(&(_tq)->list);			\
+		(_tq)->sync = 0;				\
+		PREPARE_TQUEUE((_tq), (_routine), (_data));	\
+	} while (0)
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6))
+
+/* Power management related routines */
+
+static inline int
+pci_save_state(struct pci_dev *dev, u32 *buffer)
+{
+	int i;
+	if (buffer) {
+		for (i = 0; i < 16; i++)
+			pci_read_config_dword(dev, i * 4,&buffer[i]);
+	}
+	return 0;
+}
+
+static inline int 
+pci_restore_state(struct pci_dev *dev, u32 *buffer)
+{
+	int i;
+
+	if (buffer) {
+		for (i = 0; i < 16; i++)
+			pci_write_config_dword(dev,i * 4, buffer[i]);
+	}
+	/*
+	 * otherwise, write the context information we know from bootup.
+	 * This works around a problem where warm-booting from Windows
+	 * combined with a D3(hot)->D0 transition causes PCI config
+	 * header data to be forgotten.
+	 */	
+	else {
+		for (i = 0; i < 6; i ++)
+			pci_write_config_dword(dev,
+					       PCI_BASE_ADDRESS_0 + (i * 4),
+					       pci_resource_start(dev, i));
+		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+	}
+	return 0;
+}
+
+#endif /* PCI power management */
+
+/* Old cp0 access macros deprecated in 2.4.19 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19))
+#define read_c0_count() read_32bit_cp0_register(CP0_COUNT)
+#endif
+
+/* Module refcount handled internally in 2.6.x */
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)		do {} while (0)
+#define OLD_MOD_INC_USE_COUNT		MOD_INC_USE_COUNT
+#define OLD_MOD_DEC_USE_COUNT		MOD_DEC_USE_COUNT
+#else
+#define OLD_MOD_INC_USE_COUNT		do {} while (0)
+#define OLD_MOD_DEC_USE_COUNT		do {} while (0)
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)	do {} while (0)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(dev)		kfree(dev)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+/* struct packet_type redefined in 2.6.x */
+#define af_packet_priv			data
+#endif
+
+#endif /* _linuxver_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/mipsinc.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/mipsinc.h
--- linux-2.6.16/arch/mips/bcm947xx/include/mipsinc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/mipsinc.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,552 @@
+/*
+ * HND Run Time Environment for standalone MIPS programs.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef	_MISPINC_H
+#define _MISPINC_H
+
+
+/* MIPS defines */
+
+#ifdef	_LANGUAGE_ASSEMBLY
+
+/*
+ * Symbolic register names for 32 bit ABI
+ */
+#define zero	$0	/* wired zero */
+#define AT	$1	/* assembler temp - uppercase because of ".set at" */
+#define v0	$2	/* return value */
+#define v1	$3
+#define a0	$4	/* argument registers */
+#define a1	$5
+#define a2	$6
+#define a3	$7
+#define t0	$8	/* caller saved */
+#define t1	$9
+#define t2	$10
+#define t3	$11
+#define t4	$12
+#define t5	$13
+#define t6	$14
+#define t7	$15
+#define s0	$16	/* callee saved */
+#define s1	$17
+#define s2	$18
+#define s3	$19
+#define s4	$20
+#define s5	$21
+#define s6	$22
+#define s7	$23
+#define t8	$24	/* caller saved */
+#define t9	$25
+#define jp	$25	/* PIC jump register */
+#define k0	$26	/* kernel scratch */
+#define k1	$27
+#define gp	$28	/* global pointer */
+#define sp	$29	/* stack pointer */
+#define fp	$30	/* frame pointer */
+#define s8	$30	/* same like fp! */
+#define ra	$31	/* return address */
+
+
+/*
+ * CP0 Registers 
+ */
+
+#define C0_INX		$0
+#define C0_RAND		$1
+#define C0_TLBLO0	$2
+#define C0_TLBLO	C0_TLBLO0
+#define C0_TLBLO1	$3
+#define C0_CTEXT	$4
+#define C0_PGMASK	$5
+#define C0_WIRED	$6
+#define C0_BADVADDR	$8
+#define C0_COUNT 	$9
+#define C0_TLBHI	$10
+#define C0_COMPARE	$11
+#define C0_SR		$12
+#define C0_STATUS	C0_SR
+#define C0_CAUSE	$13
+#define C0_EPC		$14
+#define C0_PRID		$15
+#define C0_CONFIG	$16
+#define C0_LLADDR	$17
+#define C0_WATCHLO	$18
+#define C0_WATCHHI	$19
+#define C0_XCTEXT	$20
+#define C0_DIAGNOSTIC	$22
+#define C0_BROADCOM	C0_DIAGNOSTIC
+#define	C0_PERFORMANCE	$25
+#define C0_ECC		$26
+#define C0_CACHEERR	$27
+#define C0_TAGLO	$28
+#define C0_TAGHI	$29
+#define C0_ERREPC	$30
+#define C0_DESAVE	$31
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define LEAF(symbol)				\
+		.globl	symbol;			\
+		.align	2;			\
+		.type	symbol,@function;	\
+		.ent	symbol,0;		\
+symbol:		.frame	sp,0,ra
+
+/*
+ * END - mark end of function
+ */
+#define END(function)				\
+		.end	function;		\
+		.size	function,.-function
+
+#define _ULCAST_
+
+#else
+
+/*
+ * The following macros are especially useful for __asm__
+ * inline assembler.
+ */
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define _ULCAST_ (unsigned long)
+
+
+/*
+ * CP0 Registers 
+ */
+
+#define C0_INX		0		/* CP0: TLB Index */
+#define C0_RAND		1		/* CP0: TLB Random */
+#define C0_TLBLO0	2		/* CP0: TLB EntryLo0 */
+#define C0_TLBLO	C0_TLBLO0	/* CP0: TLB EntryLo0 */
+#define C0_TLBLO1	3		/* CP0: TLB EntryLo1 */
+#define C0_CTEXT	4		/* CP0: Context */
+#define C0_PGMASK	5		/* CP0: TLB PageMask */
+#define C0_WIRED	6		/* CP0: TLB Wired */
+#define C0_BADVADDR	8		/* CP0: Bad Virtual Address */
+#define C0_COUNT 	9		/* CP0: Count */
+#define C0_TLBHI	10		/* CP0: TLB EntryHi */
+#define C0_COMPARE	11		/* CP0: Compare */
+#define C0_SR		12		/* CP0: Processor Status */
+#define C0_STATUS	C0_SR		/* CP0: Processor Status */
+#define C0_CAUSE	13		/* CP0: Exception Cause */
+#define C0_EPC		14		/* CP0: Exception PC */
+#define C0_PRID		15		/* CP0: Processor Revision Indentifier */
+#define C0_CONFIG	16		/* CP0: Config */
+#define C0_LLADDR	17		/* CP0: LLAddr */
+#define C0_WATCHLO	18		/* CP0: WatchpointLo */
+#define C0_WATCHHI	19		/* CP0: WatchpointHi */
+#define C0_XCTEXT	20		/* CP0: XContext */
+#define C0_DIAGNOSTIC	22		/* CP0: Diagnostic */
+#define C0_BROADCOM	C0_DIAGNOSTIC	/* CP0: Broadcom Register */
+#define	C0_PERFORMANCE	25		/* CP0: Performance Counter/Control Registers */
+#define C0_ECC		26		/* CP0: ECC */
+#define C0_CACHEERR	27		/* CP0: CacheErr */
+#define C0_TAGLO	28		/* CP0: TagLo */
+#define C0_TAGHI	29		/* CP0: TagHi */
+#define C0_ERREPC	30		/* CP0: ErrorEPC */
+#define C0_DESAVE	31		/* CP0: DebugSave */
+
+#endif	/* _LANGUAGE_ASSEMBLY */
+
+/*
+ * Memory segments (32bit kernel mode addresses)
+ */
+#undef KUSEG
+#undef KSEG0
+#undef KSEG1
+#undef KSEG2
+#undef KSEG3
+#define KUSEG		0x00000000
+#define KSEG0		0x80000000
+#define KSEG1		0xa0000000
+#define KSEG2		0xc0000000
+#define KSEG3		0xe0000000
+#define PHYSADDR_MASK	0x1fffffff
+
+/*
+ * Map an address to a certain kernel segment
+ */
+#undef PHYSADDR
+#undef KSEG0ADDR
+#undef KSEG1ADDR
+#undef KSEG2ADDR
+#undef KSEG3ADDR
+
+#define PHYSADDR(a)	(_ULCAST_(a) & PHYSADDR_MASK)
+#define KSEG0ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG0)
+#define KSEG1ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG1)
+#define KSEG2ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG2)
+#define KSEG3ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG3)
+
+
+#ifndef	Index_Invalidate_I
+/*
+ * Cache Operations
+ */
+#define Index_Invalidate_I	0x00
+#define Index_Writeback_Inv_D	0x01
+#define Index_Invalidate_SI	0x02
+#define Index_Writeback_Inv_SD	0x03
+#define Index_Load_Tag_I	0x04
+#define Index_Load_Tag_D	0x05
+#define Index_Load_Tag_SI	0x06
+#define Index_Load_Tag_SD	0x07
+#define Index_Store_Tag_I	0x08
+#define Index_Store_Tag_D	0x09
+#define Index_Store_Tag_SI	0x0A
+#define Index_Store_Tag_SD	0x0B
+#define Create_Dirty_Excl_D	0x0d
+#define Create_Dirty_Excl_SD	0x0f
+#define Hit_Invalidate_I	0x10
+#define Hit_Invalidate_D	0x11
+#define Hit_Invalidate_SI	0x12
+#define Hit_Invalidate_SD	0x13
+#define Fill_I			0x14
+#define Hit_Writeback_Inv_D	0x15
+					/* 0x16 is unused */
+#define Hit_Writeback_Inv_SD	0x17
+#define R5K_Page_Invalidate_S	0x17
+#define Hit_Writeback_I		0x18
+#define Hit_Writeback_D		0x19
+					/* 0x1a is unused */
+#define Hit_Writeback_SD	0x1b
+					/* 0x1c is unused */
+					/* 0x1e is unused */
+#define Hit_Set_Virtual_SI	0x1e
+#define Hit_Set_Virtual_SD	0x1f
+#endif
+
+
+/*
+ * R4x00 interrupt enable / cause bits
+ */
+#define IE_SW0			(_ULCAST_(1) <<  8)
+#define IE_SW1			(_ULCAST_(1) <<  9)
+#define IE_IRQ0			(_ULCAST_(1) << 10)
+#define IE_IRQ1			(_ULCAST_(1) << 11)
+#define IE_IRQ2			(_ULCAST_(1) << 12)
+#define IE_IRQ3			(_ULCAST_(1) << 13)
+#define IE_IRQ4			(_ULCAST_(1) << 14)
+#define IE_IRQ5			(_ULCAST_(1) << 15)
+
+#ifndef	ST0_UM
+/*
+ * Bitfields in the mips32 cp0 status register
+ */
+#define ST0_IE			0x00000001
+#define ST0_EXL			0x00000002
+#define ST0_ERL			0x00000004
+#define ST0_UM			0x00000010
+#define ST0_SWINT0		0x00000100
+#define ST0_SWINT1		0x00000200
+#define ST0_HWINT0		0x00000400
+#define ST0_HWINT1		0x00000800
+#define ST0_HWINT2		0x00001000
+#define ST0_HWINT3		0x00002000
+#define ST0_HWINT4		0x00004000
+#define ST0_HWINT5		0x00008000
+#define ST0_IM			0x0000ff00
+#define ST0_NMI			0x00080000
+#define ST0_SR			0x00100000
+#define ST0_TS			0x00200000
+#define ST0_BEV			0x00400000
+#define ST0_RE			0x02000000
+#define ST0_RP			0x08000000
+#define ST0_CU			0xf0000000
+#define ST0_CU0			0x10000000
+#define ST0_CU1			0x20000000
+#define ST0_CU2			0x40000000
+#define ST0_CU3			0x80000000
+#endif
+
+
+/*
+ * Bitfields in the mips32 cp0 cause register
+ */
+#define C_EXC			0x0000007c
+#define C_EXC_SHIFT		2
+#define C_INT			0x0000ff00
+#define C_INT_SHIFT		8
+#define C_SW0			(_ULCAST_(1) <<  8)
+#define C_SW1			(_ULCAST_(1) <<  9)
+#define C_IRQ0			(_ULCAST_(1) << 10)
+#define C_IRQ1			(_ULCAST_(1) << 11)
+#define C_IRQ2			(_ULCAST_(1) << 12)
+#define C_IRQ3			(_ULCAST_(1) << 13)
+#define C_IRQ4			(_ULCAST_(1) << 14)
+#define C_IRQ5			(_ULCAST_(1) << 15)
+#define C_WP			0x00400000
+#define C_IV			0x00800000
+#define C_CE			0x30000000
+#define C_CE_SHIFT		28
+#define C_BD			0x80000000
+
+/* Values in C_EXC */
+#define EXC_INT			0
+#define EXC_TLBM		1
+#define EXC_TLBL		2
+#define EXC_TLBS		3
+#define EXC_AEL			4
+#define EXC_AES			5
+#define EXC_IBE			6
+#define EXC_DBE			7
+#define EXC_SYS			8
+#define EXC_BPT			9
+#define EXC_RI			10
+#define EXC_CU			11
+#define EXC_OV			12
+#define EXC_TR			13
+#define EXC_WATCH		23
+#define EXC_MCHK		24
+
+
+/*
+ * Bits in the cp0 config register.
+ */
+#define CONF_CM_CACHABLE_NO_WA		0
+#define CONF_CM_CACHABLE_WA		1
+#define CONF_CM_UNCACHED		2
+#define CONF_CM_CACHABLE_NONCOHERENT	3
+#define CONF_CM_CACHABLE_CE		4
+#define CONF_CM_CACHABLE_COW		5
+#define CONF_CM_CACHABLE_CUW		6
+#define CONF_CM_CACHABLE_ACCELERATED	7
+#define CONF_CM_CMASK			7
+#define CONF_CU				(_ULCAST_(1) <<  3)
+#define CONF_DB				(_ULCAST_(1) <<  4)
+#define CONF_IB				(_ULCAST_(1) <<  5)
+#define CONF_SE				(_ULCAST_(1) << 12)
+#define CONF_SC				(_ULCAST_(1) << 17)
+#define CONF_AC				(_ULCAST_(1) << 23)
+#define CONF_HALT			(_ULCAST_(1) << 25)
+
+
+/*
+ * Bits in the cp0 config register select 1.
+ */
+#define CONF1_FP		0x00000001	/* FPU present */
+#define CONF1_EP		0x00000002	/* EJTAG present */
+#define CONF1_CA		0x00000004	/* mips16 implemented */
+#define CONF1_WR		0x00000008	/* Watch registers present */
+#define CONF1_PC		0x00000010	/* Performance counters present */
+#define CONF1_DA_SHIFT		7		/* D$ associativity */
+#define CONF1_DA_MASK		0x00000380
+#define CONF1_DA_BASE		1
+#define CONF1_DL_SHIFT		10		/* D$ line size */
+#define CONF1_DL_MASK		0x00001c00
+#define CONF1_DL_BASE		2
+#define CONF1_DS_SHIFT		13		/* D$ sets/way */
+#define CONF1_DS_MASK		0x0000e000
+#define CONF1_DS_BASE		64
+#define CONF1_IA_SHIFT		16		/* I$ associativity */
+#define CONF1_IA_MASK		0x00070000
+#define CONF1_IA_BASE		1
+#define CONF1_IL_SHIFT		19		/* I$ line size */
+#define CONF1_IL_MASK		0x00380000
+#define CONF1_IL_BASE		2
+#define CONF1_IS_SHIFT		22		/* Instruction cache sets/way */
+#define CONF1_IS_MASK		0x01c00000
+#define CONF1_IS_BASE		64
+#define CONF1_MS_MASK		0x7e000000	/* Number of tlb entries */
+#define CONF1_MS_SHIFT		25
+
+/* PRID register */
+#define PRID_COPT_MASK		0xff000000
+#define PRID_COMP_MASK		0x00ff0000
+#define PRID_IMP_MASK		0x0000ff00
+#define PRID_REV_MASK		0x000000ff
+
+#define PRID_COMP_LEGACY	0x000000
+#define PRID_COMP_MIPS		0x010000
+#define PRID_COMP_BROADCOM	0x020000
+#define PRID_COMP_ALCHEMY	0x030000
+#define PRID_COMP_SIBYTE	0x040000
+#define PRID_IMP_BCM4710	0x4000
+#define PRID_IMP_BCM3302	0x9000
+#define PRID_IMP_BCM3303	0x9100
+
+#define PRID_IMP_UNKNOWN	0xff00
+
+#define BCM330X(id) \
+	(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) \
+	|| ((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
+
+/* Bits in C0_BROADCOM */
+#define BRCM_PFC_AVAIL		0x20000000	/* PFC is available */
+#define BRCM_DC_ENABLE		0x40000000	/* Enable Data $ */
+#define BRCM_IC_ENABLE		0x80000000	/* Enable Instruction $ */
+#define BRCM_PFC_ENABLE		0x00400000	/* Obsolete? Enable PFC (at least on 4310) */
+
+/* PreFetch Cache aka Read Ahead Cache */
+
+#define PFC_CR0			0xff400000	/* control reg 0 */
+#define PFC_CR1			0xff400004	/* control reg 1 */
+
+/* PFC operations */
+#define PFC_I			0x00000001	/* Enable PFC use for instructions */
+#define PFC_D			0x00000002	/* Enable PFC use for data */
+#define PFC_PFI			0x00000004	/* Enable seq. prefetch for instructions */
+#define PFC_PFD			0x00000008	/* Enable seq. prefetch for data */
+#define PFC_CINV		0x00000010	/* Enable selective (i/d) cacheop flushing */
+#define PFC_NCH			0x00000020	/* Disable flushing based on cacheops */
+#define PFC_DPF			0x00000040	/* Enable directional prefetching */
+#define PFC_FLUSH		0x00000100	/* Flush the PFC */
+#define PFC_BRR			0x40000000	/* Bus error indication */
+#define PFC_PWR			0x80000000	/* Disable power saving (clock gating) */
+
+/* Handy defaults */
+#define PFC_DISABLED		0
+#define PFC_AUTO			0xffffffff	/* auto select the default mode */
+#define PFC_INST		(PFC_I | PFC_PFI | PFC_CINV)
+#define PFC_INST_NOPF		(PFC_I | PFC_CINV)
+#define PFC_DATA		(PFC_D | PFC_PFD | PFC_CINV)
+#define PFC_DATA_NOPF		(PFC_D | PFC_CINV)
+#define PFC_I_AND_D		(PFC_INST | PFC_DATA)
+#define PFC_I_AND_D_NOPF	(PFC_INST_NOPF | PFC_DATA_NOPF)
+
+
+/* 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+#define UART_TX		0	/* Out: Transmit buffer (DLAB=0) */
+#define UART_DLL	0	/* Out: Divisor Latch Low (DLAB=1) */
+#define UART_DLM	1	/* Out: Divisor Latch High (DLAB=1) */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
+#define UART_LCR_WLEN8	0x03	/* Wordlength: 8 bits */
+#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
+#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
+#define UART_LSR_RXRDY	0x01	/* Receiver ready */
+
+
+#ifndef	_LANGUAGE_ASSEMBLY
+
+/*
+ * Macros to access the system control coprocessor
+ */
+
+#define MFC0(source, sel)					\
+({								\
+	int __res;						\
+	__asm__ __volatile__(					\
+	".set\tnoreorder\n\t"					\
+	".set\tnoat\n\t"					\
+	".word\t"STR(0x40010000 | ((source)<<11) | (sel))"\n\t"	\
+	"move\t%0,$1\n\t"					\
+	".set\tat\n\t"						\
+	".set\treorder"						\
+	:"=r" (__res)						\
+	:							\
+	:"$1");							\
+	__res;							\
+})
+
+#define MTC0(source, sel, value)				\
+do {								\
+	__asm__ __volatile__(					\
+	".set\tnoreorder\n\t"					\
+	".set\tnoat\n\t"					\
+	"move\t$1,%z0\n\t"					\
+	".word\t"STR(0x40810000 | ((source)<<11) | (sel))"\n\t"	\
+	".set\tat\n\t"						\
+	".set\treorder"						\
+	:							\
+	:"jr" (value)						\
+	:"$1");							\
+} while (0)
+
+#define get_c0_count()						\
+({								\
+	int __res;						\
+	__asm__ __volatile__(					\
+	".set\tnoreorder\n\t"					\
+	".set\tnoat\n\t"					\
+	"mfc0\t%0,$9\n\t"					\
+	".set\tat\n\t"						\
+	".set\treorder"						\
+	:"=r" (__res));						\
+	__res;							\
+})
+
+static INLINE void icache_probe(uint32 config1, uint *size, uint *lsize)
+{
+	uint lsz, sets, ways;
+
+	/* Instruction Cache Size = Associativity * Line Size * Sets Per Way */
+	if ((lsz = ((config1 & CONF1_IL_MASK) >> CONF1_IL_SHIFT)))
+		lsz = CONF1_IL_BASE << lsz;
+	sets = CONF1_IS_BASE << ((config1 & CONF1_IS_MASK) >> CONF1_IS_SHIFT);
+	ways = CONF1_IA_BASE + ((config1 & CONF1_IA_MASK) >> CONF1_IA_SHIFT);
+	*size = lsz * sets * ways;
+	*lsize = lsz;
+}
+
+static INLINE void dcache_probe(uint32 config1, uint *size, uint *lsize)
+{
+	uint lsz, sets, ways;
+
+	/* Data Cache Size = Associativity * Line Size * Sets Per Way */
+	if ((lsz = ((config1 & CONF1_DL_MASK) >> CONF1_DL_SHIFT)))
+		lsz = CONF1_DL_BASE << lsz;
+	sets = CONF1_DS_BASE << ((config1 & CONF1_DS_MASK) >> CONF1_DS_SHIFT);
+	ways = CONF1_DA_BASE + ((config1 & CONF1_DA_MASK) >> CONF1_DA_SHIFT);
+	*size = lsz * sets * ways;
+	*lsize = lsz;
+}
+
+#define cache_op(base, op)			\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, (%0);			\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#define cache_unroll4(base, delta, op)		\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1,0(%0);			\
+		cache %1,delta(%0);		\
+		cache %1,(2 * delta)(%0);	\
+		cache %1,(3 * delta)(%0);	\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#endif /* !_LANGUAGE_ASSEMBLY */
+
+#endif	/* _MISPINC_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/osl.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/osl.h
--- linux-2.6.16/arch/mips/bcm947xx/include/osl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/osl.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * OS Abstraction Layer
+ * 
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#ifndef _osl_h_
+#define _osl_h_
+
+/* osl handle type forward declaration */
+typedef struct os_handle osl_t;
+
+#if defined(linux)
+#include <linux_osl.h>
+#elif defined(NDIS)
+#include <ndis_osl.h>
+#elif defined(_CFE_)
+#include <cfe_osl.h>
+#elif defined(_HNDRTE_)
+#include <hndrte_osl.h>
+#elif defined(_MINOSL_)
+#include <min_osl.h>
+#elif PMON
+#include <pmon_osl.h>
+#elif defined(MACOSX)
+#include <macosx_osl.h>
+#else
+#error "Unsupported OSL requested"
+#endif
+
+/* handy */
+#define	SET_REG(r, mask, val)	W_REG((r), ((R_REG(r) & ~(mask)) | (val)))
+#define	MAXPRIO		7	/* 0-7 */
+
+#endif	/* _osl_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/pcicfg.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/pcicfg.h
--- linux-2.6.16/arch/mips/bcm947xx/include/pcicfg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/pcicfg.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,398 @@
+/*
+ * pcicfg.h: PCI configuration  constants and structures.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef	_h_pci_
+#define	_h_pci_
+
+/* The following inside ifndef's so we don't collide with NTDDK.H */
+#ifndef PCI_MAX_BUS
+#define PCI_MAX_BUS		0x100
+#endif
+#ifndef PCI_MAX_DEVICES
+#define PCI_MAX_DEVICES		0x20
+#endif
+#ifndef PCI_MAX_FUNCTION
+#define PCI_MAX_FUNCTION	0x8
+#endif
+
+#ifndef PCI_INVALID_VENDORID
+#define PCI_INVALID_VENDORID	0xffff
+#endif
+#ifndef PCI_INVALID_DEVICEID
+#define PCI_INVALID_DEVICEID	0xffff
+#endif
+
+
+/* Convert between bus-slot-function-register and config addresses */
+
+#define	PCICFG_BUS_SHIFT	16	/* Bus shift */
+#define	PCICFG_SLOT_SHIFT	11	/* Slot shift */
+#define	PCICFG_FUN_SHIFT	8	/* Function shift */
+#define	PCICFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCICFG_BUS_MASK		0xff	/* Bus mask */
+#define	PCICFG_SLOT_MASK	0x1f	/* Slot mask */
+#define	PCICFG_FUN_MASK		7	/* Function mask */
+#define	PCICFG_OFF_MASK		0xff	/* Bus mask */
+
+#define	PCI_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCICFG_BUS_MASK) << PCICFG_BUS_SHIFT)		\
+		 | (((s) & PCICFG_SLOT_MASK) << PCICFG_SLOT_SHIFT)	\
+		 | (((f) & PCICFG_FUN_MASK) << PCICFG_FUN_SHIFT)	\
+		 | (((o) & PCICFG_OFF_MASK) << PCICFG_OFF_SHIFT))
+
+#define	PCI_CONFIG_BUS(a)	(((a) >> PCICFG_BUS_SHIFT) & PCICFG_BUS_MASK)
+#define	PCI_CONFIG_SLOT(a)	(((a) >> PCICFG_SLOT_SHIFT) & PCICFG_SLOT_MASK)
+#define	PCI_CONFIG_FUN(a)	(((a) >> PCICFG_FUN_SHIFT) & PCICFG_FUN_MASK)
+#define	PCI_CONFIG_OFF(a)	(((a) >> PCICFG_OFF_SHIFT) & PCICFG_OFF_MASK)
+
+/* The actual config space */
+
+#define	PCI_BAR_MAX		6
+
+#define	PCI_ROM_BAR		8
+
+#define	PCR_RSVDA_MAX		2
+
+/* pci config status reg has a bit to indicate that capability ptr is present*/
+
+#define PCI_CAPPTR_PRESENT	0x0010
+
+typedef struct _pci_config_regs {
+    unsigned short	vendor;
+    unsigned short	device;
+    unsigned short	command;
+    unsigned short	status;
+    unsigned char	rev_id;
+    unsigned char	prog_if;
+    unsigned char	sub_class;
+    unsigned char	base_class;
+    unsigned char	cache_line_size;
+    unsigned char	latency_timer;
+    unsigned char	header_type;
+    unsigned char	bist;
+    unsigned long	base[PCI_BAR_MAX];
+    unsigned long	cardbus_cis;
+    unsigned short	subsys_vendor;
+    unsigned short	subsys_id;
+    unsigned long	baserom;
+    unsigned long	rsvd_a[PCR_RSVDA_MAX];
+    unsigned char	int_line;
+    unsigned char	int_pin;
+    unsigned char	min_gnt;
+    unsigned char	max_lat;
+    unsigned char	dev_dep[192];
+} pci_config_regs;
+
+#define	SZPCR		(sizeof (pci_config_regs))
+#define	MINSZPCR	64		/* offsetof (dev_dep[0] */
+
+/* A structure for the config registers is nice, but in most
+ * systems the config space is not memory mapped, so we need
+ * filed offsetts. :-(
+ */
+#define	PCI_CFG_VID		0
+#define	PCI_CFG_DID		2
+#define	PCI_CFG_CMD		4
+#define	PCI_CFG_STAT		6
+#define	PCI_CFG_REV		8
+#define	PCI_CFG_PROGIF		9
+#define	PCI_CFG_SUBCL		0xa
+#define	PCI_CFG_BASECL		0xb
+#define	PCI_CFG_CLSZ		0xc
+#define	PCI_CFG_LATTIM		0xd
+#define	PCI_CFG_HDR		0xe
+#define	PCI_CFG_BIST		0xf
+#define	PCI_CFG_BAR0		0x10
+#define	PCI_CFG_BAR1		0x14
+#define	PCI_CFG_BAR2		0x18
+#define	PCI_CFG_BAR3		0x1c
+#define	PCI_CFG_BAR4		0x20
+#define	PCI_CFG_BAR5		0x24
+#define	PCI_CFG_CIS		0x28
+#define	PCI_CFG_SVID		0x2c
+#define	PCI_CFG_SSID		0x2e
+#define	PCI_CFG_ROMBAR		0x30
+#define PCI_CFG_CAPPTR		0x34
+#define	PCI_CFG_INT		0x3c
+#define	PCI_CFG_PIN		0x3d
+#define	PCI_CFG_MINGNT		0x3e
+#define	PCI_CFG_MAXLAT		0x3f
+
+/* Classes and subclasses */
+
+typedef enum {
+    PCI_CLASS_OLD = 0,
+    PCI_CLASS_DASDI,
+    PCI_CLASS_NET,
+    PCI_CLASS_DISPLAY,
+    PCI_CLASS_MMEDIA,
+    PCI_CLASS_MEMORY,
+    PCI_CLASS_BRIDGE,
+    PCI_CLASS_COMM,
+    PCI_CLASS_BASE,
+    PCI_CLASS_INPUT,
+    PCI_CLASS_DOCK,
+    PCI_CLASS_CPU,
+    PCI_CLASS_SERIAL,
+    PCI_CLASS_INTELLIGENT = 0xe,
+    PCI_CLASS_SATELLITE,
+    PCI_CLASS_CRYPT,
+    PCI_CLASS_DSP,
+    PCI_CLASS_MAX
+} pci_classes;
+
+typedef enum {
+    PCI_DASDI_SCSI,
+    PCI_DASDI_IDE,
+    PCI_DASDI_FLOPPY,
+    PCI_DASDI_IPI,
+    PCI_DASDI_RAID,
+    PCI_DASDI_OTHER = 0x80
+} pci_dasdi_subclasses;
+
+typedef enum {
+    PCI_NET_ETHER,
+    PCI_NET_TOKEN,
+    PCI_NET_FDDI,
+    PCI_NET_ATM,
+    PCI_NET_OTHER = 0x80
+} pci_net_subclasses;
+
+typedef enum {
+    PCI_DISPLAY_VGA,
+    PCI_DISPLAY_XGA,
+    PCI_DISPLAY_3D,
+    PCI_DISPLAY_OTHER = 0x80
+} pci_display_subclasses;
+
+typedef enum {
+    PCI_MMEDIA_VIDEO,
+    PCI_MMEDIA_AUDIO,
+    PCI_MMEDIA_PHONE,
+    PCI_MEDIA_OTHER = 0x80
+} pci_mmedia_subclasses;
+
+typedef enum {
+    PCI_MEMORY_RAM,
+    PCI_MEMORY_FLASH,
+    PCI_MEMORY_OTHER = 0x80
+} pci_memory_subclasses;
+
+typedef enum {
+    PCI_BRIDGE_HOST,
+    PCI_BRIDGE_ISA,
+    PCI_BRIDGE_EISA,
+    PCI_BRIDGE_MC,
+    PCI_BRIDGE_PCI,
+    PCI_BRIDGE_PCMCIA,
+    PCI_BRIDGE_NUBUS,
+    PCI_BRIDGE_CARDBUS,
+    PCI_BRIDGE_RACEWAY,
+    PCI_BRIDGE_OTHER = 0x80
+} pci_bridge_subclasses;
+
+typedef enum {
+    PCI_COMM_UART,
+    PCI_COMM_PARALLEL,
+    PCI_COMM_MULTIUART,
+    PCI_COMM_MODEM,
+    PCI_COMM_OTHER = 0x80
+} pci_comm_subclasses;
+
+typedef enum {
+    PCI_BASE_PIC,
+    PCI_BASE_DMA,
+    PCI_BASE_TIMER,
+    PCI_BASE_RTC,
+    PCI_BASE_PCI_HOTPLUG,
+    PCI_BASE_OTHER = 0x80
+} pci_base_subclasses;
+
+typedef enum {
+    PCI_INPUT_KBD,
+    PCI_INPUT_PEN,
+    PCI_INPUT_MOUSE,
+    PCI_INPUT_SCANNER,
+    PCI_INPUT_GAMEPORT,
+    PCI_INPUT_OTHER = 0x80
+} pci_input_subclasses;
+
+typedef enum {
+    PCI_DOCK_GENERIC,
+    PCI_DOCK_OTHER = 0x80
+} pci_dock_subclasses;
+
+typedef enum {
+    PCI_CPU_386,
+    PCI_CPU_486,
+    PCI_CPU_PENTIUM,
+    PCI_CPU_ALPHA = 0x10,
+    PCI_CPU_POWERPC = 0x20,
+    PCI_CPU_MIPS = 0x30,
+    PCI_CPU_COPROC = 0x40,
+    PCI_CPU_OTHER = 0x80
+} pci_cpu_subclasses;
+
+typedef enum {
+    PCI_SERIAL_IEEE1394,
+    PCI_SERIAL_ACCESS,
+    PCI_SERIAL_SSA,
+    PCI_SERIAL_USB,
+    PCI_SERIAL_FIBER,
+    PCI_SERIAL_SMBUS,
+    PCI_SERIAL_OTHER = 0x80
+} pci_serial_subclasses;
+
+typedef enum {
+    PCI_INTELLIGENT_I2O,
+} pci_intelligent_subclasses;
+
+typedef enum {
+    PCI_SATELLITE_TV,
+    PCI_SATELLITE_AUDIO,
+    PCI_SATELLITE_VOICE,
+    PCI_SATELLITE_DATA,
+    PCI_SATELLITE_OTHER = 0x80
+} pci_satellite_subclasses;
+
+typedef enum {
+    PCI_CRYPT_NETWORK,
+    PCI_CRYPT_ENTERTAINMENT,
+    PCI_CRYPT_OTHER = 0x80
+} pci_crypt_subclasses;
+
+typedef enum {
+    PCI_DSP_DPIO,
+    PCI_DSP_OTHER = 0x80
+} pci_dsp_subclasses;
+
+/* Header types */
+typedef enum {
+	PCI_HEADER_NORMAL,
+	PCI_HEADER_BRIDGE,
+	PCI_HEADER_CARDBUS
+} pci_header_types;
+
+
+/* Overlay for a PCI-to-PCI bridge */
+
+#define	PPB_RSVDA_MAX		2
+#define	PPB_RSVDD_MAX		8
+
+typedef struct _ppb_config_regs {
+    unsigned short	vendor;
+    unsigned short	device;
+    unsigned short	command;
+    unsigned short	status;
+    unsigned char	rev_id;
+    unsigned char	prog_if;
+    unsigned char	sub_class;
+    unsigned char	base_class;
+    unsigned char	cache_line_size;
+    unsigned char	latency_timer;
+    unsigned char	header_type;
+    unsigned char	bist;
+    unsigned long	rsvd_a[PPB_RSVDA_MAX];
+    unsigned char	prim_bus;
+    unsigned char	sec_bus;
+    unsigned char	sub_bus;
+    unsigned char	sec_lat;
+    unsigned char	io_base;
+    unsigned char	io_lim;
+    unsigned short	sec_status;
+    unsigned short	mem_base;
+    unsigned short	mem_lim;
+    unsigned short	pf_mem_base;
+    unsigned short	pf_mem_lim;
+    unsigned long	pf_mem_base_hi;
+    unsigned long	pf_mem_lim_hi;
+    unsigned short	io_base_hi;
+    unsigned short	io_lim_hi;
+    unsigned short	subsys_vendor;
+    unsigned short	subsys_id;
+    unsigned long	rsvd_b;
+    unsigned char	rsvd_c;
+    unsigned char	int_pin;
+    unsigned short	bridge_ctrl;
+    unsigned char	chip_ctrl;
+    unsigned char	diag_ctrl;
+    unsigned short	arb_ctrl;
+    unsigned long	rsvd_d[PPB_RSVDD_MAX];
+    unsigned char	dev_dep[192];
+} ppb_config_regs;
+
+
+/* PCI CAPABILITY DEFINES */
+#define PCI_CAP_POWERMGMTCAP_ID		0x01
+#define PCI_CAP_MSICAP_ID		0x05
+
+/* Data structure to define the Message Signalled Interrupt facility 
+ * Valid for PCI and PCIE configurations */
+typedef struct _pciconfig_cap_msi {
+	unsigned char capID;
+	unsigned char nextptr;
+	unsigned short msgctrl;
+	unsigned int msgaddr;
+} pciconfig_cap_msi;
+
+/* Data structure to define the Power managment facility
+ * Valid for PCI and PCIE configurations */
+typedef struct _pciconfig_cap_pwrmgmt {
+	unsigned char capID;
+	unsigned char nextptr;
+	unsigned short pme_cap;
+	unsigned short  pme_sts_ctrl; 
+	unsigned char  pme_bridge_ext;
+	unsigned char  data;
+} pciconfig_cap_pwrmgmt;
+
+/* Everything below is BRCM HND proprietary */
+
+#define	PCI_BAR0_WIN		0x80	/* backplane addres space accessed by BAR0 */
+#define	PCI_BAR1_WIN		0x84	/* backplane addres space accessed by BAR1 */
+#define	PCI_SPROM_CONTROL	0x88	/* sprom property control */
+#define	PCI_BAR1_CONTROL	0x8c	/* BAR1 region burst control */
+#define	PCI_INT_STATUS		0x90	/* PCI and other cores interrupts */
+#define	PCI_INT_MASK		0x94	/* mask of PCI and other cores interrupts */
+#define PCI_TO_SB_MB		0x98	/* signal backplane interrupts */
+#define PCI_BACKPLANE_ADDR	0xA0	/* address an arbitrary location on the system backplane */
+#define PCI_BACKPLANE_DATA	0xA4	/* data at the location specified by above address register */
+#define	PCI_GPIO_IN		0xb0	/* pci config space gpio input (>=rev3) */
+#define	PCI_GPIO_OUT		0xb4	/* pci config space gpio output (>=rev3) */
+#define	PCI_GPIO_OUTEN		0xb8	/* pci config space gpio output enable (>=rev3) */
+
+#define	PCI_BAR0_SPROM_OFFSET	(4 * 1024)	/* bar0 + 4K accesses external sprom */
+#define	PCI_BAR0_PCIREGS_OFFSET	(6 * 1024)	/* bar0 + 6K accesses pci core registers */
+
+/* PCI_INT_STATUS */
+#define	PCI_SBIM_STATUS_SERR	0x4	/* backplane SBErr interrupt status */
+
+/* PCI_INT_MASK */
+#define	PCI_SBIM_SHIFT		8	/* backplane core interrupt mask bits offset */
+#define	PCI_SBIM_MASK		0xff00	/* backplane core interrupt mask */
+#define	PCI_SBIM_MASK_SERR	0x4	/* backplane SBErr interrupt mask */
+
+/* PCI_SPROM_CONTROL */
+#define	SPROM_BLANK		0x04  	/* indicating a blank sprom */
+#define SPROM_WRITEEN		0x10	/* sprom write enable */
+#define SPROM_BOOTROM_WE	0x20	/* external bootrom write enable */
+
+#define	SPROM_SIZE		256	/* sprom size in 16-bit */
+#define SPROM_CRC_RANGE		64	/* crc cover range in 16-bit */
+
+/* PCI_CFG_CMD_STAT */
+#define PCI_CFG_CMD_STAT_TA	0x08000000	/* target abort status */
+
+#endif
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/proto/ethernet.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/proto/ethernet.h
--- linux-2.6.16/arch/mips/bcm947xx/include/proto/ethernet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/proto/ethernet.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ * $Id$
+ * Copyright 2001-2003, Broadcom Corporation   
+ * All Rights Reserved.   
+ *    
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY   
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM   
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS   
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.   
+ * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
+ ******************************************************************************/
+
+#ifndef _NET_ETHERNET_H_	    /* use native BSD ethernet.h when available */
+#define _NET_ETHERNET_H_
+
+#ifndef _TYPEDEFS_H_
+#include "typedefs.h"
+#endif
+
+#if defined(__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#define	PACKED
+#endif
+
+/*
+ * The number of bytes in an ethernet (MAC) address.
+ */
+#define	ETHER_ADDR_LEN		6
+
+/*
+ * The number of bytes in the type field.
+ */
+#define	ETHER_TYPE_LEN		2
+
+/*
+ * The number of bytes in the trailing CRC field.
+ */
+#define	ETHER_CRC_LEN		4
+
+/*
+ * The length of the combined header.
+ */
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN*2+ETHER_TYPE_LEN)
+
+/*
+ * The minimum packet length.
+ */
+#define	ETHER_MIN_LEN		64
+
+/*
+ * The minimum packet user data length.
+ */
+#define	ETHER_MIN_DATA		46
+
+/*
+ * The maximum packet length.
+ */
+#define	ETHER_MAX_LEN		1518
+
+/*
+ * The maximum packet user data length.
+ */
+#define	ETHER_MAX_DATA		1500
+
+/*
+ * Used to uniquely identify a 802.1q VLAN-tagged header.
+ */
+#define	VLAN_TAG			0x8100
+
+/*
+ * Located after dest & src address in ether header.
+ */
+#define VLAN_FIELDS_OFFSET		(ETHER_ADDR_LEN * 2)
+
+/*
+ * 4 bytes of vlan field info.
+ */
+#define VLAN_FIELDS_SIZE		4
+
+/* location of pri bits in 16-bit vlan fields */
+#define VLAN_PRI_SHIFT			13
+
+/* 3 bits of priority */
+#define VLAN_PRI_MASK			7
+
+/* 802.1X ethertype */
+#define ETHER_TYPE_802_1X	0x888e
+
+/*
+ * A macro to validate a length with
+ */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+
+#ifndef __INCif_etherh     /* Quick and ugly hack for VxWorks */
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+struct	ether_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];
+	uint8	ether_shost[ETHER_ADDR_LEN];
+	uint16	ether_type;
+} PACKED ;
+
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+struct	ether_addr {
+	uint8 octet[ETHER_ADDR_LEN];
+} PACKED ;
+#endif
+
+/*
+ * Takes a pointer, returns true if a 48-bit multicast address
+ * (including broadcast, since it is all ones)
+ */
+#define ETHER_ISMULTI(ea) (((uint8 *)(ea))[0] & 1)
+
+/*
+ * Takes a pointer, returns true if a 48-bit broadcast (all ones)
+ */
+#define ETHER_ISBCAST(ea) ((((uint8 *)(ea))[0] &		\
+			    ((uint8 *)(ea))[1] &		\
+			    ((uint8 *)(ea))[2] &		\
+			    ((uint8 *)(ea))[3] &		\
+			    ((uint8 *)(ea))[4] &		\
+			    ((uint8 *)(ea))[5]) == 0xff)
+
+static const struct ether_addr ether_bcast = {{255, 255, 255, 255, 255, 255}};
+
+/*
+ * Takes a pointer, returns true if a 48-bit null address (all zeros)
+ */
+#define ETHER_ISNULLADDR(ea) ((((uint8 *)(ea))[0] |		\
+			    ((uint8 *)(ea))[1] |		\
+			    ((uint8 *)(ea))[2] |		\
+			    ((uint8 *)(ea))[3] |		\
+			    ((uint8 *)(ea))[4] |		\
+			    ((uint8 *)(ea))[5]) == 0)
+
+#undef PACKED
+
+#endif /* _NET_ETHERNET_H_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/s5.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/s5.h
--- linux-2.6.16/arch/mips/bcm947xx/include/s5.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/s5.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,103 @@
+#ifndef _S5_H_
+#define _S5_H_
+/*
+ *   Copyright 2003, Broadcom Corporation
+ *   All Rights Reserved.
+ * 
+ *   Broadcom Sentry5 (S5) BCM5365, 53xx, BCM58xx SOC Internal Core
+ *   and MIPS3301 (R4K) System Address Space
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License as
+ *   published by the Free Software Foundation, located in the file
+ *   LICENSE.
+ *
+ *   $Id: s5.h,v 1.3 2003/06/10 18:54:51 jfd Exp $
+ * 
+ */
+
+/* BCM5365 Address map */
+#define KSEG1ADDR(x)    ( (x) | 0xa0000000)
+#define BCM5365_SDRAM		0x00000000 /* 0-128MB Physical SDRAM */
+#define BCM5365_PCI_MEM		0x08000000 /* Host Mode PCI mem space (64MB) */
+#define BCM5365_PCI_CFG		0x0c000000 /* Host Mode PCI cfg space (64MB) */
+#define BCM5365_PCI_DMA		0x40000000 /* Client Mode PCI mem space (1GB)*/
+#define	BCM5365_SDRAM_SWAPPED	0x10000000 /* Byteswapped Physical SDRAM */
+#define BCM5365_ENUM		0x18000000 /* Beginning of core enum space */
+
+/* BCM5365 Core register space */
+#define BCM5365_REG_CHIPC	0x18000000 /* Chipcommon  registers */
+#define BCM5365_REG_EMAC0	0x18001000 /* Ethernet MAC0 core registers */
+#define BCM5365_REG_IPSEC	0x18002000 /* BCM582x CryptoCore registers */
+#define BCM5365_REG_USB		0x18003000 /* USB core registers */
+#define BCM5365_REG_PCI		0x18004000 /* PCI core registers */
+#define BCM5365_REG_MIPS33	0x18005000 /* MIPS core registers */
+#define BCM5365_REG_MEMC	0x18006000 /* MEMC core registers */
+#define BCM5365_REG_UARTS       (BCM5365_REG_CHIPC + 0x300) /* UART regs */
+#define	BCM5365_EJTAG		0xff200000 /* MIPS EJTAG space (2M) */
+
+/* COM Ports 1/2 */
+#define	BCM5365_UART		(BCM5365_REG_UARTS)
+#define BCM5365_UART_COM2	(BCM5365_REG_UARTS + 0x00000100)
+
+/* Registers common to MIPS33 Core used in 5365 */
+#define MIPS33_FLASH_REGION           0x1fc00000 /* Boot FLASH Region  */
+#define MIPS33_EXTIF_REGION           0x1a000000 /* Chipcommon EXTIF region*/
+#define BCM5365_EXTIF                 0x1b000000 /* MISC_CS */
+#define MIPS33_FLASH_REGION_AUX       0x1c000000 /* FLASH Region 2*/
+
+/* Internal Core Sonics Backplane Devices */
+#define INTERNAL_UART_COM1            BCM5365_UART
+#define INTERNAL_UART_COM2            BCM5365_UART_COM2
+#define SB_REG_CHIPC                  BCM5365_REG_CHIPC
+#define SB_REG_ENET0                  BCM5365_REG_EMAC0
+#define SB_REG_IPSEC                  BCM5365_REG_IPSEC
+#define SB_REG_USB                    BCM5365_REG_USB
+#define SB_REG_PCI                    BCM5365_REG_PCI
+#define SB_REG_MIPS                   BCM5365_REG_MIPS33
+#define SB_REG_MEMC                   BCM5365_REG_MEMC
+#define SB_REG_MEMC_OFF               0x6000
+#define SB_EXTIF_SPACE                MIPS33_EXTIF_REGION
+#define SB_FLASH_SPACE                MIPS33_FLASH_REGION
+
+/*
+ * XXX
+ * 5365-specific backplane interrupt flag numbers.  This should be done
+ * dynamically instead.
+ */
+#define	SBFLAG_PCI	0
+#define	SBFLAG_ENET0	1
+#define	SBFLAG_ILINE20	2
+#define	SBFLAG_CODEC	3
+#define	SBFLAG_USB	4
+#define	SBFLAG_EXTIF	5
+#define	SBFLAG_ENET1	6
+
+/* BCM95365 Local Bus devices */
+#define BCM95365K_RESET_ADDR    	 BCM5365_EXTIF
+#define BCM95365K_BOARDID_ADDR  	(BCM5365_EXTIF | 0x4000)
+#define BCM95365K_DOC_ADDR      	(BCM5365_EXTIF | 0x6000)
+#define BCM95365K_LED_ADDR      	(BCM5365_EXTIF | 0xc000)
+#define BCM95365K_TOD_REG_BASE          (BCM95365K_NVRAM_ADDR | 0x1ff0)
+#define BCM95365K_NVRAM_ADDR    	(BCM5365_EXTIF | 0xe000)
+#define BCM95365K_NVRAM_SIZE             0x1ff0 /* 8K NVRAM : DS1743/STM48txx*/
+
+/* Write to DLR2416 VFD Display character RAM */
+#define LED_REG(x)      \
+ (*(volatile unsigned char *) (KSEG1ADDR(BCM95365K_LED_ADDR) + (x)))
+
+#ifdef	CONFIG_VSIM
+#define	BCM5365_TRACE(trval)        do { *((int *)0xa0002ff8) = (trval); \
+                                       } while (0)
+#else
+#define	BCM5365_TRACE(trval)        do { *((unsigned char *)\
+                                         KSEG1ADDR(BCM5365K_LED_ADDR)) = (trval); \
+				    *((int *)0xa0002ff8) = (trval); } while (0)
+#endif
+
+/* BCM9536R Local Bus devices */
+#define BCM95365R_DOC_ADDR      	BCM5365_EXTIF
+
+
+
+#endif /*!_S5_H_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbchipc.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbchipc.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbchipc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbchipc.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,440 @@
+/*
+ * SiliconBackplane Chipcommon core hardware definitions.
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ * $Id$
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ */
+
+#ifndef	_SBCHIPC_H
+#define	_SBCHIPC_H
+
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
+typedef volatile struct {
+	uint32	chipid;			/* 0x0 */
+	uint32	capabilities;
+	uint32	corecontrol;		/* corerev >= 1 */
+	uint32	bist;
+
+	/* OTP */
+	uint32	otpstatus;		/* 0x10, corerev >= 10 */
+	uint32	otpcontrol;
+	uint32	otpprog;
+	uint32	PAD;
+
+	/* Interrupt control */
+	uint32	intstatus;		/* 0x20 */
+	uint32	intmask;
+	uint32	chipcontrol;		/* 0x28, rev >= 11 */
+	uint32	chipstatus;		/* 0x2c, rev >= 11 */
+
+	/* Jtag Master */
+	uint32	jtagcmd;		/* 0x30, rev >= 10 */
+	uint32	jtagir;
+	uint32	jtagdr;
+	uint32	jtagctrl;
+
+	/* serial flash interface registers */
+	uint32	flashcontrol;		/* 0x40 */
+	uint32	flashaddress;
+	uint32	flashdata;
+	uint32	PAD[1];
+
+	/* Silicon backplane configuration broadcast control */
+	uint32	broadcastaddress;	/* 0x50 */
+	uint32	broadcastdata;
+	uint32	PAD[2];
+
+	/* gpio - cleared only by power-on-reset */
+	uint32	gpioin;			/* 0x60 */
+	uint32	gpioout;
+	uint32	gpioouten;
+	uint32	gpiocontrol;
+	uint32	gpiointpolarity;
+	uint32	gpiointmask;
+	uint32	PAD[2];
+
+	/* Watchdog timer */
+	uint32	watchdog;		/* 0x80 */
+	uint32	PAD[1];
+
+	/*GPIO based LED powersave registers corerev >= 16*/
+	uint32  gpiotimerval;		/*0x88 */
+	uint32  gpiotimeroutmask;
+
+	/* clock control */
+	uint32	clockcontrol_n;		/* 0x90 */
+	uint32	clockcontrol_sb;	/* aka m0 */
+	uint32	clockcontrol_pci;	/* aka m1 */
+	uint32	clockcontrol_m2;	/* mii/uart/mipsref */
+	uint32	clockcontrol_mips;	/* aka m3 */
+	uint32	clkdiv;			/* corerev >= 3 */
+	uint32	PAD[2];
+
+	/* pll delay registers (corerev >= 4) */
+	uint32	pll_on_delay;		/* 0xb0 */
+	uint32	fref_sel_delay;
+	uint32	slow_clk_ctl;		/* 5 < corerev < 10 */
+	uint32	PAD[1];
+
+	/* Instaclock registers (corerev >= 10) */
+	uint32	system_clk_ctl;		/* 0xc0 */
+	uint32	clkstatestretch;
+	uint32	PAD[14];
+
+	/* ExtBus control registers (corerev >= 3) */
+	uint32	pcmcia_config;		/* 0x100 */
+	uint32	pcmcia_memwait;
+	uint32	pcmcia_attrwait;
+	uint32	pcmcia_iowait;
+	uint32	ide_config;
+	uint32	ide_memwait;
+	uint32	ide_attrwait;
+	uint32	ide_iowait;
+	uint32	prog_config;
+	uint32	prog_waitcount;
+	uint32	flash_config;
+	uint32	flash_waitcount;
+	uint32	PAD[116];
+
+	/* uarts */
+	uint8	uart0data;		/* 0x300 */
+	uint8	uart0imr;
+	uint8	uart0fcr;
+	uint8	uart0lcr;
+	uint8	uart0mcr;
+	uint8	uart0lsr;
+	uint8	uart0msr;
+	uint8	uart0scratch;
+	uint8	PAD[248];		/* corerev >= 1 */
+
+	uint8	uart1data;		/* 0x400 */
+	uint8	uart1imr;
+	uint8	uart1fcr;
+	uint8	uart1lcr;
+	uint8	uart1mcr;
+	uint8	uart1lsr;
+	uint8	uart1msr;
+	uint8	uart1scratch;
+} chipcregs_t;
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#define	CC_CHIPID		0
+#define	CC_CAPABILITIES		4
+#define	CC_JTAGCMD		0x30
+#define	CC_JTAGIR		0x34
+#define	CC_JTAGDR		0x38
+#define	CC_JTAGCTRL		0x3c
+#define	CC_WATCHDOG		0x80
+#define	CC_CLKC_N		0x90
+#define	CC_CLKC_M0		0x94
+#define	CC_CLKC_M1		0x98
+#define	CC_CLKC_M2		0x9c
+#define	CC_CLKC_M3		0xa0
+#define	CC_CLKDIV		0xa4
+#define	CC_SYS_CLK_CTL		0xc0
+#define	CC_OTP			0x800
+
+/* chipid */
+#define	CID_ID_MASK		0x0000ffff		/* Chip Id mask */
+#define	CID_REV_MASK		0x000f0000		/* Chip Revision mask */
+#define	CID_REV_SHIFT		16			/* Chip Revision shift */
+#define	CID_PKG_MASK		0x00f00000		/* Package Option mask */
+#define	CID_PKG_SHIFT		20			/* Package Option shift */
+#define	CID_CC_MASK		0x0f000000		/* CoreCount (corerev >= 4) */
+#define CID_CC_SHIFT		24
+
+/* capabilities */
+#define	CAP_UARTS_MASK		0x00000003		/* Number of uarts */
+#define CAP_MIPSEB		0x00000004		/* MIPS is in big-endian mode */
+#define CAP_UCLKSEL		0x00000018		/* UARTs clock select */
+#define CAP_UINTCLK		0x00000008		/* UARTs are driven by internal divided clock */
+#define CAP_UARTGPIO		0x00000020		/* UARTs own Gpio's 15:12 */
+#define CAP_EXTBUS		0x00000040		/* External bus present */
+#define	CAP_FLASH_MASK		0x00000700		/* Type of flash */
+#define	CAP_PLL_MASK		0x00038000		/* Type of PLL */
+#define CAP_PWR_CTL		0x00040000		/* Power control */
+#define CAP_OTPSIZE		0x00380000		/* OTP Size (0 = none) */
+#define CAP_OTPSIZE_SHIFT	19			/* OTP Size shift */
+#define CAP_OTPSIZE_BASE	5			/* OTP Size base */
+#define CAP_JTAGP		0x00400000		/* JTAG Master Present */
+#define CAP_ROM			0x00800000		/* Internal boot rom active */
+
+/* PLL type */
+#define PLL_NONE		0x00000000
+#define PLL_TYPE1		0x00010000		/* 48Mhz base, 3 dividers */
+#define PLL_TYPE2		0x00020000		/* 48Mhz, 4 dividers */
+#define PLL_TYPE3		0x00030000		/* 25Mhz, 2 dividers */
+#define PLL_TYPE4		0x00008000		/* 48Mhz, 4 dividers */
+#define PLL_TYPE5		0x00018000		/* 25Mhz, 4 dividers */
+#define PLL_TYPE6		0x00028000		/* 100/200 or 120/240 only */
+#define PLL_TYPE7		0x00038000		/* 25Mhz, 4 dividers */
+
+/* corecontrol */
+#define CC_UARTCLKO		0x00000001		/* Drive UART with internal clock */
+#define	CC_SE			0x00000002		/* sync clk out enable (corerev >= 3) */
+
+/* Fields in the otpstatus register */
+#define	OTPS_PROGFAIL		0x80000000
+#define	OTPS_PROTECT		0x00000007
+#define	OTPS_HW_PROTECT		0x00000001
+#define	OTPS_SW_PROTECT		0x00000002
+#define	OTPS_CID_PROTECT	0x00000004
+
+/* Fields in the otpcontrol register */
+#define	OTPC_RECWAIT		0xff000000
+#define	OTPC_PROGWAIT		0x00ffff00
+#define	OTPC_PRW_SHIFT		8
+#define	OTPC_MAXFAIL		0x00000038
+#define	OTPC_VSEL		0x00000006
+#define	OTPC_SELVL		0x00000001
+
+/* Fields in otpprog */
+#define	OTPP_COL_MASK		0x000000ff
+#define	OTPP_ROW_MASK		0x0000ff00
+#define	OTPP_ROW_SHIFT		8
+#define	OTPP_READERR		0x10000000
+#define	OTPP_VALUE		0x20000000
+#define	OTPP_VALUE_SHIFT		29
+#define	OTPP_READ		0x40000000
+#define	OTPP_START		0x80000000
+#define	OTPP_BUSY		0x80000000
+
+/* jtagcmd */
+#define JCMD_START		0x80000000
+#define JCMD_BUSY		0x80000000
+#define JCMD_PAUSE		0x40000000
+#define JCMD0_ACC_MASK		0x0000f000
+#define JCMD0_ACC_IRDR		0x00000000
+#define JCMD0_ACC_DR		0x00001000
+#define JCMD0_ACC_IR		0x00002000
+#define JCMD0_ACC_RESET		0x00003000
+#define JCMD0_ACC_IRPDR		0x00004000
+#define JCMD0_ACC_PDR		0x00005000
+#define JCMD0_IRW_MASK		0x00000f00
+#define JCMD_ACC_MASK		0x000f0000		/* Changes for corerev 11 */
+#define JCMD_ACC_IRDR		0x00000000
+#define JCMD_ACC_DR		0x00010000
+#define JCMD_ACC_IR		0x00020000
+#define JCMD_ACC_RESET		0x00030000
+#define JCMD_ACC_IRPDR		0x00040000
+#define JCMD_ACC_PDR		0x00050000
+#define JCMD_IRW_MASK		0x00001f00
+#define JCMD_IRW_SHIFT		8
+#define JCMD_DRW_MASK		0x0000003f
+
+/* jtagctrl */
+#define JCTRL_FORCE_CLK		4			/* Force clock */
+#define JCTRL_EXT_EN		2			/* Enable external targets */
+#define JCTRL_EN		1			/* Enable Jtag master */
+
+/* Fields in clkdiv */
+#define	CLKD_SFLASH		0x0f000000
+#define	CLKD_SFLASH_SHIFT	24
+#define	CLKD_OTP		0x000f0000
+#define	CLKD_OTP_SHIFT		16
+#define	CLKD_JTAG		0x00000f00
+#define	CLKD_JTAG_SHIFT		8		
+#define	CLKD_UART		0x000000ff
+
+/* intstatus/intmask */
+#define	CI_GPIO			0x00000001		/* gpio intr */
+#define	CI_EI			0x00000002		/* ro: ext intr pin (corerev >= 3) */
+#define	CI_WDRESET		0x80000000		/* watchdog reset occurred */
+
+/* slow_clk_ctl */
+#define SCC_SS_MASK		0x00000007		/* slow clock source mask */
+#define	SCC_SS_LPO		0x00000000		/* source of slow clock is LPO */
+#define	SCC_SS_XTAL		0x00000001		/* source of slow clock is crystal */
+#define	SCC_SS_PCI		0x00000002		/* source of slow clock is PCI */
+#define SCC_LF			0x00000200		/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define SCC_LP			0x00000400		/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
+#define SCC_FS			0x00000800		/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
+#define SCC_IP			0x00001000		/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
+#define SCC_XC			0x00002000		/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
+#define SCC_XP			0x00004000		/* XtalPU (RO), 1/0: crystal running/disabled */
+#define SCC_CD_MASK		0xffff0000		/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define SCC_CD_SHIFT		16
+
+/* system_clk_ctl */
+#define	SYCC_IE			0x00000001		/* ILPen: Enable Idle Low Power */
+#define	SYCC_AE			0x00000002		/* ALPen: Enable Active Low Power */
+#define	SYCC_FP			0x00000004		/* ForcePLLOn */
+#define	SYCC_AR			0x00000008		/* Force ALP (or HT if ALPen is not set */
+#define	SYCC_HR			0x00000010		/* Force HT */
+#define SYCC_CD_MASK		0xffff0000		/* ClkDiv  (ILP = 1/(4+divisor)) */
+#define SYCC_CD_SHIFT		16
+
+/* gpiotimerval*/
+#define GPIO_ONTIME_SHIFT	16
+
+/* clockcontrol_n */
+#define	CN_N1_MASK		0x3f			/* n1 control */
+#define	CN_N2_MASK		0x3f00			/* n2 control */
+#define	CN_N2_SHIFT		8
+#define	CN_PLLC_MASK		0xf0000			/* pll control */
+#define	CN_PLLC_SHIFT		16
+
+/* clockcontrol_sb/pci/uart */
+#define	CC_M1_MASK		0x3f			/* m1 control */
+#define	CC_M2_MASK		0x3f00			/* m2 control */
+#define	CC_M2_SHIFT		8
+#define	CC_M3_MASK		0x3f0000		/* m3 control */
+#define	CC_M3_SHIFT		16
+#define	CC_MC_MASK		0x1f000000		/* mux control */
+#define	CC_MC_SHIFT		24
+
+/* N3M Clock control magic field values */
+#define	CC_F6_2			0x02			/* A factor of 2 in */
+#define	CC_F6_3			0x03			/* 6-bit fields like */
+#define	CC_F6_4			0x05			/* N1, M1 or M3 */
+#define	CC_F6_5			0x09
+#define	CC_F6_6			0x11
+#define	CC_F6_7			0x21
+
+#define	CC_F5_BIAS		5			/* 5-bit fields get this added */
+
+#define	CC_MC_BYPASS		0x08
+#define	CC_MC_M1		0x04
+#define	CC_MC_M1M2		0x02
+#define	CC_MC_M1M2M3		0x01
+#define	CC_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	CC_T2_BIAS		2			/* n1, n2, m1 & m3 bias */
+#define	CC_T2M2_BIAS		3			/* m2 bias */
+
+#define	CC_T2MC_M1BYP		1
+#define	CC_T2MC_M2BYP		2
+#define	CC_T2MC_M3BYP		4
+
+/* Type 6 Clock control magic field values */
+#define	CC_T6_MMASK		1			/* bits of interest in m */
+#define	CC_T6_M0		120000000		/* sb clock for m = 0 */
+#define	CC_T6_M1		100000000		/* sb clock for m = 1 */
+#define	SB2MIPS_T6(sb)		(2 * (sb))
+
+/* Common clock base */
+#define	CC_CLOCK_BASE1		24000000		/* Half the clock freq */
+#define CC_CLOCK_BASE2		12500000		/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define	CLKC_5350_N		0x0311
+#define	CLKC_5350_M		0x04020009
+
+/* Flash types in the chipcommon capabilities register */
+#define FLASH_NONE		0x000		/* No flash */
+#define SFLASH_ST		0x100		/* ST serial flash */
+#define SFLASH_AT		0x200		/* Atmel serial flash */
+#define	PFLASH			0x700		/* Parallel flash */
+
+/* Bits in the config registers */
+#define	CC_CFG_EN		0x0001		/* Enable */
+#define	CC_CFG_EM_MASK		0x000e		/* Extif Mode */
+#define	CC_CFG_EM_ASYNC		0x0002		/*   Async/Parallel flash */
+#define	CC_CFG_EM_SYNC		0x0004		/*   Synchronous */
+#define	CC_CFG_EM_PCMCIA	0x0008		/*   PCMCIA */
+#define	CC_CFG_EM_IDE		0x000a		/*   IDE */
+#define	CC_CFG_DS		0x0010		/* Data size, 0=8bit, 1=16bit */
+#define	CC_CFG_CD_MASK		0x0060		/* Sync: Clock divisor */
+#define	CC_CFG_CE		0x0080		/* Sync: Clock enable */
+#define	CC_CFG_SB		0x0100		/* Sync: Size/Bytestrobe */
+
+/* Start/busy bit in flashcontrol */
+#define SFLASH_START		0x80000000
+#define SFLASH_BUSY		SFLASH_START
+
+/* flashcontrol opcodes for ST flashes */
+#define SFLASH_ST_WREN		0x0006		/* Write Enable */
+#define SFLASH_ST_WRDIS		0x0004		/* Write Disable */
+#define SFLASH_ST_RDSR		0x0105		/* Read Status Register */
+#define SFLASH_ST_WRSR		0x0101		/* Write Status Register */
+#define SFLASH_ST_READ		0x0303		/* Read Data Bytes */
+#define SFLASH_ST_PP		0x0302		/* Page Program */
+#define SFLASH_ST_SE		0x02d8		/* Sector Erase */
+#define SFLASH_ST_BE		0x00c7		/* Bulk Erase */
+#define SFLASH_ST_DP		0x00b9		/* Deep Power-down */
+#define SFLASH_ST_RES		0x03ab		/* Read Electronic Signature */
+
+/* Status register bits for ST flashes */
+#define SFLASH_ST_WIP		0x01		/* Write In Progress */
+#define SFLASH_ST_WEL		0x02		/* Write Enable Latch */
+#define SFLASH_ST_BP_MASK	0x1c		/* Block Protect */
+#define SFLASH_ST_BP_SHIFT	2
+#define SFLASH_ST_SRWD		0x80		/* Status Register Write Disable */
+
+/* flashcontrol opcodes for Atmel flashes */
+#define SFLASH_AT_READ				0x07e8
+#define SFLASH_AT_PAGE_READ			0x07d2
+#define SFLASH_AT_BUF1_READ
+#define SFLASH_AT_BUF2_READ
+#define SFLASH_AT_STATUS			0x01d7
+#define SFLASH_AT_BUF1_WRITE			0x0384
+#define SFLASH_AT_BUF2_WRITE			0x0387
+#define SFLASH_AT_BUF1_ERASE_PROGRAM		0x0283
+#define SFLASH_AT_BUF2_ERASE_PROGRAM		0x0286
+#define SFLASH_AT_BUF1_PROGRAM			0x0288
+#define SFLASH_AT_BUF2_PROGRAM			0x0289
+#define SFLASH_AT_PAGE_ERASE			0x0281
+#define SFLASH_AT_BLOCK_ERASE			0x0250
+#define SFLASH_AT_BUF1_WRITE_ERASE_PROGRAM	0x0382
+#define SFLASH_AT_BUF2_WRITE_ERASE_PROGRAM	0x0385
+#define SFLASH_AT_BUF1_LOAD			0x0253
+#define SFLASH_AT_BUF2_LOAD			0x0255
+#define SFLASH_AT_BUF1_COMPARE			0x0260
+#define SFLASH_AT_BUF2_COMPARE			0x0261
+#define SFLASH_AT_BUF1_REPROGRAM		0x0258
+#define SFLASH_AT_BUF2_REPROGRAM		0x0259
+
+/* Status register bits for Atmel flashes */
+#define SFLASH_AT_READY				0x80
+#define SFLASH_AT_MISMATCH			0x40
+#define SFLASH_AT_ID_MASK			0x38
+#define SFLASH_AT_ID_SHIFT			3
+
+/* OTP regions */
+#define	OTP_HW_REGION	OTPS_HW_PROTECT
+#define	OTP_SW_REGION	OTPS_SW_PROTECT
+#define	OTP_CID_REGION	OTPS_CID_PROTECT
+
+/* OTP regions (Byte offsets from otp size) */
+#define	OTP_SWLIM_OFF	(-8)
+#define	OTP_CIDBASE_OFF	0
+#define	OTP_CIDLIM_OFF	8
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	OTP_BOUNDARY_OFF (-4)
+#define	OTP_HWSIGN_OFF	(-3)
+#define	OTP_SWSIGN_OFF	(-2)
+#define	OTP_CIDSIGN_OFF	(-1)
+
+#define	OTP_CID_OFF	0
+#define	OTP_PKG_OFF	1
+#define	OTP_FID_OFF	2
+#define	OTP_RSV_OFF	3
+#define	OTP_LIM_OFF	4
+
+#define	OTP_SIGNATURE	0x578a
+#define	OTP_MAGIC	0x4e56
+
+#endif	/* _SBCHIPC_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbconfig.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbconfig.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbconfig.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,342 @@
+/*
+ * Broadcom SiliconBackplane hardware register definitions.
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#ifndef	_SBCONFIG_H
+#define	_SBCONFIG_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/*
+ * SiliconBackplane Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SB_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SB_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SB_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+#define	SB_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SB_ENUM_BASE    	0x18000000	/* Enumeration space base */
+#define	SB_ENUM_LIM		0x18010000	/* Enumeration space limit */
+
+#define	SB_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define	SB_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
+
+#define	SB_EXTIF_BASE		0x1f000000	/* External Interface region base address */
+#define	SB_FLASH1		0x1fc00000	/* Flash Region 1 */
+#define	SB_FLASH1_SZ		0x00400000	/* Size of Flash Region 1 */
+
+#define SB_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SB_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SB_PCIE_DMA_L32		0x00000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
+#define SB_PCIE_DMA_H32		0x80000000	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
+#define	SB_EUART		(SB_EXTIF_BASE + 0x00800000)
+#define	SB_LED			(SB_EXTIF_BASE + 0x00900000)
+
+
+/* enumeration space related defs */
+#define SB_CORE_SIZE    	0x1000		/* each core gets 4Kbytes for registers */
+#define	SB_MAXCORES		((SB_ENUM_LIM - SB_ENUM_BASE)/SB_CORE_SIZE)
+#define	SBCONFIGOFF		0xf00		/* core sbconfig regs are top 256bytes of regs */
+#define	SBCONFIGSIZE		256		/* sizeof (sbconfig_t) */
+
+/* mips address */
+#define	SB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
+
+/*
+ * Sonics Configuration Space Registers.
+ */
+#define SBIPSFLAG		0x08
+#define SBTPSFLAG		0x18
+#define	SBTMERRLOGA		0x48		/* sonics >= 2.3 */
+#define	SBTMERRLOG		0x50		/* sonics >= 2.3 */
+#define SBADMATCH3		0x60
+#define SBADMATCH2		0x68
+#define SBADMATCH1		0x70
+#define SBIMSTATE		0x90
+#define SBINTVEC		0x94
+#define SBTMSTATELOW		0x98
+#define SBTMSTATEHIGH		0x9c
+#define SBBWA0			0xa0
+#define SBIMCONFIGLOW		0xa8
+#define SBIMCONFIGHIGH		0xac
+#define SBADMATCH0		0xb0
+#define SBTMCONFIGLOW		0xb8
+#define SBTMCONFIGHIGH		0xbc
+#define SBBCONFIG		0xc0
+#define SBBSTATE		0xc8
+#define SBACTCNFG		0xd8
+#define	SBFLAGST		0xe8
+#define SBIDLOW			0xf8
+#define SBIDHIGH		0xfc
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+typedef volatile struct _sbconfig {
+	uint32	PAD[2];
+	uint32	sbipsflag;		/* initiator port ocp slave flag */
+	uint32	PAD[3];
+	uint32	sbtpsflag;		/* target port ocp slave flag */
+	uint32	PAD[11];
+	uint32	sbtmerrloga;		/* (sonics >= 2.3) */
+	uint32	PAD;
+	uint32	sbtmerrlog;		/* (sonics >= 2.3) */
+	uint32	PAD[3];
+	uint32	sbadmatch3;		/* address match3 */
+	uint32	PAD;
+	uint32	sbadmatch2;		/* address match2 */
+	uint32	PAD;
+	uint32	sbadmatch1;		/* address match1 */
+	uint32	PAD[7];
+	uint32	sbimstate;		/* initiator agent state */
+	uint32	sbintvec;		/* interrupt mask */
+	uint32	sbtmstatelow;		/* target state */
+	uint32	sbtmstatehigh;		/* target state */
+	uint32	sbbwa0;			/* bandwidth allocation table0 */
+	uint32	PAD;
+	uint32	sbimconfiglow;		/* initiator configuration */
+	uint32	sbimconfighigh;		/* initiator configuration */
+	uint32	sbadmatch0;		/* address match0 */
+	uint32	PAD;
+	uint32	sbtmconfiglow;		/* target configuration */
+	uint32	sbtmconfighigh;		/* target configuration */
+	uint32	sbbconfig;		/* broadcast configuration */
+	uint32	PAD;
+	uint32	sbbstate;		/* broadcast state */
+	uint32	PAD[3];
+	uint32	sbactcnfg;		/* activate configuration */
+	uint32	PAD[3];
+	uint32	sbflagst;		/* current sbflags */
+	uint32	PAD[3];
+	uint32	sbidlow;		/* identification */
+	uint32	sbidhigh;		/* identification */
+} sbconfig_t;
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+/* sbipsflag */
+#define	SBIPS_INT1_MASK		0x3f		/* which sbflags get routed to mips interrupt 1 */
+#define	SBIPS_INT1_SHIFT	0
+#define	SBIPS_INT2_MASK		0x3f00		/* which sbflags get routed to mips interrupt 2 */
+#define	SBIPS_INT2_SHIFT	8
+#define	SBIPS_INT3_MASK		0x3f0000	/* which sbflags get routed to mips interrupt 3 */
+#define	SBIPS_INT3_SHIFT	16
+#define	SBIPS_INT4_MASK		0x3f000000	/* which sbflags get routed to mips interrupt 4 */
+#define	SBIPS_INT4_SHIFT	24
+
+/* sbtpsflag */
+#define	SBTPS_NUM0_MASK		0x3f		/* interrupt sbFlag # generated by this core */
+#define	SBTPS_F0EN0		0x40		/* interrupt is always sent on the backplane */
+
+/* sbtmerrlog */
+#define	SBTMEL_CM		0x00000007	/* command */
+#define	SBTMEL_CI		0x0000ff00	/* connection id */
+#define	SBTMEL_EC		0x0f000000	/* error code */
+#define	SBTMEL_ME		0x80000000	/* multiple error */
+
+/* sbimstate */
+#define	SBIM_PC			0xf		/* pipecount */
+#define	SBIM_AP_MASK		0x30		/* arbitration policy */
+#define	SBIM_AP_BOTH		0x00		/* use both timeslaces and token */
+#define	SBIM_AP_TS		0x10		/* use timesliaces only */
+#define	SBIM_AP_TK		0x20		/* use token only */
+#define	SBIM_AP_RSV		0x30		/* reserved */
+#define	SBIM_IBE		0x20000		/* inbanderror */
+#define	SBIM_TO			0x40000		/* timeout */
+#define	SBIM_BY			0x01800000	/* busy (sonics >= 2.3) */
+#define	SBIM_RJ			0x02000000	/* reject (sonics >= 2.3) */
+
+/* sbtmstatelow */
+#define	SBTML_RESET		0x1		/* reset */
+#define	SBTML_REJ_MASK		0x6		/* reject */
+#define	SBTML_REJ_SHIFT		1
+#define	SBTML_CLK		0x10000		/* clock enable */
+#define	SBTML_FGC		0x20000		/* force gated clocks on */
+#define	SBTML_FL_MASK		0x3ffc0000	/* core-specific flags */
+#define	SBTML_PE		0x40000000	/* pme enable */
+#define	SBTML_BE		0x80000000	/* bist enable */
+
+/* sbtmstatehigh */
+#define	SBTMH_SERR		0x1		/* serror */
+#define	SBTMH_INT		0x2		/* interrupt */
+#define	SBTMH_BUSY		0x4		/* busy */
+#define	SBTMH_TO		0x00000020	/* timeout (sonics >= 2.3) */
+#define	SBTMH_FL_MASK		0x1fff0000	/* core-specific flags */
+#define SBTMH_DMA64		0x10000000      /* supports DMA with 64-bit addresses */
+#define	SBTMH_GCR		0x20000000	/* gated clock request */
+#define	SBTMH_BISTF		0x40000000	/* bist failed */
+#define	SBTMH_BISTD		0x80000000	/* bist done */
+
+
+/* sbbwa0 */
+#define	SBBWA_TAB0_MASK		0xffff		/* lookup table 0 */
+#define	SBBWA_TAB1_MASK		0xffff		/* lookup table 1 */
+#define	SBBWA_TAB1_SHIFT	16
+
+/* sbimconfiglow */
+#define	SBIMCL_STO_MASK		0x7		/* service timeout */
+#define	SBIMCL_RTO_MASK		0x70		/* request timeout */
+#define	SBIMCL_RTO_SHIFT	4
+#define	SBIMCL_CID_MASK		0xff0000	/* connection id */
+#define	SBIMCL_CID_SHIFT	16
+
+/* sbimconfighigh */
+#define	SBIMCH_IEM_MASK		0xc		/* inband error mode */
+#define	SBIMCH_TEM_MASK		0x30		/* timeout error mode */
+#define	SBIMCH_TEM_SHIFT	4
+#define	SBIMCH_BEM_MASK		0xc0		/* bus error mode */
+#define	SBIMCH_BEM_SHIFT	6
+
+/* sbadmatch0 */
+#define	SBAM_TYPE_MASK		0x3		/* address type */
+#define	SBAM_AD64		0x4		/* reserved */
+#define	SBAM_ADINT0_MASK	0xf8		/* type0 size */
+#define	SBAM_ADINT0_SHIFT	3
+#define	SBAM_ADINT1_MASK	0x1f8		/* type1 size */
+#define	SBAM_ADINT1_SHIFT	3
+#define	SBAM_ADINT2_MASK	0x1f8		/* type2 size */
+#define	SBAM_ADINT2_SHIFT	3
+#define	SBAM_ADEN		0x400		/* enable */
+#define	SBAM_ADNEG		0x800		/* negative decode */
+#define	SBAM_BASE0_MASK		0xffffff00	/* type0 base address */
+#define	SBAM_BASE0_SHIFT	8
+#define	SBAM_BASE1_MASK		0xfffff000	/* type1 base address for the core */
+#define	SBAM_BASE1_SHIFT	12
+#define	SBAM_BASE2_MASK		0xffff0000	/* type2 base address for the core */
+#define	SBAM_BASE2_SHIFT	16
+
+/* sbtmconfiglow */
+#define	SBTMCL_CD_MASK		0xff		/* clock divide */
+#define	SBTMCL_CO_MASK		0xf800		/* clock offset */
+#define	SBTMCL_CO_SHIFT		11
+#define	SBTMCL_IF_MASK		0xfc0000	/* interrupt flags */
+#define	SBTMCL_IF_SHIFT		18
+#define	SBTMCL_IM_MASK		0x3000000	/* interrupt mode */
+#define	SBTMCL_IM_SHIFT		24
+
+/* sbtmconfighigh */
+#define	SBTMCH_BM_MASK		0x3		/* busy mode */
+#define	SBTMCH_RM_MASK		0x3		/* retry mode */
+#define	SBTMCH_RM_SHIFT		2
+#define	SBTMCH_SM_MASK		0x30		/* stop mode */
+#define	SBTMCH_SM_SHIFT		4
+#define	SBTMCH_EM_MASK		0x300		/* sb error mode */
+#define	SBTMCH_EM_SHIFT		8
+#define	SBTMCH_IM_MASK		0xc00		/* int mode */
+#define	SBTMCH_IM_SHIFT		10
+
+/* sbbconfig */
+#define	SBBC_LAT_MASK		0x3		/* sb latency */
+#define	SBBC_MAX0_MASK		0xf0000		/* maxccntr0 */
+#define	SBBC_MAX0_SHIFT		16
+#define	SBBC_MAX1_MASK		0xf00000	/* maxccntr1 */
+#define	SBBC_MAX1_SHIFT		20
+
+/* sbbstate */
+#define	SBBS_SRD		0x1		/* st reg disable */
+#define	SBBS_HRD		0x2		/* hold reg disable */
+
+/* sbidlow */
+#define	SBIDL_CS_MASK		0x3		/* config space */
+#define	SBIDL_AR_MASK		0x38		/* # address ranges supported */
+#define	SBIDL_AR_SHIFT		3
+#define	SBIDL_SYNCH		0x40		/* sync */
+#define	SBIDL_INIT		0x80		/* initiator */
+#define	SBIDL_MINLAT_MASK	0xf00		/* minimum backplane latency */
+#define	SBIDL_MINLAT_SHIFT	8
+#define	SBIDL_MAXLAT		0xf000		/* maximum backplane latency */
+#define	SBIDL_MAXLAT_SHIFT	12
+#define	SBIDL_FIRST		0x10000		/* this initiator is first */
+#define	SBIDL_CW_MASK		0xc0000		/* cycle counter width */
+#define	SBIDL_CW_SHIFT		18
+#define	SBIDL_TP_MASK		0xf00000	/* target ports */
+#define	SBIDL_TP_SHIFT		20
+#define	SBIDL_IP_MASK		0xf000000	/* initiator ports */
+#define	SBIDL_IP_SHIFT		24
+#define	SBIDL_RV_MASK		0xf0000000	/* sonics backplane revision code */
+#define	SBIDL_RV_SHIFT		28
+#define	SBIDL_RV_2_2		0x00000000	/* version 2.2 or earlier */
+#define	SBIDL_RV_2_3		0x10000000	/* version 2.3 */
+
+/* sbidhigh */
+#define	SBIDH_RC_MASK		0x000f		/* revision code */
+#define	SBIDH_RCE_MASK		0x7000		/* revision code extension field */
+#define	SBIDH_RCE_SHIFT		8
+#define	SBCOREREV(sbidh) \
+	((((sbidh) & SBIDH_RCE_MASK) >> SBIDH_RCE_SHIFT) | ((sbidh) & SBIDH_RC_MASK))
+#define	SBIDH_CC_MASK		0x8ff0		/* core code */
+#define	SBIDH_CC_SHIFT		4
+#define	SBIDH_VC_MASK		0xffff0000	/* vendor code */
+#define	SBIDH_VC_SHIFT		16
+
+#define	SB_COMMIT		0xfd8		/* update buffered registers value */
+
+/* vendor codes */
+#define	SB_VEND_BCM		0x4243		/* Broadcom's SB vendor code */
+
+/* core codes */
+#define	SB_CC			0x800		/* chipcommon core */
+#define	SB_ILINE20		0x801		/* iline20 core */
+#define	SB_SDRAM		0x803		/* sdram core */
+#define	SB_PCI			0x804		/* pci core */
+#define	SB_MIPS			0x805		/* mips core */
+#define	SB_ENET			0x806		/* enet mac core */
+#define	SB_CODEC		0x807		/* v90 codec core */
+#define	SB_USB			0x808		/* usb 1.1 host/device core */
+#define	SB_ADSL			0x809		/* ADSL core */
+#define	SB_ILINE100		0x80a		/* iline100 core */
+#define	SB_IPSEC		0x80b		/* ipsec core */
+#define	SB_PCMCIA		0x80d		/* pcmcia core */
+#define	SB_SOCRAM		0x80e		/* internal memory core */
+#define	SB_MEMC			0x80f		/* memc sdram core */
+#define	SB_EXTIF		0x811		/* external interface core */
+#define	SB_D11			0x812		/* 802.11 MAC core */
+#define	SB_MIPS33		0x816		/* mips3302 core */
+#define	SB_USB11H		0x817		/* usb 1.1 host core */
+#define	SB_USB11D		0x818		/* usb 1.1 device core */
+#define	SB_USB20H		0x819		/* usb 2.0 host core */
+#define	SB_USB20D		0x81a		/* usb 2.0 device core */
+#define	SB_SDIOH		0x81b		/* sdio host core */
+#define	SB_ROBO			0x81c		/* roboswitch core */
+#define	SB_ATA100		0x81d		/* parallel ATA core */
+#define	SB_SATAXOR		0x81e		/* serial ATA & XOR DMA core */
+#define	SB_GIGETH		0x81f		/* gigabit ethernet core */
+#define	SB_PCIE			0x820		/* pci express core */
+#define	SB_SRAMC		0x822		/* SRAM controller core */
+#define	SB_MINIMAC		0x823		/* MINI MAC/phy core */
+
+#define	SB_CC_IDX		0		/* chipc, when present, is always core 0 */
+
+/* Not really related to Silicon Backplane, but a couple of software
+ * conventions for the use the flash space:
+ */
+
+/* Minumum amount of flash we support */
+#define FLASH_MIN		0x00020000	/* Minimum flash size */
+
+/* A boot/binary may have an embedded block that describes its size  */
+#define	BISZ_OFFSET		0x3e0		/* At this offset into the binary */
+#define	BISZ_MAGIC		0x4249535a	/* Marked with this value: 'BISZ' */
+#define	BISZ_MAGIC_IDX		0		/* Word 0: magic */
+#define	BISZ_TXTST_IDX		1		/*	1: text start */
+#define	BISZ_TXTEND_IDX		2		/*	2: text start */
+#define	BISZ_DATAST_IDX		3		/*	3: text start */
+#define	BISZ_DATAEND_IDX	4		/*	4: text start */
+#define	BISZ_BSSST_IDX		5		/*	5: text start */
+#define	BISZ_BSSEND_IDX		6		/*	6: text start */
+#define BISZ_SIZE		7		/* descriptor size in 32-bit intergers */
+
+#endif	/* _SBCONFIG_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbextif.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbextif.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbextif.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbextif.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,242 @@
+/*
+ * Hardware-specific External Interface I/O core definitions
+ * for the BCM47xx family of SiliconBackplane-based chips.
+ *
+ * The External Interface core supports a total of three external chip selects
+ * supporting external interfaces. One of the external chip selects is
+ * used for Flash, one is used for PCMCIA, and the other may be
+ * programmed to support either a synchronous interface or an
+ * asynchronous interface. The asynchronous interface can be used to
+ * support external devices such as UARTs and the BCM2019 Bluetooth
+ * baseband processor.
+ * The external interface core also contains 2 on-chip 16550 UARTs, clock
+ * frequency control, a watchdog interrupt timer, and a GPIO interface.
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#ifndef	_SBEXTIF_H
+#define	_SBEXTIF_H
+
+/* external interface address space */
+#define	EXTIF_PCMCIA_MEMBASE(x)	(x)
+#define	EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
+#define	EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
+#define	EXTIF_CFGIF_BASE(x)	((x) + 0x800000)
+#define	EXTIF_FLASH_BASE(x)	((x) + 0xc00000)
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
+/*
+ * The multiple instances of output and output enable registers
+ * are present to allow driver software for multiple cores to control
+ * gpio outputs without needing to share a single register pair.
+ */
+struct gpiouser {
+	uint32	out;
+	uint32	outen;
+};
+#define	NGPIOUSER	5
+
+typedef volatile struct {
+	uint32	corecontrol;
+	uint32	extstatus;
+	uint32	PAD[2];
+
+	/* pcmcia control registers */
+	uint32	pcmcia_config;
+	uint32	pcmcia_memwait;
+	uint32	pcmcia_attrwait;
+	uint32	pcmcia_iowait;
+
+	/* programmable interface control registers */
+	uint32	prog_config;
+	uint32	prog_waitcount;
+
+	/* flash control registers */
+	uint32	flash_config;
+	uint32	flash_waitcount;
+	uint32	PAD[4];
+
+	uint32	watchdog;
+
+	/* clock control */
+	uint32	clockcontrol_n;
+	uint32	clockcontrol_sb;
+	uint32	clockcontrol_pci;
+	uint32	clockcontrol_mii;
+	uint32	PAD[3];
+
+	/* gpio */
+	uint32	gpioin;
+	struct gpiouser	gpio[NGPIOUSER];
+	uint32	PAD;
+	uint32	ejtagouten;
+	uint32	gpiointpolarity;
+	uint32	gpiointmask;
+	uint32	PAD[153];
+
+	uint8	uartdata;
+	uint8	PAD[3];
+	uint8	uartimer;
+	uint8	PAD[3];
+	uint8	uartfcr;
+	uint8	PAD[3];
+	uint8	uartlcr;
+	uint8	PAD[3];
+	uint8	uartmcr;
+	uint8	PAD[3];
+	uint8	uartlsr;
+	uint8	PAD[3];
+	uint8	uartmsr;
+	uint8	PAD[3];
+	uint8	uartscratch;
+	uint8	PAD[3];
+} extifregs_t;
+
+/* corecontrol */
+#define	CC_UE		(1 << 0)		/* uart enable */
+
+/* extstatus */
+#define	ES_EM		(1 << 0)		/* endian mode (ro) */
+#define	ES_EI		(1 << 1)		/* external interrupt pin (ro) */
+#define	ES_GI		(1 << 2)		/* gpio interrupt pin (ro) */
+
+/* gpio bit mask */
+#define GPIO_BIT0	(1 << 0)
+#define GPIO_BIT1	(1 << 1)
+#define GPIO_BIT2	(1 << 2)
+#define GPIO_BIT3	(1 << 3)
+#define GPIO_BIT4	(1 << 4)
+#define GPIO_BIT5	(1 << 5)
+#define GPIO_BIT6	(1 << 6)
+#define GPIO_BIT7	(1 << 7)
+
+
+/* pcmcia/prog/flash_config */
+#define	CF_EN		(1 << 0)		/* enable */
+#define	CF_EM_MASK	0xe			/* mode */
+#define	CF_EM_SHIFT	1
+#define	CF_EM_FLASH	0x0			/* flash/asynchronous mode */
+#define	CF_EM_SYNC	0x2			/* synchronous mode */
+#define	CF_EM_PCMCIA	0x4			/* pcmcia mode */
+#define	CF_DS		(1 << 4)		/* destsize:  0=8bit, 1=16bit */
+#define	CF_BS		(1 << 5)		/* byteswap */
+#define	CF_CD_MASK	0xc0			/* clock divider */
+#define	CF_CD_SHIFT	6
+#define	CF_CD_DIV2	0x0			/* backplane/2 */
+#define	CF_CD_DIV3	0x40			/* backplane/3 */
+#define	CF_CD_DIV4	0x80			/* backplane/4 */
+#define	CF_CE		(1 << 8)		/* clock enable */
+#define	CF_SB		(1 << 9)		/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define	PM_W0_MASK	0x3f			/* waitcount0 */
+#define	PM_W1_MASK	0x1f00			/* waitcount1 */
+#define	PM_W1_SHIFT	8
+#define	PM_W2_MASK	0x1f0000		/* waitcount2 */
+#define	PM_W2_SHIFT	16
+#define	PM_W3_MASK	0x1f000000		/* waitcount3 */
+#define	PM_W3_SHIFT	24
+
+/* pcmcia_attrwait */
+#define	PA_W0_MASK	0x3f			/* waitcount0 */
+#define	PA_W1_MASK	0x1f00			/* waitcount1 */
+#define	PA_W1_SHIFT	8
+#define	PA_W2_MASK	0x1f0000		/* waitcount2 */
+#define	PA_W2_SHIFT	16
+#define	PA_W3_MASK	0x1f000000		/* waitcount3 */
+#define	PA_W3_SHIFT	24
+
+/* pcmcia_iowait */
+#define	PI_W0_MASK	0x3f			/* waitcount0 */
+#define	PI_W1_MASK	0x1f00			/* waitcount1 */
+#define	PI_W1_SHIFT	8
+#define	PI_W2_MASK	0x1f0000		/* waitcount2 */
+#define	PI_W2_SHIFT	16
+#define	PI_W3_MASK	0x1f000000		/* waitcount3 */
+#define	PI_W3_SHIFT	24
+
+/* prog_waitcount */
+#define	PW_W0_MASK	0x0000001f			/* waitcount0 */
+#define	PW_W1_MASK	0x00001f00			/* waitcount1 */
+#define	PW_W1_SHIFT	8
+#define	PW_W2_MASK	0x001f0000		/* waitcount2 */
+#define	PW_W2_SHIFT	16
+#define	PW_W3_MASK	0x1f000000		/* waitcount3 */
+#define	PW_W3_SHIFT	24
+
+#define PW_W0       0x0000000c
+#define PW_W1       0x00000a00
+#define PW_W2       0x00020000
+#define PW_W3       0x01000000
+
+/* flash_waitcount */
+#define	FW_W0_MASK	0x1f			/* waitcount0 */
+#define	FW_W1_MASK	0x1f00			/* waitcount1 */
+#define	FW_W1_SHIFT	8
+#define	FW_W2_MASK	0x1f0000		/* waitcount2 */
+#define	FW_W2_SHIFT	16
+#define	FW_W3_MASK	0x1f000000		/* waitcount3 */
+#define	FW_W3_SHIFT	24
+
+/* watchdog */
+#define WATCHDOG_CLOCK	48000000		/* Hz */
+
+/* clockcontrol_n */
+#define	CN_N1_MASK	0x3f			/* n1 control */
+#define	CN_N2_MASK	0x3f00			/* n2 control */
+#define	CN_N2_SHIFT	8
+
+/* clockcontrol_sb/pci/mii */
+#define	CC_M1_MASK	0x3f			/* m1 control */
+#define	CC_M2_MASK	0x3f00			/* m2 control */
+#define	CC_M2_SHIFT	8
+#define	CC_M3_MASK	0x3f0000		/* m3 control */
+#define	CC_M3_SHIFT	16
+#define	CC_MC_MASK	0x1f000000		/* mux control */
+#define	CC_MC_SHIFT	24
+
+/* Clock control default values */
+#define CC_DEF_N	0x0009			/* Default values for bcm4710 */
+#define CC_DEF_100	0x04020011
+#define CC_DEF_33	0x11030011
+#define CC_DEF_25	0x11050011
+
+/* Clock control values for 125Mhz */
+#define	CC_125_N	0x0802
+#define	CC_125_M	0x04020009
+#define	CC_125_M25	0x11090009
+#define	CC_125_M33	0x11090005
+
+/* Clock control magic field values */
+#define	CC_F6_2		0x02			/* A factor of 2 in */
+#define	CC_F6_3		0x03			/*  6-bit fields like */
+#define	CC_F6_4		0x05			/*  N1, M1 or M3 */
+#define	CC_F6_5		0x09
+#define	CC_F6_6		0x11
+#define	CC_F6_7		0x21
+
+#define	CC_F5_BIAS	5			/* 5-bit fields get this added */
+
+#define	CC_MC_BYPASS	0x08
+#define	CC_MC_M1	0x04
+#define	CC_MC_M1M2	0x02
+#define	CC_MC_M1M2M3	0x01
+#define	CC_MC_M1M3	0x11
+
+#define	CC_CLOCK_BASE	24000000	/* Half the clock freq. in the 4710 */
+
+#endif	/* _SBEXTIF_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbmemc.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbmemc.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbmemc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbmemc.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,148 @@
+/*
+ * BCM47XX Sonics SiliconBackplane DDR/SDRAM controller core hardware definitions.
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * $Id$
+ */
+
+#ifndef	_SBMEMC_H
+#define	_SBMEMC_H
+
+#ifdef _LANGUAGE_ASSEMBLY
+
+#define	MEMC_CONTROL		0x00
+#define	MEMC_CONFIG		0x04
+#define	MEMC_REFRESH		0x08
+#define	MEMC_BISTSTAT		0x0c
+#define	MEMC_MODEBUF		0x10
+#define	MEMC_BKCLS		0x14
+#define	MEMC_PRIORINV		0x18
+#define	MEMC_DRAMTIM		0x1c
+#define	MEMC_INTSTAT		0x20
+#define	MEMC_INTMASK		0x24
+#define	MEMC_INTINFO		0x28
+#define	MEMC_NCDLCTL		0x30
+#define	MEMC_RDNCDLCOR		0x34
+#define	MEMC_WRNCDLCOR		0x38
+#define	MEMC_MISCDLYCTL		0x3c
+#define	MEMC_DQSGATENCDL	0x40
+#define	MEMC_SPARE		0x44
+#define	MEMC_TPADDR		0x48
+#define	MEMC_TPDATA		0x4c
+#define	MEMC_BARRIER		0x50
+#define	MEMC_CORE		0x54
+
+
+#else
+
+/* Sonics side: MEMC core registers */
+typedef volatile struct sbmemcregs {
+	uint32	control;
+	uint32	config;
+	uint32	refresh;
+	uint32	biststat;
+	uint32	modebuf;
+	uint32	bkcls;
+	uint32	priorinv;
+	uint32	dramtim;
+	uint32	intstat;
+	uint32	intmask;
+	uint32	intinfo;
+	uint32	reserved1;
+	uint32	ncdlctl;
+	uint32	rdncdlcor;
+	uint32	wrncdlcor;
+	uint32	miscdlyctl;
+	uint32	dqsgatencdl;
+	uint32	spare;
+	uint32	tpaddr;
+	uint32	tpdata;
+	uint32	barrier;
+	uint32	core;
+} sbmemcregs_t;
+
+#endif
+
+/* MEMC Core Init values (OCP ID 0x80f) */
+
+/* For sdr: */
+#define MEMC_SD_CONFIG_INIT	0x00048000
+#define MEMC_SD_DRAMTIM2_INIT	0x000754d8
+#define MEMC_SD_DRAMTIM3_INIT	0x000754da
+#define MEMC_SD_RDNCDLCOR_INIT	0x00000000
+#define MEMC_SD_WRNCDLCOR_INIT	0x49351200
+#define MEMC_SD1_WRNCDLCOR_INIT	0x14500200	/* For corerev 1 (4712) */
+#define MEMC_SD_MISCDLYCTL_INIT	0x00061c1b
+#define MEMC_SD1_MISCDLYCTL_INIT 0x00021416	/* For corerev 1 (4712) */
+#define MEMC_SD_CONTROL_INIT0	0x00000002
+#define MEMC_SD_CONTROL_INIT1	0x00000008
+#define MEMC_SD_CONTROL_INIT2	0x00000004
+#define MEMC_SD_CONTROL_INIT3	0x00000010
+#define MEMC_SD_CONTROL_INIT4	0x00000001
+#define MEMC_SD_MODEBUF_INIT	0x00000000
+#define MEMC_SD_REFRESH_INIT	0x0000840f
+
+
+/* This is for SDRM8X8X4 */
+#define	MEMC_SDR_INIT		0x0008
+#define	MEMC_SDR_MODE		0x32
+#define	MEMC_SDR_NCDL		0x00020032
+#define	MEMC_SDR1_NCDL		0x0002020f	/* For corerev 1 (4712) */
+
+/* For ddr: */
+#define MEMC_CONFIG_INIT	0x00048000
+#define MEMC_DRAMTIM2_INIT	0x000754d8
+#define MEMC_DRAMTIM25_INIT	0x000754d9
+#define MEMC_RDNCDLCOR_INIT	0x00000000
+#define MEMC_RDNCDLCOR_SIMINIT	0xf6f6f6f6	/* For hdl sim */
+#define MEMC_WRNCDLCOR_INIT	0x49351200
+#define MEMC_1_WRNCDLCOR_INIT	0x14500200
+#define MEMC_DQSGATENCDL_INIT	0x00030000
+#define MEMC_MISCDLYCTL_INIT	0x21061c1b
+#define MEMC_1_MISCDLYCTL_INIT	0x21021400
+#define MEMC_NCDLCTL_INIT	0x00002001
+#define MEMC_CONTROL_INIT0	0x00000002
+#define MEMC_CONTROL_INIT1	0x00000008
+#define MEMC_MODEBUF_INIT0	0x00004000
+#define MEMC_CONTROL_INIT2	0x00000010
+#define MEMC_MODEBUF_INIT1	0x00000100
+#define MEMC_CONTROL_INIT3	0x00000010
+#define MEMC_CONTROL_INIT4	0x00000008
+#define MEMC_REFRESH_INIT	0x0000840f
+#define MEMC_CONTROL_INIT5	0x00000004
+#define MEMC_MODEBUF_INIT2	0x00000000
+#define MEMC_CONTROL_INIT6	0x00000010
+#define MEMC_CONTROL_INIT7	0x00000001
+
+
+/* This is for DDRM16X16X2 */
+#define	MEMC_DDR_INIT		0x0009
+#define	MEMC_DDR_MODE		0x62
+#define	MEMC_DDR_NCDL		0x0005050a
+#define	MEMC_DDR1_NCDL		0x00000a0a	/* For corerev 1 (4712) */
+
+/* mask for sdr/ddr calibration registers */
+#define MEMC_RDNCDLCOR_RD_MASK	0x000000ff
+#define MEMC_WRNCDLCOR_WR_MASK	0x000000ff
+#define MEMC_DQSGATENCDL_G_MASK	0x000000ff
+
+/* masks for miscdlyctl registers */
+#define MEMC_MISC_SM_MASK	0x30000000
+#define MEMC_MISC_SM_SHIFT	28
+#define MEMC_MISC_SD_MASK	0x0f000000
+#define MEMC_MISC_SD_SHIFT	24
+
+/* hw threshhold for calculating wr/rd for sdr memc */
+#define MEMC_CD_THRESHOLD	128
+
+/* Low bit of init register says if memc is ddr or sdr */
+#define MEMC_CONFIG_DDR		0x00000001
+
+#endif	/* _SBMEMC_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbmips.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbmips.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbmips.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbmips.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,62 @@
+/*
+ * Broadcom SiliconBackplane MIPS definitions
+ *
+ * SB MIPS cores are custom MIPS32 processors with SiliconBackplane
+ * OCP interfaces. The CP0 processor ID is 0x00024000, where bits
+ * 23:16 mean Broadcom and bits 15:8 mean a MIPS core with an OCP
+ * interface. The core revision is stored in the SB ID register in SB
+ * configuration space.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef	_SBMIPS_H
+#define	_SBMIPS_H
+
+#include <mipsinc.h>
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif	/* PAD */
+
+typedef volatile struct {
+	uint32	corecontrol;
+	uint32	PAD[2];
+	uint32	biststatus;
+	uint32	PAD[4];
+	uint32	intstatus;
+	uint32	intmask;
+	uint32	timer;
+} mipsregs_t;
+
+extern uint32 sb_flag(sb_t *sbh);
+extern uint sb_irq(sb_t *sbh);
+
+extern void BCMINIT(sb_serial_init)(sb_t *sbh, void (*add)(void *regs, uint irq, uint baud_base, uint reg_shift));
+
+extern void *sb_jtagm_init(sb_t *sbh, uint clkd, bool exttap);
+extern void sb_jtagm_disable(void *h);
+extern uint32 jtag_rwreg(void *h, uint32 ir, uint32 dr);
+extern void BCMINIT(sb_mips_init)(sb_t *sbh);
+extern uint32 BCMINIT(sb_mips_clock)(sb_t *sbh);
+extern bool BCMINIT(sb_mips_setclock)(sb_t *sbh, uint32 mipsclock, uint32 sbclock, uint32 pciclock);
+extern void BCMINIT(enable_pfc)(uint32 mode);
+extern uint32 BCMINIT(sb_memc_get_ncdl)(sb_t *sbh);
+
+
+#endif /* _LANGUAGE_ASSEMBLY */
+
+#endif	/* _SBMIPS_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbpci.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbpci.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbpci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbpci.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ * BCM47XX Sonics SiliconBackplane PCI core hardware definitions.
+ *
+ * $Id$
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ */
+
+#ifndef	_SBPCI_H
+#define	_SBPCI_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* Sonics side: PCI core and host control registers */
+typedef struct sbpciregs {
+	uint32 control;		/* PCI control */
+	uint32 PAD[3];
+	uint32 arbcontrol;	/* PCI arbiter control */
+	uint32 PAD[3];
+	uint32 intstatus;	/* Interrupt status */
+	uint32 intmask;		/* Interrupt mask */
+	uint32 sbtopcimailbox;	/* Sonics to PCI mailbox */
+	uint32 PAD[9];
+	uint32 bcastaddr;	/* Sonics broadcast address */
+	uint32 bcastdata;	/* Sonics broadcast data */
+	uint32 PAD[2];
+	uint32 gpioin;		/* ro: gpio input (>=rev2) */
+	uint32 gpioout;		/* rw: gpio output (>=rev2) */
+	uint32 gpioouten;	/* rw: gpio output enable (>= rev2) */
+	uint32 gpiocontrol;	/* rw: gpio control (>= rev2) */
+	uint32 PAD[36];
+	uint32 sbtopci0;	/* Sonics to PCI translation 0 */
+	uint32 sbtopci1;	/* Sonics to PCI translation 1 */
+	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
+	uint32 PAD[445];
+	uint16 sprom[36];	/* SPROM shadow Area */
+	uint32 PAD[46];
+} sbpciregs_t;
+
+/* PCI control */
+#define PCI_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
+#define PCI_RST		0x02	/* Value driven out to pin */
+#define PCI_CLK_OE	0x04	/* When set, drives clock as gated by PCI_CLK out to pin */
+#define PCI_CLK		0x08	/* Gate for clock driven out to pin */	
+
+/* PCI arbiter control */
+#define PCI_INT_ARB	0x01	/* When set, use an internal arbiter */
+#define PCI_EXT_ARB	0x02	/* When set, use an external arbiter */
+#define PCI_PARKID_MASK	0x06	/* Selects which agent is parked on an idle bus */
+#define PCI_PARKID_SHIFT   1
+#define PCI_PARKID_LAST	   0	/* Last requestor */
+#define PCI_PARKID_4710	   1	/* 4710 */
+#define PCI_PARKID_EXTREQ0 2	/* External requestor 0 */
+#define PCI_PARKID_EXTREQ1 3	/* External requestor 1 */
+
+/* Interrupt status/mask */
+#define PCI_INTA	0x01	/* PCI INTA# is asserted */
+#define PCI_INTB	0x02	/* PCI INTB# is asserted */
+#define PCI_SERR	0x04	/* PCI SERR# has been asserted (write one to clear) */
+#define PCI_PERR	0x08	/* PCI PERR# has been asserted (write one to clear) */
+#define PCI_PME		0x10	/* PCI PME# is asserted */
+
+/* (General) PCI/SB mailbox interrupts, two bits per pci function */
+#define	MAILBOX_F0_0	0x100	/* function 0, int 0 */
+#define	MAILBOX_F0_1	0x200	/* function 0, int 1 */
+#define	MAILBOX_F1_0	0x400	/* function 1, int 0 */
+#define	MAILBOX_F1_1	0x800	/* function 1, int 1 */
+#define	MAILBOX_F2_0	0x1000	/* function 2, int 0 */
+#define	MAILBOX_F2_1	0x2000	/* function 2, int 1 */
+#define	MAILBOX_F3_0	0x4000	/* function 3, int 0 */
+#define	MAILBOX_F3_1	0x8000	/* function 3, int 1 */
+
+/* Sonics broadcast address */
+#define BCAST_ADDR_MASK	0xff	/* Broadcast register address */
+
+/* Sonics to PCI translation types */
+#define SBTOPCI0_MASK	0xfc000000
+#define SBTOPCI1_MASK	0xfc000000
+#define SBTOPCI2_MASK	0xc0000000
+#define SBTOPCI_MEM	0
+#define SBTOPCI_IO	1
+#define SBTOPCI_CFG0	2
+#define SBTOPCI_CFG1	3
+#define	SBTOPCI_PREF	0x4		/* prefetch enable */
+#define	SBTOPCI_BURST	0x8		/* burst enable */
+#define	SBTOPCI_RC_MASK		0x30	/* read command (>= rev11) */
+#define	SBTOPCI_RC_READ		0x00	/* memory read */
+#define	SBTOPCI_RC_READLINE	0x10	/* memory read line */
+#define	SBTOPCI_RC_READMULTI	0x20	/* memory read multiple */
+
+/* PCI core index in SROM shadow area */
+#define SRSH_PI_OFFSET	0	/* first word */
+#define SRSH_PI_MASK	0xf000	/* bit 15:12 */
+#define SRSH_PI_SHIFT	12	/* bit 15:12 */
+
+/* PCI side: Reserved PCI configuration registers (see pcicfg.h) */
+#define cap_list	rsvd_a[0]
+#define bar0_window	dev_dep[0x80 - 0x40]
+#define bar1_window	dev_dep[0x84 - 0x40]
+#define sprom_control	dev_dep[0x88 - 0x40]
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+extern int sbpci_read_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len);
+extern int sbpci_write_config(sb_t *sbh, uint bus, uint dev, uint func, uint off, void *buf, int len);
+extern void sbpci_ban(uint16 core);
+extern int sbpci_init(sb_t *sbh);
+extern void sbpci_check(sb_t *sbh);
+
+#endif /* !_LANGUAGE_ASSEMBLY */
+
+#endif	/* _SBPCI_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbsdram.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbsdram.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbsdram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbsdram.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * BCM47XX Sonics SiliconBackplane SDRAM controller core hardware definitions.
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#ifndef	_SBSDRAM_H
+#define	_SBSDRAM_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* Sonics side: SDRAM core registers */
+typedef volatile struct sbsdramregs {
+	uint32	initcontrol;	/* Generates external SDRAM initialization sequence */
+	uint32	config;		/* Initializes external SDRAM mode register */
+	uint32	refresh;	/* Controls external SDRAM refresh rate */
+	uint32	pad1;
+	uint32	pad2;
+} sbsdramregs_t;
+
+#endif
+
+/* SDRAM initialization control (initcontrol) register bits */
+#define SDRAM_CBR	0x0001	/* Writing 1 generates refresh cycle and toggles bit */
+#define SDRAM_PRE	0x0002	/* Writing 1 generates precharge cycle and toggles bit */
+#define SDRAM_MRS	0x0004	/* Writing 1 generates mode register select cycle and toggles bit */
+#define SDRAM_EN	0x0008	/* When set, enables access to SDRAM */
+#define SDRAM_16Mb	0x0000	/* Use 16 Megabit SDRAM */
+#define SDRAM_64Mb	0x0010	/* Use 64 Megabit SDRAM */
+#define SDRAM_128Mb	0x0020	/* Use 128 Megabit SDRAM */
+#define SDRAM_RSVMb	0x0030	/* Use special SDRAM */
+#define SDRAM_RST	0x0080	/* Writing 1 causes soft reset of controller */
+#define SDRAM_SELFREF	0x0100	/* Writing 1 enables self refresh mode */
+#define SDRAM_PWRDOWN	0x0200	/* Writing 1 causes controller to power down */
+#define SDRAM_32BIT	0x0400	/* When set, indicates 32 bit SDRAM interface */
+#define SDRAM_9BITCOL	0x0800	/* When set, indicates 9 bit column */
+
+/* SDRAM configuration (config) register bits */
+#define SDRAM_BURSTFULL	0x0000	/* Use full page bursts */
+#define SDRAM_BURST8	0x0001	/* Use burst of 8 */
+#define SDRAM_BURST4	0x0002	/* Use burst of 4 */
+#define SDRAM_BURST2	0x0003	/* Use burst of 2 */
+#define SDRAM_CAS3	0x0000	/* Use CAS latency of 3 */
+#define SDRAM_CAS2	0x0004	/* Use CAS latency of 2 */
+
+/* SDRAM refresh control (refresh) register bits */
+#define SDRAM_REF(p)	(((p)&0xff) | SDRAM_REF_EN)	/* Refresh period */
+#define SDRAM_REF_EN	0x8000		/* Writing 1 enables periodic refresh */
+
+/* SDRAM Core default Init values (OCP ID 0x803) */
+#define SDRAM_INIT	MEM4MX16X2
+#define SDRAM_CONFIG    SDRAM_BURSTFULL
+#define SDRAM_REFRESH   SDRAM_REF(0x40)
+
+#define MEM1MX16	0x009	/* 2 MB */
+#define MEM1MX16X2	0x409	/* 4 MB */
+#define MEM2MX8X2	0x809	/* 4 MB */
+#define MEM2MX8X4	0xc09	/* 8 MB */
+#define MEM2MX32	0x439	/* 8 MB */
+#define MEM4MX16	0x019	/* 8 MB */
+#define MEM4MX16X2	0x419	/* 16 MB */
+#define MEM8MX8X2	0x819	/* 16 MB */
+#define MEM8MX16	0x829	/* 16 MB */
+#define MEM4MX32	0x429	/* 16 MB */
+#define MEM8MX8X4	0xc19	/* 32 MB */
+#define MEM8MX16X2	0xc29	/* 32 MB */
+
+#endif	/* _SBSDRAM_H */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sbutils.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbutils.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sbutils.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sbutils.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,136 @@
+/*
+ * Misc utility routines for accessing chip-specific features
+ * of Broadcom HNBU SiliconBackplane-based chips.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */
+
+#ifndef	_sbutils_h_
+#define	_sbutils_h_
+
+/* 
+ * Datastructure to export all chip specific common variables 
+ * public (read-only) portion of sbutils handle returned by 
+ * sb_attach()/sb_kattach()
+*/
+
+struct sb_pub {
+
+	uint	bustype;		/* SB_BUS, PCI_BUS  */
+	uint	buscoretype;		/* SB_PCI, SB_PCMCIA, SB_PCIE*/
+	uint	buscorerev;		/* buscore rev */
+	uint	buscoreidx;		/* buscore index */
+	int	ccrev;			/* chip common core rev */
+	uint	boardtype;		/* board type */
+	uint	boardvendor;		/* board vendor */
+	uint	chip;			/* chip number */
+	uint	chiprev;		/* chip revision */
+	uint	chippkg;		/* chip package option */
+	uint    sonicsrev;		/* sonics backplane rev */
+};
+
+typedef const struct sb_pub  sb_t;
+
+/*
+ * Many of the routines below take an 'sbh' handle as their first arg.
+ * Allocate this by calling sb_attach().  Free it by calling sb_detach().
+ * At any one time, the sbh is logically focused on one particular sb core
+ * (the "current core").
+ * Use sb_setcore() or sb_setcoreidx() to change the association to another core.
+ */
+
+/* exported externs */
+extern sb_t * BCMINIT(sb_attach)(uint pcidev, osl_t *osh, void *regs, uint bustype, void *sdh, char **vars, int *varsz);
+extern sb_t * BCMINIT(sb_kattach)(void);
+extern void sb_detach(sb_t *sbh);
+extern uint BCMINIT(sb_chip)(sb_t *sbh);
+extern uint BCMINIT(sb_chiprev)(sb_t *sbh);
+extern uint BCMINIT(sb_chipcrev)(sb_t *sbh);
+extern uint BCMINIT(sb_chippkg)(sb_t *sbh);
+extern uint BCMINIT(sb_pcirev)(sb_t *sbh);
+extern bool BCMINIT(sb_war16165)(sb_t *sbh);
+extern uint BCMINIT(sb_boardvendor)(sb_t *sbh);
+extern uint BCMINIT(sb_boardtype)(sb_t *sbh);
+extern uint sb_bus(sb_t *sbh);
+extern uint sb_buscoretype(sb_t *sbh);
+extern uint sb_buscorerev(sb_t *sbh);
+extern uint sb_corelist(sb_t *sbh, uint coreid[]);
+extern uint sb_coreid(sb_t *sbh);
+extern uint sb_coreidx(sb_t *sbh);
+extern uint sb_coreunit(sb_t *sbh);
+extern uint sb_corevendor(sb_t *sbh);
+extern uint sb_corerev(sb_t *sbh);
+extern void *sb_osh(sb_t *sbh);
+extern void *sb_coreregs(sb_t *sbh);
+extern uint32 sb_coreflags(sb_t *sbh, uint32 mask, uint32 val);
+extern uint32 sb_coreflagshi(sb_t *sbh, uint32 mask, uint32 val);
+extern bool sb_iscoreup(sb_t *sbh);
+extern void *sb_setcoreidx(sb_t *sbh, uint coreidx);
+extern void *sb_setcore(sb_t *sbh, uint coreid, uint coreunit);
+extern int sb_corebist(sb_t *sbh, uint coreid, uint coreunit);
+extern void sb_commit(sb_t *sbh);
+extern uint32 sb_base(uint32 admatch);
+extern uint32 sb_size(uint32 admatch);
+extern void sb_core_reset(sb_t *sbh, uint32 bits);
+extern void sb_core_tofixup(sb_t *sbh);
+extern void sb_core_disable(sb_t *sbh, uint32 bits);
+extern uint32 sb_clock_rate(uint32 pll_type, uint32 n, uint32 m);
+extern uint32 sb_clock(sb_t *sbh);
+extern void sb_pci_setup(sb_t *sbh, uint coremask);
+extern void sb_watchdog(sb_t *sbh, uint ticks);
+extern void *sb_gpiosetcore(sb_t *sbh);
+extern uint32 sb_gpiocontrol(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioouten(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioout(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioin(sb_t *sbh);
+extern uint32 sb_gpiointpolarity(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpiointmask(sb_t *sbh, uint32 mask, uint32 val, uint8 priority);
+extern uint32 sb_gpioled(sb_t *sbh, uint32 mask, uint32 val);
+extern uint32 sb_gpioreserve(sb_t *sbh, uint32 gpio_num, uint8 priority);
+extern uint32 sb_gpiorelease(sb_t *sbh, uint32 gpio_num, uint8 priority);
+
+extern void sb_clkctl_init(sb_t *sbh);
+extern uint16 sb_clkctl_fast_pwrup_delay(sb_t *sbh);
+extern bool sb_clkctl_clk(sb_t *sbh, uint mode);
+extern int sb_clkctl_xtal(sb_t *sbh, uint what, bool on);
+extern void sb_register_intr_callback(sb_t *sbh, void *intrsoff_fn,
+	void *intrsrestore_fn, void *intrsenabled_fn, void *intr_arg);
+extern uint32 sb_set_initiator_to(sb_t *sbh, uint32 to);
+extern void sb_corepciid(sb_t *sbh, uint16 *pcivendor, uint16 *pcidevice, 
+	uint8 *pciclass, uint8 *pcisubclass, uint8 *pciprogif);
+extern uint32 sb_gpiotimerval(sb_t *sbh, uint32 mask, uint32 val);
+
+
+
+/*
+* Build device path. Path size must be >= SB_DEVPATH_BUFSZ.
+* The returned path is NULL terminated and has trailing '/'.
+* Return 0 on success, nonzero otherwise.
+*/
+extern int sb_devpath(sb_t *sbh, char *path, int size);
+
+/* clkctl xtal what flags */
+#define	XTAL		0x1			/* primary crystal oscillator (2050) */
+#define	PLL		0x2			/* main chip pll */
+
+/* clkctl clk mode */
+#define	CLK_FAST	0			/* force fast (pll) clock */
+#define	CLK_DYNAMIC	2			/* enable dynamic clock control */
+
+
+/* GPIO usage priorities */
+#define GPIO_DRV_PRIORITY	0
+#define GPIO_APP_PRIORITY	1
+
+/* device path */
+#define SB_DEVPATH_BUFSZ	16	/* min buffer size in bytes */
+
+#endif	/* _sbutils_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/sflash.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/sflash.h
--- linux-2.6.16/arch/mips/bcm947xx/include/sflash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/sflash.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * Broadcom SiliconBackplane chipcommon serial flash interface
+ *
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ *
+ * $Id$
+ */
+
+#ifndef _sflash_h_
+#define _sflash_h_
+
+#include <typedefs.h>
+#include <sbchipc.h>
+
+struct sflash {
+	uint blocksize;		/* Block size */
+	uint numblocks;		/* Number of blocks */
+	uint32 type;		/* Type */
+	uint size;		/* Total size in bytes */
+};
+
+/* Utility functions */
+extern int sflash_poll(chipcregs_t *cc, uint offset);
+extern int sflash_read(chipcregs_t *cc, uint offset, uint len, uchar *buf);
+extern int sflash_write(chipcregs_t *cc, uint offset, uint len, const uchar *buf);
+extern int sflash_erase(chipcregs_t *cc, uint offset);
+extern int sflash_commit(chipcregs_t *cc, uint offset, uint len, const uchar *buf);
+extern struct sflash * sflash_init(chipcregs_t *cc);
+
+#endif /* _sflash_h_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/trxhdr.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/trxhdr.h
--- linux-2.6.16/arch/mips/bcm947xx/include/trxhdr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/trxhdr.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * TRX image file header format.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id$
+ */ 
+
+#include <typedefs.h>
+
+#define TRX_MAGIC	0x30524448	/* "HDR0" */
+#define TRX_VERSION	1
+#define TRX_MAX_LEN	0x3A0000
+#define TRX_NO_HEADER	1		/* Do not write TRX header */	
+#define TRX_GZ_FILES	0x2     /* Contains up to TRX_MAX_OFFSET individual gzip files */
+#define TRX_MAX_OFFSET	3
+
+struct trx_header {
+	uint32 magic;		/* "HDR0" */
+	uint32 len;		/* Length of file including header */
+	uint32 crc32;		/* 32-bit CRC from flag_version to end of file */
+	uint32 flag_version;	/* 0:15 flags, 16:31 version */
+	uint32 offsets[TRX_MAX_OFFSET];	/* Offsets of partitions from start of header */
+};
+
+/* Compatibility */
+typedef struct trx_header TRXHDR, *PTRXHDR;
diff -Nur linux-2.6.16/arch/mips/bcm947xx/include/typedefs.h linux-2.6.16-owrt/arch/mips/bcm947xx/include/typedefs.h
--- linux-2.6.16/arch/mips/bcm947xx/include/typedefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/include/typedefs.h	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,326 @@
+/*
+ * Copyright 2005, Broadcom Corporation      
+ * All Rights Reserved.      
+ *       
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY      
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM      
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS      
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.      
+ * $Id$
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+
+/* Define 'SITE_TYPEDEFS' in the compile to include a site specific
+ * typedef file "site_typedefs.h".
+ *
+ * If 'SITE_TYPEDEFS' is not defined, then the "Inferred Typedefs"
+ * section of this file makes inferences about the compile environment
+ * based on defined symbols and possibly compiler pragmas.
+ *
+ * Following these two sections is the "Default Typedefs"
+ * section. This section is only prcessed if 'USE_TYPEDEF_DEFAULTS' is
+ * defined. This section has a default set of typedefs and a few
+ * proprocessor symbols (TRUE, FALSE, NULL, ...).
+ */
+
+#ifdef SITE_TYPEDEFS
+
+/*******************************************************************************
+ * Site Specific Typedefs
+ *******************************************************************************/
+
+#include "site_typedefs.h"
+
+#else
+
+/*******************************************************************************
+ * Inferred Typedefs
+ *******************************************************************************/
+
+/* Infer the compile environment based on preprocessor symbols and pramas.
+ * Override type definitions as needed, and include configuration dependent
+ * header files to define types.
+ */
+
+#ifdef __cplusplus
+
+#define TYPEDEF_BOOL
+#ifndef FALSE
+#define FALSE	false
+#endif
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#else	/* ! __cplusplus */
+
+#if defined(_WIN32)
+
+#define TYPEDEF_BOOL
+typedef	unsigned char	bool;			/* consistent w/BOOL */
+
+#endif /* _WIN32 */
+
+#endif	/* ! __cplusplus */
+
+/* use the Windows ULONG_PTR type when compiling for 64 bit */
+#if defined(_WIN64)
+#include <basetsd.h>
+#define TYPEDEF_UINTPTR
+typedef ULONG_PTR	uintptr;
+#endif
+
+#ifdef _HNDRTE_
+typedef long unsigned int size_t;
+#endif
+
+#ifdef _MSC_VER	    /* Microsoft C */
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+typedef signed __int64	int64;
+typedef unsigned __int64 uint64;
+#endif
+
+#if defined(MACOSX) && defined(KERNEL)
+#define TYPEDEF_BOOL
+#endif
+
+
+#if defined(linux)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#define TYPEDEF_ULONG
+#endif
+
+#if !defined(linux) && !defined(_WIN32) && !defined(PMON) && !defined(_CFE_) && !defined(_HNDRTE_) && !defined(_MINOSL_)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#endif
+
+
+/* Do not support the (u)int64 types with strict ansi for GNU C */
+#if defined(__GNUC__) && defined(__STRICT_ANSI__)
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+#endif
+
+/* ICL accepts unsigned 64 bit type only, and complains in ANSI mode
+ * for singned or unsigned */
+#if defined(__ICL)
+
+#define TYPEDEF_INT64
+
+#if defined(__STDC__)
+#define TYPEDEF_UINT64
+#endif
+
+#endif /* __ICL */
+
+
+#if !defined(_WIN32) && !defined(PMON) && !defined(_CFE_) && !defined(_HNDRTE_) && !defined(_MINOSL_)
+
+/* pick up ushort & uint from standard types.h */
+#if defined(linux) && defined(__KERNEL__)
+
+#include <linux/types.h>	/* sys/types.h and linux/types.h are oil and water */
+
+#else
+
+#include <sys/types.h>	
+
+#endif
+
+#endif /* !_WIN32 && !PMON && !_CFE_ && !_HNDRTE_  && !_MINOSL_ */
+
+#if defined(MACOSX) && defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#endif
+
+
+/* use the default typedefs in the next section of this file */
+#define USE_TYPEDEF_DEFAULTS
+
+#endif /* SITE_TYPEDEFS */
+
+
+/*******************************************************************************
+ * Default Typedefs
+ *******************************************************************************/
+
+#ifdef USE_TYPEDEF_DEFAULTS
+#undef USE_TYPEDEF_DEFAULTS
+
+#ifndef TYPEDEF_BOOL
+typedef	/*@abstract@*/ unsigned char	bool;
+#endif
+
+/*----------------------- define uchar, ushort, uint, ulong ------------------*/
+
+#ifndef TYPEDEF_UCHAR
+typedef unsigned char	uchar;
+#endif
+
+#ifndef TYPEDEF_USHORT
+typedef unsigned short	ushort;
+#endif
+
+#ifndef TYPEDEF_UINT
+typedef unsigned int	uint;
+#endif
+
+#ifndef TYPEDEF_ULONG
+typedef unsigned long	ulong;
+#endif
+
+/*----------------------- define [u]int8/16/32/64, uintptr --------------------*/
+
+#ifndef TYPEDEF_UINT8
+typedef unsigned char	uint8;
+#endif
+
+#ifndef TYPEDEF_UINT16
+typedef unsigned short	uint16;
+#endif
+
+#ifndef TYPEDEF_UINT32
+typedef unsigned int	uint32;
+#endif
+
+#ifndef TYPEDEF_UINT64
+typedef unsigned long long uint64;
+#endif
+
+#ifndef TYPEDEF_UINTPTR
+typedef unsigned int	uintptr;
+#endif
+
+#ifndef TYPEDEF_INT8
+typedef signed char	int8;
+#endif
+
+#ifndef TYPEDEF_INT16
+typedef signed short	int16;
+#endif
+
+#ifndef TYPEDEF_INT32
+typedef signed int	int32;
+#endif
+
+#ifndef TYPEDEF_INT64
+typedef signed long long int64;
+#endif
+
+/*----------------------- define float32/64, float_t -----------------------*/
+
+#ifndef TYPEDEF_FLOAT32
+typedef float		float32;
+#endif
+
+#ifndef TYPEDEF_FLOAT64
+typedef double		float64;
+#endif
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#ifndef TYPEDEF_FLOAT_T
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else /* default to double precision floating point */
+typedef float64 float_t;
+#endif
+
+#endif /* TYPEDEF_FLOAT_T */
+
+/*----------------------- define macro values -----------------------------*/
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1
+#endif
+
+#define	AUTO	(-1)
+
+/* Reclaiming text and data :
+   The following macros specify special linker sections that can be reclaimed
+   after a system is considered 'up'.
+ */ 
+#if defined(__GNUC__) && defined(BCMRECLAIM)
+extern bool	bcmreclaimed;
+#define BCMINITDATA(_data)	__attribute__ ((__section__ (".dataini." #_data))) _data##_ini		
+#define BCMINITFN(_fn)		__attribute__ ((__section__ (".textini." #_fn))) _fn##_ini
+#define BCMINIT(_id)		_id##_ini
+#else 
+#define BCMINITDATA(_data)	_data		
+#define BCMINITFN(_fn)		_fn
+#define BCMINIT(_id)		_id
+#define bcmreclaimed		0
+#endif
+
+/*----------------------- define PTRSZ, INLINE ----------------------------*/
+
+#ifndef PTRSZ
+#define	PTRSZ	sizeof (char*)
+#endif
+
+#ifndef INLINE
+
+#ifdef _MSC_VER
+
+#define INLINE __inline
+
+#elif __GNUC__
+
+#define INLINE __inline__
+
+#else
+
+#define INLINE
+
+#endif /* _MSC_VER */
+
+#endif /* INLINE */
+
+#undef TYPEDEF_BOOL
+#undef TYPEDEF_UCHAR
+#undef TYPEDEF_USHORT
+#undef TYPEDEF_UINT
+#undef TYPEDEF_ULONG
+#undef TYPEDEF_UINT8
+#undef TYPEDEF_UINT16
+#undef TYPEDEF_UINT32
+#undef TYPEDEF_UINT64
+#undef TYPEDEF_UINTPTR
+#undef TYPEDEF_INT8
+#undef TYPEDEF_INT16
+#undef TYPEDEF_INT32
+#undef TYPEDEF_INT64
+#undef TYPEDEF_FLOAT32
+#undef TYPEDEF_FLOAT64
+#undef TYPEDEF_FLOAT_T
+
+#endif /* USE_TYPEDEF_DEFAULTS */
+
+#endif /* _TYPEDEFS_H_ */
diff -Nur linux-2.6.16/arch/mips/bcm947xx/int-handler.S linux-2.6.16-owrt/arch/mips/bcm947xx/int-handler.S
--- linux-2.6.16/arch/mips/bcm947xx/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/int-handler.S	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+
+	NESTED(bcm47xx_irq_handler, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+
+	.set	at
+	.set    noreorder
+
+	jal	bcm47xx_irq_dispatch
+	move	a0, sp
+
+	j	ret_from_irq
+	nop
+		
+	END(bcm47xx_irq_handler)
diff -Nur linux-2.6.16/arch/mips/bcm947xx/irq.c linux-2.6.16-owrt/arch/mips/bcm947xx/irq.c
--- linux-2.6.16/arch/mips/bcm947xx/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/irq.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/types.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
+
+extern asmlinkage void bcm47xx_irq_handler(void);
+
+void bcm47xx_irq_dispatch(struct pt_regs *regs)
+{
+	u32 cause;
+
+	cause = read_c0_cause() & read_c0_status() & CAUSEF_IP;
+
+	clear_c0_status(cause);
+
+	if (cause & CAUSEF_IP7)
+		do_IRQ(7, regs);
+	if (cause & CAUSEF_IP2)
+		do_IRQ(2, regs);
+	if (cause & CAUSEF_IP3)
+		do_IRQ(3, regs);
+	if (cause & CAUSEF_IP4)
+		do_IRQ(4, regs);
+	if (cause & CAUSEF_IP5)
+		do_IRQ(5, regs);
+	if (cause & CAUSEF_IP6)
+		do_IRQ(6, regs);
+}
+
+void __init arch_init_irq(void)
+{
+	set_except_vector(0, bcm47xx_irq_handler);
+	mips_cpu_irq_init(0);
+}
diff -Nur linux-2.6.16/arch/mips/bcm947xx/Makefile linux-2.6.16-owrt/arch/mips/bcm947xx/Makefile
--- linux-2.6.16/arch/mips/bcm947xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/Makefile	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the BCM47xx specific kernel interface routines
+# under Linux.
+#
+
+obj-y := irq.o int-handler.o prom.o setup.o time.o pci.o
diff -Nur linux-2.6.16/arch/mips/bcm947xx/pci.c linux-2.6.16-owrt/arch/mips/bcm947xx/pci.c
--- linux-2.6.16/arch/mips/bcm947xx/pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/pci.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,215 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <sbmips.h>
+#include <sbconfig.h>
+#include <sbpci.h>
+#include <bcmdevs.h>
+#include <pcicfg.h>
+
+extern sb_t *sbh;
+extern spinlock_t sbh_lock;
+
+
+static int
+sb_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				int reg, int size, u32 *val)
+{
+	int ret;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sbh_lock, flags);
+	ret = sbpci_read_config(sbh, bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), reg, val, size);
+	spin_unlock_irqrestore(&sbh_lock, flags);
+
+	return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static int
+sb_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				int reg, int size, u32 val)
+{
+	int ret;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sbh_lock, flags);
+	ret = sbpci_write_config(sbh, bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn), reg, &val, size);
+	spin_unlock_irqrestore(&sbh_lock, flags);
+
+	return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+
+static struct pci_ops sb_pci_ops = {
+	.read   = sb_pci_read_config,
+	.write  = sb_pci_write_config,
+};
+
+static struct resource sb_pci_mem_resource = {
+	.name   = "SB PCI Memory resources",
+	.start  = SB_ENUM_BASE,
+	.end    = SB_ENUM_LIM - 1,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct resource sb_pci_io_resource = {
+	.name   = "SB PCI I/O resources",
+	.start  = 0x000,
+	.end    = 0x0FF,
+	.flags  = IORESOURCE_IO,
+};
+
+static struct pci_controller bcm47xx_sb_pci_controller = {
+	.pci_ops        = &sb_pci_ops,
+	.mem_resource   = &sb_pci_mem_resource,
+	.io_resource    = &sb_pci_io_resource,
+};
+
+static struct resource ext_pci_mem_resource = {
+	.name   = "Ext PCI Memory resources",
+	.start  = 0x40000000,
+	.end    = 0x7fffffff,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct resource ext_pci_io_resource = {
+	.name   = "Ext PCI I/O resources",
+	.start  = 0x100,
+	.end    = 0x1FF,
+	.flags  = IORESOURCE_IO,
+};
+
+static struct pci_controller bcm47xx_ext_pci_controller = {
+	.pci_ops        = &sb_pci_ops,
+	.io_resource    = &ext_pci_io_resource,
+	.mem_resource   = &ext_pci_mem_resource,
+	.mem_offset		= 0x24000000,
+};
+
+void bcm47xx_pci_init(void)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&sbh_lock, flags);
+	sbpci_init(sbh);
+	spin_unlock_irqrestore(&sbh_lock, flags);
+
+	set_io_port_base((unsigned long) ioremap_nocache(SB_PCI_MEM, 0x04000000));
+
+	register_pci_controller(&bcm47xx_sb_pci_controller);
+	register_pci_controller(&bcm47xx_ext_pci_controller);
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	u8 irq;
+	
+	if (dev->bus->number == 1)
+		return 2;
+
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);
+	return irq + 2;
+}
+
+u32 pci_iobase = 0x100;
+u32 pci_membase = SB_PCI_DMA;
+
+static void bcm47xx_fixup_device(struct pci_dev *d)
+{
+	struct resource *res;
+	int pos, size;
+	u32 *base;
+
+	if (d->bus->number == 0)
+		return;
+	
+	printk("PCI: Fixing up device %s\n", pci_name(d));
+
+	/* Fix up resource bases */
+	for (pos = 0; pos < 6; pos++) {
+		res = &d->resource[pos];
+		base = ((res->flags & IORESOURCE_IO) ? &pci_iobase : &pci_membase);
+		if (res->end) {
+			size = res->end - res->start + 1;
+			if (*base & (size - 1))
+				*base = (*base + size) & ~(size - 1);
+			res->start = *base;
+			res->end = res->start + size - 1;
+			*base += size;
+			pci_write_config_dword(d, PCI_BASE_ADDRESS_0 + (pos << 2), res->start);
+		}
+		/* Fix up PCI bridge BAR0 only */
+		if (d->bus->number == 1 && PCI_SLOT(d->devfn) == 0)
+			break;
+	}
+	/* Fix up interrupt lines */
+	if (pci_find_device(VENDOR_BROADCOM, SB_PCI, NULL))
+		d->irq = (pci_find_device(VENDOR_BROADCOM, SB_PCI, NULL))->irq;
+	pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+}
+
+
+static void bcm47xx_fixup_bridge(struct pci_dev *dev)
+{
+	if (dev->bus->number != 1 || PCI_SLOT(dev->devfn) != 0)
+		return;
+	
+	printk("PCI: fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and memory space */
+	pci_set_master(dev);
+	pcibios_enable_device(dev, ~0);
+	
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, PCI_BAR1_CONTROL, 3);
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	uint coreidx;
+	unsigned long flags;
+	
+	bcm47xx_fixup_device(dev);
+
+	/* These cores come out of reset enabled */
+	if ((dev->bus->number != 0) ||
+		(dev->device == SB_MIPS) ||
+		(dev->device == SB_MIPS33) ||
+		(dev->device == SB_EXTIF) ||
+		(dev->device == SB_CC))
+		return 0;
+
+	/* Do a core reset */
+	spin_lock_irqsave(&sbh_lock, flags);
+	coreidx = sb_coreidx(sbh);
+	if (sb_setcoreidx(sbh, PCI_SLOT(dev->devfn)) && (sb_coreid(sbh) == SB_USB)) {
+		/* 
+		 * The USB core requires a special bit to be set during core
+		 * reset to enable host (OHCI) mode. Resetting the SB core in
+		 * pcibios_enable_device() is a hack for compatibility with
+		 * vanilla usb-ohci so that it does not have to know about
+		 * SB. A driver that wants to use the USB core in device mode
+		 * should know about SB and should reset the bit back to 0
+		 * after calling pcibios_enable_device().
+		 */
+		sb_core_disable(sbh, sb_coreflags(sbh, 0, 0));
+		sb_core_reset(sbh, 1 << 29);
+	} else {
+		sb_core_reset(sbh, 0);
+	}
+	sb_setcoreidx(sbh, coreidx);
+	spin_unlock_irqrestore(&sbh_lock, flags);
+	
+	return 0;
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_ANY_ID, PCI_ANY_ID, bcm47xx_fixup_bridge);
diff -Nur linux-2.6.16/arch/mips/bcm947xx/prom.c linux-2.6.16-owrt/arch/mips/bcm947xx/prom.c
--- linux-2.6.16/arch/mips/bcm947xx/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/prom.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/pmon.h>
+
+const char *get_system_type(void)
+{
+	return "Broadcom BCM47xx";
+}
+
+void __init prom_init(void)
+{
+	unsigned long mem;
+
+        mips_machgroup = MACH_GROUP_BRCM;
+        mips_machtype = MACH_BCM47XX;
+
+	/* Figure out memory size by finding aliases */
+	for (mem = (1 << 20); mem < (128 << 20); mem += (1 << 20)) {
+		if (*(unsigned long *)((unsigned long)(prom_init) + mem) == 
+		    *(unsigned long *)(prom_init))
+			break;
+	}
+
+	add_memory_region(0, mem, BOOT_MEM_RAM);
+}
+
+unsigned long __init prom_free_prom_memory(void)
+{
+	return 0;
+}
diff -Nur linux-2.6.16/arch/mips/bcm947xx/setup.c linux-2.6.16-owrt/arch/mips/bcm947xx/setup.c
--- linux-2.6.16/arch/mips/bcm947xx/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/setup.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,158 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *  Copyright (C) 2005 Waldemar Brodkorb <wbx@openwrt.org>
+ *  Copyright (C) 2005 Felix Fietkau <nbd@openwrt.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <linux/pm.h>
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbutils.h>
+#include <sbmips.h>
+#include <sbpci.h>
+#include <sbconfig.h>
+#include <bcmdevs.h>
+#include <bcmutils.h>
+#include <bcmnvram.h>
+
+extern void bcm47xx_pci_init(void);
+extern void bcm47xx_time_init(void);
+extern void bcm47xx_timer_setup(struct irqaction *irq);
+void *sbh;
+spinlock_t sbh_lock = SPIN_LOCK_UNLOCKED;
+int boardflags;
+
+static int ser_line = 0;
+
+typedef struct {
+	void *regs;
+	uint irq;
+	uint baud_base;
+	uint reg_shift;
+} serial_port;
+
+static serial_port ports[4];
+static int num_ports = 0;
+
+static void
+serial_add(void *regs, uint irq, uint baud_base, uint reg_shift)
+{
+	ports[num_ports].regs = regs;
+	ports[num_ports].irq = irq;
+	ports[num_ports].baud_base = baud_base;
+	ports[num_ports].reg_shift = reg_shift;
+	num_ports++;
+}
+
+static void
+do_serial_add(serial_port *port)
+{
+	void *regs;
+	uint irq;
+	uint baud_base;
+	uint reg_shift;
+	struct uart_port s;
+	
+	regs = port->regs;
+	irq = port->irq;
+	baud_base = port->baud_base;
+	reg_shift = port->reg_shift;
+
+	memset(&s, 0, sizeof(s));
+
+	s.line = ser_line++;
+	s.membase = regs;
+	s.irq = irq + 2;
+	s.uartclk = baud_base;
+	s.flags = ASYNC_BOOT_AUTOCONF;
+	s.iotype = SERIAL_IO_MEM;
+	s.regshift = reg_shift;
+
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial setup failed!\n");
+	}
+}
+
+static void bcm47xx_machine_restart(char *command)
+{
+	printk("Please stand by while rebooting the system...\n");
+	 
+	/* Set the watchdog timer to reset immediately */
+	local_irq_disable();
+	sb_watchdog(sbh, 1);
+	while (1);
+}
+
+static void bcm47xx_machine_halt(void)
+{
+	/* Disable interrupts and watchdog and spin forever */
+	local_irq_disable();
+	sb_watchdog(sbh, 0);
+	while (1);
+}
+
+void __init plat_setup(void)
+{
+	char *s;
+	int i;
+	
+	sbh = (void *) sb_kattach();
+	sb_mips_init(sbh);
+
+	bcm47xx_pci_init();
+
+	sb_serial_init(sbh, serial_add);
+	boardflags = getintvar(NULL, "boardflags");
+
+	/* reverse serial ports if the nvram variable kernel_args starts with console=ttyS1 */
+	s = early_nvram_get("kernel_args");
+	if (!s)	s = "";
+	if (!strncmp(s, "console=ttyS1", 13)) {
+		for (i = num_ports; i; i--)
+			do_serial_add(&ports[i - 1]);
+	} else {
+		for (i = 0; i < num_ports; i++)
+			do_serial_add(&ports[i]);
+	}
+	
+	_machine_restart = bcm47xx_machine_restart;
+	_machine_halt = bcm47xx_machine_halt;
+	pm_power_off = bcm47xx_machine_halt;
+	
+	board_time_init = bcm47xx_time_init;
+	board_timer_setup = bcm47xx_timer_setup;
+}
+
+EXPORT_SYMBOL(sbh);
+EXPORT_SYMBOL(sbh_lock);
+EXPORT_SYMBOL(boardflags);
diff -Nur linux-2.6.16/arch/mips/bcm947xx/time.c linux-2.6.16-owrt/arch/mips/bcm947xx/time.c
--- linux-2.6.16/arch/mips/bcm947xx/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/bcm947xx/time.c	2006-03-21 09:31:00.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/serial_reg.h>
+#include <linux/interrupt.h>
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+void __init
+bcm47xx_time_init(void)
+{
+	unsigned int hz;
+
+	/*
+	 * Use deterministic values for initial counter interrupt
+	 * so that calibrate delay avoids encountering a counter wrap.
+	 */
+	write_c0_count(0);
+	write_c0_compare(0xffff);
+
+	hz = 200 * 1000 * 1000;
+
+	/* Set MIPS counter frequency for fixed_rate_gettimeoffset() */
+	mips_hpt_frequency = hz / 2;
+
+}
+
+void __init
+bcm47xx_timer_setup(struct irqaction *irq)
+{
+	/* Enable the timer interrupt */
+	setup_irq(7, irq);
+}
diff -Nur linux-2.6.16/arch/mips/Kconfig linux-2.6.16-owrt/arch/mips/Kconfig
--- linux-2.6.16/arch/mips/Kconfig	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/Kconfig	2006-03-21 09:31:00.000000000 +0100
@@ -244,6 +244,17 @@
 	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
 	 Olivetti M700-10 workstations.
 
+config BCM947XX
+	bool "Support for BCM947xx based boards"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	 Support for BCM947xx based boards
+
 config LASAT
 	bool "Support for LASAT Networks platforms"
 	select DMA_NONCOHERENT
diff -Nur linux-2.6.16/arch/mips/kernel/cpu-probe.c linux-2.6.16-owrt/arch/mips/kernel/cpu-probe.c
--- linux-2.6.16/arch/mips/kernel/cpu-probe.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/kernel/cpu-probe.c	2006-03-21 09:32:48.000000000 +0100
@@ -678,6 +678,28 @@
 }
 
 
+static inline void cpu_probe_broadcom(struct cpuinfo_mips *c)
+{
+	decode_config1(c);
+	switch (c->processor_id & 0xff00) {
+		case PRID_IMP_BCM3302:
+			c->cputype = CPU_BCM3302;
+			c->isa_level = MIPS_CPU_ISA_M32R1;
+			c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
+					MIPS_CPU_4K_CACHE | MIPS_CPU_COUNTER;
+		break;
+		case PRID_IMP_BCM4710:
+			c->cputype = CPU_BCM4710;
+			c->isa_level = MIPS_CPU_ISA_M32R1;
+			c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
+					MIPS_CPU_4K_CACHE | MIPS_CPU_COUNTER;
+		break;
+	default:
+		c->cputype = CPU_UNKNOWN;
+		break;
+	}
+}
+
 __init void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -700,6 +722,9 @@
 	case PRID_COMP_SIBYTE:
 		cpu_probe_sibyte(c);
 		break;
+	case PRID_COMP_BROADCOM:
+		cpu_probe_broadcom(c);
+		break;
 	case PRID_COMP_SANDCRAFT:
 		cpu_probe_sandcraft(c);
 		break;
diff -Nur linux-2.6.16/arch/mips/kernel/head.S linux-2.6.16-owrt/arch/mips/kernel/head.S
--- linux-2.6.16/arch/mips/kernel/head.S	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/kernel/head.S	2006-03-21 09:31:00.000000000 +0100
@@ -107,6 +107,14 @@
 #endif
 	.endm
 
+#ifdef CONFIG_BCM4710
+#undef eret
+#define eret nop; nop; eret
+#endif
+
+	j	kernel_entry
+	nop
+
 	/*
 	 * Reserved space for exception handlers.
 	 * Necessary for machines which link their kernels at KSEG0.
diff -Nur linux-2.6.16/arch/mips/kernel/proc.c linux-2.6.16-owrt/arch/mips/kernel/proc.c
--- linux-2.6.16/arch/mips/kernel/proc.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/kernel/proc.c	2006-03-21 09:31:00.000000000 +0100
@@ -82,6 +82,8 @@
 	[CPU_VR4181]	= "NEC VR4181",
 	[CPU_VR4181A]	= "NEC VR4181A",
 	[CPU_SR71000]	= "Sandcraft SR71000",
+	[CPU_BCM3302]	= "Broadcom BCM3302",
+	[CPU_BCM4710]	= "Broadcom BCM4710",
 	[CPU_PR4450]	= "Philips PR4450",
 };
 
diff -Nur linux-2.6.16/arch/mips/Makefile linux-2.6.16-owrt/arch/mips/Makefile
--- linux-2.6.16/arch/mips/Makefile	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/Makefile	2006-03-21 09:31:00.000000000 +0100
@@ -710,6 +710,13 @@
 load-$(CONFIG_SIBYTE_BIGSUR)	:= 0xffffffff80100000
 
 #
+# Broadcom BCM47XX boards
+#
+core-$(CONFIG_BCM947XX)		+= arch/mips/bcm947xx/ arch/mips/bcm947xx/broadcom/
+cflags-$(CONFIG_BCM947XX)	+= -Iarch/mips/bcm947xx/include
+load-$(CONFIG_BCM947XX)		:= 0xffffffff80001000
+
+#
 # SNI RM200 PCI
 #
 core-$(CONFIG_SNI_RM200_PCI)	+= arch/mips/sni/
diff -Nur linux-2.6.16/arch/mips/mm/tlbex.c linux-2.6.16-owrt/arch/mips/mm/tlbex.c
--- linux-2.6.16/arch/mips/mm/tlbex.c	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/arch/mips/mm/tlbex.c	2006-03-21 09:31:00.000000000 +0100
@@ -858,6 +858,8 @@
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
+	case CPU_BCM3302:
+	case CPU_BCM4710:
 		tlbw(p);
 		break;
 
diff -Nur linux-2.6.16/include/asm-mips/bootinfo.h linux-2.6.16-owrt/include/asm-mips/bootinfo.h
--- linux-2.6.16/include/asm-mips/bootinfo.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/bootinfo.h	2006-03-21 09:31:00.000000000 +0100
@@ -218,6 +218,12 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+/*
+ * Valid machtype for group Broadcom
+ */
+#define MACH_GROUP_BRCM		23	/* Broadcom			*/
+#define MACH_BCM47XX		1	/* Broadcom BCM47xx		*/
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -Nur linux-2.6.16/include/asm-mips/cpu.h linux-2.6.16-owrt/include/asm-mips/cpu.h
--- linux-2.6.16/include/asm-mips/cpu.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/asm-mips/cpu.h	2006-03-21 09:31:00.000000000 +0100
@@ -102,6 +102,13 @@
 #define PRID_IMP_SR71000        0x0400
 
 /*
+ * These are the PRID's for when 23:16 == PRID_COMP_BROADCOM
+ */
+
+#define PRID_IMP_BCM4710	0x4000
+#define PRID_IMP_BCM3302	0x9000
+
+/*
  * Definitions for 7:0 on legacy processors
  */
 
@@ -196,7 +203,9 @@
 #define CPU_34K			60
 #define CPU_PR4450		61
 #define CPU_SB1A		62
-#define CPU_LAST		62
+#define CPU_BCM3302		63
+#define CPU_BCM4710		64
+#define CPU_LAST		64
 
 /*
  * ISA Level encodings
diff -Nur linux-2.6.16/include/linux/init.h linux-2.6.16-owrt/include/linux/init.h
--- linux-2.6.16/include/linux/init.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/linux/init.h	2006-03-21 09:31:00.000000000 +0100
@@ -86,6 +86,8 @@
 	static initcall_t __initcall_##fn __attribute_used__ \
 	__attribute__((__section__(".initcall" level ".init"))) = fn
 
+#define early_initcall(fn)		__define_initcall(".early1",fn)
+
 #define core_initcall(fn)		__define_initcall("1",fn)
 #define postcore_initcall(fn)		__define_initcall("2",fn)
 #define arch_initcall(fn)		__define_initcall("3",fn)
diff -Nur linux-2.6.16/include/linux/pci_ids.h linux-2.6.16-owrt/include/linux/pci_ids.h
--- linux-2.6.16/include/linux/pci_ids.h	2006-03-20 06:53:29.000000000 +0100
+++ linux-2.6.16-owrt/include/linux/pci_ids.h	2006-03-21 09:31:00.000000000 +0100
@@ -1885,6 +1885,7 @@
 #define PCI_DEVICE_ID_TIGON3_5901_2	0x170e
 #define PCI_DEVICE_ID_BCM4401		0x4401
 #define PCI_DEVICE_ID_BCM4401B0		0x4402
+#define PCI_DEVICE_ID_BCM4713		0x4713
 
 #define PCI_VENDOR_ID_TOPIC		0x151f
 #define PCI_DEVICE_ID_TOPIC_TP560	0x0000
