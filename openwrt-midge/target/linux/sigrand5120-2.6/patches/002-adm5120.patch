diff -Naur linux-2.6.16/arch/mips/adm5120/altera.c linux-2.6.16-new/arch/mips/adm5120/altera.c
--- linux-2.6.16/arch/mips/adm5120/altera.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/altera.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,46 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <asm/am5120/adm5120.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#define ALTERA_FW_SIZE 158224
+
+#define ALTERA_DEBUG 
+
+static char __initdata altera_fw[]={
+#include "altera.inc"
+};
+
+int __init
+load_altera_firmware(void)
+{
+    unsigned long io_addr;
+    u32 i;
+    u8 j;
+    u8 t_byte;
+
+    ADM5120_SW_REG(GPIO_conf2_REG)=0x00000010;
+    ADM5120_SW_REG(GPIO_conf0_REG)=0x08000000;
+    ADM5120_SW_REG(GPIO_conf0_REG)=0x08080000;    
+
+    io_addr=(unsigned long)ioremap((unsigned long)EXTIO0_BASE,1);
+    for(i=0;i<ALTERA_FW_SIZE;i++){
+	t_byte=altera_fw[i];
+	for( j=0;j<8;j++){
+	    writeb(t_byte,(unsigned long)io_addr);
+	    t_byte>>=1;
+	}
+    }
+    
+    i=0;
+    while( !( ADM5120_SW_REG(GPIO_conf0_REG) & 0x00000100 ) && i<20 ){
+	udelay(1000);
+	i++;
+    }
+    if( !( ADM5120_SW_REG(GPIO_conf0_REG) & 0x00000100 ) )
+	printk("Altera firmware load: fail\n");
+    else
+	printk("Altera firmware load: successful\n");    
+
+}
diff -Naur linux-2.6.16/arch/mips/adm5120/irq.c linux-2.6.16-new/arch/mips/adm5120/irq.c
--- linux-2.6.16/arch/mips/adm5120/irq.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/irq.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,151 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *		Creator : daniell@admtek.com.tw
+ *	Carsten Langgaard, carstenl@mips.com
+ *	Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ *	Copyright (C) 2001 Ralf Baechle
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#define MIPS_CPU_TIMER_IRQ 7
+
+extern void breakpoint(void);
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+extern irq_desc_t irq_desc[];
+extern asmlinkage void mipsIRQ(void);
+
+int mips_int_lock(void);
+void mips_int_unlock(int);
+
+unsigned int mips_counter_frequency;
+
+#define ADM5120_INTC_REG(reg)	(*(volatile u32 *)(KSEG1ADDR(0x12200000+(reg))))
+#define ADM5120_INTC_STATUS	ADM5120_INTC_REG(0x00)
+#define ADM5120_INTC_ENABLE	ADM5120_INTC_REG(0x08)
+#define ADM5120_INTC_DISABLE	ADM5120_INTC_REG(0x0c)
+#define ADM5120_IRQ_MAX		9
+#define ADM5120_IRQ_MASK	0x3ff
+
+void adm5120_hw0_irqdispatch(struct pt_regs *regs)
+{
+	unsigned long intsrc;
+	int i;
+
+	intsrc = ADM5120_INTC_STATUS & ADM5120_IRQ_MASK;
+
+	for (i = 0; intsrc; intsrc >>= 1, i++)
+		if (intsrc & 0x1)
+			do_IRQ(i, regs);
+}
+
+void mips_timer_interrupt(struct pt_regs *regs)
+{
+	write_c0_compare(read_c0_count()+ mips_counter_frequency/HZ);
+	ll_timer_interrupt(MIPS_CPU_TIMER_IRQ, regs);
+}
+
+void enable_adm5120_irq(unsigned int irq)
+{
+	int s;
+
+	/* Disable all interrupts (FIQ/IRQ) */
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > ADM5120_IRQ_MAX)) 
+		goto err_exit;
+
+	ADM5120_INTC_ENABLE = (1<<irq);
+
+err_exit:
+
+	/* Restore the interrupts states */
+	mips_int_unlock(s);
+}
+
+
+void disable_adm5120_irq(unsigned int irq)
+{
+	int s;
+
+	/* Disable all interrupts (FIQ/IRQ) */
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > ADM5120_IRQ_MAX)) 
+		goto err_exit;
+
+	ADM5120_INTC_DISABLE = (1<<irq);
+
+err_exit:
+	/* Restore the interrupts states */
+	mips_int_unlock(s);
+}
+
+unsigned int startup_adm5120_irq(unsigned int irq)
+{
+	enable_adm5120_irq(irq);
+	return 0;
+}
+
+void shutdown_adm5120_irq(unsigned int irq)
+{
+	disable_adm5120_irq(irq);
+}
+
+static inline void ack_adm5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_DISABLE = (1 << irq_nr);
+}
+
+
+static void end_adm5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_ENABLE = (1 << irq_nr);
+}
+
+
+void set_affinity_adm5120_irq(unsigned int irq, cpumask_t mask)
+{
+	return;
+}
+
+	
+static hw_irq_controller adm5120_irq_type = {
+	"ADM5120 INTC",
+	startup_adm5120_irq,
+	shutdown_adm5120_irq,
+	enable_adm5120_irq,
+	disable_adm5120_irq,
+	ack_adm5120_irq,
+	end_adm5120_irq,
+	set_affinity_adm5120_irq
+};
+
+
+void __init arch_init_irq(void)
+{
+	int i;
+	set_except_vector(0, mipsIRQ);
+	
+	for (i = 0; i <= ADM5120_IRQ_MAX; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action= NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &adm5120_irq_type;
+	}
+}
+
diff -Naur linux-2.6.16/arch/mips/adm5120/Kconfig linux-2.6.16-new/arch/mips/adm5120/Kconfig
--- linux-2.6.16/arch/mips/adm5120/Kconfig	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/Kconfig	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,4 @@
+config PCI_ADM5120
+	bool "Add PCI control support for ADM5120"
+	depends on MIPS_ADM5120 && HW_HAS_PCI
+	
diff -Naur linux-2.6.16/arch/mips/adm5120/Makefile linux-2.6.16-new/arch/mips/adm5120/Makefile
--- linux-2.6.16/arch/mips/adm5120/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,2 @@
+
+obj-y	:= setup.o prom.o irq.o memory.o mipsIRQ.o altera.o
diff -Naur linux-2.6.16/arch/mips/adm5120/memory.c linux-2.6.16-new/arch/mips/adm5120/memory.c
--- linux-2.6.16/arch/mips/adm5120/memory.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/memory.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,69 @@
+/*****************************************************************************
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2003 ADMtek Incorporated.
+ *	daniell@admtek.com.tw
+ * Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+
+
+/* References to section boundaries */
+extern char _end;
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+#define ADM5120_MEMCTRL			0x1200001c
+#define ADM5120_MEMCTRL_SDRAM_MASK	0x7
+
+static const unsigned long adm_sdramsize[] __initdata = {
+	0x0,		/* Reserved */
+	0x0400000,	/* 4Mb */
+	0x0800000,	/* 8Mb */
+	0x1000000,	/* 16Mb */
+	0x4000000,	/* 64Mb */
+	0x8000000,	/* 128Mb */
+};
+
+void __init prom_meminit(void)
+{
+	unsigned long base=CPHYSADDR(PFN_ALIGN(&_end));
+	unsigned long size;
+
+	u32 memctrl = *(u32*)KSEG1ADDR(ADM5120_MEMCTRL);
+	size = 0x2000000;
+	//adm_sdramsize[memctrl & ADM5120_MEMCTRL_SDRAM_MASK];
+	add_memory_region(base, size-base, BOOT_MEM_RAM);
+}
+
+
+void __init prom_free_prom_memory (void)
+{
+	/* We don't have prom memory to free... */
+	return;
+}
diff -Naur linux-2.6.16/arch/mips/adm5120/mipsIRQ.S linux-2.6.16-new/arch/mips/adm5120/mipsIRQ.S
--- linux-2.6.16/arch/mips/adm5120/mipsIRQ.S	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/mipsIRQ.S	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,135 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+#define STATUS_IE	0x00000001
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *	
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+
+NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		
+	mfc0	s1, CP0_STATUS
+	and     s0, s0, s1
+	
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq		a0, zero, 1f
+	nop
+
+	move	a0, sp
+	jal		mips_timer_interrupt
+	nop
+
+	j		ret_from_irq
+	nop				
+
+1:
+	andi	a0, s0, CAUSEF_IP2
+	beq		a0, zero, 1f	
+	nop
+	
+	move	a0, sp			
+	jal		adm5120_hw0_irqdispatch	 
+	nop
+1:
+	j		ret_from_irq
+	nop							
+
+END(mipsIRQ)
+
+
+LEAF(mips_int_lock)
+	.set noreorder
+	mfc0	v0, CP0_STATUS
+	li		v1, ~STATUS_IE
+	and		v1, v1, v0
+	mtc0	v1, CP0_STATUS
+	j		ra
+	and		v0, v0, STATUS_IE
+	.set reorder
+END(mips_int_lock)
+
+
+LEAF(mips_int_unlock)
+	mfc0	v0, CP0_STATUS
+	and		a0, a0, STATUS_IE
+	or		v0, v0, a0
+	mtc0	v0, CP0_STATUS
+	j		ra
+	nop
+END(mips_int_unlock)
+
diff -Naur linux-2.6.16/arch/mips/adm5120/prom.c linux-2.6.16-new/arch/mips/adm5120/prom.c
--- linux-2.6.16/arch/mips/adm5120/prom.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/prom.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,47 @@
+/*****************************************************************************
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2003 ADMtek Incorporated.
+ *	daniell@admtek.com.tw
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ *****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+
+void setup_prom_printf(int);
+void prom_printf(char *, ...);
+void prom_meminit(void);
+
+/*
+ * initialize the prom module.
+ */
+void __init prom_init(void)
+{
+	/* you should these macros defined in include/asm/bootinfo.h */
+	mips_machgroup = MACH_GROUP_ADM_GW;
+	mips_machtype = MACH_ADM_GW_5120;
+
+	/* init memory map */
+	prom_meminit();
+}
diff -Naur linux-2.6.16/arch/mips/adm5120/setup.c linux-2.6.16-new/arch/mips/adm5120/setup.c
--- linux-2.6.16/arch/mips/adm5120/setup.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/adm5120/setup.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,136 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *		Creator : daniell@admtek.com.tw
+ *	Copyright 1999, 2000 MIPS Technologies, Inc.
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+
+
+#define ADM5120_SOFTRESET	0x12000004
+#define STATUS_IE		0x00000001
+#define ALLINTS (IE_IRQ0 | IE_IRQ5 | STATUS_IE)
+
+#define ADM5120_CODEREG		0x12000000
+#define ADM5120_CPU_CLK_MASK	0x00300000
+#define ADM5120_CPU_CLK_175	0x00000000
+#define ADM5120_CPU_CLK_200	0x00100000
+#define ADM5120_CPU_CLK_225	0x00200000
+#define ADM5120_CPU_CLK_250	0x00300000
+
+void  mips_time_init(void);
+
+extern unsigned int mips_counter_frequency;
+
+void adm5120_restart(char *command)
+{
+	*(u32*)KSEG1ADDR(ADM5120_SOFTRESET)=1;
+}
+
+
+void adm5120_halt(void)
+{
+        printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+        while (1);
+}
+
+
+void adm5120_power_off(void)
+{
+        adm5120_halt();
+}
+
+void __init mips_time_init(void)
+{
+	u32 clock;
+
+	clock = *(u32*)KSEG1ADDR(ADM5120_CODEREG);
+
+	switch (clock & ADM5120_CPU_CLK_MASK) {
+		case ADM5120_CPU_CLK_175:
+			mips_counter_frequency = 87500000;
+			printk("CPU clock: 175MHz\n");
+			break;
+		case ADM5120_CPU_CLK_200:
+			mips_counter_frequency = 100000000;
+			printk("CPU clock: 200MHz\n");
+			break;
+		case ADM5120_CPU_CLK_225:
+			mips_counter_frequency = 112500000;
+			printk("CPU clock: 225MHz\n");
+			break;
+		case ADM5120_CPU_CLK_250:
+			mips_counter_frequency = 125000000;
+			printk("CPU clock: 250MHz\n");
+			break;
+	}
+}
+
+void __init mips_timer_setup(struct irqaction *irq)
+{
+	/* to generate the first timer interrupt */
+    	write_c0_compare(read_c0_count()+ mips_counter_frequency/HZ);
+	clear_c0_status(ST0_BEV);
+	set_c0_status(ALLINTS);
+}
+
+void __init plat_setup(void)
+{
+	printk("ADM5120 board setup\n");
+
+	board_time_init = mips_time_init;
+	board_timer_setup = mips_timer_setup;
+
+	_machine_restart = adm5120_restart;
+	_machine_halt = adm5120_halt;
+	pm_power_off = adm5120_power_off;
+
+	set_io_port_base(KSEG1);
+	load_altera_firmware();
+}
+
+
+const char *get_system_type(void)
+{
+	return "ADM5120 Board";
+}
+
+
+static struct resource adm5120_hcd_resources[] = {
+	{"res1",0x11200000,0x11200084,IORESOURCE_MEM},
+//	{"res2",0x3,0x3,IORESOURCE_IRQ},
+	{"res2",9,9,IORESOURCE_IRQ},
+};
+
+
+static u64 hcd_dmamask = 0x01ffffff;
+static struct platform_device adm5120hcd_device = {
+	.name		= "adm5120-hcd",
+	.id		= -1,
+	.dev 		= {
+	.dma_mask       	= &hcd_dmamask,
+	.coherent_dma_mask      = 0x01ffffff,
+	},
+	.num_resources	= ARRAY_SIZE(adm5120_hcd_resources),
+	.resource	= adm5120_hcd_resources,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&adm5120hcd_device,
+};
+
+static int __init adm5120_init(void)
+{
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+subsys_initcall(adm5120_init);
diff -Naur linux-2.6.16/arch/mips/Kconfig linux-2.6.16-new/arch/mips/Kconfig
--- linux-2.6.16/arch/mips/Kconfig	2007-05-10 12:09:02.000000000 +0700
+++ linux-2.6.16-new/arch/mips/Kconfig	2007-05-10 10:27:22.000000000 +0700
@@ -10,7 +10,16 @@
 
 choice
 	prompt "System type"
-	default SGI_IP22
+	default MIPS_MTX1
+
+config MIPS_ADM5120
+	bool "Support for ADM5120 SoC"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select ADM5120_BOARDS
+	select SYS_HAS_CPU_MIPS32_R1		
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_32BIT_KERNEL
 
 config MIPS_MTX1
 	bool "Support for 4G Systems MTX-1 board"
@@ -774,6 +783,7 @@
 
 endchoice
 
+source "arch/mips/adm5120/Kconfig"
 source "arch/mips/ddb5xxx/Kconfig"
 source "arch/mips/gt64120/ev64120/Kconfig"
 source "arch/mips/jazz/Kconfig"
@@ -933,6 +943,9 @@
 	bool
 	select SOC_AU1X00
 
+config MIPS_ADM5120	
+	bool
+
 config SOC_AU1550
 	bool
 	select SOC_AU1X00
diff -Naur linux-2.6.16/arch/mips/kernel/head.S linux-2.6.16-new/arch/mips/kernel/head.S
--- linux-2.6.16/arch/mips/kernel/head.S	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/arch/mips/kernel/head.S	2007-05-10 10:27:22.000000000 +0700
@@ -25,6 +25,7 @@
 
 #include <kernel-entry-init.h>
 
+
 	.macro	ARC64_TWIDDLE_PC
 #if defined(CONFIG_ARC64) || defined(CONFIG_MAPPED_KERNEL)
 	/* We get launched at a XKPHYS address but the kernel is linked to
@@ -111,7 +112,9 @@
 	 * Reserved space for exception handlers.
 	 * Necessary for machines which link their kernels at KSEG0.
 	 */
-	.fill	0x400
+	.fill	0x6d8
+	j	kernel_entry
+
 
 EXPORT(stext)					# used for profiling
 EXPORT(_stext)
diff -Naur linux-2.6.16/arch/mips/kernel/traps.c linux-2.6.16-new/arch/mips/kernel/traps.c
--- linux-2.6.16/arch/mips/kernel/traps.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/arch/mips/kernel/traps.c	2007-05-10 10:27:22.000000000 +0700
@@ -780,8 +780,19 @@
 
 asmlinkage void do_mcheck(struct pt_regs *regs)
 {
+       const int field = 2 * sizeof(unsigned long);
+
 	show_regs(regs);
+	printk("Hi    : %0*lx\n", field, regs->hi);
+	printk("Pagemask: %0*x\n", read_c0_pagemask());
+	printk("EntryHi : %0*lx\n", field, read_c0_entryhi());
+	printk("EntryLo0: %0*lx\n", field, read_c0_entrylo0());
+	printk("EntryLo1: %0*lx\n", field, read_c0_entrylo1());
+	printk("\n");
 	dump_tlb_all();
+	show_code((unsigned int *) regs->cp0_epc);
+	printk("\n");		
+	
 	/*
 	 * Some chips may have other causes of machine check (e.g. SB1
 	 * graduation timer)
diff -Naur linux-2.6.16/arch/mips/Makefile linux-2.6.16-new/arch/mips/Makefile
--- linux-2.6.16/arch/mips/Makefile	2007-05-10 12:09:03.000000000 +0700
+++ linux-2.6.16-new/arch/mips/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -286,6 +286,12 @@
 load-$(CONFIG_MACH_JAZZ)	+= 0xffffffff80080000
 
 #
+# ADMtek 5120
+#
+core-$(CONFIG_MIPS_ADM5120)    += arch/mips/adm5120/
+load-$(CONFIG_MIPS_ADM5120)    += 0xffffffff80002000
+
+#
 # Common Alchemy Au1x00 stuff
 #
 core-$(CONFIG_SOC_AU1X00)	+= arch/mips/au1000/common/
diff -Naur linux-2.6.16/arch/mips/mm/tlbex.c linux-2.6.16-new/arch/mips/mm/tlbex.c
--- linux-2.6.16/arch/mips/mm/tlbex.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/arch/mips/mm/tlbex.c	2007-05-10 10:27:22.000000000 +0700
@@ -742,7 +742,7 @@
 	}
 #endif
 
-	memcpy((void *)CAC_BASE, tlb_handler, 0x80);
+	memcpy((void *)ebase, tlb_handler, 0x80);
 }
 
 /*
@@ -838,6 +838,7 @@
 		break;
 
 	case CPU_R4300:
+	case CPU_4KC:	
 	case CPU_5KC:
 	case CPU_TX49XX:
 	case CPU_AU1000:
@@ -852,13 +853,12 @@
 
 	case CPU_R10000:
 	case CPU_R12000:
-	case CPU_4KC:
 	case CPU_SB1:
 	case CPU_SB1A:
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
-		tlbw(p);
+    		tlbw(p);
 		break;
 
 	case CPU_NEVADA:
@@ -1260,7 +1260,7 @@
 	}
 #endif
 
-	memcpy((void *)CAC_BASE, final_handler, 0x100);
+	memcpy((void *)ebase, final_handler, 0x100);
 }
 
 /*
diff -Naur linux-2.6.16/arch/mips/pci/Makefile linux-2.6.16-new/arch/mips/pci/Makefile
--- linux-2.6.16/arch/mips/pci/Makefile	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/arch/mips/pci/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -7,6 +7,7 @@
 #
 # PCI bus host bridge specific code
 #
+obj-$(CONFIG_PCI_ADM5120)	+= ops-adm5120.o pci-adm5120.o
 obj-$(CONFIG_ITE_BOARD_GEN)	+= ops-it8172.o
 obj-$(CONFIG_MIPS_BONITO64)	+= ops-bonito64.o
 obj-$(CONFIG_MIPS_GT64111)	+= ops-gt64111.o
diff -Naur linux-2.6.16/arch/mips/pci/ops-adm5120.c linux-2.6.16-new/arch/mips/pci/ops-adm5120.c
--- linux-2.6.16/arch/mips/pci/ops-adm5120.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/pci/ops-adm5120.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,59 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+volatile u32* pci_config_address_reg = (volatile u32*)KSEG1ADDR(0x115ffff0);
+volatile u32* pci_config_data_reg = (volatile u32*)KSEG1ADDR(0x115ffff8);
+
+#define PCI_ENABLE 0x80000000
+                          
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, uint32_t *val)
+{
+	*pci_config_address_reg = ((bus->number & 0xff) << 0x10) |
+	    ((devfn & 0xff) << 0x08) | (where & 0xfc) | PCI_ENABLE;
+	switch (size) {
+		case 1:
+			*val = ((*pci_config_data_reg)>>((where&3)<<3))&0xff;
+			break;
+		case 2:
+			*val = ((*pci_config_data_reg)>>((where&3)<<3))&0xffff;
+			break;
+		default:
+			*val = (*pci_config_data_reg);
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn, int where,
+                            int size, uint32_t val)
+{
+	*pci_config_address_reg = ((bus->number & 0xff) << 0x10) |
+	    ((devfn & 0xff) << 0x08) | (where & 0xfc) | PCI_ENABLE;
+	switch (size) {
+		case 1:
+			*(volatile u8 *)(((int)pci_config_data_reg) +
+			    (where & 3)) = val;
+			break;
+		case 2:
+			*(volatile u16 *)(((int)pci_config_data_reg) +
+			    (where & 2)) = (val);
+			break;
+		default:
+			*pci_config_data_reg = (val);
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops adm5120_pci_ops = {
+	pci_config_read,
+	pci_config_write
+};
diff -Naur linux-2.6.16/arch/mips/pci/pci-adm5120.c linux-2.6.16-new/arch/mips/pci/pci-adm5120.c
--- linux-2.6.16/arch/mips/pci/pci-adm5120.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/arch/mips/pci/pci-adm5120.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,93 @@
+/*
+ *	Copyright (C) ADMtek Incorporated.
+ *	Copyright (C) 2005 Jeroen Vreeken (pe1rxq@amsat.org)
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+extern struct pci_ops adm5120_pci_ops;
+
+#define ADM5120_CODE		0x12000000
+#define ADM5120_CODE_PQFP	0x20000000
+
+#define PCI_CMM_IOACC_EN	0x1
+#define PCI_CMM_MEMACC_EN	0x2
+#define PCI_CMM_MASTER_EN	0x4
+#define PCI_CMM_DEF \
+		(PCI_CMM_IOACC_EN | PCI_CMM_MEMACC_EN | PCI_CMM_MASTER_EN)
+
+#define PCI_DEF_CACHE_LINE_SZ	4
+
+
+struct resource pci_io_resource = {
+	"PCI IO space", 
+	0x11500000,  
+	0x115ffff0-1,
+	IORESOURCE_IO
+};
+
+struct resource pci_mem_resource = {
+	"PCI memory space", 
+	0x11400000,
+	0x11500000,
+	IORESOURCE_MEM
+};
+
+static struct pci_controller adm5120_controller = {
+	.pci_ops	= &adm5120_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+};
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (slot < 2 || slot > 4)
+		return -1;
+	return slot + 4;
+}
+
+static void adm5120_pci_fixup(struct pci_dev *dev)
+{
+	if (dev->devfn == 0) {
+		pci_write_config_word(dev, PCI_COMMAND, PCI_CMM_DEF);
+		pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE,
+		    PCI_DEF_CACHE_LINE_SZ);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0);
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, adm5120_pci_fixup);
+
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+static int __init adm5120_pci_setup(void)
+{
+
+	if ((*(volatile u32 *)(KSEG1ADDR(ADM5120_CODE))) & ADM5120_CODE_PQFP) {
+		printk("System has no PCI BIOS\n");
+		return 1;
+	}
+	printk("System has PCI BIOS\n");
+
+	/* Avoid ISA compat ranges.  */
+	PCIBIOS_MIN_IO = 0x00000000;
+	PCIBIOS_MIN_MEM = 0x00000000;
+
+	/* Set I/O resource limits.  */
+	ioport_resource.end = 0x1fffffff;
+	iomem_resource.end = 0xffffffff;	
+
+	register_pci_controller(&adm5120_controller);
+	return 0;
+}
+
+arch_initcall(adm5120_pci_setup);
diff -Naur linux-2.6.16/compile linux-2.6.16-new/compile
--- linux-2.6.16/compile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/compile	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+#CROSS_COMPILE_PATH=/buildroot/build_mipsel/staging_dir/bin
+CROSS_COMPILE_PATH=../../staging_dir_mipsel/bin
+export PATH=$CROSS_COMPILE_PATH:$PATH
+make -j4 CROSS_COMPILE=mipsel-linux- V=1 CONFIG_CMDLINE_BOOL=y CONFIG_CMDLINE="root=/dev/hda0 fstype=aaaa"
+$CROSS_COMPILE_PATH/mipsel-linux-uclibc-nm vmlinux | grep -v '\(compiled\)\|\(\.o$\)\|\( [aUw] \)\|\(\.\.ng$\)\|\(LASH[RL]DI\)' | sort > System.map
+$CROSS_COMPILE_PATH/mipsel-linux-uclibc-objcopy -O binary vmlinux vmlinux.bin
+gzip -c vmlinux.bin > vmlinuz
diff -Naur linux-2.6.16/.config linux-2.6.16-new/.config
--- linux-2.6.16/.config	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/.config	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,1040 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.16
+# Wed Jul 12 14:53:50 2006
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+CONFIG_MIPS_ADM5120=y
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_PCI_ADM5120=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+CONFIG_SLAB=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_LBD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK is not set
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+# CONFIG_NETFILTER_XT_MATCH_STATE is not set
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CONNTRACK_EVENTS is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+# CONFIG_IP_NF_FTP is not set
+# CONFIG_IP_NF_IRC is not set
+# CONFIG_IP_NF_NETBIOS_NS is not set
+# CONFIG_IP_NF_TFTP is not set
+# CONFIG_IP_NF_AMANDA is not set
+# CONFIG_IP_NF_PPTP is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_IPRANGE is not set
+# CONFIG_IP_NF_MATCH_MULTIPORT is not set
+# CONFIG_IP_NF_MATCH_TOS is not set
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_DSCP is not set
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+# CONFIG_IP_NF_MATCH_POLICY is not set
+# CONFIG_IP_NF_FILTER is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_IP_NF_TARGET_TCPMSS is not set
+# CONFIG_IP_NF_NAT is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_CLK_JIFFIES is not set
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
+# CONFIG_NET_SCH_CLK_CPU is not set
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_ESTIMATOR=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_DM9000 is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+CONFIG_ADM5120_GPIO=y
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# EDAC - error detection and reporting (RAS) (EXPERIMENTAL)
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_JFFS2_RUBIN=y
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+CONFIG_UFS_FS=m
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=ext2 console=ttyS0"
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
diff -Naur linux-2.6.16/drivers/base/firmware_class.c linux-2.6.16-new/drivers/base/firmware_class.c
--- linux-2.6.16/drivers/base/firmware_class.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/base/firmware_class.c	2007-05-10 10:27:22.000000000 +0700
@@ -18,6 +18,7 @@
 #include <asm/semaphore.h>
 
 #include <linux/firmware.h>
+#include <linux/delay.h>
 #include "base.h"
 
 MODULE_AUTHOR("Manuel Estrada Sainz <ranty@debian.org>");
@@ -251,6 +252,7 @@
 	struct firmware *fw;
 	ssize_t retval;
 
+        mdelay(2);
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
diff -Naur linux-2.6.16/drivers/char/adm5120_gpio.c linux-2.6.16-new/drivers/char/adm5120_gpio.c
--- linux-2.6.16/drivers/char/adm5120_gpio.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/char/adm5120_gpio.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,57 @@
+/*
+ *	ADM5120 LED (GPIO) driver
+ *
+ *	Copyright (C) Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#define LED_MINOR 151
+#define GPIO_IO        ((unsigned long *)0xb20000b8)
+
+MODULE_AUTHOR("Jeroen Vreeken");
+MODULE_LICENSE("GPL");
+
+static ssize_t adm5120_led_write(struct file *file, const char __user *data,
+	size_t len, loff_t *ppos)
+{
+	unsigned char val;
+
+	if (!len || get_user(val, data))
+		return -EFAULT;
+	*GPIO_IO=(*GPIO_IO & 0x00ffffff) | (val<<24);
+	return 1;
+}
+
+static struct file_operations adm5120_led_fops = {
+	.owner	= THIS_MODULE,
+	.write	= adm5120_led_write,
+};
+
+static struct miscdevice adm5120_led_device = {
+	LED_MINOR,
+	"led",
+	&adm5120_led_fops,
+};
+
+static int __init adm5120_led_init(void)
+{
+	printk(KERN_INFO "ADM5120 LED & GPIO driver\n");
+	if (misc_register(&adm5120_led_device)) {
+		printk(KERN_WARNING "Couldn't register device %d\n", LED_MINOR);
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static void __exit adm5120_led_exit(void)
+{
+	misc_deregister(&adm5120_led_device);
+}
+
+module_init(adm5120_led_init);
+module_exit(adm5120_led_exit);
diff -Naur linux-2.6.16/drivers/char/Kconfig linux-2.6.16-new/drivers/char/Kconfig
--- linux-2.6.16/drivers/char/Kconfig	2007-05-10 12:09:03.000000000 +0700
+++ linux-2.6.16-new/drivers/char/Kconfig	2007-05-10 10:27:22.000000000 +0700
@@ -468,9 +468,10 @@
        depends on SGI_TIOCX
        help
          If you have an SGI Altix with an attached SABrick
-         say Y or M here, otherwise say N.
+         say Y or M here, otherwise say 
+	 
+source "drivers/char/tpm/Kconfig"
 
-source "drivers/serial/Kconfig"
 
 config UNIX98_PTYS
 	bool "Unix98 PTY support" if EMBEDDED
@@ -1055,7 +1056,11 @@
 	  The mmtimer device allows direct userspace access to the
 	  Altix system timer.
 
-source "drivers/char/tpm/Kconfig"
+config ADM5120_GPIO
+       tristate "ADM5120 GPIO"
+       depends on MIPS_ADM5120
+
+
 
 config TELCLOCK
 	tristate "Telecom clock driver for MPBL0010 ATCA SBC"
diff -Naur linux-2.6.16/drivers/char/Makefile linux-2.6.16-new/drivers/char/Makefile
--- linux-2.6.16/drivers/char/Makefile	2007-05-10 12:09:03.000000000 +0700
+++ linux-2.6.16-new/drivers/char/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -80,6 +80,7 @@
 obj-$(CONFIG_FTAPE) += ftape/
 obj-$(CONFIG_COBALT_LCD) += lcd.o
 obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
+obj-$(CONFIG_ADM5120_GPIO) += adm5120_gpio.o
 obj-$(CONFIG_AU1000_GPIO) += au1000_gpio.o
 obj-$(CONFIG_AU1000_USB_TTY) += au1000_usbtty.o
 obj-$(CONFIG_AU1000_USB_RAW) += au1000_usbraw.o
diff -Naur linux-2.6.16/drivers/debug/debug_net.c linux-2.6.16-new/drivers/debug/debug_net.c
--- linux-2.6.16/drivers/debug/debug_net.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/debug/debug_net.c	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,174 @@
+#include <linux/time.h>
+#include <linux/module.h>
+
+
+struct timeval debug_ip_arp;
+u32 debug_ip_arp_cnt;
+struct timeval debug_ip_igmp;
+u32 debug_ip_igmp_cnt;
+struct timeval debug_ip_input;
+u32 debug_ip_input_cnt;
+struct timeval debug_ip_output;
+u32 debug_ip_output_cnt;
+struct timeval debug_ip_forward;
+u32  debug_ip_forward_cnt;
+struct timeval debug_ip_hook;
+u32  debug_ip_hook_cnt;
+
+struct timeval debug_ip_test;
+u32  debug_ip_test_cnt;
+
+struct timeval debug_ip_ipmr;
+u32  debug_ip_ipmr_cnt;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_vs_xmit;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_ipt_REJECT;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_raw;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_xfrm4_input;
+//u32 debug_ip_arp_cnt;
+struct timeval debug_ip_xfrm4_output;
+//u32 debug_ip_arp_cnt;
+
+static int __init debug_net_init(void)
+{
+	struct timeval probe1,probe2,tv1,tv2;
+	u32 cntr=0;
+	
+	printk("\n");
+
+	do_gettimeofday(&probe1);
+	
+	do_gettimeofday(&tv1);
+	do_gettimeofday(&tv2);
+	debug_count_delta(&tv1,tv2);
+	debug_sum_tv( &tv2,tv1);
+	cntr+=1 ;
+	
+	do_gettimeofday(&probe2);
+	debug_count_delta(&probe1,probe2);
+	printk("%s: CALIBRATING: delay= %ld.%06ld\n\n",__FUNCTION__,probe1.tv_sec,probe1.tv_usec);
+	
+	printk("\n%s: ZEROING COUNTERS\n\n",__FUNCTION__);
+	memset(&debug_ip_arp,0,sizeof(struct timeval));
+	memset(&debug_ip_igmp,0,sizeof(struct timeval)); 
+	memset(&debug_ip_input,0,sizeof(struct timeval));
+	memset(&debug_ip_output,0,sizeof(struct timeval));		
+	memset(&debug_ip_forward,0,sizeof(struct timeval));		
+	memset(&debug_ip_ipmr,0,sizeof(struct timeval));			
+	memset(&debug_ip_hook,0,sizeof(struct timeval));				
+	memset(&debug_ip_test,0,sizeof(struct timeval));				
+
+
+	debug_ip_arp_cnt=0;
+	debug_ip_igmp_cnt=0;
+	debug_ip_input_cnt=0;
+	debug_ip_output_cnt=0;
+	debug_ip_forward_cnt=0;
+	debug_ip_ipmr_cnt=0;
+	debug_ip_test_cnt=0;	
+	debug_ip_hook_cnt=0;	
+
+	
+	return 0;
+}
+
+
+int debug_count_delta(struct timeval *tv1,struct timeval tv2)
+{
+        struct timeval *left,*right;    
+	int d=0;
+	if(tv1->tv_sec > tv2.tv_sec){
+		left=tv1;
+		right=&tv2;
+	}else{
+    		right=tv1;
+    		left=&tv2;
+        }
+	
+
+	left->tv_sec-=right->tv_sec;
+	d=left->tv_usec-right->tv_usec;
+	if( d < 0 ){
+		if( left->tv_sec ){
+			d+=1000000;
+			left->tv_sec--;
+		}
+		else
+			d*=-1;
+	}
+
+	tv1->tv_sec=left->tv_sec;
+	tv1->tv_usec=d;
+	return 0;	
+}
+
+void debug_sum_tv(struct timeval *tv1,struct timeval tv2)
+{
+        struct timeval *left,*right;    
+	int s;
+	
+	left=tv1;
+	right=&tv2;
+
+	left->tv_sec+=right->tv_sec;	
+
+	s=left->tv_usec+right->tv_usec;
+	if( s>1000000 ){
+	    left->tv_sec++;
+	    s-=1000000;
+	}
+	left->tv_usec=s;
+}
+
+void debug_div_tv(struct timeval *tv1,u32 z)
+{
+    u32 a;
+    tv1->tv_usec= (tv1->tv_usec/z);
+    if( (a=tv1->tv_sec%z) ){
+	tv1->tv_usec+= (a*1000000)/z;
+    }
+    tv1->tv_sec/=z;
+    
+}
+
+void debug_print_tv(struct timeval *tv,u32 cnt,struct timeval *tv1,char *str)
+{
+    sprintf(str,"avg = %ld.%06ld, num= %d,global=%ld.%06ld",tv->tv_sec,tv->tv_usec,
+    cnt,tv1->tv_sec,tv1->tv_usec);
+}
+
+// export functions
+EXPORT_SYMBOL(debug_count_delta);
+EXPORT_SYMBOL(debug_print_tv);
+EXPORT_SYMBOL(debug_sum_tv);
+EXPORT_SYMBOL(debug_div_tv);
+
+// export counters
+EXPORT_SYMBOL(debug_ip_arp);
+EXPORT_SYMBOL(debug_ip_igmp);
+EXPORT_SYMBOL(debug_ip_input);
+EXPORT_SYMBOL(debug_ip_output);
+EXPORT_SYMBOL(debug_ip_ipmr);
+EXPORT_SYMBOL(debug_ip_forward);
+EXPORT_SYMBOL(debug_ip_hook);
+EXPORT_SYMBOL(debug_ip_test);
+EXPORT_SYMBOL(debug_ip_vs_xmit);
+EXPORT_SYMBOL(debug_ip_ipt_REJECT);
+EXPORT_SYMBOL(debug_ip_raw);
+EXPORT_SYMBOL(debug_ip_xfrm4_input);
+EXPORT_SYMBOL(debug_ip_xfrm4_output);
+
+EXPORT_SYMBOL(debug_ip_arp_cnt);
+EXPORT_SYMBOL(debug_ip_igmp_cnt);
+EXPORT_SYMBOL(debug_ip_input_cnt);
+EXPORT_SYMBOL(debug_ip_output_cnt);
+EXPORT_SYMBOL(debug_ip_ipmr_cnt);
+EXPORT_SYMBOL(debug_ip_forward_cnt);
+EXPORT_SYMBOL(debug_ip_hook_cnt);
+EXPORT_SYMBOL(debug_ip_test_cnt);
+
+
+module_init(debug_net_init);
diff -Naur linux-2.6.16/drivers/debug/Makefile linux-2.6.16-new/drivers/debug/Makefile
--- linux-2.6.16/drivers/debug/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/debug/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -0,0 +1,2 @@
+obj-y		+= debug_net.o
+
diff -Naur linux-2.6.16/drivers/mtd/nand/adm5120.c linux-2.6.16-new/drivers/mtd/nand/adm5120.c
--- linux-2.6.16/drivers/mtd/nand/adm5120.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/mtd/nand/adm5120.c	2007-05-07 10:32:51.000000000 +0700
@@ -0,0 +1,219 @@
+/*
+ *  drivers/mtd/nand/adm5120.c
+ *
+ *  Copyright (C) 2000 Polyakov Artyom (art@granch.ru)
+ *
+ *  Derived from drivers/mtd/spia.c
+ *       Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com) *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   SPIA board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 64Mibit (8MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/delay.h>
+#include <linux/mtd/partitions.h>
+#include <asm/io.h>
+#include "adm5120.h"
+
+#define DEBUG_ADM5120
+#define DEBUG_ADM5120_LEVEL 0
+#include <asm/am5120/debug.h>
+
+/*
+ * MTD structure for SPIA board
+ */
+
+static struct mtd_info *adm5120_mtd = NULL;
+/*
+ * Values specific to the ADM5120 board
+ */
+static int adm5120_fio_pbase = NAND_REG_PBASE;
+static int adm5120_fio_base;
+
+/*
+ * Define partitions for flash device
+ */
+#define FLASH_SIZE      0x02000000
+#define FLASH_PART_BOOT_ADDR    0x00000000
+#define FLASH_PART_BOOT_SIZE    0x00020000
+#define FLASH_PART_KERNEL_ADDR  0x00020000
+#define FLASH_PART_KERNEL_SIZE  0x00200000
+#define FLASH_PART_ROOT_ADDR    (FLASH_PART_KERNEL_ADDR + FLASH_PART_KERNEL_SIZE)
+#define FLASH_PART_ROOT_SIZE    FLASH_SIZE-FLASH_PART_ROOT_ADDR
+															
+#define NUM_PARTITIONS 3
+static struct mtd_partition partition_info32M[] = {
+    {	.name         = "Boot Partition",
+        .offset       = FLASH_PART_BOOT_ADDR,
+	.size         = FLASH_PART_BOOT_SIZE	},
+    {	.name         = "Kernel partition",
+	.offset       = FLASH_PART_KERNEL_ADDR,
+	.size         = FLASH_PART_KERNEL_SIZE    },
+    {	.name	      = "Root partition",
+	.offset       =  FLASH_PART_ROOT_ADDR,
+	.size         =  FLASH_PART_ROOT_SIZE
+	    },
+
+};
+					
+
+/* 
+ *	hardware specific access to control-lines
+ */
+static void adm5120_hwcontrol(struct mtd_info *mtd, int cmd){
+
+    switch (cmd){
+    case NAND_CTL_SETCLE:
+        writeb(0x01,(unsigned char *)adm5120_fio_base + NAND_SET_CLE);
+        break;
+    case NAND_CTL_CLRCLE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_CLR_CLE);
+        break;
+    case NAND_CTL_SETALE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_SET_ALE);
+        break;
+    case NAND_CTL_CLRALE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_CLR_ALE);
+        break;
+    case NAND_CTL_SETNCE:
+        writeb( 0x01,(unsigned char *)adm5120_fio_base + NAND_SET_CEn);
+        break;
+    case NAND_CTL_CLRNCE:
+        writeb( 0x01, (unsigned char *)adm5120_fio_base + NAND_CLR_CEn);
+    default:
+        break;
+    }
+}
+
+
+int adm5120_device_ready(struct mtd_info *mtd)
+{
+	udelay(20);
+	return 1;
+}
+    
+
+/*
+ * Main initialization routine
+ */
+int __init adm5120_init (void)
+{
+	struct nand_chip *this;
+	int err;
+
+	/* Allocate memory for MTD device structure and private data */
+	adm5120_mtd = kmalloc (sizeof(struct mtd_info) + sizeof (struct nand_chip),
+				GFP_KERNEL);
+
+        if (!adm5120_mtd) {
+                printk ("adm5120: Unable to allocate NAND MTD device structure.\n");
+                err = -ENOMEM;
+                goto out;
+        }
+        PDEBUG(1,"Memory for MTD device structure and private data allocated");
+															
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&adm5120_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) adm5120_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	adm5120_mtd->priv = this;
+
+	/*
+	 * Set GPIO Port E control register so that the pins are configured
+	 * to be outputs for controlling the NAND flash.
+	 */
+        adm5120_fio_base=(unsigned long)ioremap(adm5120_fio_pbase,1024);
+	if(!adm5120_fio_base){
+	    printk("adm5120: Ioremap failed\n");
+	    err=-ENXIO;	     
+
+	}
+	PDEBUG(1,"IO Remap successfull");
+											 
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = (void __iomem *)adm5120_fio_base;
+        this->IO_ADDR_W = (void __iomem *)adm5120_fio_base;
+	/* Set address of hardware control function */       
+        this->hwcontrol = adm5120_hwcontrol;
+	this->dev_ready = adm5120_device_ready;
+       /* 20 us command delay time */
+       this->chip_delay = 20;
+       this->eccmode = NAND_ECC_SOFT;
+       this->options = NAND_USE_FLASH_BBT;                                                                     
+							       
+	/* Scan to find existence of the device */
+	if (nand_scan (adm5120_mtd, 1)) {
+		err=-ENXIO;
+                goto out_mtd;		
+	}
+
+	/* Register the partitions */
+	add_mtd_partitions(adm5120_mtd, partition_info32M, NUM_PARTITIONS);
+
+
+/*--------------- DEBUG
+	size_t retlen;	
+	u_char buf[20];
+	int i,j;
+	
+	mdelay(1000);
+	printk("oob listing:\n");
+	mdelay(1000);
+	mdelay(1000);	
+	mdelay(1000);
+	mdelay(1000);	
+	mdelay(1000);	
+	for(i=0x0000; i<=0x20000; i+=0x4000){
+	    adm5120_mtd->read_oob (adm5120_mtd,i,16,&retlen,buf);
+	    printk("%08x (%d): ",i,retlen);
+	    for(j=0;j<16;j++)
+		printk("%02x ",buf[j] & 0xff);
+	    mdelay(100);
+	    printk("\n");	    
+	}
+
+//--------------- END DEBUG */
+	/* Return happy */
+	return 0;
+out_mtd:
+        kfree (adm5120_mtd);
+out:
+        return err;
+		
+}
+module_init(adm5120_init);
+
+/*
+ * Clean up routine
+
+#ifdef MODULE
+static void __exit spia_cleanup (void)
+{
+	// Release resources, unregister device 
+	nand_release (spia_mtd);
+
+	// Free the MTD device structure 
+	kfree (spia_mtd);
+}
+module_exit(spia_cleanup);
+#endif
+*/
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Artyom U. Plyakov <art@sigrand.ru");
diff -Naur linux-2.6.16/drivers/mtd/nand/adm5120.h linux-2.6.16-new/drivers/mtd/nand/adm5120.h
--- linux-2.6.16/drivers/mtd/nand/adm5120.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/mtd/nand/adm5120.h	2007-05-07 10:32:51.000000000 +0700
@@ -0,0 +1,91 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : David Weng
+;    File    : adm5120.h
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __ADM5120_H__
+#define  __ADM5120_H__
+
+
+/*=========================  Physical Memory Map  ============================*/
+#define ADM5120_SDRAM_BASE						0
+#define ADM5120_SMEM1_BASE						0x10000000
+#define MEM_KSEG1_BASE							0xA0000000
+
+#define ADM5120_EXTIO0_BASE						0x10C00000
+#define ADM5120_EXTIO1_BASE						0x10E00000
+#define ADM5120_MPMC_BASE						0x11000000
+#define ADM5120_USBHOST_BASE					0x11200000
+#define ADM5120_PCIMEM_BASE						0x11400000
+#define ADM5120_PCIIO_BASE						0x11500000
+#define ADM5120_PCICFG_BASE						0x115FFFF0
+#define ADM5120_MIPS_BASE						0x11A00000
+#define ADM5120_SWCTRL_BASE						0x12000000
+#define ADM5120_INTC_BASE						0x12200000
+#define ADM5120_SYSC_BASE						0x12400000
+#define ADM5120_UART0_BASE						0x12600000
+#define ADM5120_UART1_BASE						0x12800000
+#define ADM5120_SMEM0_BASE						0x1FC00000
+
+
+#define NAND_REG_PBASE				ADM5120_SMEM1_BASE
+
+/* NAND flash interface */
+#define NAND_RW_REG                             0x00
+#define NAND_CLR_CE_REG                       0x01
+#define NAND_SET_CE_REG                         0x02
+#define NAND_CLR_CLE_REG                      0x03
+#define NAND_SET_CLE_REG                        0x04
+#define NAND_CLR_ALE_REG                      0x05
+#define NAND_SET_ALE_REG                        0x06
+#define NAND_SET_SPn_REG                       0x07
+#define NAND_CLR_SPn_REG                         0x08
+#define NAND_CLR_WP_REG                       0x09
+#define NAND_SET_WP_REG                         0x0a
+#define NAND_RDY_REG                            0x0b
+
+#define NAND_SET_BIT                            0x01
+#define NAND_ENABLE                             0x100
+
+/* Macros for accessing NAND flash interface register */
+#define ADM5120_NAND_REG(_reg)		\
+	(*((volatile unsigned long *)(PA2VA(ADM5120_SMEM1_BASE + (_reg)))))
+
+
+#define NAND_SET_CEn    0x1     //CE# low
+#define NAND_CLR_CEn    0x2     //CE# high
+#define NAND_CLR_CLE    0x3     //CLE low
+#define NAND_SET_CLE    0x4     //CLE high
+#define NAND_CLR_ALE    0x5     //ALE low
+#define NAND_SET_ALE    0x6     //ALE high
+#define NAND_SET_SPn    0x7     //SP# low (use spare area)
+#define NAND_CLR_SPn    0x8     //SP# high (do not use spare area)
+#define NAND_SET_WPn    0x9     //WP# low
+#define NAND_CLR_WPn    0xA     //WP# high
+#define NAND_STS_REG    0xB     //Status register
+
+#endif
diff -Naur linux-2.6.16/drivers/mtd/nand/Makefile linux-2.6.16-new/drivers/mtd/nand/Makefile
--- linux-2.6.16/drivers/mtd/nand/Makefile	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/mtd/nand/Makefile	2007-05-10 10:27:22.000000000 +0700
@@ -6,10 +6,14 @@
 obj-$(CONFIG_MTD_NAND)			+= nand.o nand_ecc.o
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
 
+obj-y					+= adm5120.o
+
 obj-$(CONFIG_MTD_NAND_SPIA)		+= spia.o
 obj-$(CONFIG_MTD_NAND_TOTO)		+= toto.o
 obj-$(CONFIG_MTD_NAND_AUTCPU12)		+= autcpu12.o
 obj-$(CONFIG_MTD_NAND_EDB7312)		+= edb7312.o
+obj-$(CONFIG_MTD_NAND_TX4925NDFMC)	+= tx4925ndfmc.o
+obj-$(CONFIG_MTD_NAND_TX4938NDFMC)	+= tx4938ndfmc.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
diff -Naur linux-2.6.16/drivers/mtd/nand/nand_base.c linux-2.6.16-new/drivers/mtd/nand/nand_base.c
--- linux-2.6.16/drivers/mtd/nand/nand_base.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/mtd/nand/nand_base.c	2007-05-13 18:17:45.000000000 +0700
@@ -5,14 +5,14 @@
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
  *   Basic support for AG-AND chips is provided.
- *
+ *   
  *	Additional technical information is available on
  *	http://www.linux-mtd.infradead.org/tech/nand.html
- *
+ *	
  *  Copyright (C) 2000 Steven J. Hill (sjhill@realitydiluted.com)
  * 		  2002 Thomas Gleixner (tglx@linutronix.de)
  *
- *  02-08-2004  tglx: support for strange chips, which cannot auto increment
+ *  02-08-2004  tglx: support for strange chips, which cannot auto increment 
  *		pages on read / read_oob
  *
  *  03-17-2004  tglx: Check ready before auto increment check. Simon Bayes
@@ -21,36 +21,16 @@
  *		Make reads over block boundaries work too
  *
  *  04-14-2004	tglx: first working version for 2k page size chips
- *
+ *  
  *  05-19-2004  tglx: Basic support for Renesas AG-AND chips
  *
  *  09-24-2004  tglx: add support for hardware controllers (e.g. ECC) shared
  *		among multiple independend devices. Suggestions and initial patch
  *		from Ben Dooks <ben-mtd@fluff.org>
  *
- *  12-05-2004	dmarlin: add workaround for Renesas AG-AND chips "disturb" issue.
- *		Basically, any block not rewritten may lose data when surrounding blocks
- *		are rewritten many times.  JFFS2 ensures this doesn't happen for blocks
- *		it uses, but the Bad Block Table(s) may not be rewritten.  To ensure they
- *		do not lose data, force them to be rewritten when some of the surrounding
- *		blocks are erased.  Rather than tracking a specific nearby block (which
- *		could itself go bad), use a page address 'mask' to select several blocks
- *		in the same area, and rewrite the BBT when any of them are erased.
- *
- *  01-03-2005	dmarlin: added support for the device recovery command sequence for Renesas
- *		AG-AND chips.  If there was a sudden loss of power during an erase operation,
- * 		a "device recovery" operation must be performed when power is restored
- * 		to ensure correct operation.
- *
- *  01-20-2005	dmarlin: added support for optional hardware specific callback routine to
- *		perform extra error status checks on erase and write failures.  This required
- *		adding a wrapper function for nand_read_ecc.
- *
- * 08-20-2005	vwool: suspend/resume added
- *
  * Credits:
- *	David Woodhouse for adding multichip support
- *
+ *	David Woodhouse for adding multichip support  
+ *	
  *	Aleph One Ltd. and Toby Churchill Ltd. for supporting the
  *	rework for 2K page size chips
  *
@@ -61,7 +41,7 @@
  *	The AG-AND chips have nice features for speed improvement,
  *	which are not supported yet. Read / program 4 pages in one go.
  *
- * $Id: nand_base.c,v 1.150 2005/09/15 13:58:48 vwool Exp $
+ * $Id: nand_base.c,v 1.126 2004/12/13 11:22:25 lavinen Exp $
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -105,8 +85,8 @@
 	.useecc = MTD_NANDECC_AUTOPLACE,
 	.eccbytes = 24,
 	.eccpos = {
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
+		40, 41, 42, 43, 44, 45, 46, 47, 
+		48, 49, 50, 51, 52, 53, 54, 55, 
 		56, 57, 58, 59, 60, 61, 62, 63},
 	.oobfree = { {2, 38} }
 };
@@ -149,19 +129,19 @@
 static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, u_char *oob_buf,
 		struct nand_oobinfo *oobsel, int mode);
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode);
 #else
 #define nand_verify_pages(...) (0)
 #endif
-
-static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
+		
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state);
 
 /**
  * nand_release_device - [GENERIC] release chip
  * @mtd:	MTD device structure
- *
- * Deselect, release chip lock and wake up anyone waiting on the device
+ * 
+ * Deselect, release chip lock and wake up anyone waiting on the device 
  */
 static void nand_release_device (struct mtd_info *mtd)
 {
@@ -169,21 +149,17 @@
 
 	/* De-select the NAND device */
 	this->select_chip(mtd, -1);
-
+	/* Do we have a hardware controller ? */
 	if (this->controller) {
-		/* Release the controller and the chip */
 		spin_lock(&this->controller->lock);
 		this->controller->active = NULL;
-		this->state = FL_READY;
-		wake_up(&this->controller->wq);
 		spin_unlock(&this->controller->lock);
-	} else {
-		/* Release the chip */
-		spin_lock(&this->chip_lock);
-		this->state = FL_READY;
-		wake_up(&this->wq);
-		spin_unlock(&this->chip_lock);
 	}
+	/* Release the chip */
+	spin_lock (&this->chip_lock);
+	this->state = FL_READY;
+	wake_up (&this->wq);
+	spin_unlock (&this->chip_lock);
 }
 
 /**
@@ -215,7 +191,7 @@
  * nand_read_byte16 - [DEFAULT] read one byte endianess aware from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith with
+ * Default read function for 16bit buswith with 
  * endianess conversion
  */
 static u_char nand_read_byte16(struct mtd_info *mtd)
@@ -242,7 +218,7 @@
  * nand_read_word - [DEFAULT] read one word from the chip
  * @mtd:	MTD device structure
  *
- * Default read function for 16bit buswith without
+ * Default read function for 16bit buswith without 
  * endianess conversion
  */
 static u16 nand_read_word(struct mtd_info *mtd)
@@ -256,7 +232,7 @@
  * @mtd:	MTD device structure
  * @word:	data word to write
  *
- * Default write function for 16bit buswith without
+ * Default write function for 16bit buswith without 
  * endianess conversion
  */
 static void nand_write_word(struct mtd_info *mtd, u16 word)
@@ -277,7 +253,7 @@
 	struct nand_chip *this = mtd->priv;
 	switch(chip) {
 	case -1:
-		this->hwcontrol(mtd, NAND_CTL_CLRNCE);
+		this->hwcontrol(mtd, NAND_CTL_CLRNCE);	
 		break;
 	case 0:
 		this->hwcontrol(mtd, NAND_CTL_SETNCE);
@@ -300,13 +276,15 @@
 {
 	int i;
 	struct nand_chip *this = mtd->priv;
+	
+					
 
 	for (i=0; i<len; i++)
 		writeb(buf[i], this->IO_ADDR_W);
 }
 
 /**
- * nand_read_buf - [DEFAULT] read chip data into buffer
+ * nand_read_buf - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -317,13 +295,12 @@
 {
 	int i;
 	struct nand_chip *this = mtd->priv;
-
 	for (i=0; i<len; i++)
 		buf[i] = readb(this->IO_ADDR_R);
 }
 
 /**
- * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -356,14 +333,14 @@
 	struct nand_chip *this = mtd->priv;
 	u16 *p = (u16 *) buf;
 	len >>= 1;
-
+	
 	for (i=0; i<len; i++)
 		writew(p[i], this->IO_ADDR_W);
-
+		
 }
 
 /**
- * nand_read_buf16 - [DEFAULT] read chip data into buffer
+ * nand_read_buf16 - [DEFAULT] read chip data into buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer to store date
  * @len:	number of bytes to read
@@ -382,7 +359,7 @@
 }
 
 /**
- * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer
+ * nand_verify_buf16 - [DEFAULT] Verify chip data against buffer 
  * @mtd:	MTD device structure
  * @buf:	buffer containing the data to compare
  * @len:	number of bytes to compare
@@ -409,7 +386,7 @@
  * @ofs:	offset from device start
  * @getchip:	0, if the chip is already selected
  *
- * Check, if the block is bad.
+ * Check, if the block is bad. 
  */
 static int nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
 {
@@ -426,27 +403,37 @@
 
 		/* Select the NAND device */
 		this->select_chip(mtd, chipnr);
-	} else
-		page = (int) ofs;
+	} else 
+		page = (int) ofs;	
 
 	if (this->options & NAND_BUSWIDTH_16) {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos & 0xFE, page & this->pagemask);
 		bad = cpu_to_le16(this->read_word(mtd));
 		if (this->badblockpos & 0x1)
-			bad >>= 8;
+			bad >>= 1;
 		if ((bad & 0xFF) != 0xff)
 			res = 1;
 	} else {
 		this->cmdfunc (mtd, NAND_CMD_READOOB, this->badblockpos, page & this->pagemask);
-		if (this->read_byte(mtd) != 0xff)
-			res = 1;
+		
+		u8 tmp=this->read_byte(mtd);
+		if ( tmp!= 0xff){
+		    printk("NAND_BAD_BLOCK (%08x): oob= %02x",page,tmp);
+		    int i;
+		    for(i=0;i<15;i++){
+			udelay(20);
+			printk(" %02x",this->read_byte(mtd));
+		    }
+		    printk("\n");
+		    res = 1;
+		}
 	}
-
+		
 	if (getchip) {
 		/* Deselect and wake up anyone waiting on the device */
 		nand_release_device(mtd);
-	}
-
+	}	
+	
 	return res;
 }
 
@@ -464,34 +451,33 @@
 	u_char buf[2] = {0, 0};
 	size_t	retlen;
 	int block;
-
+	
 	/* Get block number */
 	block = ((int) ofs) >> this->bbt_erase_shift;
-	if (this->bbt)
-		this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+	this->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
 
 	/* Do we have a flash based bad block table ? */
 	if (this->options & NAND_USE_FLASH_BBT)
 		return nand_update_bbt (mtd, ofs);
-
+		
 	/* We write two bytes, so we dont have to mess with 16 bit access */
 	ofs += mtd->oobsize + (this->badblockpos & ~0x01);
 	return nand_write_oob (mtd, ofs , 2, &retlen, buf);
 }
 
-/**
+/** 
  * nand_check_wp - [GENERIC] check if the chip is write protected
  * @mtd:	MTD device structure
- * Check, if the device is write protected
+ * Check, if the device is write protected 
  *
- * The function expects, that the device is already selected
+ * The function expects, that the device is already selected 
  */
 static int nand_check_wp (struct mtd_info *mtd)
 {
 	struct nand_chip *this = mtd->priv;
 	/* Check the WP bit */
 	this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
-	return (this->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+	return (this->read_byte(mtd) & 0x80) ? 0 : 1; 
 }
 
 /**
@@ -507,31 +493,15 @@
 static int nand_block_checkbad (struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
 {
 	struct nand_chip *this = mtd->priv;
-
+	
 	if (!this->bbt)
 		return this->block_bad(mtd, ofs, getchip);
-
+	
 	/* Return info from the table */
+//	return nand_isbad_bbt (mtd, ofs*mtd->oobblock, allowbbt);
 	return nand_isbad_bbt (mtd, ofs, allowbbt);
 }
 
-/*
- * Wait for the ready pin, after a command
- * The timeout is catched later.
- */
-static void nand_wait_ready(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-	unsigned long	timeo = jiffies + 2;
-
-	/* wait until command is processed or timeout occures */
-	do {
-		if (this->dev_ready(mtd))
-			return;
-		touch_softlockup_watchdog();
-	} while (time_before(jiffies, timeo));
-}
-
 /**
  * nand_command - [DEFAULT] Send command to NAND device
  * @mtd:	MTD device structure
@@ -592,13 +562,13 @@
 		/* Latch in address */
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
+	
+	/* 
+	 * program and erase have their own busy handlers 
 	 * status and sequential in needs no delay
 	*/
 	switch (command) {
-
+			
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
@@ -607,35 +577,37 @@
 		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		while ( !(this->read_byte(mtd) & 0x40));
 		return;
 
-	/* This applies to read commands */
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
+	
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-
-	nand_wait_ready(mtd);
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd));
 }
 
 /**
- * nand_command_lp - [DEFAULT] Send command to NAND large page device
+ * 
+ nand_command_lp - [DEFAULT] Send command to NAND large page device
  * @mtd:	MTD device structure
  * @command:	the command to be sent
  * @column:	the column address for this command, -1 if none
@@ -655,12 +627,12 @@
 		column += mtd->oobblock;
 		command = NAND_CMD_READ0;
 	}
-
-
+	
+		
 	/* Begin command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_SETCLE);
 	/* Write out the command to the device. */
-	this->write_byte(mtd, (command & 0xff));
+	this->write_byte(mtd, command);
 	/* End command latch cycle */
 	this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 
@@ -674,7 +646,7 @@
 				column >>= 1;
 			this->write_byte(mtd, column & 0xff);
 			this->write_byte(mtd, column >> 8);
-		}
+		}	
 		if (page_addr != -1) {
 			this->write_byte(mtd, (unsigned char) (page_addr & 0xff));
 			this->write_byte(mtd, (unsigned char) ((page_addr >> 8) & 0xff));
@@ -683,43 +655,33 @@
 				this->write_byte(mtd, (unsigned char) ((page_addr >> 16) & 0xff));
 		}
 		/* Latch in address */
+		
 		this->hwcontrol(mtd, NAND_CTL_CLRALE);
 	}
-
-	/*
-	 * program and erase have their own busy handlers
-	 * status, sequential in, and deplete1 need no delay
-	 */
+	
+	/* 
+	 * program and erase have their own busy handlers 
+	 * status and sequential in needs no delay
+	*/
 	switch (command) {
-
+			
 	case NAND_CMD_CACHEDPROG:
 	case NAND_CMD_PAGEPROG:
 	case NAND_CMD_ERASE1:
 	case NAND_CMD_ERASE2:
 	case NAND_CMD_SEQIN:
 	case NAND_CMD_STATUS:
-	case NAND_CMD_DEPLETE1:
 		return;
 
-	/*
-	 * read error status commands require only a short delay
-	 */
-	case NAND_CMD_STATUS_ERROR:
-	case NAND_CMD_STATUS_ERROR0:
-	case NAND_CMD_STATUS_ERROR1:
-	case NAND_CMD_STATUS_ERROR2:
-	case NAND_CMD_STATUS_ERROR3:
-		udelay(this->chip_delay);
-		return;
 
 	case NAND_CMD_RESET:
-		if (this->dev_ready)
+		if (this->dev_ready)	
 			break;
 		udelay(this->chip_delay);
 		this->hwcontrol(mtd, NAND_CTL_SETCLE);
 		this->write_byte(mtd, NAND_CMD_STATUS);
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
-		while ( !(this->read_byte(mtd) & NAND_STATUS_READY));
+		while ( !(this->read_byte(mtd) & 0x40));
 		return;
 
 	case NAND_CMD_READ0:
@@ -730,68 +692,67 @@
 		/* End command latch cycle */
 		this->hwcontrol(mtd, NAND_CTL_CLRCLE);
 		/* Fall through into ready check */
-
-	/* This applies to read commands */
+		
+	/* This applies to read commands */	
 	default:
-		/*
+		/* 
 		 * If we don't have access to the busy pin, we apply the given
 		 * command delay
 		*/
 		if (!this->dev_ready) {
 			udelay (this->chip_delay);
 			return;
-		}
+		}	
 	}
-
+	
 	/* Apply this short delay always to ensure that we do wait tWB in
 	 * any case on any machine. */
 	ndelay (100);
-
-	nand_wait_ready(mtd);
+	/* wait until command is processed */
+	while (!this->dev_ready(mtd));
 }
 
 /**
  * nand_get_device - [GENERIC] Get chip for selected access
  * @this:	the nand chip descriptor
  * @mtd:	MTD device structure
- * @new_state:	the state which is requested
+ * @new_state:	the state which is requested 
  *
  * Get the device and lock it for exclusive access
  */
-static int nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
+static void nand_get_device (struct nand_chip *this, struct mtd_info *mtd, int new_state)
 {
-	struct nand_chip *active;
-	spinlock_t *lock;
-	wait_queue_head_t *wq;
+	struct nand_chip *active = this;
+
 	DECLARE_WAITQUEUE (wait, current);
 
-	lock = (this->controller) ? &this->controller->lock : &this->chip_lock;
-	wq = (this->controller) ? &this->controller->wq : &this->wq;
+	/* 
+	 * Grab the lock and see if the device is available 
+	*/
 retry:
-	active = this;
-	spin_lock(lock);
-
 	/* Hardware controller shared among independend devices */
 	if (this->controller) {
+		spin_lock (&this->controller->lock);
 		if (this->controller->active)
 			active = this->controller->active;
 		else
 			this->controller->active = this;
+		spin_unlock (&this->controller->lock);
 	}
-	if (active == this && this->state == FL_READY) {
-		this->state = new_state;
-		spin_unlock(lock);
-		return 0;
-	}
-	if (new_state == FL_PM_SUSPENDED) {
-		spin_unlock(lock);
-		return (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
-	}
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	add_wait_queue(wq, &wait);
-	spin_unlock(lock);
-	schedule();
-	remove_wait_queue(wq, &wait);
+	
+	if (active == this) {
+		spin_lock (&this->chip_lock);
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			spin_unlock (&this->chip_lock);
+			return;
+		}
+	}	
+	set_current_state (TASK_UNINTERRUPTIBLE);
+	add_wait_queue (&active->wq, &wait);
+	spin_unlock (&active->chip_lock);
+	schedule ();
+	remove_wait_queue (&active->wq, &wait);
 	goto retry;
 }
 
@@ -802,7 +763,7 @@
  * @state:	state to select the max. timeout value
  *
  * Wait for command done. This applies to erase and program only
- * Erase can take up to 400ms and program up to 20ms according to
+ * Erase can take up to 400ms and program up to 20ms according to 
  * general NAND and SmartMedia specs
  *
 */
@@ -811,7 +772,7 @@
 
 	unsigned long	timeo = jiffies;
 	int	status;
-
+	
 	if (state == FL_ERASING)
 		 timeo += (HZ * 400) / 1000;
 	else
@@ -823,22 +784,23 @@
 
 	if ((state == FL_ERASING) && (this->options & NAND_IS_AND))
 		this->cmdfunc (mtd, NAND_CMD_STATUS_MULTI, -1, -1);
-	else
+	else	
 		this->cmdfunc (mtd, NAND_CMD_STATUS, -1, -1);
 
-	while (time_before(jiffies, timeo)) {
+	while (time_before(jiffies, timeo)) {		
 		/* Check, if we were interrupted */
-		if (this->state != state)
+/*		if (this->state != state)
 			return 0;
 
 		if (this->dev_ready) {
 			if (this->dev_ready(mtd))
-				break;
+				break;	
 		} else {
-			if (this->read_byte(mtd) & NAND_STATUS_READY)
-				break;
-		}
-		cond_resched();
+*/		
+		if (this->read_byte(mtd) & NAND_STATUS_READY)
+			break;
+//		}
+		yield ();
 	}
 	status = (int) this->read_byte(mtd);
 	return status;
@@ -859,7 +821,7 @@
  *
  * Cached programming is not supported yet.
  */
-static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page,
+static int nand_write_page (struct mtd_info *mtd, struct nand_chip *this, int page, 
 	u_char *oob_buf,  struct nand_oobinfo *oobsel, int cached)
 {
 	int 	i, status;
@@ -868,10 +830,10 @@
 	int  	*oob_config = oobsel->eccpos;
 	int	datidx = 0, eccidx = 0, eccsteps = this->eccsteps;
 	int	eccbytes = 0;
-
+	
 	/* FIXME: Enable cached programming */
 	cached = 0;
-
+	
 	/* Send command to begin auto page programming */
 	this->cmdfunc (mtd, NAND_CMD_SEQIN, 0x00, page);
 
@@ -882,7 +844,7 @@
 		printk (KERN_WARNING "Writing data without ECC to NAND-FLASH is not recommended\n");
 		this->write_buf(mtd, this->data_poi, mtd->oobblock);
 		break;
-
+		
 	/* Software ecc 3/256, write all */
 	case NAND_ECC_SOFT:
 		for (; eccsteps; eccsteps--) {
@@ -911,12 +873,21 @@
 		}
 		break;
 	}
-
+										
 	/* Write out OOB data */
+	
 	if (this->options & NAND_HWECC_SYNDROME)
 		this->write_buf(mtd, &oob_buf[oobsel->eccbytes], mtd->oobsize - oobsel->eccbytes);
-	else
-		this->write_buf(mtd, oob_buf, mtd->oobsize);
+	else {
+/*		mdelay(100);
+    		printk("write oob(%08x): ",page);
+	    	for(i=0;i< mtd->oobsize;i++){
+		    printk("%02x ",oob_buf[i] & 0xff);
+		}
+		printk("\n");
+*/		this->write_buf(mtd, oob_buf, mtd->oobsize);
+	}
+		
 
 	/* Send command to actually program the data */
 	this->cmdfunc (mtd, cached ? NAND_CMD_CACHEDPROG : NAND_CMD_PAGEPROG, -1, -1);
@@ -924,14 +895,9 @@
 	if (!cached) {
 		/* call wait ready function */
 		status = this->waitfunc (mtd, this, FL_WRITING);
-
-		/* See if operation failed and additional status checks are available */
-		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
-			status = this->errstat(mtd, this, FL_WRITING, status, page);
-		}
-
 		/* See if device thinks it succeeded */
-		if (status & NAND_STATUS_FAIL) {
+		if (status & 0x01) {
+			printk(KERN_WARNING "%s: Failed write, page 0x%08x, ", __FUNCTION__, page);
 			DEBUG (MTD_DEBUG_LEVEL0, "%s: " "Failed write, page 0x%08x, ", __FUNCTION__, page);
 			return -EIO;
 		}
@@ -940,7 +906,7 @@
 		/* wait until cache is ready*/
 		// status = this->waitfunc (mtd, this, FL_CACHEDRPG);
 	}
-	return 0;
+	return 0;	
 }
 
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
@@ -956,19 +922,19 @@
  * @oobmode:	1 = full buffer verify, 0 = ecc only
  *
  * The NAND device assumes that it is always writing to a cleanly erased page.
- * Hence, it performs its internal write verification only on bits that
+ * Hence, it performs its internal write verification only on bits that 
  * transitioned from 1 to 0. The device does NOT verify the whole page on a
- * byte by byte basis. It is possible that the page was not completely erased
- * or the page is becoming unusable due to wear. The read with ECC would catch
- * the error later when the ECC page check fails, but we would rather catch
+ * byte by byte basis. It is possible that the page was not completely erased 
+ * or the page is becoming unusable due to wear. The read with ECC would catch 
+ * the error later when the ECC page check fails, but we would rather catch 
  * it early in the page write stage. Better to write no data than invalid data.
  */
-static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages,
+static int nand_verify_pages (struct mtd_info *mtd, struct nand_chip *this, int page, int numpages, 
 	u_char *oob_buf, struct nand_oobinfo *oobsel, int chipnr, int oobmode)
 {
 	int 	i, j, datidx = 0, oobofs = 0, res = -EIO;
 	int	eccsteps = this->eccsteps;
-	int	hweccbytes;
+	int	hweccbytes; 
 	u_char 	oobdata[64];
 
 	hweccbytes = (this->options & NAND_HWECC_SYNDROME) ? (oobsel->eccbytes / eccsteps) : 0;
@@ -1008,7 +974,7 @@
 
 			if (oobsel->useecc != MTD_NANDECC_OFF && !hweccbytes) {
 				int ecccnt = oobsel->eccbytes;
-
+		
 				for (i = 0; i < ecccnt; i++) {
 					int idx = oobsel->eccpos[i];
 					if (oobdata[idx] != oob_buf[oobofs + idx] ) {
@@ -1018,62 +984,61 @@
 						goto out;
 					}
 				}
-			}
+			}	
 		}
 		oobofs += mtd->oobsize - hweccbytes * eccsteps;
 		page++;
 		numpages--;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		 * Do this also before returning, so the chip is
 		 * ready for the next command.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
+			while (!this->dev_ready(mtd));	
 
 		/* All done, return happy */
 		if (!numpages)
 			return 0;
-
-
-		/* Check, if the chip supports auto page increment */
+		
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this))
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 	}
-	/*
+	/* 
 	 * Terminate the read command. We come here in case of an error
 	 * So we must issue a reset command.
 	 */
-out:
+out:	 
 	this->cmdfunc (mtd, NAND_CMD_RESET, -1, -1);
 	return res;
 }
 #endif
 
 /**
- * nand_read - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read - [MTD Interface] MTD compability function for nand_read_ecc
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
  * @retlen:	pointer to variable to store the number of read bytes
  * @buf:	the databuffer to put data
  *
- * This function simply calls nand_do_read_ecc with oob buffer and oobsel = NULL
- * and flags = 0xff
- */
+ * This function simply calls nand_read_ecc with oob buffer and oobsel = NULL
+*/
 static int nand_read (struct mtd_info *mtd, loff_t from, size_t len, size_t * retlen, u_char * buf)
 {
-	return nand_do_read_ecc (mtd, from, len, retlen, buf, NULL, &mtd->oobinfo, 0xff);
-}
+	return nand_read_ecc (mtd, from, len, retlen, buf, NULL, NULL);
+}			   
 
 
 /**
- * nand_read_ecc - [MTD Interface] MTD compability function for nand_do_read_ecc
+ * nand_read_ecc - [MTD Interface] Read data with ECC
  * @mtd:	MTD device structure
  * @from:	offset to read from
  * @len:	number of bytes to read
@@ -1082,39 +1047,11 @@
  * @oob_buf:	filesystem supplied oob data buffer
  * @oobsel:	oob selection structure
  *
- * This function simply calls nand_do_read_ecc with flags = 0xff
+ * NAND read with ECC
  */
 static int nand_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
 			  size_t * retlen, u_char * buf, u_char * oob_buf, struct nand_oobinfo *oobsel)
 {
-	/* use userspace supplied oobinfo, if zero */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-	return nand_do_read_ecc(mtd, from, len, retlen, buf, oob_buf, oobsel, 0xff);
-}
-
-
-/**
- * nand_do_read_ecc - [MTD Interface] Read data with ECC
- * @mtd:	MTD device structure
- * @from:	offset to read from
- * @len:	number of bytes to read
- * @retlen:	pointer to variable to store the number of read bytes
- * @buf:	the databuffer to put data
- * @oob_buf:	filesystem supplied oob data buffer (can be NULL)
- * @oobsel:	oob selection structure
- * @flags:	flag to indicate if nand_get_device/nand_release_device should be preformed
- *		and how many corrected error bits are acceptable:
- *		  bits 0..7 - number of tolerable errors
- *		  bit  8    - 0 == do not get/release chip, 1 == get/release chip
- *
- * NAND read with ECC
- */
-int nand_do_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
-			     size_t * retlen, u_char * buf, u_char * oob_buf,
-			     struct nand_oobinfo *oobsel, int flags)
-{
-
 	int i, j, col, realpage, page, end, ecc, chipnr, sndcmd = 1;
 	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
 	struct nand_chip *this = mtd->priv;
@@ -1128,7 +1065,6 @@
 	int	compareecc = 1;
 	int	oobreadlen;
 
-
 	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_ecc: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
@@ -1139,14 +1075,17 @@
 	}
 
 	/* Grab the lock and see if the device is available */
-	if (flags & NAND_GET_DEVICE)
-		nand_get_device (this, mtd, FL_READING);
+	nand_get_device (this, mtd ,FL_READING);
 
+	/* use userspace supplied oobinfo, if zero */
+	if (oobsel == NULL)
+		oobsel = &mtd->oobinfo;
+	
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 		oobsel = this->autooob;
-
-	eccmode = oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
+		
+	eccmode = NAND_ECC_NONE;//oobsel->useecc ? this->eccmode : NAND_ECC_NONE;
 	oob_config = oobsel->eccpos;
 
 	/* Select the NAND device */
@@ -1163,28 +1102,28 @@
 	end = mtd->oobblock;
 	ecc = this->eccsize;
 	eccbytes = this->eccbytes;
-
+	
 	if ((eccmode == NAND_ECC_NONE) || (this->options & NAND_HWECC_SYNDROME))
 		compareecc = 0;
 
 	oobreadlen = mtd->oobsize;
-	if (this->options & NAND_HWECC_SYNDROME)
+	if (this->options & NAND_HWECC_SYNDROME) 
 		oobreadlen -= oobsel->eccbytes;
 
 	/* Loop until all data read */
 	while (read < len) {
-
+		
 		int aligned = (!col && (len - read) >= end);
-		/*
+		/* 
 		 * If the read is not page aligned, we have to read into data buffer
 		 * due to ecc, else we read into return buffer direct
 		 */
 		if (aligned)
 			data_poi = &buf[read];
-		else
+		else 
 			data_poi = this->data_buf;
-
-		/* Check, if we have this page in the buffer
+		
+		/* Check, if we have this page in the buffer 
 		 *
 		 * FIXME: Make it work when we must provide oob data too,
 		 * check the usage of data_buf oob field
@@ -1200,31 +1139,32 @@
 		if (sndcmd) {
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0x00, page);
 			sndcmd = 0;
-		}
+		}	
 
 		/* get oob area, if we have no oob buffer from fs-driver */
-		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE ||
-			oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
+		if (!oob_buf || oobsel->useecc == MTD_NANDECC_AUTOPLACE)
 			oob_data = &this->data_buf[end];
 
 		eccsteps = this->eccsteps;
-
+		
+		udelay(100);
+		
 		switch (eccmode) {
 		case NAND_ECC_NONE: {	/* No ECC, Read in a page */
 			static unsigned long lastwhinge = 0;
 			if ((lastwhinge / HZ) != (jiffies / HZ)) {
-				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
+//				printk (KERN_WARNING "Reading data from NAND FLASH without ECC is not recommended\n");
 				lastwhinge = jiffies;
 			}
 			this->read_buf(mtd, data_poi, end);
 			break;
 		}
-
+			
 		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
 			this->read_buf(mtd, data_poi, end);
-			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc)
+			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=3, datidx += ecc) 
 				this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-			break;
+			break;	
 
 		default:
 			for (i = 0, datidx = 0; eccsteps; eccsteps--, i+=eccbytes, datidx += ecc) {
@@ -1241,17 +1181,16 @@
 					/* We calc error correction directly, it checks the hw
 					 * generator for an error, reads back the syndrome and
 					 * does the error correction on the fly */
-					ecc_status = this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]);
-					if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
-						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: "
+					if (this->correct_data(mtd, &data_poi[datidx], &oob_data[i], &ecc_code[i]) == -1) {
+						DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " 
 							"Failed ECC read, page 0x%08x on chip %d\n", page, chipnr);
 						ecc_failed++;
 					}
 				} else {
 					this->calculate_ecc(mtd, &data_poi[datidx], &ecc_calc[i]);
-				}
+				}	
 			}
-			break;
+			break;						
 		}
 
 		/* read oobdata */
@@ -1259,8 +1198,8 @@
 
 		/* Skip ECC check, if not requested (ECC_NONE or HW_ECC with syndromes) */
 		if (!compareecc)
-			goto readoob;
-
+			goto readoob;	
+		
 		/* Pick the ECC bytes out of the oob data */
 		for (j = 0; j < oobsel->eccbytes; j++)
 			ecc_code[j] = oob_data[oob_config[j]];
@@ -1268,24 +1207,24 @@
 		/* correct data, if neccecary */
 		for (i = 0, j = 0, datidx = 0; i < this->eccsteps; i++, datidx += ecc) {
 			ecc_status = this->correct_data(mtd, &data_poi[datidx], &ecc_code[j], &ecc_calc[j]);
-
+			
 			/* Get next chunk of ecc bytes */
 			j += eccbytes;
-
-			/* Check, if we have a fs supplied oob-buffer,
+			
+			/* Check, if we have a fs supplied oob-buffer, 
 			 * This is the legacy mode. Used by YAFFS1
 			 * Should go away some day
 			 */
-			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) {
+			if (oob_buf && oobsel->useecc == MTD_NANDECC_PLACE) { 
 				int *p = (int *)(&oob_data[mtd->oobsize]);
 				p[i] = ecc_status;
 			}
-
-			if ((ecc_status == -1) || (ecc_status > (flags && 0xff))) {
+			
+			if (ecc_status == -1) {	
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_read_ecc: " "Failed ECC read, page 0x%08x\n", page);
 				ecc_failed++;
 			}
-		}
+		}		
 
 	readoob:
 		/* check, if we have a fs supplied oob-buffer */
@@ -1293,14 +1232,14 @@
 			/* without autoplace. Legacy mode used by YAFFS1 */
 			switch(oobsel->useecc) {
 			case MTD_NANDECC_AUTOPLACE:
-			case MTD_NANDECC_AUTOPL_USR:
 				/* Walk through the autoplace chunks */
-				for (i = 0; oobsel->oobfree[i][1]; i++) {
+				for (i = 0, j = 0; j < mtd->oobavail; i++) {
 					int from = oobsel->oobfree[i][0];
 					int num = oobsel->oobfree[i][1];
 					memcpy(&oob_buf[oob], &oob_data[from], num);
-					oob += num;
+					j+= num;
 				}
+				oob += mtd->oobavail;
 				break;
 			case MTD_NANDECC_PLACE:
 				/* YAFFS1 legacy mode */
@@ -1311,25 +1250,25 @@
 		}
 	readdata:
 		/* Partial page read, transfer data into fs buffer */
-		if (!aligned) {
+		if (!aligned) { 
 			for (j = col; j < end && read < len; j++)
 				buf[read++] = data_poi[j];
-			this->pagebuf = realpage;
-		} else
+			this->pagebuf = realpage;	
+		} else		
 			read += mtd->oobblock;
 
-		/* Apply delay or wait for ready/busy pin
+		/* Apply delay or wait for ready/busy pin 
 		 * Do this before the AUTOINCR check, so no problems
 		 * arise if a chip which does auto increment
 		 * is marked as NOAUTOINCR by the board driver.
 		*/
-		if (!this->dev_ready)
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
-
+			while (!this->dev_ready(mtd));	
+			
 		if (read == len)
-			break;
+			break;	
 
 		/* For subsequent reads align to page boundary. */
 		col = 0;
@@ -1343,16 +1282,15 @@
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
 		}
-		/* Check, if the chip supports auto page increment
-		 * or if we have hit a block boundary.
-		*/
+		/* Check, if the chip supports auto page increment 
+		 * or if we have hit a block boundary. 
+		*/ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
-			sndcmd = 1;
+			sndcmd = 1;				
 	}
 
 	/* Deselect and wake up anyone waiting on the device */
-	if (flags & NAND_GET_DEVICE)
-		nand_release_device(mtd);
+	nand_release_device(mtd);
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -1384,7 +1322,7 @@
 	/* Shift to get page */
 	page = (int)(from >> this->page_shift);
 	chipnr = (int)(from >> this->chip_shift);
-
+	
 	/* Mask to get column */
 	col = from & (mtd->oobsize - 1);
 
@@ -1406,17 +1344,33 @@
 
 	/* Send the read command */
 	this->cmdfunc (mtd, NAND_CMD_READOOB, col, page & this->pagemask);
-	/*
+	/* 
 	 * Read the data, if we read more than one page
 	 * oob data, let the device transfer the data !
 	 */
+	 
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_read_oob: col=%d page=%d,page&mask=%d\n",
+			col, page,page & this->pagemask);
+		
 	i = 0;
 	while (i < len) {
+
 		int thislen = mtd->oobsize - col;
 		thislen = min_t(int, thislen, len);
 		this->read_buf(mtd, &buf[i], thislen);
 		i += thislen;
 
+/*!!!*/		udelay(100);		
+		/* Apply delay or wait for ready/busy pin 
+		 * Do this before the AUTOINCR check, so no problems
+		 * arise if a chip which does auto increment
+		 * is marked as NOAUTOINCR by the board driver.
+		*/
+		if (!this->dev_ready) 
+			udelay (this->chip_delay);
+		else
+			while (!this->dev_ready(mtd));	
+
 		/* Read more ? */
 		if (i < len) {
 			page++;
@@ -1428,20 +1382,10 @@
 				this->select_chip(mtd, -1);
 				this->select_chip(mtd, chipnr);
 			}
-
-			/* Apply delay or wait for ready/busy pin
-			 * Do this before the AUTOINCR check, so no problems
-			 * arise if a chip which does auto increment
-			 * is marked as NOAUTOINCR by the board driver.
-			 */
-			if (!this->dev_ready)
-				udelay (this->chip_delay);
-			else
-				nand_wait_ready(mtd);
-
-			/* Check, if the chip supports auto page increment
-			 * or if we have hit a block boundary.
-			*/
+				
+			/* Check, if the chip supports auto page increment 
+			 * or if we have hit a block boundary. 
+			*/ 
 			if (!NAND_CANAUTOINCR(this) || !(page & blockcheck)) {
 				/* For subsequent page reads set offset to 0 */
 			        this->cmdfunc (mtd, NAND_CMD_READOOB, 0x0, page & this->pagemask);
@@ -1487,27 +1431,27 @@
 	nand_get_device (this, mtd , FL_READING);
 
 	this->select_chip (mtd, chip);
-
+	
 	/* Add requested oob length */
 	len += ooblen;
-
+	
 	while (len) {
 		if (sndcmd)
 			this->cmdfunc (mtd, NAND_CMD_READ0, 0, page & this->pagemask);
-		sndcmd = 0;
+		sndcmd = 0;	
 
 		this->read_buf (mtd, &buf[cnt], pagesize);
 
 		len -= pagesize;
 		cnt += pagesize;
 		page++;
-
-		if (!this->dev_ready)
+		
+		if (!this->dev_ready) 
 			udelay (this->chip_delay);
 		else
-			nand_wait_ready(mtd);
-
-		/* Check, if the chip supports auto page increment */
+			while (!this->dev_ready(mtd));	
+			
+		/* Check, if the chip supports auto page increment */ 
 		if (!NAND_CANAUTOINCR(this) || !(page & blockcheck))
 			sndcmd = 1;
 	}
@@ -1518,8 +1462,8 @@
 }
 
 
-/**
- * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer
+/** 
+ * nand_prepare_oobbuf - [GENERIC] Prepare the out of band buffer 
  * @mtd:	MTD device structure
  * @fsbuf:	buffer given by fs driver
  * @oobsel:	out of band selection structre
@@ -1548,20 +1492,20 @@
 	int i, len, ofs;
 
 	/* Zero copy fs supplied buffer */
-	if (fsbuf && !autoplace)
+	if (fsbuf && !autoplace) 
 		return fsbuf;
 
 	/* Check, if the buffer must be filled with ff again */
-	if (this->oobdirty) {
-		memset (this->oob_buf, 0xff,
+	if (this->oobdirty) {	
+		memset (this->oob_buf, 0xff, 
 			mtd->oobsize << (this->phys_erase_shift - this->page_shift));
 		this->oobdirty = 0;
-	}
-
+	}	
+	
 	/* If we have no autoplacement or no fs buffer use the internal one */
 	if (!autoplace || !fsbuf)
 		return this->oob_buf;
-
+	
 	/* Walk through the pages and place the data */
 	this->oobdirty = 1;
 	ofs = 0;
@@ -1595,7 +1539,7 @@
 {
 	return (nand_write_ecc (mtd, to, len, retlen, buf, NULL, NULL));
 }
-
+			   
 /**
  * nand_write_ecc - [MTD Interface] NAND write with ECC
  * @mtd:	MTD device structure
@@ -1617,7 +1561,7 @@
 	u_char *oobbuf, *bufstart;
 	int	ppblock = (1 << (this->phys_erase_shift - this->page_shift));
 
-	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	DEBUG (MTD_DEBUG_LEVEL3, "nand_write_ecc: to = 0x%08x, len = %i, oobsel=%d\n", (unsigned int) to, (int) len, oobsel);
 
 	/* Initialize retlen, in case of early exit */
 	*retlen = 0;
@@ -1628,7 +1572,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1647,24 +1591,22 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
-
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
+		
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+	}	
 
 	/* Setup variables and oob buffer */
 	totalpages = len >> this->page_shift;
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))
+	if (page <= this->pagebuf && this->pagebuf < (page + totalpages))  
 		this->pagebuf = -1;
-
+	
 	/* Set it relative to chip */
 	page &= this->pagemask;
 	startpage = page;
@@ -1686,14 +1628,14 @@
 		if (ret) {
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: write_page failed %d\n", ret);
 			goto out;
-		}
+		}	
 		/* Next oob page */
 		oob += mtd->oobsize;
 		/* Update written bytes count */
 		written += mtd->oobblock;
-		if (written == len)
+		if (written == len) 
 			goto cmp;
-
+		
 		/* Increment page address */
 		page++;
 
@@ -1704,13 +1646,13 @@
 		if (!(page & (ppblock - 1))){
 			int ofs;
 			this->data_poi = bufstart;
-			ret = nand_verify_pages (mtd, this, startpage,
+			ret = nand_verify_pages (mtd, this, startpage, 
 				page - startpage,
 				oobbuf, oobsel, chipnr, (eccbuf != NULL));
 			if (ret) {
 				DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 				goto out;
-			}
+			}	
 			*retlen = written;
 
 			ofs = autoplace ? mtd->oobavail : mtd->oobsize;
@@ -1720,9 +1662,8 @@
 			numpages = min (totalpages, ppblock);
 			page &= this->pagemask;
 			startpage = page;
-			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel,
+			oobbuf = nand_prepare_oobbuf (mtd, eccbuf, oobsel, 
 					autoplace, numpages);
-			oob = 0;
 			/* Check, if we cross a chip boundary */
 			if (!page) {
 				chipnr++;
@@ -1738,7 +1679,7 @@
 		oobbuf, oobsel, chipnr, (eccbuf != NULL));
 	if (!ret)
 		*retlen = written;
-	else
+	else	
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_ecc: verify_pages failed %d\n", ret);
 
 out:
@@ -1798,7 +1739,7 @@
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd))
 		goto out;
-
+	
 	/* Invalidate the page cache, if we write to the cached page */
 	if (page == this->pagebuf)
 		this->pagebuf = -1;
@@ -1824,7 +1765,7 @@
 	status = this->waitfunc (mtd, this, FL_WRITING);
 
 	/* See if device thinks it succeeded */
-	if (status & NAND_STATUS_FAIL) {
+	if (status & 0x01) {
 		DEBUG (MTD_DEBUG_LEVEL0, "nand_write_oob: " "Failed write, page 0x%08x\n", page);
 		ret = -EIO;
 		goto out;
@@ -1861,10 +1802,10 @@
  *
  * NAND write with kvec. This just calls the ecc function
  */
-static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+static int nand_writev (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen)
 {
-	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));
+	return (nand_writev_ecc (mtd, vecs, count, to, retlen, NULL, NULL));	
 }
 
 /**
@@ -1879,7 +1820,7 @@
  *
  * NAND write with iovec with ecc
  */
-static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count,
+static int nand_writev_ecc (struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, 
 		loff_t to, size_t * retlen, u_char *eccbuf, struct nand_oobinfo *oobsel)
 {
 	int i, page, len, total_len, ret = -EIO, written = 0, chipnr;
@@ -1905,7 +1846,7 @@
 		return -EINVAL;
 	}
 
-	/* reject writes, which are not page aligned */
+	/* reject writes, which are not page aligned */	
 	if (NOTALIGNED (to) || NOTALIGNED(total_len)) {
 		printk (KERN_NOTICE "nand_write_ecc: Attempt to write not page aligned data\n");
 		return -EINVAL;
@@ -1924,21 +1865,19 @@
 		goto out;
 
 	/* if oobsel is NULL, use chip defaults */
-	if (oobsel == NULL)
-		oobsel = &mtd->oobinfo;
+	if (oobsel == NULL) 
+		oobsel = &mtd->oobinfo;		
 
 	/* Autoplace of oob data ? Use the default placement scheme */
 	if (oobsel->useecc == MTD_NANDECC_AUTOPLACE) {
 		oobsel = this->autooob;
 		autoplace = 1;
-	}
-	if (oobsel->useecc == MTD_NANDECC_AUTOPL_USR)
-		autoplace = 1;
+	}	
 
 	/* Setup start page */
 	page = (int) (to >> this->page_shift);
 	/* Invalidate the page cache, if we write to the cached page */
-	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))
+	if (page <= this->pagebuf && this->pagebuf < ((to + total_len) >> this->page_shift))  
 		this->pagebuf = -1;
 
 	startpage = page & this->pagemask;
@@ -1962,10 +1901,10 @@
 			oob = 0;
 			for (i = 1; i <= numpages; i++) {
 				/* Write one page. If this is the last page to write
-				 * then use the real pageprogram command, else select
+				 * then use the real pageprogram command, else select 
 				 * cached programming if supported by the chip.
 				 */
-				ret = nand_write_page (mtd, this, page & this->pagemask,
+				ret = nand_write_page (mtd, this, page & this->pagemask, 
 					&oobbuf[oob], oobsel, i != numpages);
 				if (ret)
 					goto out;
@@ -1981,12 +1920,12 @@
 				count--;
 			}
 		} else {
-			/* We must use the internal buffer, read data out of each
+			/* We must use the internal buffer, read data out of each 
 			 * tuple until we have a full page to write
 			 */
 			int cnt = 0;
 			while (cnt < mtd->oobblock) {
-				if (vecs->iov_base != NULL && vecs->iov_len)
+				if (vecs->iov_base != NULL && vecs->iov_len) 
 					this->data_buf[cnt++] = ((u_char *) vecs->iov_base)[len++];
 				/* Check, if we have to switch to the next tuple */
 				if (len >= (int) vecs->iov_len) {
@@ -1995,10 +1934,10 @@
 					count--;
 				}
 			}
-			this->pagebuf = page;
-			this->data_poi = this->data_buf;
+			this->pagebuf = page;	
+			this->data_poi = this->data_buf;	
 			bufstart = this->data_poi;
-			numpages = 1;
+			numpages = 1;		
 			oobbuf = nand_prepare_oobbuf (mtd, NULL, oobsel, autoplace, numpages);
 			ret = nand_write_page (mtd, this, page & this->pagemask,
 				oobbuf, oobsel, 0);
@@ -2011,7 +1950,7 @@
 		ret = nand_verify_pages (mtd, this, startpage, numpages, oobbuf, oobsel, chipnr, 0);
 		if (ret)
 			goto out;
-
+			
 		written += mtd->oobblock * numpages;
 		/* All done ? */
 		if (!count)
@@ -2077,10 +2016,9 @@
  */
 static int nand_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
-	return nand_erase_nand (mtd, instr, 0);
+	return nand_erase_nand (mtd, instr, 1);
 }
-
-#define BBT_PAGE_MASK	0xffffff3f
+ 
 /**
  * nand_erase_intern - [NAND Interface] erase block(s)
  * @mtd:	MTD device structure
@@ -2093,13 +2031,8 @@
 {
 	int page, len, status, pages_per_block, ret, chipnr;
 	struct nand_chip *this = mtd->priv;
-	int rewrite_bbt[NAND_MAX_CHIPS]={0};	/* flags to indicate the page, if bbt needs to be rewritten. */
-	unsigned int bbt_masked_page;		/* bbt mask to compare to page being erased. */
-						/* It is used to see if the current page is in the same */
-						/*   256 block group and the same bank as the bbt. */
 
-	DEBUG (MTD_DEBUG_LEVEL3,
-	       "nand_erase: start = 0x%08x, len = %i\n", (unsigned int) instr->addr, (unsigned int) instr->len);
+	DEBUG (MTD_DEBUG_LEVEL3,"nand_erase: start = 0x%08x, len = %i allowbbt=%d page_shift=%d\n", (unsigned int) instr->addr, (unsigned int) instr->len,allowbbt,this->page_shift);
 
 	/* Start address must align on block boundary */
 	if (instr->addr & ((1 << this->phys_erase_shift) - 1)) {
@@ -2142,13 +2075,6 @@
 		goto erase_exit;
 	}
 
-	/* if BBT requires refresh, set the BBT page mask to see if the BBT should be rewritten */
-	if (this->options & BBT_AUTO_REFRESH) {
-		bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
-	} else {
-		bbt_masked_page = 0xffffffff;	/* should not match anything */
-	}
-
 	/* Loop through the pages */
 	len = instr->len;
 
@@ -2156,42 +2082,31 @@
 
 	while (len) {
 		/* Check if we have a bad block, we do not erase bad blocks ! */
-		if (nand_block_checkbad(mtd, ((loff_t) page) << this->page_shift, 0, allowbbt)) {
+		//if (nand_block_checkbad(mtd, ((loff_t) page) >> this->page_shift, 0, allowbbt)) {
+		if (nand_block_checkbad(mtd, ((loff_t) page*mtd->oobblock) , 0, allowbbt)) {
 			printk (KERN_WARNING "nand_erase: attempt to erase a bad block at page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
 		}
-
-		/* Invalidate the page cache, if we erase the block which contains
+		
+		/* Invalidate the page cache, if we erase the block which contains 
 		   the current cached page */
 		if (page <= this->pagebuf && this->pagebuf < (page + pages_per_block))
 			this->pagebuf = -1;
 
 		this->erase_cmd (mtd, page & this->pagemask);
-
+		
 		status = this->waitfunc (mtd, this, FL_ERASING);
 
-		/* See if operation failed and additional status checks are available */
-		if ((status & NAND_STATUS_FAIL) && (this->errstat)) {
-			status = this->errstat(mtd, this, FL_ERASING, status, page);
-		}
-
 		/* See if block erase succeeded */
-		if (status & NAND_STATUS_FAIL) {
+		if (status & 0x01) {
+			printk (KERN_WARNING  "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			DEBUG (MTD_DEBUG_LEVEL0, "nand_erase: " "Failed erase, page 0x%08x\n", page);
 			instr->state = MTD_ERASE_FAILED;
 			instr->fail_addr = (page << this->page_shift);
 			goto erase_exit;
 		}
-
-		/* if BBT requires refresh, set the BBT rewrite flag to the page being erased */
-		if (this->options & BBT_AUTO_REFRESH) {
-			if (((page & BBT_PAGE_MASK) == bbt_masked_page) &&
-			     (page != this->bbt_td->pages[chipnr])) {
-				rewrite_bbt[chipnr] = (page << this->page_shift);
-			}
-		}
-
+		
 		/* Increment page address and decrement length */
 		len -= (1 << this->phys_erase_shift);
 		page += pages_per_block;
@@ -2201,13 +2116,6 @@
 			chipnr++;
 			this->select_chip(mtd, -1);
 			this->select_chip(mtd, chipnr);
-
-			/* if BBT requires refresh and BBT-PERCHIP,
-			 *   set the BBT page mask to see if this BBT should be rewritten */
-			if ((this->options & BBT_AUTO_REFRESH) && (this->bbt_td->options & NAND_BBT_PERCHIP)) {
-				bbt_masked_page = this->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
-			}
-
 		}
 	}
 	instr->state = MTD_ERASE_DONE;
@@ -2222,18 +2130,6 @@
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
-	/* if BBT requires refresh and erase was successful, rewrite any selected bad block tables */
-	if ((this->options & BBT_AUTO_REFRESH) && (!ret)) {
-		for (chipnr = 0; chipnr < this->numchips; chipnr++) {
-			if (rewrite_bbt[chipnr]) {
-				/* update the BBT for chip */
-				DEBUG (MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt (%d:0x%0x 0x%0x)\n",
-					chipnr, rewrite_bbt[chipnr], this->bbt_td->pages[chipnr]);
-				nand_update_bbt (mtd, rewrite_bbt[chipnr]);
-			}
-		}
-	}
-
 	/* Return more or less happy */
 	return ret;
 }
@@ -2265,10 +2161,10 @@
 static int nand_block_isbad (struct mtd_info *mtd, loff_t ofs)
 {
 	/* Check for invalid offset */
-	if (ofs > mtd->size)
+	if (ofs > mtd->size) 
 		return -EINVAL;
-
-	return nand_block_checkbad (mtd, ofs, 1, 0);
+	
+	return nand_block_checkbad (mtd, ofs, 1, 1);
 }
 
 /**
@@ -2292,34 +2188,6 @@
 }
 
 /**
- * nand_suspend - [MTD Interface] Suspend the NAND flash
- * @mtd:	MTD device structure
- */
-static int nand_suspend(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-
-	return nand_get_device (this, mtd, FL_PM_SUSPENDED);
-}
-
-/**
- * nand_resume - [MTD Interface] Resume the NAND flash
- * @mtd:	MTD device structure
- */
-static void nand_resume(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-
-	if (this->state == FL_PM_SUSPENDED)
-		nand_release_device(mtd);
-	else
-		printk(KERN_ERR "resume() called for the chip which is not "
-				"in suspended state\n");
-
-}
-
-
-/**
  * nand_scan - [NAND Interface] Scan for the NAND device
  * @mtd:	MTD device structure
  * @maxchips:	Number of chips to scan for
@@ -2333,7 +2201,7 @@
  */
 int nand_scan (struct mtd_info *mtd, int maxchips)
 {
-	int i, nand_maf_id, nand_dev_id, busw, maf_id;
+	int i, j, nand_maf_id, nand_dev_id, busw;
 	struct nand_chip *this = mtd->priv;
 
 	/* Get buswidth to select the correct functions*/
@@ -2386,13 +2254,13 @@
 
 	/* Print and store flash device information */
 	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
-
-		if (nand_dev_id != nand_flash_ids[i].id)
+				
+		if (nand_dev_id != nand_flash_ids[i].id) 
 			continue;
 
 		if (!mtd->name) mtd->name = nand_flash_ids[i].name;
 		this->chipsize = nand_flash_ids[i].chipsize << 20;
-
+		
 		/* New devices have all the information in additional id bytes */
 		if (!nand_flash_ids[i].pagesize) {
 			int extid;
@@ -2404,14 +2272,14 @@
 			mtd->oobblock = 1024 << (extid & 0x3);
 			extid >>= 2;
 			/* Calc oobsize */
-			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->oobblock >> 9);
+			mtd->oobsize = (8 << (extid & 0x03)) * (mtd->oobblock / 512);
 			extid >>= 2;
 			/* Calc blocksize. Blocksize is multiples of 64KiB */
 			mtd->erasesize = (64 * 1024)  << (extid & 0x03);
 			extid >>= 2;
 			/* Get buswidth information */
 			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
-
+		
 		} else {
 			/* Old devices have this data hardcoded in the
 			 * device id table */
@@ -2421,33 +2289,27 @@
 			busw = nand_flash_ids[i].options & NAND_BUSWIDTH_16;
 		}
 
-		/* Try to identify manufacturer */
-		for (maf_id = 0; nand_manuf_ids[maf_id].id != 0x0; maf_id++) {
-			if (nand_manuf_ids[maf_id].id == nand_maf_id)
-				break;
-		}
-
 		/* Check, if buswidth is correct. Hardware drivers should set
 		 * this correct ! */
 		if (busw != (this->options & NAND_BUSWIDTH_16)) {
 			printk (KERN_INFO "NAND device: Manufacturer ID:"
-				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-				nand_manuf_ids[maf_id].name , mtd->name);
-			printk (KERN_WARNING
-				"NAND bus width %d instead %d bit\n",
+				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+				nand_manuf_ids[i].name , mtd->name);
+			printk (KERN_WARNING 
+				"NAND bus width %d instead %d bit\n", 
 					(this->options & NAND_BUSWIDTH_16) ? 16 : 8,
 					busw ? 16 : 8);
 			this->select_chip(mtd, -1);
-			return 1;
+			return 1;	
 		}
-
-		/* Calculate the address shift from the page size */
+		
+		/* Calculate the address shift from the page size */	
 		this->page_shift = ffs(mtd->oobblock) - 1;
 		this->bbt_erase_shift = this->phys_erase_shift = ffs(mtd->erasesize) - 1;
 		this->chip_shift = ffs(this->chipsize) - 1;
 
 		/* Set the bad block position */
-		this->badblockpos = mtd->oobblock > 512 ?
+		this->badblockpos = mtd->oobblock > 512 ? 
 			NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
 
 		/* Get chip options, preserve non chip based options */
@@ -2457,10 +2319,10 @@
 		this->options |= NAND_NO_AUTOINCR;
 		/* Check if this is a not a samsung device. Do not clear the options
 		 * for chips which are not having an extended id.
-		 */
+		 */	
 		if (nand_maf_id != NAND_MFR_SAMSUNG && !nand_flash_ids[i].pagesize)
 			this->options &= ~NAND_SAMSUNG_LP_OPTIONS;
-
+		
 		/* Check for AND chips with 4 page planes */
 		if (this->options & NAND_4PAGE_ARRAY)
 			this->erase_cmd = multi_erase_cmd;
@@ -2470,10 +2332,15 @@
 		/* Do not replace user supplied command function ! */
 		if (mtd->oobblock > 512 && this->cmdfunc == nand_command)
 			this->cmdfunc = nand_command_lp;
-
+				
+		/* Try to identify manufacturer */
+		for (j = 0; nand_manuf_ids[j].id != 0x0; j++) {
+			if (nand_manuf_ids[j].id == nand_maf_id)
+				break;
+		}
 		printk (KERN_INFO "NAND device: Manufacturer ID:"
-			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id,
-			nand_manuf_ids[maf_id].name , nand_flash_ids[i].name);
+			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", nand_maf_id, nand_dev_id, 
+			nand_manuf_ids[j].name , nand_flash_ids[i].name);
 		break;
 	}
 
@@ -2496,7 +2363,7 @@
 	}
 	if (i > 1)
 		printk(KERN_INFO "%d NAND chips detected\n", i);
-
+	
 	/* Allocate buffers, if neccecary */
 	if (!this->oob_buf) {
 		size_t len;
@@ -2508,7 +2375,7 @@
 		}
 		this->options |= NAND_OOBBUF_ALLOC;
 	}
-
+	
 	if (!this->data_buf) {
 		size_t len;
 		len = mtd->oobblock + mtd->oobsize;
@@ -2535,7 +2402,7 @@
 	if (!this->autooob) {
 		/* Select the appropriate default oob placement scheme for
 		 * placement agnostic filesystems */
-		switch (mtd->oobsize) {
+		switch (mtd->oobsize) { 
 		case 8:
 			this->autooob = &nand_oob_8;
 			break;
@@ -2551,19 +2418,22 @@
 			BUG();
 		}
 	}
-
+	
 	/* The number of bytes available for the filesystem to place fs dependend
 	 * oob data */
-	mtd->oobavail = 0;
-	for (i = 0; this->autooob->oobfree[i][1]; i++)
-		mtd->oobavail += this->autooob->oobfree[i][1];
+	if (this->options & NAND_BUSWIDTH_16) {
+		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 2);
+		if (this->autooob->eccbytes & 0x01)
+			mtd->oobavail--;
+	} else
+		mtd->oobavail = mtd->oobsize - (this->autooob->eccbytes + 1);
 
-	/*
+	/* 
 	 * check ECC mode, default to software
 	 * if 3byte/512byte hardware ECC is selected and we have 256 byte pagesize
-	 * fallback to software ECC
+	 * fallback to software ECC 
 	*/
-	this->eccsize = 256;	/* set default eccsize */
+	this->eccsize = 256;	/* set default eccsize */	
 	this->eccbytes = 3;
 
 	switch (this->eccmode) {
@@ -2578,56 +2448,56 @@
 			this->eccsize = 2048;
 		break;
 
-	case NAND_ECC_HW3_512:
-	case NAND_ECC_HW6_512:
-	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW3_512: 
+	case NAND_ECC_HW6_512: 
+	case NAND_ECC_HW8_512: 
 		if (mtd->oobblock == 256) {
 			printk (KERN_WARNING "512 byte HW ECC not possible on 256 Byte pagesize, fallback to SW ECC \n");
 			this->eccmode = NAND_ECC_SOFT;
 			this->calculate_ecc = nand_calculate_ecc;
 			this->correct_data = nand_correct_data;
-		} else
+		} else 
 			this->eccsize = 512; /* set eccsize to 512 */
 		break;
-
+			
 	case NAND_ECC_HW3_256:
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		printk (KERN_WARNING "NAND_ECC_NONE selected by board driver. This is not recommended !!\n");
 		this->eccmode = NAND_ECC_NONE;
 		break;
 
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->calculate_ecc = nand_calculate_ecc;
 		this->correct_data = nand_correct_data;
 		break;
 
 	default:
 		printk (KERN_WARNING "Invalid NAND_ECC_MODE %d\n", this->eccmode);
-		BUG();
-	}
+		BUG();	
+	}	
 
-	/* Check hardware ecc function availability and adjust number of ecc bytes per
+	/* Check hardware ecc function availability and adjust number of ecc bytes per 
 	 * calculation step
 	*/
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
 		this->eccbytes += 4;
-	case NAND_ECC_HW8_512:
+	case NAND_ECC_HW8_512: 
 		this->eccbytes += 2;
-	case NAND_ECC_HW6_512:
+	case NAND_ECC_HW6_512: 
 		this->eccbytes += 3;
-	case NAND_ECC_HW3_512:
+	case NAND_ECC_HW3_512: 
 	case NAND_ECC_HW3_256:
 		if (this->calculate_ecc && this->correct_data && this->enable_hwecc)
 			break;
 		printk (KERN_WARNING "No ECC functions supplied, Hardware ECC not possible\n");
-		BUG();
+		BUG();	
 	}
-
+		
 	mtd->eccsize = this->eccsize;
-
+	
 	/* Set the number of read / write steps for one page to ensure ECC generation */
 	switch (this->eccmode) {
 	case NAND_ECC_HW12_2048:
@@ -2639,15 +2509,15 @@
 		this->eccsteps = mtd->oobblock / 512;
 		break;
 	case NAND_ECC_HW3_256:
-	case NAND_ECC_SOFT:
+	case NAND_ECC_SOFT:	
 		this->eccsteps = mtd->oobblock / 256;
 		break;
-
-	case NAND_ECC_NONE:
+		
+	case NAND_ECC_NONE: 
 		this->eccsteps = 1;
 		break;
 	}
-
+	
 	/* Initialize state, waitqueue and spinlock */
 	this->state = FL_READY;
 	init_waitqueue_head (&this->wq);
@@ -2678,8 +2548,8 @@
 	mtd->sync = nand_sync;
 	mtd->lock = NULL;
 	mtd->unlock = NULL;
-	mtd->suspend = nand_suspend;
-	mtd->resume = nand_resume;
+	mtd->suspend = NULL;
+	mtd->resume = NULL;
 	mtd->block_isbad = nand_block_isbad;
 	mtd->block_markbad = nand_block_markbad;
 
@@ -2688,16 +2558,16 @@
 
 	mtd->owner = THIS_MODULE;
 
-	/* Check, if we should skip the bad block table scan */
-	if (this->options & NAND_SKIP_BBTSCAN)
-		return 0;
-
 	/* Build bad block table */
-	return this->scan_bbt (mtd);
+	int ret=this->scan_bbt (mtd);
+//	DEBUG (MTD_DEBUG_LEVEL3,
+//	       "nand_scan_bbt: ret=%x",ret);
+	
+	return 0;
 }
 
 /**
- * nand_release - [NAND Interface] Free resources held by the NAND device
+ * nand_release - [NAND Interface] Free resources held by the NAND device 
  * @mtd:	MTD device structure
 */
 void nand_release (struct mtd_info *mtd)
@@ -2711,8 +2581,9 @@
 	/* Deregister the device */
 	del_mtd_device (mtd);
 
-	/* Free bad block table memory */
-	kfree (this->bbt);
+	/* Free bad block table memory, if allocated */
+	if (this->bbt)
+		kfree (this->bbt);
 	/* Buffer allocated by nand_scan ? */
 	if (this->options & NAND_OOBBUF_ALLOC)
 		kfree (this->oob_buf);
@@ -2721,8 +2592,8 @@
 		kfree (this->data_buf);
 }
 
-EXPORT_SYMBOL_GPL (nand_scan);
-EXPORT_SYMBOL_GPL (nand_release);
+EXPORT_SYMBOL (nand_scan);
+EXPORT_SYMBOL (nand_release);
 
 MODULE_LICENSE ("GPL");
 MODULE_AUTHOR ("Steven J. Hill <sjhill@realitydiluted.com>, Thomas Gleixner <tglx@linutronix.de>");
diff -Naur linux-2.6.16/drivers/mtd/nand/nand_bbt.c linux-2.6.16-new/drivers/mtd/nand/nand_bbt.c
--- linux-2.6.16/drivers/mtd/nand/nand_bbt.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/mtd/nand/nand_bbt.c	2007-05-08 19:05:17.000000000 +0700
@@ -981,7 +981,8 @@
 };
 
 static struct nand_bbt_descr smallpage_flashbased = {
-	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	//.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
+	.options = NAND_BBT_SCANALLPAGES,
 	.offs = 5,
 	.len = 1,
 	.pattern = scan_ff_pattern
@@ -1095,8 +1096,8 @@
 
 	/* Get block number * 2 */
 	block = (int) (offs >> (this->bbt_erase_shift - 1));
+	//block = (int) offs;
 	res = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
-
 	DEBUG (MTD_DEBUG_LEVEL2, "nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",
 		(unsigned int)offs, block >> 1, res);
 
diff -Naur linux-2.6.16/drivers/pci/setup-bus.c linux-2.6.16-new/drivers/pci/setup-bus.c
--- linux-2.6.16/drivers/pci/setup-bus.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/pci/setup-bus.c	2007-05-10 10:27:23.000000000 +0700
@@ -41,7 +41,9 @@
  * have a P2P bridge below a cardbus bridge, we need 4K.
  */
 #define CARDBUS_IO_SIZE		(256)
-#define CARDBUS_MEM_SIZE	(32*1024*1024)
+//#define CARDBUS_MEM_SIZE     (32*1024*1024)
+#define CARDBUS_MEM_SIZE       (64*1024)
+
 
 static void __devinit
 pbus_assign_resources_sorted(struct pci_bus *bus)
diff -Naur linux-2.6.16/drivers/pcmcia/yenta_socket.c linux-2.6.16-new/drivers/pcmcia/yenta_socket.c
--- linux-2.6.16/drivers/pcmcia/yenta_socket.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/drivers/pcmcia/yenta_socket.c	2007-05-10 10:27:23.000000000 +0700
@@ -27,11 +27,12 @@
 #include "yenta_socket.h"
 #include "i82365.h"
 
-static int disable_clkrun;
+static int disable_clkrun=1;
+/*
 module_param(disable_clkrun, bool, 0444);
 MODULE_PARM_DESC(disable_clkrun, "If PC card doesn't function properly, please try this option");
-
-static int isa_probe = 1;
+*/
+static int isa_probe = 0;
 module_param(isa_probe, bool, 0444);
 MODULE_PARM_DESC(isa_probe, "If set ISA interrupts are probed (default). Set to N to disable probing");
 
@@ -895,6 +896,7 @@
 	u8 csc;
         u32 cb_event;
 
+printk(KERN_NOTICE"%s:\n",__FUNCTION__);
 	/* Clear interrupt status for the event */
 	cb_event = cb_readl(socket, CB_SOCKET_EVENT);
 	cb_writel(socket, CB_SOCKET_EVENT, -1);
diff -Naur linux-2.6.16/drivers/serial/adm5120_uart.c linux-2.6.16-new/drivers/serial/adm5120_uart.c
--- linux-2.6.16/drivers/serial/adm5120_uart.c	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/drivers/serial/adm5120_uart.c	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,523 @@
+/*
+ *	Serial driver for ADM5120 SoC
+ *
+ *	Derived from drivers/serial/uart00.c
+ *	Copyright 2001 Altera Corporation
+ *
+ *	Some pieces are derived from the ADMtek 2.4 serial driver.
+ *	Copyright (C) ADMtek Incorporated, 2003
+ *		daniell@admtek.com.tw
+ *	Which again was derived from drivers/char/serial.c
+ *	Copyright (C) Linus Torvalds et al.
+ *
+ *	Copyright Jeroen Vreeken (pe1rxq@amsat.org), 2005
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/console.h>
+
+#define ADM5120_UART_BASE0		0x12600000
+#define ADM5120_UART_BASE1		0x12800000
+#define ADM5120_UART_SIZE		0x20
+
+#define ADM5120_UART_IRQ0		1
+#define ADM5120_UART_IRQ1		2
+
+#define ADM5120_UART_REG(base, reg) \
+	(*(volatile u32 *)KSEG1ADDR((base)+(reg)))
+
+#define ADM5120_UART_BAUDDIV(rate)	((u32)((62500000/(8*(rate))+1)/2-1))
+#define ADM5120_UART_BAUD115200		ADM5120_UART_BAUDDIV(115200)
+
+#define ADM5120_UART_DATA		0x00
+#define ADM5120_UART_RS			0x04
+#define ADM5120_UART_LCR_H		0x08
+#define ADM5120_UART_LCR_M		0x0c
+#define ADM5120_UART_LCR_L		0x10
+#define ADM5120_UART_CR			0x14
+#define ADM5120_UART_FR			0x18
+#define ADM5120_UART_IR			0x1c
+
+#define ADM5120_UART_FE			0x01
+#define ADM5120_UART_PE			0x02
+#define ADM5120_UART_BE			0x04
+#define ADM5120_UART_OE			0x08
+#define ADM5120_UART_ERR		0x0f
+#define ADM5120_UART_FIFO_EN		0x10
+#define ADM5120_UART_EN			0x01
+#define ADM5120_UART_TIE		0x20
+#define ADM5120_UART_RIE		0x50
+#define ADM5120_UART_IE			0x78
+#define ADM5120_UART_CTS		0x01
+#define ADM5120_UART_DSR		0x02
+#define ADM5120_UART_DCD		0x04
+#define ADM5120_UART_TXFF		0x20
+#define ADM5120_UART_TXFE		0x80
+#define ADM5120_UART_RXFE		0x10
+#define ADM5120_UART_BRK		0x01
+#define ADM5120_UART_PEN		0x02
+#define ADM5120_UART_EPS		0x04
+#define ADM5120_UART_STP2		0x08
+#define ADM5120_UART_W5			0x00
+#define ADM5120_UART_W6			0x20
+#define ADM5120_UART_W7			0x40
+#define ADM5120_UART_W8			0x60
+#define ADM5120_UART_MIS		0x01
+#define ADM5120_UART_RIS		0x02
+#define ADM5120_UART_TIS		0x04
+#define ADM5120_UART_RTIS		0x08
+
+static void adm5120ser_stop_tx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_TIE;
+}
+
+static void adm5120ser_irq_rx(struct uart_port *port, struct pt_regs *regs)
+{
+	struct tty_struct *tty = port->info->tty;
+	unsigned int status, ch, rds, flg, ignored = 0;
+
+	status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	while (!(status & ADM5120_UART_RXFE)) {
+		/* 
+		 * We need to read rds before reading the 
+		 * character from the fifo
+		 */
+		rds = ADM5120_UART_REG(port->iobase, ADM5120_UART_RS);
+		ch = ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA);
+		port->icount.rx++;
+
+/*
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+*/
+		flg = TTY_NORMAL;
+
+		/*
+		 * Note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (rds & ADM5120_UART_ERR)
+			goto handle_error;
+		if (uart_handle_sysrq_char(port, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		tty_insert_flip_char(tty, ch, flg);
+
+	ignore_char:
+		status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	}
+ out:
+	tty_flip_buffer_push(tty);
+	return;
+
+ handle_error:
+ 	ADM5120_UART_REG(port->iobase, ADM5120_UART_RS) = 0xff;
+	if (rds & ADM5120_UART_BE) {
+		port->icount.brk++;
+		if (uart_handle_break(port))
+			goto ignore_char;
+	} else if (rds & ADM5120_UART_PE)
+		port->icount.parity++;
+	else if (rds & ADM5120_UART_FE)
+		port->icount.frame++;
+	if (rds & ADM5120_UART_OE)
+		port->icount.overrun++;
+
+	if (rds & port->ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+	rds &= port->read_status_mask;
+
+	if (rds & ADM5120_UART_BE)
+		flg = TTY_BREAK;
+	else if (rds & ADM5120_UART_PE)
+		flg = TTY_PARITY;
+	else if (rds & ADM5120_UART_FE)
+		flg = TTY_FRAME;
+
+	if (rds & ADM5120_UART_OE) {
+		/*
+		 * CHECK: does overrun affect the current character?
+		 * ASSUMPTION: it does not.
+		 */
+		tty_insert_flip_char(tty, ch, flg);
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef CONFIG_MAGIC_SYSRQ
+	port->sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void adm5120ser_irq_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->info->xmit;
+	int count;
+
+	if (port->x_char) {
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA) =
+		    port->x_char;
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
+		adm5120ser_stop_tx(port);
+		return;
+	}
+
+	count = port->fifosize >> 1;
+	do {
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_DATA) =
+		    xmit->buf[xmit->tail];
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	if (uart_circ_empty(xmit))
+		adm5120ser_stop_tx(port);
+}
+
+static void adm5120ser_irq_modem(struct uart_port *port)
+{
+	unsigned int status;
+
+	status = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+
+	if (status & ADM5120_UART_DCD)
+		uart_handle_dcd_change(port, status & ADM5120_UART_DCD);
+
+	if (status & ADM5120_UART_DSR)
+		port->icount.dsr++;
+
+	if (status & ADM5120_UART_CTS)
+		uart_handle_cts_change(port, status & ADM5120_UART_CTS);
+
+	wake_up_interruptible(&port->info->delta_msr_wait);
+}
+
+static irqreturn_t adm5120ser_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct uart_port *port = dev_id;
+	unsigned long ir = ADM5120_UART_REG(port->iobase, ADM5120_UART_IR);
+
+	if (ir & (ADM5120_UART_RIS | ADM5120_UART_RTIS))
+		adm5120ser_irq_rx(port, regs);
+	if (ir & ADM5120_UART_TIS)
+		adm5120ser_irq_tx(port);
+	if (ir & ADM5120_UART_MIS) {
+		adm5120ser_irq_modem(port);
+		ADM5120_UART_REG(port->iobase, ADM5120_UART_IR) = 0xff;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int adm5120ser_tx_empty(struct uart_port *port)
+{
+	unsigned int fr = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+	return (fr & ADM5120_UART_TXFE) ? TIOCSER_TEMT : 0;
+}
+
+static void adm5120ser_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+}
+
+static unsigned int adm5120ser_get_mctrl(struct uart_port *port)
+{
+	unsigned int result = 0;
+	unsigned int fr = ADM5120_UART_REG(port->iobase, ADM5120_UART_FR);
+
+	if (fr & ADM5120_UART_CTS)
+		result |= TIOCM_CTS;
+	if (fr & ADM5120_UART_DSR)
+		result |= TIOCM_DSR;
+	if (fr & ADM5120_UART_DCD)
+		result |= TIOCM_CAR;
+	return result;
+}
+
+static void adm5120ser_start_tx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) |= ADM5120_UART_TIE;
+}
+
+static void adm5120ser_stop_rx(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_RIE;
+}
+
+static void adm5120ser_enable_ms(struct uart_port *port)
+{
+}
+
+static void adm5120ser_break_ctl(struct uart_port *port, int break_state)
+{
+	unsigned long flags;
+	unsigned long lcrh;
+
+	spin_lock_irqsave(&port->lock, flags);
+	lcrh = ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H);
+	if (break_state == -1)
+		lcrh |= ADM5120_UART_BRK;
+	else
+		lcrh &= ~ADM5120_UART_BRK;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) = lcrh;
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static int adm5120ser_startup(struct uart_port *port)
+{
+	int ret;
+	ret = request_irq(port->irq, adm5120ser_irq, 0, "ADM5120 UART", port);
+	if (ret) {
+		printk(KERN_ERR "Couldn't get irq %d\n", port->irq);
+		return ret;
+	}
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) |=
+	    ADM5120_UART_FIFO_EN;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) |=
+	    ADM5120_UART_EN | ADM5120_UART_IE;
+	return 0;
+}
+
+static void adm5120ser_shutdown(struct uart_port *port)
+{
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_CR) &= ~ADM5120_UART_IE;
+	free_irq(port->irq, port);
+}
+
+static void adm5120ser_set_termios(struct uart_port *port,
+    struct termios *termios, struct termios *old)
+{
+	unsigned int baud, quot, lcrh;
+	unsigned long flags;
+
+	termios->c_cflag |= CREAD;
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	lcrh = ADM5120_UART_FIFO_EN;
+	switch (termios->c_cflag & CSIZE) {
+		case CS5:
+			lcrh |= ADM5120_UART_W5;
+			break;
+		case CS6:
+			lcrh |= ADM5120_UART_W6;
+			break;
+		case CS7:
+			lcrh |= ADM5120_UART_W7;
+			break;
+		default:
+			lcrh |= ADM5120_UART_W8;
+			break;
+	}
+	if (termios->c_cflag & CSTOPB)
+		lcrh |= ADM5120_UART_STP2;
+	if (termios->c_cflag & PARENB) {
+		lcrh |= ADM5120_UART_PEN;
+		if (!(termios->c_cflag & PARODD))
+			lcrh |= ADM5120_UART_EPS;
+	}
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_H) = lcrh;
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	port->read_status_mask = ADM5120_UART_OE;
+	if (termios->c_iflag & INPCK)
+		port->read_status_mask |= ADM5120_UART_FE | ADM5120_UART_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		port->read_status_mask |= ADM5120_UART_BE;
+
+	/*
+	 * Characters to ignore
+	 */
+	port->ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		port->ignore_status_mask |= ADM5120_UART_FE | ADM5120_UART_PE;
+	if (termios->c_iflag & IGNBRK) {
+		port->ignore_status_mask |= ADM5120_UART_BE;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns to (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			port->ignore_status_mask |= ADM5120_UART_OE;
+	}
+
+	quot = ADM5120_UART_BAUD115200;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_L) = quot & 0xff;
+	ADM5120_UART_REG(port->iobase, ADM5120_UART_LCR_M) = quot >> 8;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *adm5120ser_type(struct uart_port *port)
+{
+	return port->type == PORT_ADM5120 ? "ADM5120" : NULL;
+}
+
+static void adm5120ser_config_port(struct uart_port *port, int flags)
+{
+	if (flags & UART_CONFIG_TYPE)
+		port->type = PORT_ADM5120;
+}
+
+static void adm5120ser_release_port(struct uart_port *port)
+{
+	release_mem_region(port->iobase, ADM5120_UART_SIZE);
+}
+
+static int adm5120ser_request_port(struct uart_port *port)
+{
+	return request_mem_region(port->iobase, ADM5120_UART_SIZE,
+	    "adm5120-uart") != NULL ? 0 : -EBUSY; 
+}
+
+static struct uart_ops adm5120ser_ops = {
+	.tx_empty =	adm5120ser_tx_empty,
+	.set_mctrl =	adm5120ser_set_mctrl,
+	.get_mctrl =	adm5120ser_get_mctrl,
+	.stop_tx =	adm5120ser_stop_tx,
+	.start_tx =	adm5120ser_start_tx,
+	.stop_rx =	adm5120ser_stop_rx,
+	.enable_ms =	adm5120ser_enable_ms,
+	.break_ctl =	adm5120ser_break_ctl,
+	.startup =	adm5120ser_startup,
+	.shutdown =	adm5120ser_shutdown,
+	.set_termios =	adm5120ser_set_termios,
+	.type =		adm5120ser_type,
+	.config_port =	adm5120ser_config_port,
+	.release_port =	adm5120ser_release_port,
+	.request_port =	adm5120ser_request_port,
+};
+
+static void adm5120console_put(const char c)
+{
+	while ((ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_FR) &
+	     ADM5120_UART_TXFF) != 0);
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_DATA) = c;
+}
+
+static void adm5120console_write(struct console *con, const char *s,
+    unsigned int count)
+{
+	while (count--) {
+		if (*s == '\n')
+			adm5120console_put('\r');
+		adm5120console_put(*s);
+		s++;
+	}
+}
+
+static int __init adm5120console_setup(struct console *con, char *options)
+{
+	/* Set to 115200 baud, 8N1 and enable FIFO */
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_L) =
+	    ADM5120_UART_BAUD115200 & 0xff;
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_M) =
+	    ADM5120_UART_BAUD115200 >> 8;
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_LCR_H) =
+	    ADM5120_UART_W8 | ADM5120_UART_FIFO_EN;
+	/* Enable port */
+	ADM5120_UART_REG(ADM5120_UART_BASE0, ADM5120_UART_CR) =
+	    ADM5120_UART_EN;
+
+	return 0;
+}
+
+static struct uart_driver adm5120ser_reg;
+
+static struct console adm5120_serconsole = {
+	.name =		"ttyS",
+	.write =	adm5120console_write,
+	.device =	uart_console_device,
+	.setup =	adm5120console_setup,
+	.flags =	CON_PRINTBUFFER,
+	.cflag =	B115200 | CS8 | CREAD,
+	.index =	0,
+	.data =		&adm5120ser_reg,
+};
+
+static int __init adm5120console_init(void)
+{
+	register_console(&adm5120_serconsole);
+	return 0;
+}
+
+console_initcall(adm5120console_init);
+
+#define CONFIG_ADM5120_NR_UARTS 1
+static struct uart_port adm5120ser_ports[] = {
+	{
+		.iobase =	ADM5120_UART_BASE0,
+		.irq =		ADM5120_UART_IRQ0,
+		.uartclk =	62500000,
+		.fifosize =	16,
+		.ops =		&adm5120ser_ops,
+		.line =		0,
+		.flags =	ASYNC_BOOT_AUTOCONF,
+	},
+#if (CONFIG_ADM5120_NR_UARTS > 1)
+	{
+		.iobase =	ADM5120_UART_BASE1,
+		.irq =		ADM5120_UART_IRQ1,
+		.uartclk =	62500000,
+		.fifosize =	16,
+		.ops =		&adm5120ser_ops,
+		.line =		1,
+		.flags =	ASYNC_BOOT_AUTOCONF,
+	},
+#endif
+};
+
+static struct uart_driver adm5120ser_reg = {
+	.owner	=	THIS_MODULE,
+	.driver_name =	"ttyS",
+	.dev_name =	"ttyS",
+	.devfs_name =	"ttyS",	
+	.major =	TTY_MAJOR,
+	.minor =	64,
+	.nr =		CONFIG_ADM5120_NR_UARTS,
+	.cons =		&adm5120_serconsole,
+};
+
+static int __init adm5120ser_init(void)
+{
+	int ret, i;
+
+	ret = uart_register_driver(&adm5120ser_reg);
+	if (!ret) {
+		for (i = 0; i < CONFIG_ADM5120_NR_UARTS; i++)
+			uart_add_one_port(&adm5120ser_reg, &adm5120ser_ports[i]);
+	}
+
+	return ret;
+}
+
+__initcall(adm5120ser_init);
diff -Naur linux-2.6.16/drivers/serial/Kconfig linux-2.6.16-new/drivers/serial/Kconfig
--- linux-2.6.16/drivers/serial/Kconfig	2007-05-10 12:09:04.000000000 +0700
+++ linux-2.6.16-new/drivers/serial/Kconfig	2007-05-10 10:27:23.000000000 +0700
@@ -225,6 +225,22 @@
 	  to this option.  The driver can handle 1 or 2 serial ports.
 	  If unsure, say N.
 
+config SERIAL_ADM5120
+       bool "ADM5120 serial port support"
+       depends on MIPS_ADM5120
+       select SERIAL_CORE
+       select SERIAL_CORE_CONSOLE
+       help
+         Driver for the on chip UARTs on the ADM5120 SoC
+
+config ADM5120_NR_UARTS
+       int "Maximum number of ADM5120 serial ports"
+       depends on SERIAL_ADM5120
+       default "2"
+       ---help---
+         Set this to the number of serial ports you want the driver to
+         support.
+
 comment "Non-8250 serial port support"
 
 config SERIAL_AMBA_PL010
diff -Naur linux-2.6.16/drivers/serial/Makefile linux-2.6.16-new/drivers/serial/Makefile
--- linux-2.6.16/drivers/serial/Makefile	2007-05-10 12:09:04.000000000 +0700
+++ linux-2.6.16-new/drivers/serial/Makefile	2007-05-10 10:27:23.000000000 +0700
@@ -11,7 +11,8 @@
 serial-8250-$(CONFIG_PCI) += 8250_pci.o
 serial-8250-$(CONFIG_HP300) += 8250_hp300.o
 
-obj-$(CONFIG_SERIAL_CORE) += serial_core.o
+obj-y += serial_core.o
+#$(CONFIG_SERIAL_CORE) += serial_core.o
 obj-$(CONFIG_SERIAL_21285) += 21285.o
 obj-$(CONFIG_SERIAL_8250) += 8250.o $(serial-8250-y)
 obj-$(CONFIG_SERIAL_8250_CS) += serial_cs.o
@@ -23,6 +24,8 @@
 obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
 obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
 obj-$(CONFIG_SERIAL_8250_AU1X00) += 8250_au1x00.o
+obj-y += adm5120_uart.o
+#$(CONFIG_SERIAL_ADM5120) += adm5120_uart.o
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
diff -Naur linux-2.6.16/drivers/video/Kconfig linux-2.6.16-new/drivers/video/Kconfig
--- linux-2.6.16/drivers/video/Kconfig	2007-05-10 12:09:04.000000000 +0700
+++ linux-2.6.16-new/drivers/video/Kconfig	2007-05-10 10:27:23.000000000 +0700
@@ -1233,8 +1233,6 @@
 	  various panels and CRTs by passing in kernel cmd line option
 	  au1200fb:panel=<name>.
 
-source "drivers/video/geode/Kconfig"
-
 config FB_FFB
 	bool "Creator/Creator3D/Elite3D support"
 	depends on FB_SBUS && SPARC64
diff -Naur linux-2.6.16/fs/jffs2/scan.c linux-2.6.16-new/fs/jffs2/scan.c
--- linux-2.6.16/fs/jffs2/scan.c	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/fs/jffs2/scan.c	2007-06-04 16:25:06.000000000 +0700
@@ -424,7 +424,7 @@
 	/* Now ofs is a complete physical flash offset as it always was... */
 	ofs += jeb->offset;
 
-	noise = 10;
+	noise = 0;
 
 	dbg_summary("no summary found in jeb 0x%08x. Apply original scan.\n",jeb->offset);
 
diff -Naur linux-2.6.16/include/asm-mips/am5120/adm5120.h linux-2.6.16-new/include/asm-mips/am5120/adm5120.h
--- linux-2.6.16/include/asm-mips/am5120/adm5120.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/asm-mips/am5120/adm5120.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,1083 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/adm5120.h
+;	 Date    : 2003.3.10
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __ADM5120_H__
+#define  __ADM5120_H__
+
+
+#include <asm/addrspace.h>
+
+
+/*=========================  Physical Memory Map  ============================*/
+#define SDRAM_BASE				0
+#define SMEM1_BASE				0x10000000
+
+#define EXTIO0_BASE				0x10C00000
+#define EXTIO1_BASE				0x10E00000
+#define MPMC_BASE				0x11000000
+#define USBHOST_BASE				0x11200000
+#define PCIMEM_BASE				0x11400000
+#define PCIIO_BASE				0x11500000
+#define PCICFG_BASE				0x115FFFF0
+#define MIPS_BASE				0x11A00000
+#define SWCTRL_BASE				0x12000000
+
+#define INTC_BASE				0x12200000
+#define SYSC_BASE				0x12400000
+
+#define UART0_BASE				0x12600000
+#define UART1_BASE				0x12800000
+
+#define SMEM0_BASE				0x1FC00000
+
+
+/*=======================  MIPS interrupt  ===================*/
+#define MIPSINT_SOFT0				0
+#define MIPSINT_SOFT1				1
+#define MIPSINT_IRQ				2
+#define MIPSINT_FIQ				3
+#define MIPSINT_REV0				4
+#define MIPSINT_REV1				5
+#define MIPSINT_REV2				6
+#define MIPSINT_TIMER				7
+
+
+
+/*====================  MultiPort Memory Controller (MPMC) ==================*/
+/* registers offset */
+#define MPMC_CONTROL_REG			0x0000
+#define MPMC_STATUS_REG				0x0004
+#define MPMC_CONFIG_REG				0x0008
+
+#define MPMC_DM_CONTROL_REG			0x0020
+#define MPMC_DM_REFRESH_REG			0x0024
+
+#define MPMC_DM_TRP_REG				0x0030
+#define MPMC_DM_TRAS_REG			0x0034
+#define MPMC_DM_TSREX_REG			0x0038
+#define MPMC_DM_TAPR_REG			0x003C
+#define MPMC_DM_TDAL_REG			0x0040
+#define MPMC_DM_TWR_REG				0x0044
+#define MPMC_DM_TRC_REG				0x0048
+#define MPMC_DM_TRFC_REG			0x004C
+#define MPMC_DM_TXSR_REG			0x0050
+#define MPMC_DM_TRRD_REG			0x0054
+#define MPMC_DM_TMRD_REG			0x0058
+
+#define MPMC_SM_EXTWAIT_REG			0x0080
+
+#define MPMC_DM_CONFIG0_REG			0x0100
+#define MPMC_DM_RASCAS0_REG			0x0104
+
+#define MPMC_DM_CONFIG1_REG			0x0120
+#define MPMC_DM_RASCAS1_REG			0x0124
+
+#define MPMC_SM_CONFIG0_REG			0x0200
+#define MPMC_SM_WAITWEN0_REG			0x0204
+#define MPMC_SM_WAITOEN0_REG			0x0208
+#define MPMC_SM_WAITRD0_REG			0x020C
+#define MPMC_SM_WAITPAGE0_REG			0x0210
+#define MPMC_SM_WAITWR0_REG			0x0214
+#define MPMC_SM_WAITTURN0_REG			0x0218
+
+#define MPMC_SM_CONFIG1_REG			0x0220
+#define MPMC_SM_WAITWEN1_REG			0x0224
+#define MPMC_SM_WAITOEN1_REG			0x0228
+#define MPMC_SM_WAITRD1_REG			0x022C
+#define MPMC_SM_WAITPAGE1_REG			0x0230
+#define MPMC_SM_WAITWR1_REG			0x0234
+#define MPMC_SM_WAITTURN1_REG			0x0238
+
+#define MPMC_SM_CONFIG2_REG			0x0240
+#define MPMC_SM_WAITWEN2_REG			0x0244
+#define MPMC_SM_WAITOEN2_REG			0x0248
+#define MPMC_SM_WAITRD2_REG			0x024C
+#define MPMC_SM_WAITPAGE2_REG			0x0250
+#define MPMC_SM_WAITWR2_REG			0x0254
+#define MPMC_SM_WAITTURN2_REG			0x0258
+
+#define MPMC_SM_CONFIG3_REG			0x0260
+#define MPMC_SM_WAITWEN3_REG			0x0264
+#define MPMC_SM_WAITOEN3_REG			0x0268
+#define MPMC_SM_WAITRD3_REG			0x026C
+#define MPMC_SM_WAITPAGE3_REG			0x0270
+#define MPMC_SM_WAITWR3_REG			0x0274
+#define MPMC_SM_WAITTURN3_REG			0x0278
+
+/* Macro for access MPMC register */
+#define MPMC_REG(_offset)				\
+		(*((volatile unsigned long *)(KSEG1ADDR(MPMC_BASE + (_offset)))))
+
+
+/* MPMC_CONTROL_REG (offset: 0x0000) */
+#define MPMC_DRAIN_W_BUF			0x00000008
+#define MPMC_LOW_POWER_MODE			0x00000004
+#define MPMC_ADDR_MIRROR			0x00000002
+#define MPMC_ENABLE				0x00000001
+#define MPMC_CONTROL_MASK			0x0000000f
+
+/* MPMC_STATUS_REG (offset: 0x0004) */
+#define MPMC_SREFACK				0x00000004
+#define MPMC_WBUF_DIRTY				0x00000002
+#define MPMC_BUSY				0x00000001
+#define MPMC_STATUS_MASK			0x00000007
+
+/* MPMC_CONFIG_REG (offset: 0x0008) */
+#define MPMC_CLK_RATIO_1_1			0x00000000
+#define MPMC_CLK_RATIO_1_2			0x00000100
+#define MPMC_LITTLE_ENDIAN			0x00000000
+#define MPMC_BIG_ENDIAN				0x00000001
+#define MPMC_CONFIG_MASK			0x00000101
+
+/* MPMC_DM_CONTROL_REG (offset: 0x0020) */
+#define DM_PVHHOUT_HI_VOLTAGE			0x00008000
+#define DM_RPOUT_HI_VOLTAGE			0x00004000
+#define DM_DEEP_SLEEP_MODE			0x00002000
+
+#define DM_SDRAM_NOP				0x00000180
+#define DM_SDRAM_PRECHARGE_ALL			0x00000100
+#define DM_SDRAM_MODE_SETTING			0x00000080
+#define DM_SDRAM_NORMAL_OP			0x00000000
+#define DM_SDRAM_OPMODE_MASK			0x00000180
+
+#define DM_SELF_REFRESH_MODE			0x00000004
+#define DM_CLKOUT_ALWAYS			0x00000002
+#define DM_CLKEN_ALWAYS				0x00000001
+
+#define MPMC_DM_CONTROL_MASK			0x0000e187
+
+
+/* MPMC_DM_REFRESH_REG (offset:0x0024) */
+#define MPMC_DM_REFRESH_MASK			0x00000300
+
+/* MPMC_DM_TRP_REG (offset: 0x0030) */
+#define MPMC_DM_TRP_MASK			0x0000000f
+
+/* MPMC_DM_TRAS_REG (offset: 0x0034) */
+#define MPMC_DM_TRAS_MASK			0x0000000f
+
+/* MPMC_DM_TSREX_REG (offset: 0x0038) */
+#define MPMC_DM_TSREX_MASK			0x0000000f
+
+/* MPMC_DM_TAPR_REG	(offset: 0x003C) */
+#define MPMC_DM_TAPR_MASK			0x0000000f
+
+/* MPMC_DM_TDAL_REG	(offset: 0x0040) */
+#define MPMC_DM_TDAL_MASK			0x0000000f
+
+/* MPMC_DM_TWR_REG (offset: 0x0044) */
+#define MPMC_DM_TWR_MASK			0x0000000f
+
+/* MPMC_DM_TRC_REG (offset: 0x0048) */
+#define MPMC_DM_TRC_MASK 			0x0000001f
+
+/* MPMC_DM_TRFC_REG (offset: 0x004C) */
+#define MPMC_DM_TRFC_MASK			0x0000001f
+
+/* MPMC_DM_TXSR_REG	(offset: 0x0050) */
+#define MPMC_DM_TXSR_MASK			0x0000001f
+
+/* MPMC_DM_TRRD_REG	(offset: 0x0054) */
+#define MPMC_DM_TRRD_MASK			0x0000000f
+
+/* MPMC_DM_TMRD_REG	(offset: 0x0058) */
+#define MPMC_DM_TMRD_MASK			0x0000000f
+
+/* MPMC_SM_EXTWAIT_REG (offset:	0x0080) */
+#define MPMC_SM_EXTWAIT_MASK			0x0000003f
+
+
+/* MPMC_DM_CONFIG0_REG (offset: 0x0100) */
+/* MPMC_DM_CONFIG1_REG (offset: 0x0120) */
+#define DM_CFG_ROW_WIDTH_13BIT			0x20000000
+#define DM_CFG_ROW_WIDTH_12BIT			0x10000000
+#define DM_CFG_ROW_WIDTH_11BIT			0x00000000
+#define DM_CFG_ROW_WIDTH_MASK			0x30000000
+#define DM_CFG_ROW_WIDTH_SHIFT			28
+
+#define DM_CFG_2BANK_DEV			0x00000000
+#define DM_CFG_4BANK_DEV			0x04000000
+#define DM_CFG_BANK_SHIFT			26
+
+#define DM_CFG_COL_WIDTH_11BIT			0x01400000
+#define DM_CFG_COL_WIDTH_10BIT			0x01000000
+#define DM_CFG_COL_WIDTH_9BIT			0x00c00000
+#define DM_CFG_COL_WIDTH_8BIT			0x00800000
+#define DM_CFG_COL_WIDTH_7BIT			0x00400000
+#define DM_CFG_COL_WIDTH_6BIT			0x00000000
+#define DM_CFG_COL_WIDTH_MASK			0x01c00000
+#define DM_CFG_COL_WIDTH_SHIFT			22
+
+#define DM_CFG_WRITE_PROTECT			0x00100000
+#define DM_CFG_BUFFER_EN			0x00080000
+
+#define DM_CFG_ADDR_MAPPING_MASK		0x00005F80
+
+#define DM_CFG_DEV_SYNC_FLASH			0x00000010
+#define DM_CFG_DEV_LOWPOWER_SDRAM		0x00000008
+#define DM_CFG_DEV_SDRAM			0x00000000
+#define DM_CFG_DEV_MASK				0x00000018
+
+
+/* MPMC_DM_RASCAS0_REG (offset: 0x0104) */
+/* MPMC_DM_RASCAS1_REG (offset: 0x0124) */
+
+#define DM_CAS_LATENCY_3			0x00000300
+#define DM_CAS_LATENCY_2			0x00000200
+#define DM_CAS_LATENCY_1			0x00000100
+
+#define DM_RAS_LATENCY_3			0x00000003
+#define DM_RAS_LATENCY_2			0x00000002
+#define DM_RAS_LATENCY_1			0x00000001
+
+
+/* MPMC_SM_CONFIG0_REG (offset: 0x0200) */
+/* MPMC_SM_CONFIG1_REG (offset: 0x0220) */
+/* MPMC_SM_CONFIG2_REG (offset: 0x0240) */
+/* MPMC_SM_CONFIG3_REG (offset: 0x0260) */
+
+#define SM_WRITE_PROTECT			0x00100000
+#define SM_WRITEBUF_ENABLE			0x00080000
+#define SM_EXTENDED_WAIT			0x00000100
+#define SM_PB					0x00000080
+#define SM_CS_HIGH				0x00000040
+#define SM_PAGE_MODE				0x00000008
+
+#define SM_MEM_WIDTH_32BIT			0x00000002
+#define SM_MEM_WIDTH_16BIT			0x00000001
+#define SM_MEM_WIDTH_8BIT			0x00000000
+
+#define MPMC_SM_CONFIG_MASK			0x001801cb
+
+
+/* MPMC_SM_WAITWEN0_REG	(offset: 0x0204) */
+/* MPMC_SM_WAITWEN1_REG	(offset: 0x0224) */
+/* MPMC_SM_WAITWEN2_REG	(offset: 0x0244) */
+/* MPMC_SM_WAITWEN3_REG	(offset: 0x0264) */
+#define MPMC_SM_WAITWEN_MASK			0x0000000f
+
+
+/* MPMC_SM_WAITOEN0_REG (offset: 0x0208) */
+/* MPMC_SM_WAITOEN1_REG (offset: 0x0228) */
+/* MPMC_SM_WAITOEN2_REG (offset: 0x0248) */
+/* MPMC_SM_WAITOEN3_REG (offset: 0x0268) */
+#define MPMC_SM_WAITOEN_MASK			0x0000000f
+
+/* MPMC_SM_WAITRD0_REG (offset: 0x020C) */
+/* MPMC_SM_WAITRD1_REG (offset: 0x022C) */
+/* MPMC_SM_WAITRD2_REG (offset: 0x024C) */
+/* MPMC_SM_WAITRD3_REG (offset: 0x026C) */
+#define MPMC_SM_WAITRD_MASK			0x0000001f
+
+/* MPMC_SM_WAITPAGE0_REG (offset: 0x0210) */
+/* MPMC_SM_WAITPAGE1_REG (offset: 0x0230) */
+/* MPMC_SM_WAITPAGE2_REG (offset: 0x0250) */
+/* MPMC_SM_WAITPAGE3_REG (offset: 0x0270) */
+#define MPMC_SM_WAITPAGE_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITWR0_REG (offset: 0x0214) */
+/* MPMC_SM_WAITWR1_REG (offset: 0x0234) */
+/* MPMC_SM_WAITWR2_REG (offset: 0x0254) */
+/* MPMC_SM_WAITWR3_REG (offset: 0x0274) */
+#define MPMC_SM_WAITWR_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITTURN0_REG (offset: 0x0218) */
+/* MPMC_SM_WAITTURN1_REG (offset: 0x0238) */
+/* MPMC_SM_WAITTURN2_REG (offset: 0x0258) */
+/* MPMC_SM_WAITTURN3_REG (offset: 0x0278) */
+#define MPMC_SM_WAITTURN_MASK			0x0000000f
+
+
+/* SDRAM mode register */
+/* ref: SDRAM data sheet. Ex: Micron MT48LC4M16A2 data sheet. */
+#define SDRAM_BTLEN_1				0x0000
+#define SDRAM_BTLEN_2				0x0001
+#define SDRAM_BTLEN_4				0x0002
+#define SDRAM_BTLEN_8				0x0003
+#define SDRAM_BTLEN_FULLPAGE			0x0007
+#define SDRAM_BTLEN_MASK			0x0007
+
+#define SDRAM_BT_SEQUENCIAL			0x0000
+#define SDRAM_BT_INTERLEVED			0x0008
+
+#define SDRAM_CAS_LATENCY_2			0x0020
+#define SDRAM_CAS_LATENCY_3			0x0030
+#define SDRAM_CAS_LATENCY_MASK			0x0030
+
+#define SDRAM_OPMODE_STANDARD			0x0000
+#define SDRAM_OPMODE_MASK			0x0180
+
+#define SDRAM_WBTMODE_ENABLE			0x0000
+#define SDRAM_WBTMODE_DISABLE			0x0200
+
+#define SDRAM_MODEREG_MASK			0x03FF
+
+
+
+/*==========================  Interrupt Controller  ==========================*/
+/* registers offset */
+#define IRQ_STATUS_REG				0x00	/* Read */
+#define IRQ_RAW_STATUS_REG			0x04	/* Read */
+#define IRQ_ENABLE_REG				0x08	/* Read/Write */
+#define IRQ_DISABLE_REG				0x0C	/* Write */
+#define IRQ_SOFT_REG				0x10	/* Write */
+
+#define IRQ_MODE_REG				0x14	/* Read/Write */
+#define FIQ_STATUS_REG				0x18	/* Read */
+
+/* test registers */
+#define IRQ_TESTSRC_REG				0x1c	/* Read/Write */
+#define IRQ_SRCSEL_REG				0x20	/* Read/Write */
+#define IRQ_LEVEL_REG				0x24	/* Read/Write */
+
+/*  Macro for accessing Interrupt controller register  */
+#define ADM5120_INTC_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(INTC_BASE + (_reg)))))
+
+/* interrupt levels */
+#define INT_LVL_TIMER				0	/* Timer */
+#define INT_LVL_UART0				1	/* Uart 0 */
+#define INT_LVL_UART1				2	/* Uart 1 */
+#define INT_LVL_USBHOST				3	/* USB Host */
+#define INT_LVL_EXTIO_0				4	/* External I/O 0 */
+#define INT_LVL_EXTIO_1				5	/* External I/O 1 */
+#define INT_LVL_PCI_0				6	/* PCI 0 */
+#define INT_LVL_PCI_1				7	/* PCI 1 */
+#define INT_LVL_PCI_2				8	/* PCI 2 */
+#define INT_LVL_SWITCH				9	/* Switch */
+#define INT_LVL_MAX				INT_LVL_SWITCH	
+
+/* interrupts */
+#define IRQ_TIMER				(0x1 << INT_LVL_TIMER)
+#define IRQ_UART0				(0x1 << INT_LVL_UART0)
+#define IRQ_UART1				(0x1 << INT_LVL_UART1)
+#define IRQ_USBHOST				(0x1 << INT_LVL_USBHOST)
+#define IRQ_EXTIO_0				(0x1 << INT_LVL_EXTIO_0)
+#define IRQ_EXTIO_1				(0x1 << INT_LVL_EXTIO_1)
+#define IRQ_PCI_INT0				(0x1 << INT_LVL_PCI_0)
+#define IRQ_PCI_INT1				(0x1 << INT_LVL_PCI_1)
+#define IRQ_PCI_INT2				(0x1 << INT_LVL_PCI_2)
+#define IRQ_SWITCH				(0x1 << INT_LVL_SWITCH)
+
+#define IRQ_MASK				0x3ff
+
+
+/* IRQ LEVEL reg */
+#define IRQ_EXTIO0_ACT_LOW			IRQ_EXTIO_0
+#define IRQ_EXTIO1_ACT_LOW			IRQ_EXTIO_1
+#define IRQ_PCIINT0_ACT_LOW			IRQ_PCI_INT0
+#define IRQ_PCIINT1_ACT_LOW			IRQ_PCI_INT1
+#define IRQ_PCIINT2_ACT_LOW			IRQ_PCI_INT2
+
+#define IRQ_LEVEL_MASK				0x01F0
+
+/*=========================  Switch Control Register  ========================*/
+/* Control Register */
+#define CODE_REG				0x0000
+#define SftRest_REG				0x0004
+#define Boot_done_REG				0x0008
+#define SWReset_REG				0x000C
+#define Global_St_REG				0x0010
+#define PHY_st_REG				0x0014
+#define Port_st_REG				0x0018
+#define Mem_control_REG				0x001C
+#define SW_conf_REG				0x0020
+#define CPUp_conf_REG				0x0024
+#define Port_conf0_REG				0x0028
+#define Port_conf1_REG				0x002C
+#define Port_conf2_REG				0x0030
+
+#define VLAN_G1_REG				0x0040
+#define VLAN_G2_REG				0x0044
+#define Send_trig_REG				0x0048
+#define Srch_cmd_REG				0x004C
+#define ADDR_st0_REG				0x0050
+#define ADDR_st1_REG				0x0054
+#define MAC_wt0_REG				0x0058
+#define MAC_wt1_REG				0x005C
+#define BW_cntl0_REG				0x0060
+#define BW_cntl1_REG				0x0064
+#define PHY_cntl0_REG				0x0068
+#define PHY_cntl1_REG				0x006C
+#define FC_th_REG				0x0070
+#define Adj_port_th_REG				0x0074
+#define Port_th_REG				0x0078
+#define PHY_cntl2_REG				0x007C
+#define PHY_cntl3_REG				0x0080
+#define Pri_cntl_REG				0x0084
+#define VLAN_pri_REG				0x0088
+#define TOS_en_REG				0x008C
+#define TOS_map0_REG				0x0090
+#define TOS_map1_REG				0x0094
+#define Custom_pri1_REG				0x0098
+#define Custom_pri2_REG				0x009C
+
+#define Empty_cnt_REG				0x00A4
+#define Port_cnt_sel_REG			0x00A8
+#define Port_cnt_REG				0x00AC
+#define SW_Int_st_REG				0x00B0
+#define SW_Int_mask_REG				0x00B4
+
+// GPIO config
+#define GPIO_conf0_REG				0x00B8
+#define GPIO_conf2_REG				0x00BC
+
+// Watch dog
+#define Watchdog0_REG				0x00C0
+#define Watchdog1_REG				0x00C4
+
+#define Swap_in_REG				0x00C8
+#define Swap_out_REG				0x00CC
+
+// Tx/Rx Descriptors
+#define Send_HBaddr_REG				0x00D0
+#define Send_LBaddr_REG				0x00D4
+#define Recv_HBaddr_REG				0x00D8
+#define Recv_LBaddr_REG				0x00DC
+#define Send_HWaddr_REG				0x00E0
+#define Send_LWaddr_REG				0x00E4
+#define Recv_HWaddr_REG				0x00E8
+#define Recv_LWaddr_REG				0x00EC
+
+// Timer Control 
+#define Timer_int_REG				0x00F0
+#define Timer_REG				0x00F4
+
+// LED control
+#define Port0_LED_REG				0x0100
+#define Port1_LED_REG				0x0104
+#define Port2_LED_REG				0x0108
+#define Port3_LED_REG				0x010c
+#define Port4_LED_REG				0x0110
+
+
+/* Macros for accessing Switch control register */
+#define ADM5120_SW_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(SWCTRL_BASE + (_reg)))))
+
+
+
+/* CODE_REG */
+#define CODE_ID_MASK				0x00FFFF
+#define CODE_ADM5120_ID				0x5120
+
+#define CODE_REV_MASK				0x0F0000
+#define CODE_REV_SHIFT				16
+#define CODE_REV_ADM5120_0			0x8
+
+#define CODE_CLK_MASK				0x300000
+#define CODE_CLK_SHIFT				20
+
+#define CPU_CLK_175MHZ				0x0
+#define CPU_CLK_200MHZ				0x1
+#define CPU_CLK_225MHZ				0x2
+#define CPU_CLK_250MHZ				0x3
+
+#define CPU_SPEED_175M				(175000000/2)
+#define CPU_SPEED_200M				(200000000/2)
+#define CPU_SPEED_225M				(225000000/2)
+#define CPU_SPEED_250M				(250000000/2)
+
+#define CPU_NAND_BOOT				0x01000000
+#define CPU_DCACHE_2K_WAY			(0x1 << 25)
+#define CPU_DCACHE_2WAY				(0x1 << 26)
+#define CPU_ICACHE_2K_WAY			(0x1 << 27)
+#define CPU_ICACHE_2WAY				(0x1 << 28)
+
+#define CPU_GMII_SUPPORT			0x20000000
+
+#define CPU_PQFP_MODE				(0x1 << 29)
+
+#define CPU_CACHE_LINE_SIZE			16
+
+/* SftRest_REG	*/
+#define SOFTWARE_RESET				0x1
+
+/* Boot_done_REG */
+#define BOOT_DONE				0x1
+
+/* SWReset_REG */
+#define SWITCH_RESET				0x1
+
+/* Global_St_REG */
+#define DATA_BUF_BIST_FAILED			(0x1 << 0)
+#define LINK_TAB_BIST_FAILED			(0x1 << 1)
+#define MC_TAB_BIST_FAILED			(0x1 << 2)
+#define ADDR_TAB_BIST_FAILED			(0x1 << 3)
+#define DCACHE_D_FAILED				(0x3 << 4)
+#define DCACHE_T_FAILED				(0x1 << 6)
+#define ICACHE_D_FAILED				(0x3 << 7)
+#define ICACHE_T_FAILED				(0x1 << 9)
+#define BIST_FAILED_MASK			0x03FF
+
+#define ALLMEM_TEST_DONE			(0x1 << 10)
+
+#define SKIP_BLK_CNT_MASK			0x1FF000
+#define SKIP_BLK_CNT_SHIFT			12
+
+
+/* PHY_st_REG */
+#define PORT_LINK_MASK				0x0000001F
+#define PORT_MII_LINKFAIL			0x00000020
+#define PORT_SPEED_MASK				0x00001F00
+
+#define PORT_GMII_SPD_MASK			0x00006000
+#define PORT_GMII_SPD_10M			0
+#define PORT_GMII_SPD_100M			0x00002000
+#define PORT_GMII_SPD_1000M			0x00004000
+
+#define PORT_DUPLEX_MASK			0x003F0000
+#define PORT_FLOWCTRL_MASK			0x1F000000
+
+#define PORT_GMII_FLOWCTRL_MASK			0x60000000
+#define PORT_GMII_FC_ON				0x20000000
+#define PORT_GMII_RXFC_ON			0x20000000
+#define PORT_GMII_TXFC_ON			0x40000000
+
+/* Port_st_REG */
+#define PORT_SECURE_ST_MASK			0x001F
+#define MII_PORT_TXC_ERR			0x0080
+
+/* Mem_control_REG */
+#define SDRAM_SIZE_4MBYTES			0x0001
+#define SDRAM_SIZE_8MBYTES			0x0002
+#define SDRAM_SIZE_16MBYTES			0x0003
+#define SDRAM_SIZE_64MBYTES			0x0004
+#define SDRAM_SIZE_128MBYTES			0x0005
+#define SDRAM_SIZE_MASK				0x0007
+
+#define MEMCNTL_SDRAM1_EN			(0x1 << 5)
+
+#define ROM_SIZE_DISABLE			0x0000
+#define ROM_SIZE_512KBYTES			0x0001
+#define ROM_SIZE_1MBYTES			0x0002
+#define	ROM_SIZE_2MBYTES			0x0003
+#define ROM_SIZE_4MBYTES			0x0004
+#define ROM_SIZE_8MBYTES			0x0005
+#define ROM_SIZE_MASK				0x0007
+
+#define ROM0_SIZE_SHIFT				8
+#define ROM1_SIZE_SHIFT				16
+
+
+/* SW_conf_REG */
+#define SW_AGE_TIMER_MASK			0x000000F0
+#define SW_AGE_TIMER_DISABLE			0x0
+#define SW_AGE_TIMER_FAST			0x00000080
+#define SW_AGE_TIMER_300SEC			0x00000010
+#define SW_AGE_TIMER_600SEC			0x00000020
+#define SW_AGE_TIMER_1200SEC			0x00000030
+#define SW_AGE_TIMER_2400SEC			0x00000040
+#define SW_AGE_TIMER_4800SEC			0x00000050
+#define SW_AGE_TIMER_9600SEC			0x00000060
+#define SW_AGE_TIMER_19200SEC			0x00000070
+//#define SW_AGE_TIMER_38400SEC			0x00000070
+
+#define SW_BC_PREV_MASK				0x00000300
+#define SW_BC_PREV_DISABLE			0
+#define SW_BC_PREV_64BC				0x00000100
+#define SW_BC_PREV_48BC				0x00000200
+#define SW_BC_PREV_32BC				0x00000300
+
+#define SW_MAX_LEN_MASK				0x00000C00
+#define SW_MAX_LEN_1536				0
+#define SW_MAX_LEN_1522				0x00000800
+#define SW_MAX_LEN_1518				0x00000400
+
+#define SW_DIS_COLABT				0x00001000
+
+#define SW_HASH_ALG_MASK			0x00006000
+#define SW_HASH_ALG_DIRECT			0
+#define SW_HASH_ALG_XOR48			0x00002000
+#define SW_HASH_ALG_XOR32			0x00004000
+
+#define SW_DISABLE_BACKOFF_TIMER		0x00008000
+
+#define SW_BP_NUM_MASK				0x000F0000
+#define SW_BP_NUM_SHIFT				16
+#define SW_BP_MODE_MASK				0x00300000
+#define SW_BP_MODE_DISABLE			0
+#define SW_BP_MODE_JAM				0x00100000
+#define SW_BP_MODE_JAMALL			0x00200000
+#define SW_BP_MODE_CARRIER			0x00300000
+#define SW_RESRV_MC_FILTER			0x00400000
+#define SW_BISR_DISABLE				0x00800000
+
+#define SW_DIS_MII_WAS_TX			0x01000000
+#define SW_BISS_EN				0x02000000
+#define SW_BISS_TH_MASK				0x0C000000
+#define SW_BISS_TH_SHIFT			26
+#define SW_REQ_LATENCY_MASK			0xF0000000
+#define SW_REQ_LATENCY_SHIFT			28
+
+
+/* CPUp_conf_REG */
+#define SW_CPU_PORT_DISABLE			0x00000001
+#define SW_PADING_CRC				0x00000002
+#define SW_BRIDGE_MODE				0x00000004
+
+#define SW_DIS_UN_SHIFT				9
+#define SW_DIS_UN_MASK				(0x3F << SW_DIS_UN_SHIFT)
+#define SW_DIS_MC_SHIFT				16
+#define SW_DIS_MC_MASK				(0x3F << SW_DIS_MC_SHIFT)
+#define SW_DIS_BC_SHIFT				24
+#define SW_DIS_BC_MASK				(0x3F << SW_DIS_BC_SHIFT)
+
+
+/* Port_conf0_REG */
+#define SW_DISABLE_PORT_MASK			0x0000003F
+#define SW_EN_MC_MASK				0x00003F00
+#define SW_EN_MC_SHIFT				8
+#define SW_EN_BP_MASK				0x003F0000
+#define SW_EN_BP_SHIFT				16
+#define SW_EN_FC_MASK				0x3F000000
+#define SW_EN_FC_SHIFT				24
+
+
+/* Port_conf1_REG */
+#define SW_DIS_SA_LEARN_MASK			0x0000003F
+#define SW_PORT_BLOCKING_MASK			0x00000FC0
+#define SW_PORT_BLOCKING_SHIFT			6
+#define SW_PORT_BLOCKING_ON			0x1
+
+#define SW_PORT_BLOCKING_MODE_MASK		0x0003F000
+#define SW_PORT_BLOCKING_MODE_SHIFT		12
+#define SW_PORT_BLOCKING_CTRLONLY		0x1
+
+#define SW_EN_PORT_AGE_MASK			0x03F00000
+#define SW_EN_PORT_AGE_SHIFT			20
+#define SW_EN_SA_SECURED_MASK			0xFC000000
+#define SW_EN_SA_SECURED_SHIFT			26
+
+
+/* Port_conf2_REG */
+#define SW_GMII_AN_EN				0x00000001
+#define SW_GMII_FORCE_SPD_MASK			0x00000006
+#define SW_GMII_FORCE_SPD_10M			0
+#define SW_GMII_FORCE_SPD_100M			0x2
+#define SW_GMII_FORCE_SPD_1000M			0x4
+
+#define SW_GMII_FORCE_FULL_DUPLEX		0x00000008
+
+#define SW_GMII_FORCE_RXFC			0x00000010
+#define SW_GMII_FORCE_TXFC			0x00000020
+
+#define SW_GMII_EN				0x00000040
+#define SW_GMII_REVERSE				0x00000080
+
+#define SW_GMII_TXC_CHECK_EN			0x00000100
+
+#define SW_LED_FLASH_TIME_MASK			0x00030000
+#define SW_LED_FLASH_TIME_30MS			0
+#define SW_LED_FLASH_TIME_60MS			0x00010000
+#define SW_LED_FLASH_TIME_240MS			0x00020000
+#define SW_LED_FLASH_TIME_480MS			0x00030000
+
+
+/* Send_trig_REG */
+#define SEND_TRIG_LOW				0x0001
+#define SEND_TRIG_HIGH				0x0002
+
+
+/* Srch_cmd_REG */
+#define SW_MAC_SEARCH_START			0x000001
+#define SW_MAX_SEARCH_AGAIN			0x000002
+
+/* MAC_wt0_REG */
+#define SW_MAC_WRITE				0x00000001
+#define SW_MAC_WRITE_DONE			0x00000002
+#define SW_MAC_FILTER_EN			0x00000004
+#define SW_MAC_VLANID_SHIFT			3
+#define SW_MAC_VLANID_MASK			0x00000038
+#define SW_MAC_VLANID_EN			0x00000040
+#define SW_MAC_PORTMAP_MASK			0x00001F80
+#define SW_MAC_PORTMAP_SHIFT			7
+#define SW_MAC_AGE_MASK				(0x7 << 13)
+#define SW_MAC_AGE_STATIC			(0x7 << 13)
+#define SW_MAC_AGE_VALID			(0x1 << 13)
+#define SW_MAC_AGE_EMPTY			0
+
+/* BW_cntl0_REG */
+#define SW_PORT_TX_NOLIMIT			0
+#define SW_PORT_TX_64K				1
+#define SW_PORT_TX_128K				2
+#define SW_PORT_TX_256K				3
+#define SW_PORT_TX_512K				4
+#define SW_PORT_TX_1M				5
+#define SW_PORT_TX_4M				6
+#define SW_PORT_TX_10MK				7
+
+/* BW_cntl1_REG */
+#define SW_TRAFFIC_SHAPE_IPG			(0x1 << 31)
+
+/* PHY_cntl0_REG */
+#define SW_PHY_ADDR_MASK			0x0000001F
+#define PHY_ADDR_MAX				0x1f
+#define SW_PHY_REG_ADDR_MASK			0x00001F00
+#define SW_PHY_REG_ADDR_SHIFT			8
+#define PHY_REG_ADDR_MAX			0x1f
+#define SW_PHY_WRITE				0x00002000
+#define SW_PHY_READ				0x00004000
+#define SW_PHY_WDATA_MASK			0xFFFF0000
+#define SW_PHY_WDATA_SHIFT			16
+
+
+/* PHY_cntl1_REG */
+#define SW_PHY_WRITE_DONE			0x00000001
+#define SW_PHY_READ_DONE			0x00000002
+#define SW_PHY_RDATA_MASK			0xFFFF0000
+#define SW_PHY_RDATA_SHIFT			16
+
+/* FC_th_REG */
+/* Adj_port_th_REG */
+/* Port_th_REG */
+
+/* PHY_cntl2_REG */
+#define SW_PHY_AN_MASK				0x0000001F
+#define SW_PHY_SPD_MASK				0x000003E0
+#define SW_PHY_SPD_SHIFT			5
+#define SW_PHY_DPX_MASK				0x00007C00
+#define SW_PHY_DPX_SHIFT			10
+#define SW_FORCE_FC_MASK			0x000F8000
+#define SW_FORCE_FC_SHIFT			15
+#define SW_PHY_NORMAL_MASK			0x01F00000
+#define SW_PHY_NORMAL_SHIFT			20
+#define SW_PHY_AUTOMDIX_MASK			0x3E000000
+#define SW_PHY_AUTOMDIX_SHIFT			25
+#define SW_PHY_REC_MCCAVERAGE			0x40000000
+
+
+/* PHY_cntl3_REG */
+/* Pri_cntl_REG */
+/* VLAN_pri_REG */
+/* TOS_en_REG */
+/* TOS_map0_REG */
+/* TOS_map1_REG */
+/* Custom_pri1_REG */
+/* Custom_pri2_REG */
+/* Empty_cnt_REG */
+/* Port_cnt_sel_REG */
+/* Port_cnt_REG */
+
+
+/* SW_Int_st_REG & SW_Int_mask_REG */
+#define SEND_H_DONE_INT				0x0000001
+#define SEND_L_DONE_INT				0x0000002
+#define RX_H_DONE_INT				0x0000004
+#define RX_L_DONE_INT				0x0000008
+#define RX_H_DESC_FULL_INT			0x0000010
+#define RX_L_DESC_FULL_INT			0x0000020
+#define PORT0_QUE_FULL_INT			0x0000040
+#define PORT1_QUE_FULL_INT			0x0000080
+#define PORT2_QUE_FULL_INT			0x0000100
+#define PORT3_QUE_FULL_INT			0x0000200
+#define PORT4_QUE_FULL_INT			0x0000400
+#define PORT5_QUE_FULL_INT			0x0000800
+
+#define CPU_QUE_FULL_INT			0x0002000
+#define GLOBAL_QUE_FULL_INT			0x0004000
+#define MUST_DROP_INT				0x0008000
+#define BC_STORM_INT				0x0010000
+
+#define PORT_STATUS_CHANGE_INT			0x0040000
+#define INTRUDER_INT				0x0080000
+#define	WATCHDOG0_EXPR_INT			0x0100000
+#define WATCHDOG1_EXPR_INT			0x0200000
+#define RX_DESC_ERR_INT				0x0400000
+#define SEND_DESC_ERR_INT			0x0800000
+#define CPU_HOLD_INT				0x1000000
+#define SWITCH_INT_MASK				0x1FDEFFF
+
+
+/* GPIO_conf0_REG */
+#define GPIO0_INPUT_MODE			0x00000001
+#define GPIO1_INPUT_MODE			0x00000002
+#define GPIO2_INPUT_MODE			0x00000004
+#define GPIO3_INPUT_MODE			0x00000008
+#define GPIO4_INPUT_MODE			0x00000010
+#define GPIO5_INPUT_MODE			0x00000020
+#define GPIO6_INPUT_MODE			0x00000040
+#define GPIO7_INPUT_MODE			0x00000080
+
+#define GPIO0_OUTPUT_MODE			0
+#define GPIO1_OUTPUT_MODE			0
+#define GPIO2_OUTPUT_MODE			0
+#define GPIO3_OUTPUT_MODE			0
+#define GPIO4_OUTPUT_MODE			0
+#define GPIO5_OUTPUT_MODE			0
+#define GPIO6_OUTPUT_MODE			0
+#define GPIO7_OUTPUT_MODE			0
+
+#define GPIO0_INPUT_MASK			0x00000100
+#define GPIO1_INPUT_MASK			0x00000200
+#define GPIO2_INPUT_MASK			0x00000400
+#define GPIO3_INPUT_MASK			0x00000800
+#define GPIO4_INPUT_MASK			0x00001000
+#define GPIO5_INPUT_MASK			0x00002000
+#define GPIO6_INPUT_MASK			0x00004000
+#define GPIO7_INPUT_MASK			0x00008000
+
+#define GPIO0_OUTPUT_EN				0x00010000
+#define GPIO1_OUTPUT_EN				0x00020000
+#define GPIO2_OUTPUT_EN				0x00040000
+#define GPIO3_OUTPUT_EN				0x00080000
+#define GPIO4_OUTPUT_EN				0x00100000
+#define GPIO5_OUTPUT_EN				0x00200000
+#define GPIO6_OUTPUT_EN				0x00400000
+#define GPIO7_OUTPUT_EN				0x00800000
+
+#define GPIO_CONF0_OUTEN_MASK			0x00ff0000
+
+#define GPIO0_OUTPUT_HI				0x01000000
+#define GPIO1_OUTPUT_HI				0x02000000
+#define GPIO2_OUTPUT_HI				0x04000000
+#define GPIO3_OUTPUT_HI				0x08000000
+#define GPIO4_OUTPUT_HI				0x10000000
+#define GPIO5_OUTPUT_HI				0x20000000
+#define GPIO6_OUTPUT_HI				0x40000000
+#define GPIO7_OUTPUT_HI				0x80000000
+
+#define GPIO0_OUTPUT_LOW			0
+#define GPIO1_OUTPUT_LOW			0
+#define GPIO2_OUTPUT_LOW			0
+#define GPIO3_OUTPUT_LOW			0
+#define GPIO4_OUTPUT_LOW			0
+#define GPIO5_OUTPUT_LOW			0
+#define GPIO6_OUTPUT_LOW			0
+#define GPIO7_OUTPUT_LOW			0
+
+
+/* GPIO_conf2_REG */
+#define EXTIO_WAIT_EN				(0x1 << 6)
+#define EXTIO_CS1_INT1_EN			(0x1 << 5)
+#define EXTIO_CS0_INT0_EN			(0x1 << 4)
+
+/* Watchdog0_REG, Watchdog1_REG */
+#define WATCHDOG0_RESET_EN			0x80000000
+#define WATCHDOG1_DROP_EN			0x80000000
+
+#define WATCHDOG_TIMER_SET_MASK			0x7FFF0000
+#define WATCHDOG_TIMER_SET_SHIFT		16
+#define WATCHDOG_TIMER_MASK			0x00007FFF
+
+
+/* Timer_int_REG */
+#define SW_TIMER_INT_DISABLE			0x10000
+#define SW_TIMER_INT				0x1
+
+/* Timer_REG */
+#define SW_TIMER_EN				0x10000
+#define SW_TIMER_MASK				0xffff
+#define SW_TIMER_10MS_TICKS			0x3D09
+#define SW_TIMER_1MS_TICKS			0x61A
+#define SW_TIMER_100US_TICKS			0x9D
+
+
+/* Port0_LED_REG, Port1_LED_REG, Port2_LED_REG, Port3_LED_REG, Port4_LED_REG*/
+#define GPIOL_INPUT_MODE			0x00
+#define GPIOL_OUTPUT_FLASH			0x01
+#define GPIOL_OUTPUT_LOW			0x02
+#define GPIOL_OUTPUT_HIGH			0x03
+#define GPIOL_LINK_LED				0x04
+#define GPIOL_SPEED_LED				0x05
+#define GPIOL_DUPLEX_LED			0x06
+#define GPIOL_ACT_LED				0x07
+#define GPIOL_COL_LED				0x08
+#define GPIOL_LINK_ACT_LED			0x09
+#define GPIOL_DUPLEX_COL_LED			0x0A
+#define GPIOL_10MLINK_ACT_LED			0x0B
+#define GPIOL_100MLINK_ACT_LED			0x0C
+#define GPIOL_CTRL_MASK				0x0F
+
+#define GPIOL_INPUT_MASK			0x7000
+#define GPIOL_INPUT_0_MASK			0x1000
+#define GPIOL_INPUT_1_MASK			0x2000
+#define GPIOL_INPUT_2_MASK			0x4000
+
+#define PORT_LED0_SHIFT				0
+#define PORT_LED1_SHIFT				4
+#define PORT_LED2_SHIFT				8
+
+
+/*===========================  UART Control Register  ========================*/
+#define UART_DR_REG				0x00
+#define UART_RSR_REG				0x04
+#define UART_ECR_REG				0x04
+#define UART_LCR_H_REG				0x08
+#define UART_LCR_M_REG				0x0c
+#define UART_LCR_L_REG				0x10
+#define UART_CR_REG				0x14
+#define UART_FR_REG				0x18
+#define UART_IIR_REG				0x1c
+#define UART_ICR_REG				0x1C
+#define UART_ILPR_REG				0x20
+
+/*  rsr/ecr reg  */
+#define UART_OVERRUN_ERR			0x08
+#define UART_BREAK_ERR				0x04
+#define UART_PARITY_ERR				0x02
+#define UART_FRAMING_ERR			0x01
+#define UART_RX_STATUS_MASK			0x0f
+#define UART_RX_ERROR				( UART_BREAK_ERR | UART_PARITY_ERR | UART_FRAMING_ERR)
+
+/*  lcr_h reg  */
+#define UART_SEND_BREAK				0x01
+#define UART_PARITY_EN				0x02
+#define UART_EVEN_PARITY			0x04
+#define UART_TWO_STOP_BITS			0x08
+#define UART_ENABLE_FIFO			0x10
+
+#define UART_WLEN_5BITS				0x00
+#define UART_WLEN_6BITS				0x20
+#define UART_WLEN_7BITS				0x40
+#define UART_WLEN_8BITS				0x60
+#define UART_WLEN_MASK				0x60
+
+/*  cr reg  */
+#define UART_PORT_EN				0x01
+#define UART_SIREN				0x02
+#define UART_SIRLP				0x04
+#define UART_MODEM_STATUS_INT_EN		0x08
+#define UART_RX_INT_EN				0x10
+#define UART_TX_INT_EN				0x20
+#define UART_RX_TIMEOUT_INT_EN			0x40
+#define UART_LOOPBACK_EN			0x80
+
+/*  fr reg  */
+#define UART_CTS				0x01
+#define UART_DSR				0x02
+#define UART_DCD				0x04
+#define UART_BUSY				0x08
+#define UART_RX_FIFO_EMPTY			0x10
+#define UART_TX_FIFO_FULL			0x20
+#define UART_RX_FIFO_FULL			0x40
+#define UART_TX_FIFO_EMPTY			0x80
+
+/*  iir/icr reg  */
+#define UART_MODEM_STATUS_INT			0x01
+#define UART_RX_INT				0x02
+#define UART_TX_INT				0x04
+#define UART_RX_TIMEOUT_INT			0x08
+
+#define UART_INT_MASK				0x0f
+
+#define ADM5120_UARTCLK_FREQ			62500000
+
+#define UART_BAUDDIV(_rate)			((unsigned long)(ADM5120_UARTCLK_FREQ/(16*(_rate)) - 1))
+
+/*  uart_baudrate  */
+#define UART_230400bps_DIVISOR			UART_BAUDDIV(230400)
+#define UART_115200bps_DIVISOR			UART_BAUDDIV(115200)
+#define UART_76800bps_DIVISOR			UART_BAUDDIV(76800)
+#define UART_57600bps_DIVISOR			UART_BAUDDIV(57600)
+#define UART_38400bps_DIVISOR			UART_BAUDDIV(38400)
+#define UART_19200bps_DIVISOR			UART_BAUDDIV(19200)
+#define UART_14400bps_DIVISOR			UART_BAUDDIV(14400)
+#define UART_9600bps_DIVISOR			UART_BAUDDIV(9600)
+#define UART_2400bps_DIVISOR			UART_BAUDDIV(2400)
+#define UART_1200bps_DIVISOR			UART_BAUDDIV(1200)
+
+
+/* Cache Controller */
+//#define ADM5120_CACHE_CTRL_BASE		0x70000000
+#define ADM5120_CACHE_LINE_SIZE			16
+//#define ADM5120_CACHE_CTRL_REGSIZE		4
+
+
+/********** GPIO macro *************/
+#define GPIO_MEASURE	0x000f00f0 //enable output status of pin 0, 1, 2, 3 
+
+#define GPIO_MEASURE_INIT() \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) = GPIO_MEASURE; \
+} while (0)
+
+
+#define GPIO_SET_HI(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) |= 1 << (24 + num); \
+} while (0)
+
+
+#define GPIO_SET_LOW(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) &= ~(1 << (24 + num)); \
+} while (0)
+
+
+#define GPIO_TOGGLE(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) ^= (1 << (24 + num)); \
+} while (0)
+
+
+#define BOOT_LINE_SIZE		256
+#define BSP_STR_LEN		64
+
+/*
+ * System configuration
+ */
+/*typedef struct BOARD_CFG_S
+{
+	unsigned long blmagic;
+	unsigned char bootline[BOOT_LINE_SIZE+1];
+	
+	unsigned long macmagic;
+	unsigned char mac[4][8];
+
+	unsigned long idmagic;    
+	unsigned char serial[BSP_STR_LEN+1];
+
+	unsigned long vermagic;
+	unsigned char ver[BSP_STR_LEN+1];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define BL_MAGIC			0x6c62676d
+#define MAC_MAGIC			0x636d676d
+#define VER_MAGIC			0x7276676d
+#define ID_MAGIC			0x6469676d
+*/
+typedef struct BOARD_CFG_S
+{
+	unsigned long macmagic;
+	unsigned char sr[3];
+	unsigned char mac[3][6];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define MAC_MAGIC			0x31305348
+
+
+#endif /* __ADM5120_H__ */
diff -Naur linux-2.6.16/include/asm-mips/am5120/debug.h linux-2.6.16-new/include/asm-mips/am5120/debug.h
--- linux-2.6.16/include/asm-mips/am5120/debug.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/asm-mips/am5120/debug.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,16 @@
+#define PDEBUG(debug_lev,fmt,args...)
+
+#ifdef ADM5120_DEBUG 
+#	define DEBUG_1 1
+#	define DEBUG_2 2
+#	define DEBUG_3 3
+#	define DEBUG_4 4
+#	define DEBUG_5 5
+#	ifndef DEBUG_DEF
+#		define DEBUG_DEF 0
+#	endif
+#	undef PDEBUG
+#	define PDEBUG(debug_lev,fmt,args...) \
+    	    if( debug_lev < DEBUG_DEF ) \
+		printk(KERN_NOTICE"%s: " fmt " \n", __FUNCTION__, ## args )
+#endif
diff -Naur linux-2.6.16/include/asm-mips/am5120/mx29lv320b.h linux-2.6.16-new/include/asm-mips/am5120/mx29lv320b.h
--- linux-2.6.16/include/asm-mips/am5120/mx29lv320b.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/asm-mips/am5120/mx29lv320b.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,79 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/mx29lv320b.h
+;    Date    : 2003.07.30
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __MX29LV320B_H__
+#define  __MX29LV320B_H__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_PHYS_ADDR 	0x1FC00000
+
+#include<asm/am5120/mx_parts.h>
+
+#define FLASH_PART_ROOT_ADDR (FLASH_PART_KERNEL_ADDR + FLASH_PART_KERNEL_SIZE)
+#define FLASH_PART_DATA_ADDR (FLASH_PART_ROOT_ADDR + FLASH_PART_ROOT_SIZE)
+#define FLASH_PART_DATA_SIZE (FLASH_SIZE - FLASH_PART_DATA_ADDR)
+
+
+struct mtd_partition mx29lv320b_parts[] = {
+	{
+		.name =		"Boot Partition",
+		.offset =	FLASH_PART_BOOT_ADDR,
+		.size =		FLASH_PART_BOOT_SIZE,
+		.mask_flags =   MTD_WRITEABLE
+	},
+	{
+		.name =		"Kernel",
+		.offset =	FLASH_PART_KERNEL_ADDR,
+		.size =		FLASH_PART_KERNEL_SIZE
+	},
+	{
+		.name =		"Root",
+		.offset =	FLASH_PART_ROOT_ADDR,
+		.size =		FLASH_PART_ROOT_SIZE
+	},
+	{
+		.name =		"Data",
+		.offset =	FLASH_PART_DATA_ADDR,
+		.size =		FLASH_PART_DATA_SIZE
+	},
+	{
+		.name =		"WholeFlash",
+		.offset =	FLASH_PART_KERNEL_ADDR,
+		.size =		0x1F0000
+	}
+};
+
+#define PARTITION_COUNT (sizeof(mx29lv320b_parts)/sizeof(struct mtd_partition))
+
+#endif /* __MX29LV320B_H__ */
+
diff -Naur linux-2.6.16/include/asm-mips/am5120/mx_parts.h linux-2.6.16-new/include/asm-mips/am5120/mx_parts.h
--- linux-2.6.16/include/asm-mips/am5120/mx_parts.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/asm-mips/am5120/mx_parts.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,10 @@
+/**********************************************************************************
+;   Auto generated by target/linux/linux-2.4/adm5120.mk
+;   DO NOT EDIT!!!
+;**********************************************************************************/
+#define FLASH_SIZE      0x00200000
+#define FLASH_PART_BOOT_ADDR    0x00000000
+#define FLASH_PART_BOOT_SIZE    0x00008000
+#define FLASH_PART_KERNEL_ADDR  0x00010000
+#define FLASH_PART_KERNEL_SIZE  0x000A0000
+#define FLASH_PART_ROOT_SIZE    0x00140000
diff -Naur linux-2.6.16/include/asm-mips/am5120/prom.h linux-2.6.16-new/include/asm-mips/am5120/prom.h
--- linux-2.6.16/include/asm-mips/am5120/prom.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/asm-mips/am5120/prom.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,49 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * MIPS boards bootprom interface for the Linux kernel.
+ *
+ */
+
+#ifndef _MIPS_PROM_H
+#define _MIPS_PROM_H
+
+extern char *prom_getcmdline(void);
+extern char *prom_getenv(char *name);
+extern void setup_prom_printf(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern void prom_init_cmdline(void);
+extern void prom_meminit(void);
+extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
+extern void prom_free_prom_memory (void);
+extern void mips_display_message(const char *str);
+extern void mips_display_word(unsigned int num);
+extern int get_ethernet_addr(char *ethernet_addr);
+
+/* Memory descriptor management. */
+#define PROM_MAX_PMEMBLOCKS    32
+struct prom_pmemblock {
+        unsigned long base; /* Within KSEG0. */
+        unsigned int size;  /* In bytes. */
+        unsigned int type;  /* free or prom memory */
+};
+
+#endif /* !(_MIPS_PROM_H) */
diff -Naur linux-2.6.16/include/asm-mips/asm.h linux-2.6.16-new/include/asm-mips/asm.h
--- linux-2.6.16/include/asm-mips/asm.h	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/include/asm-mips/asm.h	2007-05-10 10:27:23.000000000 +0700
@@ -107,7 +107,7 @@
 /*
  * Print formatted string
  */
-#ifdef CONFIG_PRINTK
+//#ifdef CONFIG_PRINTK
 #define PRINT(string)                                   \
 		.set	push;				\
 		.set	reorder;                        \
@@ -115,10 +115,11 @@
 		jal	printk;                         \
 		.set	pop;				\
 		TEXT(string)
+/*
 #else
 #define PRINT(string)
 #endif
-
+*/
 #define	TEXT(msg)                                       \
 		.pushsection .data;			\
 8:		.asciiz	msg;                            \
diff -Naur linux-2.6.16/include/asm-mips/bootinfo.h linux-2.6.16-new/include/asm-mips/bootinfo.h
--- linux-2.6.16/include/asm-mips/bootinfo.h	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/include/asm-mips/bootinfo.h	2007-05-10 10:27:23.000000000 +0700
@@ -218,6 +218,13 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+/*
+ * Valid machtype for group ADMtek
+ */
+#define MACH_GROUP_ADM_GW      23
+#define MACH_ADM_GW_5120       0
+
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -Naur linux-2.6.16/include/asm-mips/system.h linux-2.6.16-new/include/asm-mips/system.h
--- linux-2.6.16/include/asm-mips/system.h	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/include/asm-mips/system.h	2007-05-10 10:27:23.000000000 +0700
@@ -442,6 +442,7 @@
 extern void *set_vi_handler (int n, void *addr);
 extern void *set_vi_srs_handler (int n, void *addr, int regset);
 extern void *set_except_vector(int n, void *addr);
+extern unsigned long ebase;
 extern void per_cpu_trap_init(void);
 
 extern NORET_TYPE void die(const char *, struct pt_regs *);
diff -Naur linux-2.6.16/include/linux/debug_net.h linux-2.6.16-new/include/linux/debug_net.h
--- linux-2.6.16/include/linux/debug_net.h	1970-01-01 07:00:00.000000000 +0700
+++ linux-2.6.16-new/include/linux/debug_net.h	2007-05-10 10:27:23.000000000 +0700
@@ -0,0 +1,111 @@
+#include<linux/time.h>
+#include<linux/delay.h>
+#include<linux/interrupt.h>
+#include<linux/netfilter.h>
+
+/* functions */
+void debug_count_delta(struct timeval *tv1,struct timeval tv2);
+void debug_print_tv(struct timeval *tv,u32 cnt,struct timeval *tv1,char *str);
+void debug_div_tv(struct timeval *tv1,u32 z);
+void debug_sum_tv(struct timeval *tv1,struct timeval tv2);
+
+
+
+/* debug macroses */
+#define DEBUG_NET
+
+#ifdef DEBUG_NET
+
+#define DEBUG_NF_HOOK(pf, hook, skb, indev, outdev, okfn,counter_var)	\
+({int __ret; 								\
+struct timeval tv1,tv2; 						\
+disable_irq(9); 							\
+do_gettimeofday(&tv1); 							\
+__ret=nf_hook_thresh(pf, hook, &(skb), indev, outdev, okfn,INT_MIN, 1); \
+do_gettimeofday(&tv2); 							\
+if( __ret == 1 ) 							\
+	__ret = (okfn)(skb);                                            \
+enable_irq(9); 								\
+debug_count_delta(&tv1,tv2); 						\
+debug_sum_tv(& debug_ip_##counter_var,tv1); 				\
+debug_ip_##counter_var##_cnt+=1;  					\
+__ret; })
+
+#define DEBUG_NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond,counter_var) \
+({int __ret; \
+struct timeval tv1,tv2; \
+disable_irq(9); \
+do_gettimeofday(&tv1); \
+__ret=NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond); \
+do_gettimeofday(&tv2); \
+enable_irq(9); \
+debug_count_delta(&tv1,tv2); \
+debug_sum_tv(& debug_ip_ ## counter_var,tv1); \
+debug_ip_##counter_var##_cnt+=1 ;\
+__ret; })
+
+
+#define DEBUG_ADD_NEW_DELTA(tv1,tv2,counter_var) 	\
+({ 								\
+debug_count_delta(&tv1,tv2); 					\
+debug_sum_tv(& debug_ip_ ## counter_var,tv1); 			\
+debug_ip_##counter_var##_cnt+=1 ;				\
+})
+
+#else /* Not defined DEBUG_NET */
+
+#define DEBUG_NF_HOOK(pf, hook, skb, indev, outdev, okfn,counter_var) \
+({int __ret; \
+__ret=NF_HOOK(pf, hook, skb, indev, outdev, okfn); \
+__ret; })
+
+#define DEBUG_NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond,counter_var) \
+({ int __ret; \
+__ret=NF_HOOK_COND(pf, hook, skb, indev, outdev, okfn, cond); \
+__ret; })
+
+#endif /* DEBUG_NET */
+
+
+#define DEBUG_NET_OUTPUT(counter_var,str) \
+({	struct timeval rez;\
+	memset(&rez,0,sizeof(struct timeval)); \
+	if ( debug_ip_##counter_var##_cnt ){ \
+		rez.tv_sec=debug_ip_##counter_var.tv_sec; \
+		rez.tv_usec=debug_ip_##counter_var.tv_usec; \
+		debug_div_tv(&rez, debug_ip_##counter_var##_cnt ); \
+	} \
+	debug_print_tv(&rez,debug_ip_##counter_var##_cnt,&debug_ip_##counter_var,str);\
+})
+
+
+
+/* counters */
+	
+
+extern struct timeval debug_ip_arp;
+extern struct timeval debug_ip_igmp;
+extern struct timeval debug_ip_input;
+extern struct timeval debug_ip_output;
+extern struct timeval debug_ip_forward;
+extern struct timeval debug_ip_hook;
+extern struct timeval debug_ip_test;
+
+extern struct timeval debug_ip_vs_xmit;
+extern struct timeval debug_ip_ipt_REJECT;
+extern struct timeval debug_ip_raw;
+extern struct timeval debug_ip_xfrm4_input;
+extern struct timeval debug_ip_xfrm4_output;
+extern struct timeval debug_ip_ipmr;
+
+
+
+extern u32 debug_ip_arp_cnt;
+extern u32 debug_ip_igmp_cnt;
+extern u32 debug_ip_input_cnt;
+extern u32 debug_ip_output_cnt;
+extern u32  debug_ip_ipmr_cnt;
+extern u32  debug_ip_forward_cnt;
+extern u32  debug_ip_hook_cnt;
+extern u32  debug_ip_test_cnt;
+
diff -Naur linux-2.6.16/include/linux/serial_core.h linux-2.6.16-new/include/linux/serial_core.h
--- linux-2.6.16/include/linux/serial_core.h	2006-03-20 11:53:29.000000000 +0600
+++ linux-2.6.16-new/include/linux/serial_core.h	2007-05-10 10:27:23.000000000 +0700
@@ -82,6 +82,11 @@
 /* Samsung S3C2410 SoC and derivatives thereof */
 #define PORT_S3C2410    55
 
+/* ADMtek ADM5120 SoC */
+#define PORT_ADM5120   68
+
+
+
 /* SGI IP22 aka Indy / Challenge S / Indigo 2 */
 #define PORT_IP22ZILOG	56
 
diff -Naur linux-2.6.16/Makefile linux-2.6.16-new/Makefile
--- linux-2.6.16/Makefile	2007-05-10 12:09:04.000000000 +0700
+++ linux-2.6.16-new/Makefile	2007-05-10 10:27:23.000000000 +0700
@@ -315,7 +315,7 @@
 DEPMOD		= /sbin/depmod
 KALLSYMS	= scripts/kallsyms
 PERL		= perl
-CHECK		= sparse
+CHECK		= sparse -Wbitwise
 
 CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise $(CF)
 MODFLAGS	= -DMODULE
@@ -739,6 +739,11 @@
 	$(call if_changed_rule,vmlinux__)
 	$(Q)rm -f .old_version
 
+vmlinuz: vmlinux
+	$(OBJCOPY) -O binary vmlinux vmlinux.bin
+	gzip vmlinux.bin -c >vmlinuz
+
+
 # The actual objects are generated when descending, 
 # make sure no implicit rule kicks in
 $(sort $(vmlinux-init) $(vmlinux-main)) $(vmlinux-lds): $(vmlinux-dirs) ;
