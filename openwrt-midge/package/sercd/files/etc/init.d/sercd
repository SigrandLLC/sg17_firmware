#!/bin/sh

usage()
{
	echo 1>&2 "Usage: $0 start|stop N"
	exit 1
}

if test "$#" -ne 2; then
	usage
fi

N=$2

PORT_BASE=2000
PORT=$(( $PORT_BASE + $N ))
ADDR=0.0.0.0
LOGLEVEL=7
DEVICE=/dev/ttyRS${N}
LOCKFILE=/var/lock/LCK..ttyRS${N}
 PIDFILE=/var/run/sercd${N}.pid

case $1 in
	start)
		sercd -p $PORT -l $ADDR -P $PIDFILE $LOGLEVEL $DEVICE $LOCKFILE 100
		;;
	 stop)
		if test -e        $PIDFILE; then
			kill `cat $PIDFILE`
			rm -f     $PIDFILE
		fi
		;;
	    *)	usage
		;;
esac

# sercd [-ie] [-p port] [-l addr] <loglevel> <device> <lockfile> [pollingterval]
#
# -i	Enable compatability with Cisco IOS
#	which has a small bug in the handling of the inbound flow control.
# -e	Send output to standard error instead of syslog.
# -p port
#	Listen on specified port, instead of port 7000.
# -l addr
#	Standalone mode, bind to specified adress, empty string for all.
# -P pidfile
#
# loglevel	log level for use in syslog,
#		0 to 7, 0 being no log and 7 being debug log.
# device	the device complete path, i.e. /dev/ttyS0
# lockfile	lock file, i.e. /var/lock/LCK..ttyS0
# pollingterval	checks for line state changes (DSR/CTS/DCD/RNG)
#		on every single char sent on the serial line.
#		When there's no traffic on the serial port, sercd also polls
#		the line state with poll interval. The value is in milliseconds,
#		default is 100 milliseconds. 0 disables the polling feature.
#		This is also the maximum time data is left in the output buffer
#		before sending it, even if the buffer isn't completely full.

