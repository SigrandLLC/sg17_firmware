<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Классовая дисциплина HTB</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Руководство по эксплуатации мультиплексора ГМ-2-MPR"><link rel="up" href="qos.html" title="Качество обслуживания"><link rel="prev" href="tbf.html" title="Бесклассовая дисциплина TBF"><link rel="next" href="multiplexing.html" title="Глава 6. Мультиплексирование"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Классовая дисциплина HTB</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="tbf.html">Пред.</a> </td><th width="60%" align="center">Качество обслуживания</th><td width="20%" align="right"> <a accesskey="n" href="multiplexing.html">След.</a></td></tr></table><hr></div><div class="section" lang="ru"><div class="titlepage"><div><div><h3 class="title"><a name="htb"></a>Классовая дисциплина HTB</h3></div></div></div><p>
				Дисциплина HTB позволяет отдать предпочтение определенным пользователям или типам трафика, определяя их на основании IP-адресов или портов отправителя/получателя в разные классы трафика.
			</p><p>
				В первую очередь следует отметить, что управлять скоростью можно только исходящего трафика (что, в общем, вполне разумно), поэтому при добавлении правил шейпинга необходимо определить интерфейс, на котором этот трафик будет исходящим.
			</p><p>
				Реализация QoS на основе классовой дисциплины HTB состоит из двух этапов - создания класса и распределения трафика по классам в соответствии с определенными критериями с помощью фильтров. Классы, определяющие скорость трафика, могут добавляться как в корень, так и в другие подклассы, образуя иерархию классов. Фильтры добавляются в корень иерархии.
			</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Подсказка</h3><p>
					Особенность подклассов в том, что скорость одного подкласса может быть увеличена (в пределах скорости родительского класса) за счет <span class="emphasis"><em>неиспользуемой</em></span> скорости другого подкласса.
				</p></div><div class="figure"><a name="qos_class"></a><p class="title"><b>Рисунок 5.17. Классы трафика</b></p><div><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="img/qos-class.png" width="540" alt="Классы трафика"></td></tr></table></div></div><div class="figure"><a name="qos_filter"></a><p class="title"><b>Рисунок 5.18. Фильтры, направляющие трафик в классы</b></p><div><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="img/qos-filter.png" width="540" alt="Фильтры, направляющие трафик в классы"></td></tr></table></div></div><p>
				Рассмотрим в качестве примера простую сеть, схема которой представленна ниже:
			</p><div class="figure"><a name="id2527595"></a><p class="title"><b>Рисунок 5.19. Пример сети</b></p><div><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="img/tc-network.png" width="540" alt="Пример сети"></td></tr></table></div></div><p>
				К примеру, если мы хотим ограничить пропускную способность канала для входящего трафика к хосту PC2, то нам необходимо работать с интерфейсом eth1 мультиплексора, поскольку через него проходит исходящий трафик к хосту PC2. В качестве примера  ограничим весь трафик, поступающий на PC2, для этого нам необходимо создать класс, в который будет поступать трафик, идущий к хосту PC2:
			</p><div class="figure"><a name="qos_class_add"></a><p class="title"><b>Рисунок 5.20. Добавление класса</b></p><div><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="img/qos-class-add.png" width="540" alt="Добавление класса"></td></tr></table></div></div><div class="itemizedlist"><ul type="disc"><li><p>Short name - имя добавляемого класса. Используется при классификации трафика в фильтре</p></li><li><p>Enable - активен ли класс</p></li><li><p>Parent class - родительский класс. root - корневой класс. При добавлении класса в некорневой класс - добавляемый класс будет <span class="emphasis"><em>подклассом</em></span></p></li><li><p>Rate - пропускная способность, выделяемая классу</p></li><li><p>Ceil - максимальная пропускная способность подкласса (в случае, если другой подкласс этого же класса использует не всю предоставленную ему пропускную способность)</p></li></ul></div><p>
				Чтобы избежать путаницы, заранее рассмотрим принятые сокращения, описывающие скорость:
				</p><div class="itemizedlist"><ul type="disc"><li>mbps = 1024 kbps = 1024 * 1024 bps =&gt; byte/s =&gt; 1024 килобайт в секунду</li><li>mbit = 1024 kbit =&gt; kilo bit/s =&gt; 1024 килобит в секунду</li></ul></div><p>
			</p><p>
				Теперь нам необходимо классифицировать трафик, идущий к хосту PC2. Для этого нам необходимо создать фильтр:
			</p><div class="figure"><a name="qos_filter_add"></a><p class="title"><b>Рисунок 5.21. Добавление фильтра</b></p><div><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="img/qos-filter-add.png" width="540" alt="Добавление фильтра"></td></tr></table></div></div><div class="itemizedlist"><ul type="disc"><li><p>Short name - имя фильтра</p></li><li><p>Enable - активен ли фильтр</p></li><li><p>Prio - приоритет фильтра. Чем меньше значение приоритета - тем он выше</p></li><li><p>Protocol - классификация трафика по используемому протоколу</p></li><li><p>Src - классификация трафика по адресу отправителя пакета</p></li><li><p>Dst - классификация трафика по адресу получателя пакета</p></li><li><p>Src port - классификация трафика по номеру порта отправителя пакета</p></li><li><p>Dst port - классификация трафика по номеру порта получателя пакета</p></li><li><p>Class - в какой класс направить пакет</p></li></ul></div><p>
				В приведенным ваше примере мы ограничили входящую скорость для хоста PC2. Но исходящая осталась неограниченной. Чтобы исправить положение, необходимо определить, какой интерфейс является исходящем для трафика с PC2. Это зависит от того, кто запрашивает трафик с PC2, в нашем случае это может быть только PC1, следовательно интерфейс, через который пойдет трафик к PC1, будет eth0. Поэтому для ограничения исходящего трафика необходимо создать класс с требуемой скоростью и добавить фильтр, который будет отправлять трафик, идущий от хоста PC2 (src 192.168.90.2) направлять в нужный класс.
			</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tbf.html">Пред.</a> </td><td width="20%" align="center"><a accesskey="u" href="qos.html">Уровень выше</a></td><td width="40%" align="right"> <a accesskey="n" href="multiplexing.html">След.</a></td></tr><tr><td width="40%" align="left" valign="top">Бесклассовая дисциплина TBF </td><td width="20%" align="center"><a accesskey="h" href="index.html">Начало</a></td><td width="40%" align="right" valign="top"> Глава 6. Мультиплексирование</td></tr></table></div></body></html>
