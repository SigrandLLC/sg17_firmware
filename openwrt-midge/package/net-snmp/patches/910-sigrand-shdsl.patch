Index: net-snmp-5.1.2/configure
===================================================================
--- net-snmp-5.1.2/configure	(revision 42)
+++ net-snmp-5.1.2/configure	(revision 50)
@@ -27770,6 +27770,8 @@
 s,@installucdheaders@,$installucdheaders,;t t
 s,@installucdlibs@,$installucdlibs,;t t
 s,@CC@,$CC,;t t
+s,@CXX@,$CXX,;t t
+s,@AR@,$AR,;t t
 s,@CFLAGS@,$CFLAGS,;t t
 s,@LDFLAGS@,$LDFLAGS,;t t
 s,@CPPFLAGS@,$CPPFLAGS,;t t
Index: net-snmp-5.1.2/mibs/Makefile.in
===================================================================
--- net-snmp-5.1.2/mibs/Makefile.in	(revision 42)
+++ net-snmp-5.1.2/mibs/Makefile.in	(revision 50)
@@ -35,7 +35,8 @@
 	IPV6-TC.txt IPV6-MIB.txt IPV6-ICMP-MIB.txt IPV6-TCP-MIB.txt \
 	IPV6-UDP-MIB.txt \
 	DISMAN-SCRIPT-MIB.txt DISMAN-SCHEDULE-MIB.txt \
-	NOTIFICATION-LOG-MIB.txt SNMP-USM-AES-MIB.txt
+	NOTIFICATION-LOG-MIB.txt SNMP-USM-AES-MIB.txt \
+	HDSL2-SHDSL-LINE-MIB-rfc4319.txt
 
 NETSNMPMIBS = NET-SNMP-TC.txt NET-SNMP-MIB.txt NET-SNMP-AGENT-MIB.txt \
 	NET-SNMP-EXAMPLES-MIB.txt
Index: net-snmp-5.1.2/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt
===================================================================
--- net-snmp-5.1.2/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt	(revision 0)
+++ net-snmp-5.1.2/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt	(revision 50)
@@ -0,0 +1,2541 @@
+-- extracted from rfc4319.txt
+-- at Thu Dec 15 06:40:11 2005
+
+   HDSL2-SHDSL-LINE-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+      MODULE-IDENTITY,
+      OBJECT-TYPE,
+      Counter32,
+      Unsigned32,
+      Gauge32,
+      NOTIFICATION-TYPE,
+      Integer32,
+      transmission
+         FROM SNMPv2-SMI
+      RowStatus,
+      TEXTUAL-CONVENTION
+         FROM SNMPv2-TC
+      ifIndex
+         FROM IF-MIB
+      PerfCurrentCount,
+      PerfIntervalCount
+         FROM PerfHist-TC-MIB
+      SnmpAdminString
+         FROM SNMP-FRAMEWORK-MIB
+      MODULE-COMPLIANCE,
+      OBJECT-GROUP,
+      NOTIFICATION-GROUP
+         FROM SNMPv2-CONF;
+
+   hdsl2ShdslMIB MODULE-IDENTITY
+      LAST-UPDATED "200512070000Z" -- December 7, 2005
+      ORGANIZATION "ADSLMIB Working Group"
+      CONTACT-INFO "WG-email:  adslmib@ietf.org
+         WG-URL:
+            http://www.ietf.org/html.charters/adslmib-charter.html
+         Info:       https://www1.ietf.org/mailman/listinfo/adslmib
+         Chair:      Mike Sneed
+                     Sand Channel Systems
+         Postal:     1210-203 Westview Ln
+                     Raleigh NC 27605  USA
+         Email:      sneedmike@hotmail.com
+         Phone:     +1 206 600 7022
+
+         Co-Chair    Bob Ray
+                     PESA Switching Systems, Inc.
+
+         Postal      330-A Wynn Drive
+                     Huntsville, AL 35805 USA
+         Phone       +1 256 726 9200 ext. 142
+
+         Co-editor:  Clay Sikes
+                     Zhone Technologies, Inc.
+         Postal:     8545 126th Ave. N.
+                     Largo, FL 33772 USA
+         Email:      csikes@zhone.com
+         Phone:      +1 727 530 8257
+
+         Co-editor:  Bob Ray
+                     PESA Switching Systems, Inc.
+         Postal:     330-A Wynn Drive
+                     Huntsville, AL 35805 USA
+         Email:      rray@pesa.com
+         Phone:      +1 256 726 9200 ext. 142
+
+         Co-editor:  Rajesh Abbi
+                     Alcatel USA
+         Postal:     2301 Sugar Bush Road
+                     Raleigh, NC 27612-3339 USA
+
+         Email:      Rajesh.Abbi@alcatel.com
+         Phone:      +1 919 850 6194"
+
+   DESCRIPTION
+        "This MIB module defines a collection of objects for managing
+         HDSL2/SHDSL lines.  An agent may reside at either end of the
+         line; however, the MIB module is designed to require no
+         management communication between the modems beyond that
+         inherent in the low-level EOC line protocol as defined in
+         ANSI T1E1.4/2000-006 (for HDSL2 lines) or in ITU G.991.2
+         (for SHDSL lines).
+
+         Copyright (C) The Internet Society (2005).  This version of
+         this MIB module is part of RFC 4319; see the RFC itself for
+         full legal notices."
+
+   REVISION    "200512070000Z" -- December 7, 2005
+   DESCRIPTION "This version, published as RFC 4319.
+         The following changes have been made in this version:
+           1.  Added a 3rd and 4th wire pair.
+           2.  Modified all rates such that their rates are only
+               constrained by an unsigned 32-bit value and not by
+               what today's perceived technology limitations are.
+
+           3.  Clarified that the rates from RFC 3276 include
+               payload and any applicable framing and added
+               objects for payload-only rates.
+           4.  Added an object to indicate whether the
+               tip and ring are reversed on a wire pair.
+           5.  Added an object to display the activation state
+               of a wire pair.
+           6.  Added references as necessary for clarification.
+           7.  Added display hints to textual conventions as
+               necessary.
+           8.  Updated conformance statements as necessary.
+           9.  Some changes were due to IETF requirements and
+               RFC generation tools."
+
+   REVISION    "200205090000Z" -- May 9, 2002
+   DESCRIPTION "Initial version, published as RFC 3276."
+
+   ::= { transmission 48 }
+
+   hdsl2ShdslMibObjects OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 1 }
+
+   -- Textual Conventions used in this MIB module
+   --
+
+   Hdsl2ShdslPerfCurrDayCount ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "A gauge associated with interface performance measurements in
+         a current 1-day (24 hour) measurement interval.
+
+         The value of this gauge starts at zero at the beginning of an
+         interval and is increased when associated events occur, until
+         the end of the 1-day interval.  At that time, the value of the
+         gauge is stored in the previous 1-day history interval, as
+         defined in a companion object of type
+         Hdsl2Shdsl1DayIntevalCount, and the current interval gauge
+         is restarted at zero.
+
+         In the case where the agent has no valid data available for
+         this interval, the corresponding object instance is not
+         available, and upon a retrieval request, a corresponding error
+         message shall be returned to indicate that this instance does
+         not exist.  Please note that zero is a valid value."
+      SYNTAX  Gauge32
+
+   Hdsl2Shdsl1DayIntervalCount ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "A counter associated with interface performance measurements
+         during the most previous 1-day (24 hour) measurement interval.
+         The value of this gauge is equal to the value of the current
+         day gauge, as defined in a companion object of type
+         Hdsl2ShdslPerfCurrDayCount, at the end of its most recent
+         interval.
+
+         In the case where the agent has no valid data available for
+         this interval, the corresponding object instance is not
+         available, and upon a retrieval request, a corresponding error
+         message shall be returned to indicate that this instance does
+         not exist."
+      SYNTAX  Gauge32
+
+   Hdsl2ShdslPerfTimeElapsed ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "The number of seconds that have elapsed since the beginning of
+         the current measurement period.  If, for some reason, such as
+         an adjustment in the system's time-of-day clock or the addition
+         of a leap second, the current interval exceeds the maximum
+         value, the agent will return the maximum value.
+
+         For 15-minute intervals, the range is limited to (0..899).
+         For 24-hour intervals, the range is limited to (0..86399)."
+      SYNTAX    Unsigned32(0..86399)
+
+   Hdsl2ShdslPerfIntervalThreshold ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "This convention defines a range of values that may be set in
+         a fault threshold alarm control.  As the number of seconds in
+         a 15-minute interval numbers at most 900, objects of this type
+         may have a range of 0...900, where the value of 0 disables the
+         alarm."
+      SYNTAX    Unsigned32(0..900)
+
+   Hdsl2ShdslUnitId ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the unique identification for all units in an
+         HDSL2/SHDSL span.  It is based on the EOC unit addressing
+         scheme with reference to the xtuC."
+      SYNTAX    INTEGER
+              {
+              xtuC(1),
+              xtuR(2),
+              xru1(3),
+              xru2(4),
+              xru3(5),
+              xru4(6),
+              xru5(7),
+              xru6(8),
+              xru7(9),
+              xru8(10)
+              }
+
+   Hdsl2ShdslUnitSide ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the referenced side of an HDSL2/SHDSL unit - Network
+         or Customer side.  The side facing the Network is the Network
+         side, while the side facing the Customer is the Customer side."
+      SYNTAX    INTEGER
+              {
+              networkSide(1),
+              customerSide(2)
+              }
+
+   Hdsl2ShdslWirePair ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the referenced pair of wires in an HDSL2/SHDSL segment.
+         HDSL2 only supports a single pair (wirePair1 or two wire),
+         SHDSL lines support an optional second pair (wirePair2 or four
+         wire), and G.shdsl.bis support an optional third pair
+         (wirePair3 or six wire) and an optional fourth pair
+         (wirePair4 or eight wire)."
+      SYNTAX    INTEGER
+              {
+              wirePair1(1),    -- two wire
+              wirePair2(2),    -- four wire
+              wirePair3(3),    -- six wire
+              wirePair4(4)     -- eight wire
+              }
+
+   Hdsl2ShdslTransmissionModeType ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "Contains the regional setting of the HDSL2/SHDSL span,
+         represented as a bit-map of possible settings.  The various
+         bit positions are as follows:
+         Bit   Meaning      Description
+         1     region 1     Indicates ITU-T G.991.2 Annex A.
+         2     region 2     Indicates ITU-T G.991.2 Annex B."
+      SYNTAX      BITS
+              {
+              region1(0),
+              region2(1)
+              }
+
+   Hdsl2ShdslClockReferenceType ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "The various STU-C symbol clock references for the
+         HDSL2/SHDSL span, represented as an enumeration."
+      SYNTAX    INTEGER
+             {
+             localClk(1),          -- Mode-1 per G991.2
+             networkClk(2),        -- Mode-2 per G991.2
+             dataOrNetworkClk(3),  -- Mode-3a per G991.2
+             dataClk(4)            -- Mode-3b per G991.2
+             }
+
+   -- Span Configuration Group
+   --
+
+   hdsl2ShdslSpanConfTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslSpanConfEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+
+      DESCRIPTION
+        "This table supports overall configuration of HDSL2/SHDSL
+         spans.  Entries in this table MUST be maintained in a
+         persistent manner."
+      ::= { hdsl2ShdslMibObjects 1 }
+
+   hdsl2ShdslSpanConfEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslSpanConfTable.  Each entry
+         represents the complete span in a single HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the associated HDSL2/SHDSL
+         line."
+      INDEX { ifIndex }
+      ::= { hdsl2ShdslSpanConfTable 1 }
+
+   Hdsl2ShdslSpanConfEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslSpanConfNumRepeaters          Unsigned32,
+      hdsl2ShdslSpanConfProfile               SnmpAdminString,
+      hdsl2ShdslSpanConfAlarmProfile          SnmpAdminString
+      }
+
+      hdsl2ShdslSpanConfNumRepeaters OBJECT-TYPE
+      SYNTAX      Unsigned32(0..8)
+      UNITS       "repeaters"
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object provisions the number of repeaters/regenerators
+         in this HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanConfEntry 1 }
+
+   hdsl2ShdslSpanConfProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object is a pointer to a span configuration profile in
+         the hdsl2ShdslSpanConfProfileTable, which applies to this
+         span.  The value of this object is the index of the referenced
+         profile in the hdsl2ShdslSpanConfProfileTable.  Note that span
+         configuration profiles are only applicable to SHDSL lines.
+
+         HDSL2 lines MUST reference the default profile, 'DEFVAL'.
+         By default, this object will have the value 'DEFVAL'
+         (the index of the default profile).
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslSpanConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslSpanConfEntry 2 }
+
+   hdsl2ShdslSpanConfAlarmProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object is a pointer to an alarm configuration profile in
+         the hdsl2ShdslEndpointAlarmConfProfileTable.  The value of
+         this object is the index of the referenced profile in the
+         hdsl2ShdslEndpointAlarmConfProfileTable.  The alarm
+         threshold configuration in the referenced profile will be
+         used by default for all segment endpoints in this span.
+         Individual endpoints may override this profile by explicitly
+         specifying some other profile in the
+         hdsl2ShdslEndpointConfTable.  By default, this object will
+         have the value 'DEFVAL' (the index of the default
+         profile).
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslEndpointAlarmConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslSpanConfEntry 3 }
+
+   -- Span Status Group
+   --
+
+   hdsl2ShdslSpanStatusTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslSpanStatusEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+      DESCRIPTION
+        "This table provides overall status information of
+         HDSL2/SHDSL spans.  This table contains live data from
+         equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 2 }
+
+   hdsl2ShdslSpanStatusEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanStatusEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslSpanStatusTable.  Each entry
+         represents the complete span in a single HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the associated HDSL2/SHDSL
+         line."
+      INDEX { ifIndex }
+      ::= { hdsl2ShdslSpanStatusTable 1 }
+
+   Hdsl2ShdslSpanStatusEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslStatusNumAvailRepeaters        Unsigned32,
+      hdsl2ShdslStatusMaxAttainableLineRate    Unsigned32,
+      hdsl2ShdslStatusActualLineRate           Unsigned32,
+      hdsl2ShdslStatusTransmissionModeCurrent
+                           Hdsl2ShdslTransmissionModeType,
+      hdsl2ShdslStatusMaxAttainablePayloadRate Unsigned32,
+      hdsl2ShdslStatusActualPayloadRate        Unsigned32
+      }
+
+   hdsl2ShdslStatusNumAvailRepeaters OBJECT-TYPE
+      SYNTAX      Unsigned32(0..8)
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual number of repeaters/regenerators
+         discovered in this HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanStatusEntry 1 }
+
+   hdsl2ShdslStatusMaxAttainableLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the maximum attainable line rate in this HDSL2/SHDSL
+         span.  This object provides the maximum rate the line is
+         capable of achieving.  This is based upon measurements made
+         during line probing.  This rate includes payload (user data)
+         and any applicable framing overhead."
+      ::= { hdsl2ShdslSpanStatusEntry 2 }
+
+   hdsl2ShdslStatusActualLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual line rate in this HDSL2/SHDSL span.  This
+         SHOULD equal ifSpeed.  This rate includes payload (user data)
+         and any applicable framing overhead"
+      ::= { hdsl2ShdslSpanStatusEntry 3 }
+
+   hdsl2ShdslStatusTransmissionModeCurrent OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the current Power Spectral Density (PSD) regional
+         setting of the HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanStatusEntry 4 }
+
+   hdsl2ShdslStatusMaxAttainablePayloadRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the maximum attainable payload (user data)
+         line rate in this HDSL2/SHDSL span.  This object provides
+         the maximum rate the line is capable of achieving.  This
+         is based upon measurements made during line probing.  Any
+         framing overhead is not included."
+      ::= { hdsl2ShdslSpanStatusEntry 5 }
+
+   hdsl2ShdslStatusActualPayloadRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual line rate in this HDSL2/SHDSL span.  Any
+         framing overhead is not included."
+      ::= { hdsl2ShdslSpanStatusEntry 6 }
+
+   -- Unit Inventory Group
+   --
+
+   hdsl2ShdslInventoryTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslInventoryEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+      DESCRIPTION
+        "This table supports retrieval of unit inventory information
+         available via the EOC from units in an HDSL2/SHDSL line.
+
+         Entries in this table are dynamically created during the
+         line discovery process.  The life cycle for these entries
+         is as follows:
+
+            - xtu discovers a device, either a far-end xtu or an xru
+            - an inventory table entry is created for the device
+            - the line goes down for whatever reason
+            - inventory table entries for unreachable devices are
+              destroyed
+
+         As these entries are created/destroyed dynamically, they
+         are NOT persistent."
+      ::= { hdsl2ShdslMibObjects 3 }
+
+   hdsl2ShdslInventoryEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslInventoryEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslInventoryTable.  Each entry
+         represents inventory information for a single unit in an
+         HDSL2/SHDSL line.  It is indexed by the ifIndex of the
+         HDSL2/SHDSL line and the Hdsl2ShdslUnitId of the
+         associated unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex }
+      ::= { hdsl2ShdslInventoryTable 1 }
+
+   Hdsl2ShdslInventoryEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslInvIndex                      Hdsl2ShdslUnitId,
+      hdsl2ShdslInvVendorID                   OCTET STRING,
+      hdsl2ShdslInvVendorModelNumber          OCTET STRING,
+      hdsl2ShdslInvVendorSerialNumber         OCTET STRING,
+      hdsl2ShdslInvVendorEOCSoftwareVersion   Integer32,
+      hdsl2ShdslInvStandardVersion            Integer32,
+      hdsl2ShdslInvVendorListNumber           OCTET STRING,
+      hdsl2ShdslInvVendorIssueNumber          OCTET STRING,
+      hdsl2ShdslInvVendorSoftwareVersion      OCTET STRING,
+      hdsl2ShdslInvEquipmentCode              OCTET STRING,
+      hdsl2ShdslInvVendorOther                OCTET STRING,
+      hdsl2ShdslInvTransmissionModeCapability
+                            Hdsl2ShdslTransmissionModeType
+      }
+
+   hdsl2ShdslInvIndex OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitId
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry in this table corresponds to a physical element
+         in an HDSL2/SHDSL span.  It is based on the EOC unit addressing
+         scheme with reference to the xtuC."
+      ::= { hdsl2ShdslInventoryEntry 1 }
+
+   hdsl2ShdslInvVendorID OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(8))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor ID as reported in an Inventory Response message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 25-32."
+      ::= { hdsl2ShdslInventoryEntry 2 }
+
+   hdsl2ShdslInvVendorModelNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor model number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 33-44."
+      ::= { hdsl2ShdslInventoryEntry 3 }
+
+   hdsl2ShdslInvVendorSerialNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor serial number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 45-56."
+      ::= { hdsl2ShdslInventoryEntry 4 }
+
+   hdsl2ShdslInvVendorEOCSoftwareVersion OBJECT-TYPE
+      SYNTAX      Integer32
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor EOC version as reported in a Discovery Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.2, Discovery response - Message ID
+         129, Octet 12."
+      ::= { hdsl2ShdslInventoryEntry 5 }
+
+   hdsl2ShdslInvStandardVersion OBJECT-TYPE
+      SYNTAX      Integer32
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Version of the HDSL2/SHDSL standard implemented, as reported
+         in an Inventory Response message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octet 2."
+      ::= { hdsl2ShdslInventoryEntry 6 }
+
+   hdsl2ShdslInvVendorListNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(3))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor list number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 3-5."
+      ::= { hdsl2ShdslInventoryEntry 7 }
+
+   hdsl2ShdslInvVendorIssueNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(2))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor issue number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 6-7."
+      ::= { hdsl2ShdslInventoryEntry 8 }
+
+   hdsl2ShdslInvVendorSoftwareVersion OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(6))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor software version as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 8-13."
+      ::= { hdsl2ShdslInventoryEntry 9 }
+
+   hdsl2ShdslInvEquipmentCode OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(10))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Equipment code conforming to ANSI T1.213, Coded Identification
+         of Equipment Entities."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 14-23."
+      ::= { hdsl2ShdslInventoryEntry 10 }
+
+   hdsl2ShdslInvVendorOther OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Other vendor information as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 57-68."
+      ::= { hdsl2ShdslInventoryEntry 11 }
+
+   hdsl2ShdslInvTransmissionModeCapability OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the transmission mode capability of the SHDSL unit."
+      ::= { hdsl2ShdslInventoryEntry 12 }
+
+   -- Segment Endpoint Configuration Group
+   --
+
+   hdsl2ShdslEndpointConfTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports configuration parameters for segment
+         endpoints in an HDSL2/SHDSL line.  As this table is indexed
+         by ifIndex, it MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 4 }
+
+   hdsl2ShdslEndpointConfEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointConfTable.  Each entry
+         represents a single segment endpoint in an HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the HDSL2/SHDSL line, the
+         UnitId of the associated unit, the side of the unit, and the
+         wire pair of the associated modem."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair}
+      ::= { hdsl2ShdslEndpointConfTable 1 }
+
+   Hdsl2ShdslEndpointConfEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointSide                   Hdsl2ShdslUnitSide,
+      hdsl2ShdslEndpointWirePair               Hdsl2ShdslWirePair,
+      hdsl2ShdslEndpointAlarmConfProfile       SnmpAdminString
+      }
+
+   hdsl2ShdslEndpointSide OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitSide
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "The side of the unit associated with this segment endpoint --
+         Network/Customer side -- as per the Hdsl2ShdslUnitSide textual
+         convention."
+      ::= { hdsl2ShdslEndpointConfEntry 1 }
+
+   hdsl2ShdslEndpointWirePair OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslWirePair
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "The wire pair of the modem associated with this segment
+         endpoint as per the Hdsl2ShdslWirePair textual convention."
+      ::= { hdsl2ShdslEndpointConfEntry 2 }
+
+   hdsl2ShdslEndpointAlarmConfProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(0..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the alarm threshold values to be used
+         for this segment endpoint.  The values are obtained from the
+         alarm configuration profile referenced by this object.  The
+         value of this object is the index of the referenced profile in
+         the hdsl2ShdslEndpointAlarmConfProfileTable, or NULL (a
+         zero-length SnmpAdminString).  If the value is a zero-length
+         SnmpAdminString, the endpoint uses the default Alarm
+         Configuration Profile for the associated span as per the
+         hdsl2ShdslSpanConfAlarmProfile object in the
+         hdsl2ShdslSpanConfTable.  The default value of this object is
+         a zero-length SnmpAdminString.
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslEndpointAlarmConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslEndpointConfEntry 3 }
+
+   -- Segment Endpoint Current Status/Performance Group
+   --
+   hdsl2ShdslEndpointCurrTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointCurrEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table contains current status and performance information
+         for segment endpoints in HDSL2/SHDSL lines.  As with other
+         tables in this MIB module indexed by ifIndex, entries in this
+         table MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 5 }
+
+   hdsl2ShdslEndpointCurrEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointCurrEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointCurrTable.  Each entry
+         contains status and performance information relating to a
+         single segment endpoint.  It is indexed by the ifIndex of the
+         HDSL2/SHDSL line, the UnitId of the associated unit, the side
+         of the unit, and the wire pair of the associated modem."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair }
+      ::= { hdsl2ShdslEndpointCurrTable 1 }
+
+   Hdsl2ShdslEndpointCurrEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointCurrAtn                Integer32,
+      hdsl2ShdslEndpointCurrSnrMgn             Integer32,
+      hdsl2ShdslEndpointCurrStatus             BITS,
+      hdsl2ShdslEndpointES                     Counter32,
+      hdsl2ShdslEndpointSES                    Counter32,
+      hdsl2ShdslEndpointCRCanomalies           Counter32,
+      hdsl2ShdslEndpointLOSWS                  Counter32,
+      hdsl2ShdslEndpointUAS                    Counter32,
+      hdsl2ShdslEndpointCurr15MinTimeElapsed
+                               Hdsl2ShdslPerfTimeElapsed,
+      hdsl2ShdslEndpointCurr15MinES            PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinSES           PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinCRCanomalies  PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinLOSWS         PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinUAS           PerfCurrentCount,
+      hdsl2ShdslEndpointCurr1DayTimeElapsed
+                                      Hdsl2ShdslPerfTimeElapsed,
+      hdsl2ShdslEndpointCurr1DayES
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DaySES
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayCRCanomalies
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayLOSWS
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayUAS
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurrTipRingReversal    INTEGER,
+      hdsl2ShdslEndpointCurrActivationState    INTEGER
+      }
+
+   hdsl2ShdslEndpointCurrAtn OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "The current loop attenuation for this endpoint as reported in
+         a Network or Customer Side Performance Status message."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 1 }
+
+   hdsl2ShdslEndpointCurrSnrMgn OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "The current SNR margin for this endpoint as reported in a
+         Status Response/SNR message."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 2 }
+
+   hdsl2ShdslEndpointCurrStatus OBJECT-TYPE
+      SYNTAX      BITS
+                  {
+                  noDefect(0),
+                  powerBackoff(1),
+                  deviceFault(2),
+                  dcContinuityFault(3),
+                  snrMarginAlarm(4),
+                  loopAttenuationAlarm(5),
+                  loswFailureAlarm(6),
+                  configInitFailure(7),
+                  protocolInitFailure(8),
+                  noNeighborPresent(9),
+                  loopbackActive(10)
+                  }
+
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the current state of the endpoint.  This is a
+         bit-map of possible conditions.  The various bit positions
+         are as follows:
+
+         noDefect               There are no defects on the line.
+
+         powerBackoff           Indicates enhanced Power Backoff.
+
+         deviceFault            Indicates that a vendor-dependent
+                                diagnostic or self-test fault
+                                has been detected.
+
+         dcContinuityFault      Indicates vendor-dependent
+                                conditions that interfere with
+                                span powering such as short and
+                                open circuits.
+
+         snrMarginAlarm         Indicates that the SNR margin
+                                has dropped below the alarm threshold.
+
+         loopAttenuationAlarm   Indicates that the loop attenuation
+                                exceeds the alarm threshold.
+
+         loswFailureAlarm       Indicates a forward LOSW alarm.
+
+         configInitFailure      Endpoint failure during initialization
+                                due to paired endpoint not able to
+                                support requested configuration.
+
+         protocolInitFailure    Endpoint failure during initialization
+                                due to incompatible protocol used by
+                                the paired endpoint.
+
+         noNeighborPresent      Endpoint failure during initialization
+                                due to no activation sequence detected
+                                from paired endpoint.
+
+         loopbackActive         A loopback is currently active at this
+                                segment endpoint.
+
+         This is intended to supplement ifOperStatus.  Note that there
+         is a 1:1 relationship between the status bits defined in this
+         object and the notification thresholds defined elsewhere in
+         this MIB module."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 3 }
+
+   hdsl2ShdslEndpointES OBJECT-TYPE
+      SYNTAX      Counter32
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) on this endpoint since the xU
+         was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 4 }
+
+   hdsl2ShdslEndpointSES OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) on this endpoint
+         since the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 5 }
+
+   hdsl2ShdslEndpointCRCanomalies OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies on this endpoint since the xU was
+         last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 6 }
+
+   hdsl2ShdslEndpointLOSWS OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds on this endpoint
+         since the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 7 }
+
+   hdsl2ShdslEndpointUAS OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) on this endpoint since
+         the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 8 }
+
+   hdsl2ShdslEndpointCurr15MinTimeElapsed OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Total elapsed seconds in the current 15-minute interval."
+      ::= { hdsl2ShdslEndpointCurrEntry 9 }
+
+   hdsl2ShdslEndpointCurr15MinES OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) in the current 15-minute
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 10 }
+
+   hdsl2ShdslEndpointCurr15MinSES OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) in the current
+         15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 11 }
+
+   hdsl2ShdslEndpointCurr15MinCRCanomalies OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies in the current 15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 12 }
+
+   hdsl2ShdslEndpointCurr15MinLOSWS OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds in the current
+         15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 13 }
+
+   hdsl2ShdslEndpointCurr15MinUAS OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) in the current 15-minute
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 14 }
+
+   hdsl2ShdslEndpointCurr1DayTimeElapsed OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Number of seconds that have elapsed since the beginning of
+         the current 1-day interval."
+      ::= { hdsl2ShdslEndpointCurrEntry 15 }
+
+   hdsl2ShdslEndpointCurr1DayES OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the current day as
+         measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 16 }
+
+   hdsl2ShdslEndpointCurr1DaySES OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the current
+         day as measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 17 }
+
+   hdsl2ShdslEndpointCurr1DayCRCanomalies OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies during the current day as measured
+         by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 18 }
+
+   hdsl2ShdslEndpointCurr1DayLOSWS OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the current
+         day as measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 19 }
+
+   hdsl2ShdslEndpointCurr1DayUAS OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the current day as
+         measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 20 }
+
+   hdsl2ShdslEndpointCurrTipRingReversal OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  normal(1),
+                  reversed(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the state of the tip/ring for the
+         wire pair."
+      ::= { hdsl2ShdslEndpointCurrEntry 21 }
+
+   hdsl2ShdslEndpointCurrActivationState OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  preActivation(1),  -- PreTrain
+                  activation(2),     -- Training
+                  data(3)            -- Trained
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the activation or training state of
+         the wire pair."
+      REFERENCE   "ITU-T G.991.2, Section 6.2 PMD Activation Sequence"
+      ::= { hdsl2ShdslEndpointCurrEntry 22 }
+
+   -- Segment Endpoint 15-Minute Interval Status/Performance Group
+   --
+
+   hdsl2Shdsl15MinIntervalTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2Shdsl15MinIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table provides one row for each HDSL2/SHDSL endpoint
+         performance data collection interval.  This table contains
+         live data from equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 6 }
+
+   hdsl2Shdsl15MinIntervalEntry OBJECT-TYPE
+      SYNTAX      Hdsl2Shdsl15MinIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2Shdsl15MinIntervalTable."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair, hdsl2Shdsl15MinIntervalNumber}
+      ::= { hdsl2Shdsl15MinIntervalTable 1 }
+
+   Hdsl2Shdsl15MinIntervalEntry ::=
+      SEQUENCE
+      {
+      hdsl2Shdsl15MinIntervalNumber         Unsigned32,
+      hdsl2Shdsl15MinIntervalES             PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalSES            PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalCRCanomalies   PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalLOSWS          PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalUAS            PerfIntervalCount
+      }
+
+   hdsl2Shdsl15MinIntervalNumber OBJECT-TYPE
+      SYNTAX      Unsigned32(1..96)
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Performance Data Interval number.  Interval 1 is the most
+         recent previous interval; interval 96 is 24 hours ago.
+         Intervals 2..96 are optional."
+      ::= { hdsl2Shdsl15MinIntervalEntry 1 }
+
+   hdsl2Shdsl15MinIntervalES OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 2 }
+
+   hdsl2Shdsl15MinIntervalSES OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 3 }
+
+   hdsl2Shdsl15MinIntervalCRCanomalies OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "detected CRC Anomalies"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of CRC anomalies during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 4 }
+
+   hdsl2Shdsl15MinIntervalLOSWS OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 5 }
+
+   hdsl2Shdsl15MinIntervalUAS OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 6 }
+
+   -- Segment Endpoint 1-Day Interval Status/Performance Group
+   --
+
+   hdsl2Shdsl1DayIntervalTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2Shdsl1DayIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table provides one row for each HDSL2/SHDSL endpoint
+         performance data collection interval.  This table contains
+         live data from equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 7 }
+
+   hdsl2Shdsl1DayIntervalEntry OBJECT-TYPE
+      SYNTAX      Hdsl2Shdsl1DayIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2Shdsl1DayIntervalTable."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair, hdsl2Shdsl1DayIntervalNumber }
+      ::= { hdsl2Shdsl1DayIntervalTable 1 }
+
+   Hdsl2Shdsl1DayIntervalEntry ::=
+      SEQUENCE
+      {
+      hdsl2Shdsl1DayIntervalNumber         Unsigned32,
+      hdsl2Shdsl1DayIntervalMoniSecs       Hdsl2ShdslPerfTimeElapsed,
+      hdsl2Shdsl1DayIntervalES             Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalSES            Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalCRCanomalies   Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalLOSWS          Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalUAS            Hdsl2Shdsl1DayIntervalCount
+      }
+
+   hdsl2Shdsl1DayIntervalNumber OBJECT-TYPE
+      SYNTAX      Unsigned32(1..30)
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "History Data Interval number.  Interval 1 is the most
+         recent previous day; interval 30 is 30 days ago.  Intervals
+         2..30 are optional."
+      ::= { hdsl2Shdsl1DayIntervalEntry 1 }
+
+   hdsl2Shdsl1DayIntervalMoniSecs OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "The amount of time in the 1-day interval over which the
+         performance monitoring information is actually counted.
+         This value will be the same as the interval duration except
+         in a situation where performance monitoring data could not
+         be collected for any reason."
+      ::= { hdsl2Shdsl1DayIntervalEntry 2 }
+
+   hdsl2Shdsl1DayIntervalES OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the 1-day interval as
+         measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 3 }
+
+   hdsl2Shdsl1DayIntervalSES OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the 1-day
+         interval as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 4 }
+
+   hdsl2Shdsl1DayIntervalCRCanomalies OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies during the 1-day interval as
+         measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 5 }
+
+   hdsl2Shdsl1DayIntervalLOSWS OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the 1-day
+         interval as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 6 }
+
+   hdsl2Shdsl1DayIntervalUAS OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the 1-day interval
+         as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 7 }
+
+   -- Maintenance Group
+   --
+
+   hdsl2ShdslEndpointMaintTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports maintenance operations (e.g., loopbacks)
+         to be performed on HDSL2/SHDSL segment endpoints.  This table
+         contains live data from equipment.  As such, it is NOT
+         persistent."
+      ::= { hdsl2ShdslMibObjects 8 }
+
+   hdsl2ShdslEndpointMaintEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointMaintTable.  Each entry
+         corresponds to a single segment endpoint and is indexed by the
+         ifIndex of the HDSL2/SHDSL line, the UnitId of the associated
+         unit, and the side of the unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide }
+      ::= { hdsl2ShdslEndpointMaintTable 1 }
+
+   Hdsl2ShdslEndpointMaintEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslMaintLoopbackConfig      INTEGER,
+      hdsl2ShdslMaintTipRingReversal     INTEGER,
+      hdsl2ShdslMaintPowerBackOff        INTEGER,
+      hdsl2ShdslMaintSoftRestart         INTEGER
+      }
+
+   hdsl2ShdslMaintLoopbackConfig OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  noLoopback(1),
+                  normalLoopback(2),
+                  specialLoopback(3)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object controls configuration of loopbacks for the
+         associated segment endpoint.  The status of the loopback
+         is obtained via the hdsl2ShdslEndpointCurrStatus object."
+      ::= { hdsl2ShdslEndpointMaintEntry 1 }
+
+   hdsl2ShdslMaintTipRingReversal OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  normal(1),
+                  reversed(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the state of the tip/ring pair at the
+         associated segment endpoint."
+      ::= { hdsl2ShdslEndpointMaintEntry 2 }
+
+   hdsl2ShdslMaintPowerBackOff OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  default(1),
+                  enhanced(2)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the receiver at the associated
+         segment endpoint to operate in default or enhanced power
+         backoff mode."
+      ::= { hdsl2ShdslEndpointMaintEntry 3 }
+
+   hdsl2ShdslMaintSoftRestart OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  ready(1),
+                  restart(2)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object enables the manager to trigger a soft restart
+         of the modem at the associated segment endpoint.  The
+         manager may only set this object to the 'restart(2)'
+         value, which initiates a restart.  The agent will perform a
+         restart after approximately 5 seconds.  Following the 5 second
+         period, the agent will restore the object to the 'ready(1)'
+         state."
+      ::= { hdsl2ShdslEndpointMaintEntry 4 }
+
+   hdsl2ShdslUnitMaintTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslUnitMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports maintenance operations for units in a
+         HDSL2/SHDSL line.  Entries in this table MUST be maintained
+         in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 9 }
+
+   hdsl2ShdslUnitMaintEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslUnitMaintTable.  Each entry
+         corresponds to a single unit and is indexed by the
+         ifIndex of the HDSL2/SHDSL line and the UnitId of the
+         associated unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex  }
+      ::= { hdsl2ShdslUnitMaintTable 1 }
+
+   Hdsl2ShdslUnitMaintEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslMaintLoopbackTimeout     Integer32,
+      hdsl2ShdslMaintUnitPowerSource     INTEGER
+      }
+
+   hdsl2ShdslMaintLoopbackTimeout OBJECT-TYPE
+      SYNTAX      Integer32(0..4095)
+      UNITS       "minutes"
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the timeout value for loopbacks
+         initiated at segments endpoints contained in the associated
+         unit.  A value of 0 disables the timeout."
+      ::= { hdsl2ShdslUnitMaintEntry 1 }
+
+   hdsl2ShdslMaintUnitPowerSource OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  local(1),
+                  span(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the DC power source being used by the
+         associated unit."
+      ::= { hdsl2ShdslUnitMaintEntry 2 }
+
+   -- Span Configuration Profile Group
+   --
+
+   hdsl2ShdslSpanConfProfileTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslSpanConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports definitions of span configuration
+         profiles for SHDSL lines.  HDSL2 does not support these
+         configuration options.  This table MUST be maintained
+         in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 10 }
+
+   hdsl2ShdslSpanConfProfileEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry corresponds to a single span configuration
+         profile.  Each profile contains a set of span configuration
+         parameters.  The configuration parameters in a profile are
+         applied to those lines referencing that profile (see the
+         hdsl2ShdslSpanConfProfile object).  Profiles may be
+         created/deleted using the row creation/deletion mechanism
+         via hdsl2ShdslSpanConfProfileRowStatus.  If an active
+         entry is referenced in hdsl2ShdslSpanConfProfile, the
+         entry MUST remain active until all references are removed."
+      INDEX { IMPLIED hdsl2ShdslSpanConfProfileName }
+      ::= { hdsl2ShdslSpanConfProfileTable 1 }
+
+   Hdsl2ShdslSpanConfProfileEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslSpanConfProfileName               SnmpAdminString,
+      hdsl2ShdslSpanConfWireInterface             INTEGER,
+      hdsl2ShdslSpanConfMinLineRate               Unsigned32,
+      hdsl2ShdslSpanConfMaxLineRate               Unsigned32,
+      hdsl2ShdslSpanConfPSD                       INTEGER,
+      hdsl2ShdslSpanConfTransmissionMode
+                              Hdsl2ShdslTransmissionModeType,
+      hdsl2ShdslSpanConfRemoteEnabled             INTEGER,
+      hdsl2ShdslSpanConfPowerFeeding              INTEGER,
+      hdsl2ShdslSpanConfCurrCondTargetMarginDown  Integer32,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginDown Integer32,
+      hdsl2ShdslSpanConfCurrCondTargetMarginUp    Integer32,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginUp   Integer32,
+      hdsl2ShdslSpanConfUsedTargetMargins         BITS,
+      hdsl2ShdslSpanConfReferenceClock
+                                Hdsl2ShdslClockReferenceType,
+      hdsl2ShdslSpanConfLineProbeEnable           INTEGER,
+      hdsl2ShdslSpanConfProfileRowStatus          RowStatus
+      }
+
+   hdsl2ShdslSpanConfProfileName OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This object is the unique index associated with this profile.
+         Entries in this table are referenced via the object
+         hdsl2ShdslSpanConfProfile in Hdsl2ShdslSpanConfEntry."
+      ::= { hdsl2ShdslSpanConfProfileEntry 1 }
+
+   hdsl2ShdslSpanConfWireInterface OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  twoWire(1),
+                  fourWire(2),
+                  sixWire(3),
+                  eightWire(4)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the two-wire or optional four-wire,
+         six-wire, or eight-wire operation for SHDSL lines."
+      DEFVAL      { twoWire }
+      ::= { hdsl2ShdslSpanConfProfileEntry 2 }
+
+   hdsl2ShdslSpanConfMinLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the minimum transmission rate for
+         the associated SHDSL Line in bits-per-second (bps) and includes
+         both payload (user data) and any applicable framing overhead.
+         If the minimum line rate equals the maximum line rate
+         (hdsl2ShdslSpanMaxLineRate), the line rate is considered
+         'fixed'.  If the minimum line rate is less than the
+         maximum line rate, the line rate is considered
+         'rate-adaptive'."
+      DEFVAL      { 1552000 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 3 }
+
+   hdsl2ShdslSpanConfMaxLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the maximum transmission rate for
+         the associated SHDSL Line in bits-per-second (bps) and includes
+         both payload (user data) and any applicable framing overhead.
+         If the minimum line rate equals the maximum line rate
+         (hdsl2ShdslSpanMaxLineRate), the line rate is considered
+         'fixed'.  If the minimum line rate is less than the
+         maximum line rate, the line rate is considered
+         'rate-adaptive'."
+      DEFVAL      { 1552000 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 4 }
+
+   hdsl2ShdslSpanConfPSD OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  symmetric(1),
+                  asymmetric(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures use of symmetric/asymmetric PSD (Power
+         Spectral Density) Mask for the associated SHDSL Line.  Support
+         for symmetric PSD is mandatory for all supported data rates.
+         Support for asymmetric PSD is optional."
+      DEFVAL      { symmetric }
+      ::= { hdsl2ShdslSpanConfProfileEntry 5 }
+
+   hdsl2ShdslSpanConfTransmissionMode OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the regional setting for the SHDSL
+         line."
+      DEFVAL      { { region1 } }
+      ::= { hdsl2ShdslSpanConfProfileEntry 6 }
+
+   hdsl2ShdslSpanConfRemoteEnabled OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  enabled(1),
+                  disabled(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for remote management
+         of the units in an SHDSL line from the STU-R via the EOC."
+
+      DEFVAL      { enabled }
+      ::= { hdsl2ShdslSpanConfProfileEntry 7 }
+
+   hdsl2ShdslSpanConfPowerFeeding OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  noPower(1),
+                  powerFeed(2),
+                  wettingCurrent(3)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for optional power
+         feeding in an SHDSL line."
+      DEFVAL      { noPower }
+      ::= { hdsl2ShdslSpanConfProfileEntry 8 }
+
+   hdsl2ShdslSpanConfCurrCondTargetMarginDown OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the downstream current condition target
+         SNR margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 9 }
+
+   hdsl2ShdslSpanConfWorstCaseTargetMarginDown OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the downstream worst-case target SNR
+         margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR
+         margin is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 10 }
+
+   hdsl2ShdslSpanConfCurrCondTargetMarginUp OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the upstream current-condition target
+         SNR margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 11 }
+
+   hdsl2ShdslSpanConfWorstCaseTargetMarginUp OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the upstream worst-case target SNR
+         margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 12 }
+
+   hdsl2ShdslSpanConfUsedTargetMargins OBJECT-TYPE
+      SYNTAX      BITS
+                  {
+                  currCondDown(0),
+                  worstCaseDown(1),
+                  currCondUp(2),
+                  worstCaseUp(3)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "Indicates whether a target SNR margin is enabled or
+         disabled.  This is a bit-map of possible settings.  The
+         various bit positions are as follows:
+
+         currCondDown   - current-condition downstream target SNR
+                          margin enabled
+
+         worstCaseDown  - worst-case downstream target SNR margin
+                          enabled
+
+         currCondUp     - current-condition upstream target SNR
+                          margin enabled
+
+         worstCaseUp    - worst-case upstream target SNR margin
+                          enabled."
+
+      DEFVAL      { { currCondDown } }
+      ::= { hdsl2ShdslSpanConfProfileEntry 13 }
+
+   hdsl2ShdslSpanConfReferenceClock OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslClockReferenceType
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the clock reference for the STU-C
+         in an SHDSL Line."
+      DEFVAL      { localClk }
+      ::= { hdsl2ShdslSpanConfProfileEntry 14 }
+
+   hdsl2ShdslSpanConfLineProbeEnable OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  disable(1),
+                  enable(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for Line Probe of
+         the units in an SHDSL line.  When Line Probe is enabled, the
+         system performs Line Probing to find the best possible
+         rate.  If Line Probe is disabled, the rate adaptation phase
+         is skipped to shorten set up time."
+      DEFVAL      { disable }
+      ::= { hdsl2ShdslSpanConfProfileEntry 15 }
+
+   hdsl2ShdslSpanConfProfileRowStatus OBJECT-TYPE
+      SYNTAX      RowStatus
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object controls creation/deletion of the associated
+         entry in this table per the semantics of RowStatus.  If an
+         active entry is referenced in hdsl2ShdslSpanConfProfile, the
+         entry MUST remain active until all references are removed."
+      ::= { hdsl2ShdslSpanConfProfileEntry 16 }
+
+   -- Segment Endpoint Alarm Configuration Profile group
+   --
+
+   hdsl2ShdslEndpointAlarmConfProfileTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointAlarmConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports definitions of alarm configuration
+         profiles for HDSL2/SHDSL segment endpoints.  This table
+         MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 11 }
+
+   hdsl2ShdslEndpointAlarmConfProfileEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointAlarmConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry corresponds to a single alarm configuration profile.
+         Each profile contains a set of parameters for setting alarm
+         thresholds for various performance attributes monitored at
+         HDSL2/SHDSL segment endpoints.  Profiles may be created/deleted
+         using the row creation/deletion mechanism via
+         hdsl2ShdslEndpointAlarmConfProfileRowStatus.  If an active
+         entry is referenced in either hdsl2ShdslSpanConfAlarmProfile
+         or hdsl2ShdslEndpointAlarmConfProfile, the entry MUST remain
+         active until all references are removed."
+      INDEX { IMPLIED hdsl2ShdslEndpointAlarmConfProfileName }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileTable 1 }
+
+   Hdsl2ShdslEndpointAlarmConfProfileEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointAlarmConfProfileName       SnmpAdminString,
+      hdsl2ShdslEndpointThreshLoopAttenuation      Integer32,
+      hdsl2ShdslEndpointThreshSNRMargin            Integer32,
+      hdsl2ShdslEndpointThreshES
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshSES
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshCRCanomalies         Integer32,
+      hdsl2ShdslEndpointThreshLOSWS
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshUAS
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointAlarmConfProfileRowStatus  RowStatus
+      }
+
+   hdsl2ShdslEndpointAlarmConfProfileName OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This object is the unique index associated with this profile."
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 1 }
+
+   hdsl2ShdslEndpointThreshLoopAttenuation OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the loop attenuation alarm threshold.
+         When the current value of hdsl2ShdslEndpointCurrAtn reaches
+         or exceeds this threshold, an hdsl2ShdslLoopAttenCrossing
+         MAY be generated."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 2 }
+
+   hdsl2ShdslEndpointThreshSNRMargin OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the SNR margin alarm threshold.
+         When the current value of hdsl2ShdslEndpointCurrSnrMgn
+         reaches or drops below this threshold, a
+         hdsl2ShdslSNRMarginCrossing MAY be generated."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 3 }
+
+   hdsl2ShdslEndpointThreshES OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Errored Seconds (ES) within any given 15-minute performance
+         data collection interval.  If the value of Errored Seconds
+         in a particular 15-minute collection interval reaches/
+         exceeds this value, an hdsl2ShdslPerfESThresh MAY be
+         generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 4 }
+
+   hdsl2ShdslEndpointThreshSES OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Severely Errored Seconds (SES) within any given 15-minute
+         performance data collection interval.  If the value of
+         Severely Errored Seconds in a particular 15-minute collection
+         interval reaches/exceeds this value, an hdsl2ShdslPerfSESThresh
+         MAY be generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 5 }
+
+   hdsl2ShdslEndpointThreshCRCanomalies OBJECT-TYPE
+      SYNTAX      Integer32
+      UNITS       "detected CRC Anomalies"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         CRC anomalies within any given 15-minute performance data
+         collection interval.  If the value of CRC anomalies in a
+         particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfCRCanomaliesThresh MAY be
+         generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 6 }
+
+   hdsl2ShdslEndpointThreshLOSWS OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Loss of Sync Word (LOSW) Seconds within any given 15-minute
+         performance data collection interval.  If the value of LOSW
+         in a particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfLOSWSThresh MAY be generated.
+         At most, one notification will be sent per interval per
+         endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 7 }
+
+   hdsl2ShdslEndpointThreshUAS OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Unavailable Seconds (UAS) within any given 15-minute
+         performance data collection interval.  If the value of UAS
+         in a particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfUASThresh MAY be generated.
+         At most, one notification will be sent per interval per
+         endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 8 }
+
+   hdsl2ShdslEndpointAlarmConfProfileRowStatus OBJECT-TYPE
+      SYNTAX      RowStatus
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object controls creation/deletion of the associated
+         entry in this table as per the semantics of RowStatus.
+         If an active entry is referenced in either
+         hdsl2ShdslSpanConfAlarmProfile or
+         hdsl2ShdslEndpointAlarmConfProfile, the entry MUST remain
+         active until all references are removed."
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 9 }
+
+   -- Notifications Group
+   --
+
+   hdsl2ShdslNotifications OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 0 }
+
+   hdsl2ShdslLoopAttenCrossing NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn,
+      hdsl2ShdslEndpointThreshLoopAttenuation
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the loop attenuation
+         threshold (as per the hdsl2ShdslEndpointThreshLoopAttenuation
+         value) has been reached/exceeded for the HDSL2/SHDSL segment
+         endpoint."
+      ::= { hdsl2ShdslNotifications 1 }
+
+   hdsl2ShdslSNRMarginCrossing NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrSnrMgn,
+      hdsl2ShdslEndpointThreshSNRMargin
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the SNR margin threshold (as
+         per the hdsl2ShdslEndpointThreshSNRMargin value) has been
+         reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 2 }
+
+   hdsl2ShdslPerfESThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinES,
+      hdsl2ShdslEndpointThreshES
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the errored seconds
+         threshold (as per the hdsl2ShdslEndpointThreshES value)
+         has been reached/exceeded for the HDSL2/SHDSL segment
+         endpoint."
+      ::= { hdsl2ShdslNotifications 3 }
+
+   hdsl2ShdslPerfSESThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinSES,
+      hdsl2ShdslEndpointThreshSES
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the severely errored seconds
+         threshold (as per the hdsl2ShdslEndpointThreshSES value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 4 }
+
+   hdsl2ShdslPerfCRCanomaliesThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinCRCanomalies,
+      hdsl2ShdslEndpointThreshCRCanomalies
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the CRC anomalies threshold
+         (as per the hdsl2ShdslEndpointThreshCRCanomalies value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 5 }
+
+   hdsl2ShdslPerfLOSWSThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinLOSWS,
+      hdsl2ShdslEndpointThreshLOSWS
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the LOSW Seconds threshold
+         (as per the hdsl2ShdslEndpointThreshLOSWS value) has been
+         reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 6 }
+
+   hdsl2ShdslPerfUASThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinUAS,
+      hdsl2ShdslEndpointThreshUAS
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the unavailable seconds
+         threshold (as per the hdsl2ShdslEndpointThreshUAS value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 7 }
+
+   hdsl2ShdslSpanInvalidNumRepeaters NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfNumRepeaters
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that a mismatch has been detected
+         between the number of repeater/regenerator units configured
+         for an HDSL2/SHDSL line via the hdsl2ShdslSpanConfNumRepeaters
+         object and the actual number of repeater/regenerator units
+         discovered via the EOC."
+      ::= { hdsl2ShdslNotifications 8 }
+
+   hdsl2ShdslLoopbackFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslMaintLoopbackConfig
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that an endpoint maintenance
+         loopback command failed for an HDSL2/SHDSL segment."
+      ::= { hdsl2ShdslNotifications 9 }
+
+   hdsl2ShdslpowerBackoff NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         powerBackoff in the hdsl2ShdslEndpointCurrStatus object for
+         this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 10 }
+
+   hdsl2ShdsldeviceFault NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         deviceFault in the hdsl2ShdslEndpointCurrStatus object for
+         this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 11 }
+
+   hdsl2ShdsldcContinuityFault NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         dcContinuityFault in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 12 }
+
+   hdsl2ShdslconfigInitFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         configInitFailure in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 13 }
+
+   hdsl2ShdslprotocolInitFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         protocolInitFailure in the hdsl2ShdslEndpointCurrStatus
+         object for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 14 }
+
+   hdsl2ShdslnoNeighborPresent NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         noNeighborPresent in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 15 }
+
+   hdsl2ShdslLocalPowerLoss NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslInvVendorID
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates impending unit failure due to
+         loss of local power (last gasp)."
+      ::= { hdsl2ShdslNotifications 16 }
+
+   -- conformance information
+   --
+
+   hdsl2ShdslConformance OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 3 }
+   hdsl2ShdslGroups      OBJECT IDENTIFIER ::=
+                { hdsl2ShdslConformance 1 }
+   hdsl2ShdslCompliances OBJECT IDENTIFIER ::=
+                { hdsl2ShdslConformance 2 }
+
+   -- agent compliance statements
+   hdsl2ShdslLineMibCompliance MODULE-COMPLIANCE
+      STATUS  deprecated
+      DESCRIPTION
+        "The compliance statement for SNMP entities that implement
+        HDSL2 and SHDSL.  The version of SHDSL supported in this
+        compliance statement is g.shdsl.
+
+        **** This compliance statement is deprecated. ****"
+      MODULE
+      MANDATORY-GROUPS
+      {
+      hdsl2ShdslSpanConfGroup,
+      hdsl2ShdslSpanStatusGroup,
+      hdsl2ShdslInventoryGroup,
+      hdsl2ShdslEndpointConfGroup,
+      hdsl2ShdslEndpointCurrGroup,
+      hdsl2Shdsl15MinIntervalGroup,
+      hdsl2Shdsl1DayIntervalGroup,
+      hdsl2ShdslMaintenanceGroup,
+      hdsl2ShdslEndpointAlarmConfGroup,
+      hdsl2ShdslNotificationGroup
+      }
+
+   GROUP  hdsl2ShdslInventoryShdslGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanShdslStatusGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanConfProfileGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   OBJECT hdsl2ShdslSpanConfWireInterface
+      SYNTAX      INTEGER
+                  {
+                  twoWire(1),
+                  fourWire(2)
+                  }
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslStatusMaxAttainableLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslStatusActualLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslSpanConfMinLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslSpanConfMaxLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+      ::= { hdsl2ShdslCompliances 1 }
+
+   hdsl2GshdslbisLineMibCompliance MODULE-COMPLIANCE
+      STATUS  current
+      DESCRIPTION
+        "The compliance statement for SNMP entities that implement
+        HDSL2 and SHDSL.  The version of SHDSL supported in this
+        compliance statement is g.shdsl.bis."
+      MODULE
+      MANDATORY-GROUPS
+      {
+      hdsl2ShdslSpanConfGroup,
+      hdsl2ShdslSpanStatusGroup,
+      hdsl2ShdslInventoryGroup,
+      hdsl2ShdslEndpointConfGroup,
+      hdsl2ShdslEndpointCurrGroup,
+      hdsl2Shdsl15MinIntervalGroup,
+      hdsl2Shdsl1DayIntervalGroup,
+      hdsl2ShdslMaintenanceGroup,
+      hdsl2ShdslEndpointAlarmConfGroup,
+      hdsl2ShdslNotificationGroup
+      }
+
+   GROUP  hdsl2ShdslInventoryShdslGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanShdslStatusGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanConfProfileGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP hdsl2ShdslWirePairGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP hdsl2ShdslPayloadRateGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+      ::= { hdsl2ShdslCompliances 2 }
+
+   -- units of conformance
+   --
+
+   hdsl2ShdslSpanConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfNumRepeaters,
+      hdsl2ShdslSpanConfProfile,
+      hdsl2ShdslSpanConfAlarmProfile
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for configuring span-related
+         parameters for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 1 }
+
+   hdsl2ShdslSpanStatusGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusNumAvailRepeaters
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving span-related
+         status for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 2 }
+
+   hdsl2ShdslInventoryShdslGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslInvTransmissionModeCapability
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving SHDSL-specific
+         inventory information."
+      ::= { hdsl2ShdslGroups 3 }
+
+   hdsl2ShdslSpanShdslStatusGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusMaxAttainableLineRate,
+      hdsl2ShdslStatusActualLineRate,
+      hdsl2ShdslStatusTransmissionModeCurrent
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving SHDSL-specific
+         span-related status."
+      ::= { hdsl2ShdslGroups 4 }
+
+   hdsl2ShdslInventoryGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslInvVendorID,
+      hdsl2ShdslInvVendorModelNumber,
+      hdsl2ShdslInvVendorSerialNumber,
+      hdsl2ShdslInvVendorEOCSoftwareVersion,
+      hdsl2ShdslInvStandardVersion,
+      hdsl2ShdslInvVendorListNumber,
+      hdsl2ShdslInvVendorIssueNumber,
+      hdsl2ShdslInvVendorSoftwareVersion,
+      hdsl2ShdslInvEquipmentCode,
+      hdsl2ShdslInvVendorOther
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide unit inventory
+         information about the units in HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 5 }
+
+   hdsl2ShdslEndpointConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for configuring parameters for
+         segment endpoints in HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 6 }
+
+   hdsl2ShdslEndpointCurrGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn,
+      hdsl2ShdslEndpointCurrSnrMgn,
+      hdsl2ShdslEndpointCurrStatus,
+      hdsl2ShdslEndpointES,
+      hdsl2ShdslEndpointSES,
+      hdsl2ShdslEndpointCRCanomalies,
+      hdsl2ShdslEndpointLOSWS,
+      hdsl2ShdslEndpointUAS,
+      hdsl2ShdslEndpointCurr15MinTimeElapsed,
+      hdsl2ShdslEndpointCurr15MinES,
+      hdsl2ShdslEndpointCurr15MinSES,
+      hdsl2ShdslEndpointCurr15MinCRCanomalies,
+      hdsl2ShdslEndpointCurr15MinLOSWS,
+      hdsl2ShdslEndpointCurr15MinUAS,
+      hdsl2ShdslEndpointCurr1DayTimeElapsed,
+      hdsl2ShdslEndpointCurr1DayES,
+      hdsl2ShdslEndpointCurr1DaySES,
+      hdsl2ShdslEndpointCurr1DayCRCanomalies,
+      hdsl2ShdslEndpointCurr1DayLOSWS,
+      hdsl2ShdslEndpointCurr1DayUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide current status and
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 7 }
+
+   hdsl2Shdsl15MinIntervalGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2Shdsl15MinIntervalES,
+      hdsl2Shdsl15MinIntervalSES,
+      hdsl2Shdsl15MinIntervalCRCanomalies,
+      hdsl2Shdsl15MinIntervalLOSWS,
+      hdsl2Shdsl15MinIntervalUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that maintain historic
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines in 15-minute intervals."
+      ::= { hdsl2ShdslGroups 8 }
+
+   hdsl2Shdsl1DayIntervalGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2Shdsl1DayIntervalMoniSecs,
+      hdsl2Shdsl1DayIntervalES,
+      hdsl2Shdsl1DayIntervalSES,
+      hdsl2Shdsl1DayIntervalCRCanomalies,
+      hdsl2Shdsl1DayIntervalLOSWS,
+      hdsl2Shdsl1DayIntervalUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that maintain historic
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines in 1-day intervals."
+      ::= { hdsl2ShdslGroups 9 }
+
+   hdsl2ShdslMaintenanceGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslMaintLoopbackConfig,
+      hdsl2ShdslMaintTipRingReversal,
+      hdsl2ShdslMaintPowerBackOff,
+      hdsl2ShdslMaintSoftRestart,
+      hdsl2ShdslMaintLoopbackTimeout,
+      hdsl2ShdslMaintUnitPowerSource
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide support for
+         maintenance actions for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 10 }
+
+   hdsl2ShdslEndpointAlarmConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointAlarmConfProfile,
+      hdsl2ShdslEndpointThreshLoopAttenuation,
+      hdsl2ShdslEndpointThreshSNRMargin,
+      hdsl2ShdslEndpointThreshES,
+      hdsl2ShdslEndpointThreshSES,
+      hdsl2ShdslEndpointThreshCRCanomalies,
+      hdsl2ShdslEndpointThreshLOSWS,
+      hdsl2ShdslEndpointThreshUAS,
+      hdsl2ShdslEndpointAlarmConfProfileRowStatus
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that allow configuration of alarm
+         thresholds for various performance parameters for HDSL2/SHDSL
+         lines."
+      ::= { hdsl2ShdslGroups 11 }
+
+   hdsl2ShdslNotificationGroup NOTIFICATION-GROUP
+      NOTIFICATIONS
+      {
+      hdsl2ShdslLoopAttenCrossing,
+      hdsl2ShdslSNRMarginCrossing,
+      hdsl2ShdslPerfESThresh,
+      hdsl2ShdslPerfSESThresh,
+      hdsl2ShdslPerfCRCanomaliesThresh,
+      hdsl2ShdslPerfLOSWSThresh,
+      hdsl2ShdslPerfUASThresh,
+      hdsl2ShdslSpanInvalidNumRepeaters,
+      hdsl2ShdslLoopbackFailure,
+      hdsl2ShdslpowerBackoff,
+      hdsl2ShdsldeviceFault,
+      hdsl2ShdsldcContinuityFault,
+      hdsl2ShdslconfigInitFailure,
+      hdsl2ShdslprotocolInitFailure,
+      hdsl2ShdslnoNeighborPresent,
+      hdsl2ShdslLocalPowerLoss
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports notifications of significant conditions
+         associated with HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 12 }
+
+   hdsl2ShdslSpanConfProfileGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfWireInterface,
+      hdsl2ShdslSpanConfMinLineRate,
+      hdsl2ShdslSpanConfMaxLineRate,
+      hdsl2ShdslSpanConfPSD,
+      hdsl2ShdslSpanConfTransmissionMode,
+      hdsl2ShdslSpanConfRemoteEnabled,
+      hdsl2ShdslSpanConfPowerFeeding,
+      hdsl2ShdslSpanConfCurrCondTargetMarginDown,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginDown,
+      hdsl2ShdslSpanConfCurrCondTargetMarginUp,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginUp,
+      hdsl2ShdslSpanConfUsedTargetMargins,
+      hdsl2ShdslSpanConfReferenceClock,
+      hdsl2ShdslSpanConfLineProbeEnable,
+      hdsl2ShdslSpanConfProfileRowStatus
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that constitute configuration
+         profiles for configuring span-related parameters in SHDSL
+         lines."
+      ::= { hdsl2ShdslGroups 13 }
+
+   hdsl2ShdslWirePairGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrTipRingReversal,
+      hdsl2ShdslEndpointCurrActivationState
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide the status
+         of SHDSL-specific wire pairs."
+      ::= { hdsl2ShdslGroups 14 }
+
+   hdsl2ShdslPayloadRateGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusMaxAttainablePayloadRate,
+      hdsl2ShdslStatusActualPayloadRate
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving payload rates
+         that exclude any framing overhead."
+      ::= { hdsl2ShdslGroups 15 }
+
+   END
+
+-- 
+--    Copyright (C) The Internet Society (2005).
+-- 
+--    This document is subject to the rights, licenses and restrictions
+--    contained in BCP 78, and except as set forth therein, the authors
+--    retain all their rights.
+-- 
+--    This document and the information contained herein are provided on an
+--    "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+--    OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+--    ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+--    INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+--    INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+--    WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+-- 
+-- Intellectual Property
+-- 
+--    The IETF takes no position regarding the validity or scope of any
+--    Intellectual Property Rights or other rights that might be claimed to
+--    pertain to the implementation or use of the technology described in
+--    this document or the extent to which any license under such rights
+--    might or might not be available; nor does it represent that it has
+--    made any independent effort to identify any such rights.  Information
+--    on the procedures with respect to rights in RFC documents can be
+--    found in BCP 78 and BCP 79.
+-- 
+--    Copies of IPR disclosures made to the IETF Secretariat and any
+--    assurances of licenses to be made available, or the result of an
+--    attempt made to obtain a general license or permission for the use of
+--    such proprietary rights by implementers or users of this
+--    specification can be obtained from the IETF on-line IPR repository at
+--    http://www.ietf.org/ipr.
+-- 
+--    The IETF invites any interested party to bring to its attention any
+--    copyrights, patents or patent applications, or other proprietary
+--    rights that may cover technology that may be required to implement
+--    this standard.  Please address the information to the IETF at ietf-
+--    ipr@ietf.org.
+-- 
+
Index: net-snmp-5.1.2/agent/Makefile.in
===================================================================
--- net-snmp-5.1.2/agent/Makefile.in	(revision 42)
+++ net-snmp-5.1.2/agent/Makefile.in	(revision 50)
@@ -75,8 +75,10 @@
 # Objects
 #
 
+SHDSL_LMIBOBJS = mibgroup/mibII/shdsl/app-if/comm.lo mibgroup/mibII/shdsl/app-if/app_comm.lo mibgroup/mibII/shdsl/app-if/app_comm_cli.lo mibgroup/mibII/shdsl/app-if/app_comm_srv.lo mibgroup/mibII/shdsl/app-if/app_frame.lo
+
 # libnetsnmpmib objects.
-LMIBOBJS	= @mibgroup_list_lo@ mib_modules.lo auto_nlist.lo
+LMIBOBJS	= @mibgroup_list_lo@ mib_modules.lo auto_nlist.lo $(SHDSL_LMIBOBJS)
 MIBOBJS		= @mibgroup_list_o@ mib_modules.o auto_nlist.o
 
 # libnetsnmpagent objects
@@ -94,7 +96,7 @@
 #
 # Define OBJS and LOBJS for clean target (just this directory)
 #
-OBJS		= $(LIBAGENTOBJS)  $(AGENTOBJS)  mib_modules.o  auto_nlist.o
+OBJS		= $(LIBAGENTOBJS)  $(AGENTOBJS)  mib_modules.o  auto_nlist.o  
 LOBJS		= $(LLIBAGENTOBJS) $(LAGENTOBJS) mib_modules.lo auto_nlist.lo
 
 
@@ -124,7 +126,7 @@
 	$(RANLIB) libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION)
 
 libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION):    ${LMIBOBJS}
-	$(LIB_LD_CMD) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION) ${LMIBOBJS}  $(LIB_LD_LIBS) $(MIBS_RELINK_LIBS) $(LIBSENSORS)
+	$(LIB_LD_CMD) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION) ${LMIBOBJS} -lstdc++ $(LIB_LD_LIBS) $(MIBS_RELINK_LIBS) $(LIBSENSORS)
 	$(RANLIB) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION)
 
 embedperlinstall:
Index: net-snmp-5.1.2/agent/mibgroup/Makefile.in
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/Makefile.in	(revision 42)
+++ net-snmp-5.1.2/agent/mibgroup/Makefile.in	(revision 50)
@@ -2,6 +2,7 @@
 
 CPPFLAGS=-I../../include -I$(top_srcdir)/include \
 	-I. -I../.. -I$(srcdir) -I$(srcdir)/../.. \
+	-ImibII/shdsl/include \
 	-I$(srcdir)/../../snmplib -I$(srcdir)/.. -I.. @CPPFLAGS@ $(LIB_CFLAGS)
 
 # Need a special .c -> .o definition here to make sure we place the
@@ -10,9 +11,12 @@
 .c.o:
 	$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<
 
-OBJS = @module_list_o@
-LOBJS = @module_list_lo@
-SRCS = @module_list_c@
+SHDSL_OBJS = mibII/shdsl/app-if/comm.o mibII/shdsl/app-if/app_comm.o mibII/shdsl/app-if/app_comm_cli.o mibII/shdsl/app-if/app_comm_srv.o mibII/shdsl/app-if/app_frame.o
+SHDSL_LOBJS = mibII/shdsl/app-if/comm.lo mibII/shdsl/app-if/app_comm.lo mibII/shdsl/app-if/app_comm_cli.lo mibII/shdsl/app-if/app_comm_srv.lo mibII/shdsl/app-if/app_frame.lo
+SHDSL_SRCS = mibII/shdsl/app-if/comm.cpp mibII/shdsl/app-if/app_comm.cpp mibII/shdsl/app-if/app_comm_cli.cpp mibII/shdsl/app-if/app_comm_srv.cpp mibII/shdsl/app-if/app_frame.cpp
 
+OBJS = @module_list_o@  $(SHDSL_OBJS)
+LOBJS = @module_list_lo@ $(SHDSL_LOBJS)
+SRCS = @module_list_c@ $(SHDSL_SRCS)
 all: standardall $(LOBJS)
 
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/EOC_main.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/EOC_main.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/EOC_main.h	(revision 50)
@@ -0,0 +1,68 @@
+#ifndef EOC_MAIN_H
+#define EOC_MAIN_H
+
+#include <utils/hash_table.h>
+#include <snmp/snmp-generic.h>
+#include <app-if/app_frame.h>
+#include <app-if/app_comm_srv.h>
+
+
+// TODO: consult for OS about this values
+#define MAX_IF_NAME_LEN 256
+#define MAX_FNAME 256
+
+#define TICK_PER_MINUTE_MAX 60
+#define TICK_PER_MINUTE_DEF 6
+
+#define OS_IF_PATH "/sys/class/net"
+
+
+
+class EOC_main{
+protected:
+    char config_file[MAX_FNAME];
+    hash_table conf_profs;
+    hash_table alarm_profs;
+    hash_table channels;
+    app_comm_srv app_srv;
+    int valid;
+public:
+    EOC_main(char *cfg,char *sockpath) : conf_profs(SNMP_ADMIN_LEN), alarm_profs(SNMP_ADMIN_LEN),
+		     channels(MAX_IF_NAME_LEN), app_srv(sockpath,"eocd-socket")
+    {
+	valid = 0;
+	strncpy(config_file,cfg,MAX_FNAME);
+	config_file[MAX_FNAME-1] = '\0';
+	if( read_config() )
+	    return;
+//	configure_channels();
+	valid = 1;
+    }
+    ~EOC_main(){
+    }
+    int get_valid(){ return valid; }
+    // Read configuration file and initialise or change channels
+    int read_config();
+    // Write configuration to config file (when it changes from network)
+//    int write_config();
+    // Add (initialise) or change slave channel with name "ch_name"
+    int add_slave(char *ch_name);
+    // Add (initialise) or change master channel with name "ch_name"
+    int add_master(char *ch_name, char *conf,char *alarm,int reps,int tick);
+    //
+    int configure_channels();    
+    // process channels
+    int poll_channels();
+
+
+    void app_listen(int);
+    int app_request(app_frame *fr);
+    int app_spanname(app_frame *fr);
+    int app_chann_request(app_frame *fr);
+    int app_spanconf_prof(app_frame *fr);
+    int app_endpalarm_prof(app_frame *fr);
+
+};
+
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/handlers/EOC_poller_req.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/handlers/EOC_poller_req.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/handlers/EOC_poller_req.h	(revision 50)
@@ -0,0 +1,16 @@
+#ifndef EOC_POLLER_REQUESTS_H
+#define EOC_POLLER_REQUESTS_H
+
+#include <generic/EOC_requests.h>
+#include <generic/EOC_msg.h>
+#include <db/EOC_db.h>
+#include <engine/EOC_handlers.h>
+
+EOC_msg *_req_discovery(sched_state stat,sched_elem el,EOC_config *cfg);
+EOC_msg *_req_inventory(sched_state stat,sched_elem el,EOC_config *cfg);
+EOC_msg *_req_configure(sched_state stat,sched_elem el,EOC_config *cfg);
+EOC_msg *_req_status(sched_state stat,sched_elem el,EOC_config *cfg);
+
+EOC_msg *_req_test(sched_state stat,sched_elem el,EOC_config *cfg);
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/hash_table.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/hash_table.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/hash_table.h	(revision 50)
@@ -0,0 +1,48 @@
+#ifndef SIGRAND_HASH_TABLE_H
+#define SIGRAND_HASH_TABLE_H
+
+#define HASH_SIZE 200
+#include <string.h>
+#include <list>
+using namespace std;
+
+
+class hash_elem{
+public:
+    char *name;
+    int nsize;
+    hash_elem *next;
+    hash_elem *prev;
+    inline bool operator < (hash_elem &right){
+        int len = right.nsize > nsize ? nsize : right.nsize;
+        if( strncmp(name,right.name,len) < 0 )
+    	    return 1;
+        return 0;
+    }
+};
+
+
+class hash_table{
+private:
+    list< hash_elem *> table[HASH_SIZE];
+    int _hash(char *name);
+    int max_hash_name;
+    // sequential list of table items
+    hash_elem *head,*tail;
+public:
+    hash_table(int mhash_name);
+    ~hash_table();
+    hash_elem *find(char *name, int nsize);
+    int add(hash_elem *el);
+    int del(char *name,int nsize);
+    // sequential trace
+    inline hash_elem *first(){ return head; }
+    inline hash_elem *next(char *name, int nsize){
+	hash_elem *el = find(name,nsize);
+	if( !el )
+	    return NULL;
+	return el->next;
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOClist.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOClist.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOClist.h	(revision 50)
@@ -0,0 +1,62 @@
+#ifndef SIGRAND_LIST_H
+#define SIGRAND_LIST_H
+
+class EOCList_elem{
+
+};
+
+class __list{
+private:
+    EOCList_elem *data;
+    __list *next;
+public:
+    __list(){
+	data = NULL;
+	next = NULL;
+    }
+    ~__list(){
+	if( data )
+	    delete data;
+    }
+    inline EOCList_elem *get_data(){
+	return data;
+    }
+    inline __list *get_next(){
+	return next;
+    }
+    inline void set_data(EOCList_elem *d){
+	data = d;
+    }
+    inline void set_next(__list *n){
+	next = n;
+    }
+};
+
+class EOClist{
+private:
+    __list *head;
+    __list *tail;    
+    __list *current;
+    int size;
+
+    __list *prev_by_ptr(__list *);
+public:
+    EOClist();
+    ~EOClist();
+    int head_current();
+    int next();
+    int add_first(EOCList_elem *d);
+    int add_last(EOCList_elem *d);    
+    EOCList_elem *get_cur();
+    EOCList_elem *get_first();
+    EOCList_elem *get_tail();
+    int del_cur();
+    int del_first();
+    int del_last();    
+    // iteration through list
+};
+
+
+// TODO: make as objects rather than include!!!
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOC_ring_container.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOC_ring_container.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOC_ring_container.h	(revision 50)
@@ -0,0 +1,78 @@
+#ifndef EOC_RING_CONTAINER_H
+#define EOC_RING_CONTAINER_H
+
+#include <generic/EOC_types.h>
+
+template <class T>
+class EOC_ring_container{
+private:
+    T **mas;
+    u32 len;
+    u32 head,qlen;
+    
+    inline void inc_head(){
+	head = (head+1)%len;
+    }
+    inline int ind(int i){
+	if( !(i<len) )
+	    return -1;
+	if( head<i )
+	    return (head+len-i);
+	return (head-i);
+    }
+    
+public:
+    EOC_ring_container(int l){
+	mas = new T*[l];
+	for(int i=0;i<l;i++){
+	    mas[i] = NULL;
+	}
+	len = l;
+	head = 0;
+	mas[head] = new T;
+    }
+    
+    ~EOC_ring_container<T>(){
+	for(int i=0;i<len;i++)
+	    if( mas[i] )
+		delete mas[i];
+	delete[] mas;
+    }
+    
+    
+    T * operator[](unsigned int i){
+	int ret = ind(i);
+	if( ret<0 )
+	    return NULL;
+	return mas[ret];
+    }
+    
+    void shift(u32 ints){
+	u32 nhead = (head+ints)%len;
+	u32 nrings = ints / len;
+	
+	if( !ints )
+	    return;
+	    
+	if( nrings ){
+	    for(int i=0;i<len;i++){
+		if( mas[i] ){
+		    delete mas[i];
+		    mas[i] = NULL;
+		}
+	    }
+	    head = nhead;
+	}else{
+	    while(head!=nhead){
+		inc_head();
+		if(mas[head]){
+		    delete mas[head];
+		    mas[head] =NULL;
+		}
+	    }
+	}
+	mas[head] = new T;
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOCLog.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOCLog.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/utils/EOCLog.h	(revision 50)
@@ -0,0 +1,42 @@
+#ifndef SIGRAND_LOG_H
+#define SIGRAND_LOG_H
+
+#define LOG_ERR 0
+#define LOG_WARN 1
+
+
+class EOCLog_config{
+
+
+
+};
+
+
+class EOCLog{
+        
+public:
+    void print(int,char*);
+}
+
+
+void
+EOCLog::print(int facility,char* s)
+{
+    char sfacility[256];
+    
+    switch( facility ){
+    case LOG_ERR:
+	sfacility = strdup("Error");
+	break;
+    case LOG_WARN:
+	sfacility = strdup("Warning");
+	break;
+    default:
+	sfacility = strdup("Default");
+    }
+    
+    printf("%s %s\n",sfacility,s);
+}
+
+
+#endif
\ No newline at end of file
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev_terminal.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev_terminal.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev_terminal.h	(revision 50)
@@ -0,0 +1,21 @@
+#ifndef SIGRAND_EOC_DEV_MASTER_H
+#define SIGRAND_EOC_DEV_MASTER_H
+
+#include <generic/span_conf_type.h>
+#include <devs/EOC_dev.h>
+
+
+class EOC_dev_terminal: public EOC_dev{
+protected:
+    char *ifname;
+    char *conf_path;
+    char *chan_path;
+    int check_ctrl_files(char *d,char **opts,int opts_num);
+public:
+    virtual  span_conf_profile_t *cur_config() = 0;                                                                                     
+    virtual int configure(span_conf_profile_t &cfg) = 0; 
+    virtual int configure() = 0; 
+};
+ 
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_r17.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_r17.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_r17.h	(revision 50)
@@ -0,0 +1,30 @@
+#ifndef SIGRAND_EOC_SRU_H
+#define SIGRAND_EOC_SRU_H
+
+#include <generic/EOC_generic.h>
+#include <devs/EOC_dev.h>
+#include "EOC_msg.h"
+extern "C" {
+#include "../include/sdfe4_lib.h"
+}
+
+#define HDLC_MSG_SIZE 112
+
+class EOC_sru : public EOC_dev{
+protected:
+    struct sdfe4 *hwdev;
+    int ch;
+public:
+    EOC_sru(struct sdfe4 *h,int c);
+    int send(EOC_msg *m);
+    int recv(EOC_msg *m);
+//    int init(char *ptr,int size);
+    int loops();
+    Linkstate link_state();
+    //----- SHDSL settings ---------//
+    int tresholds(s8 loop_attn,s8 snr_m);
+    int statistics(int loop,side_perf &stat);
+    
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy.h	(revision 50)
@@ -0,0 +1,28 @@
+#ifndef SIGRAND_EOC_SG17_H
+#define SIGRAND_EOC_SG17_H
+
+#include <devs/EOC_dev.h>
+#include <generic/EOC_msg.h>
+
+#define HDLC_BUFF_SZ 112
+
+class EOC_dummy : public EOC_dev{
+protected:
+    char *f1,*f2;
+    int valid;
+    u8 loop_attn_atr,snr_marg_atr;
+public:
+    EOC_dummy(char *file1,char *file2);
+    ~EOC_dummy();    
+    int send(EOC_msg *m);
+    EOC_msg *recv();
+    Linkstate link_state();
+    int tresholds(u8 lattn,u8 snr){
+	loop_attn_atr = lattn;
+	snr_marg_atr = snr;
+    }
+    u8 loop_attn(){ return loop_attn_atr; }
+    u8 snr_marg(){return snr_marg_atr; } 
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy1.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy1.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dummy1.h	(revision 50)
@@ -0,0 +1,113 @@
+#ifndef EOC_DUMMY_1_H
+#define EOC_DUMMY_1_H
+#include<string.h>
+#include<stdio.h>
+
+#include <devs/EOC_dev_terminal.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_responses.h>
+
+class dummy_channel{
+protected:
+    struct{
+	char buf[256];
+	int len;
+    } chan[256];
+    int head,tail;
+    inline int inc(int ind){
+	if( ind+1 < 256 )
+	    return ind+1;
+	return 0;
+    }
+public:
+    dummy_channel(){
+	head = 0;
+	tail = 0;
+    }
+    inline int enqueue(char *m,int col){
+	if( inc(tail) == head )
+	    return -1;
+	memcpy(chan[tail].buf,m,col);
+	chan[tail].len = col;
+	tail = inc(tail);
+	return 0;
+    }
+
+    inline int dequeue(char *m,int *col){
+	if( head == tail )
+	    return -1;
+	memcpy(m,chan[head].buf,chan[head].len);
+	*col = chan[head].len;
+	head = inc(head);
+	return 0;
+    }
+    
+    
+};
+
+
+
+class EOC_dummy1 : public EOC_dev_terminal{
+protected:
+    char name[256];
+    dummy_channel *snd,*rcv;
+    int valid;
+    side_perf perf;
+    int perf_changed;
+public:
+    EOC_dummy1(char *name,dummy_channel *snd,dummy_channel *rcv);
+    ~EOC_dummy1();    
+
+    int send(EOC_msg *m);
+    EOC_msg *recv();
+
+    Linkstate link_state();
+
+    span_conf_profile_t *cur_config() { return NULL; }
+    int configure(span_conf_profile_t &cfg){ return 0; }
+    int configure(){ return 0; }
+
+
+    int setup_current_stat(side_perf p){
+	perf = p;
+	perf_changed = 1;
+    }
+
+    side_perf get_current_stat(){
+	return perf;
+    }
+    
+    int loops() { return 1;};
+
+    int tresholds(s8 loopattn,s8 snr){
+	printf("%s: loop_attn(%d) snr_marg(%d)\n",name,loopattn,snr);
+    }
+    int statistics(int loop, side_perf &perf);
+    
+};
+
+#endif
+
+
+
+/*
+int main()
+{
+    char a[256];
+    int b;
+    dummy_channel d;
+    d.enqueue("aaaaaaaaaa",10);
+    d.enqueue("aaaaaaaaaaa",11);
+    d.enqueue("aaaaaaaaaaaa",12);
+    d.enqueue("aaaaaaaaaaaaaaa",15);
+    d.enqueue("aaaaa",5);
+    d.enqueue("aaaaaa",6);    
+    d.enqueue("aaaaaaaaaa",10);    
+    d.enqueue("aaaaaaaaaaa",11);
+    
+    while( !d.dequeue(a,&b) ){
+	a[b] = 0;
+	printf("(%d): %s\n",b,a);
+    }
+}
+*/
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr16h.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr16h.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr16h.h	(revision 50)
@@ -0,0 +1,21 @@
+#ifndef SIGRAND_EOC_SG17_H
+#define SIGRAND_EOC_SG17_H
+
+#include <devs/EOC_dev_master.h>
+#include <generic/EOC_msg.h>
+
+#define HDLC_BUFF_SZ 112
+
+class EOC_sg17 : public EOC_dev_terminal{
+protected:
+    char *fname;
+    int valid;    
+public:
+    EOC_sg17(char *fname);
+    ~EOC_sg17();    
+    int send(EOC_msg *m);
+    EOC_msg *recv();
+//    Linkstate link_state();
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_dev.h	(revision 50)
@@ -0,0 +1,71 @@
+#ifndef SIGRAND_EOC_DEV_H
+#define SIGRAND_EOC_DEV_H
+
+#define EOC_DEV_NAMESZ 256
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_responses.h>
+
+
+class EOC_dev{
+public:
+    typedef enum{ OFFLINE, ONLINE } Linkstate  ;
+    enum device { SG16PCI,SG17PCI,SG17R };
+    enum annex_t { annexA,annexB,annexF };
+    enum tcpam_t { tcpam4, tcpam8, tcpam16,tcpam32 };
+    enum terminator_t { master,slave };
+    typedef struct {
+	unsigned int lrate;
+	annex_t annex;
+	tcpam_t tcpam;
+	terminator_t term;
+    } EOC_dev_cfg;
+    typedef struct {
+	s8 snr_marg, loop_attn;
+	u8 es,ses,losws,uas;
+	u16 crc, sega;
+	u8 seg_def,cntr_ovfl,cntr_rst;
+    } shdsl_statistics;
+    typedef struct {
+	u8 master:1;
+	u8 tcpam :3;
+	u8 annex :3;
+	u32 rate;
+    } shdsl_settings;
+protected:
+    int error_init;
+    device dev_type;
+    s8 attn_tresh,snr_tresh;
+    side_perf last_perf;
+    int valid;
+public:
+    // Initialisation check
+    int init_ok() { return valid; }
+    EOC_dev(){
+	memset((void*)&last_perf,0,sizeof(last_perf));
+    }
+    //----- EOC functions ---------//
+    virtual int send(EOC_msg *msg) = 0;
+    virtual EOC_msg *recv() = 0;
+    //----- SHDSL channel ----------//
+    virtual int loops() = 0;
+    virtual Linkstate link_state() = 0;
+    //----- SHDSL settings ---------//
+    int tresholds(s8 loop_attn_tr,s8 snr_m_tr){
+	attn_tresh = loop_attn_tr;
+	snr_tresh = snr_m_tr;
+    }
+    int get_tresholds(s8 &loop_attn_tr,s8 &snr_m_tr){
+	loop_attn_tr = attn_tresh;
+	snr_m_tr = snr_tresh;
+	return 0;
+    }
+    
+    virtual int statistics(int loop,side_perf &stat) = 0;
+
+
+};
+
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr17h.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr17h.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/devs/EOC_mr17h.h	(revision 50)
@@ -0,0 +1,57 @@
+#ifndef SIGRAND_EOC_SG17_H
+#define SIGRAND_EOC_SG17_H
+
+#include <devs/EOC_dev_terminal.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_responses.h>
+
+inline int
+mr17h_conf_dir(char *name,char *buf,int max_size){
+    return snprintf(buf,max_size,"/sys/class/net/%s/sg17_private",name);    
+}
+
+class EOC_mr17h : public EOC_dev_terminal{
+protected:
+
+    //DEBUG
+    side_perf perf;
+    int perf_changed;
+    
+public:
+    EOC_mr17h(char *_ifname);
+    ~EOC_mr17h();
+    
+    // EOC message send/receive
+    int send(EOC_msg *m);
+    EOC_msg *recv();
+
+    // Span status
+    Linkstate link_state();
+
+    // Device configuration
+    int set_dev_option(char *name,char *val);
+    int get_dev_option(char *name,char *&buf);
+
+    span_conf_profile_t *cur_config();
+    int configure(span_conf_profile_t &cfg);
+    int configure();
+
+    // Statistic info
+    // DEBUG
+    int loops() { return 1;};
+
+    int tresholds(s8 attn,s8 snr){
+	snr_tresh = snr;
+	attn_tresh = attn;
+    }
+    
+    
+    
+    int statistics(int loop,side_perf &stat);
+    void 	dbg_last_msg(){
+	printf("LAST MSG:\nes(%u) ses(%u) losws(%u) crc(%u)\n",last_perf.es,last_perf.ses,last_perf.losws,last_perf.crc);
+    }
+
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/eoc_debug.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/eoc_debug.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/eoc_debug.h	(revision 50)
@@ -0,0 +1,38 @@
+#ifndef EOC_DEBUG_H
+#define EOC_DEBUG_H
+
+//#define EOC_DEBUG
+
+extern int debug_lev;
+
+#define DOFF -1
+#define DERR 0
+#define DINFO 5
+#define DFULL 10
+
+#ifdef EOC_DEBUG
+#	include <cassert>
+#	define ASSERT(x) assert(x)
+#       define PDEBUG(lev,fmt,args...) \
+		if( lev<=debug_lev ) \
+			printf("eocd(%s): " fmt " \n",__FUNCTION__, ## args  )
+
+
+#	define EDEBUG(lev,function) \
+		if( lev<=debug_lev ) \
+			function
+
+#	define PERROR(fmt,args...) printf("eocd(%s) " fmt " : %s\n", __FUNCTION__, ##args,strerror(errno))
+
+#else
+#	define ASSERT(x) 
+#	define PDEBUG(lev,fmt,args...)
+#	define EDEBUG(lev,function)
+#	define PERROR(fmt,args...)
+
+#endif
+
+
+#endif
+
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/config/EOC_config.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/config/EOC_config.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/config/EOC_config.h	(revision 50)
@@ -0,0 +1,33 @@
+#ifndef EOC_CONFIG_H
+#define EOC_CONFIG_H
+
+#include <generic/EOC_types.h>
+#include <utils/hash_table.h>
+
+#include <conf_profile.h>
+
+class EOC_config{
+    hash_table *conf_prof;
+    hash_table *alarm_prof;
+    char *cprof_name;
+    char *aprof_name;
+    u16 rep_num;
+public:
+    EOC_config(hash_table *c,hash_table *a,char *cn,char *an,u16 rep)
+    {
+	conf_prof = c;
+	alarm_prof = a;
+	cprof_name = cn;
+	aprof_name = an;
+	rep_num = rep;
+    }
+    const char *conf_prof_name(){return cprof_name;}
+    const char *alarm_prof_name(){return cprof_name;}
+    u16 repeaters(){ return rep_num; }
+    hash_table *conf_tbl(){ return conf_prof; }
+    hash_table *alarm_tbl(){ return alarm_prof; }
+    s8 snr_tresh(){ return 0;}
+    s8 loop_tresh(){ return 0; }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_side.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_side.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_side.h	(revision 50)
@@ -0,0 +1,49 @@
+#ifndef EOC_SIDE_H
+#define EOC_SIDE_H
+
+#include <db/EOC_loop.h>
+#include <eoc_debug.h>
+
+class EOC_side{
+public:
+
+private:
+    EOC_loop *loops[MAX_LOOPS];
+    int loop_num;
+public:
+    EOC_side(int lnum){
+	ASSERT( lnum < MAX_LOOPS );
+	loop_num = lnum;
+	for(int i=0;i<lnum;i++){
+	    loops[i] = new EOC_loop;
+	}
+    }
+
+    ~EOC_side(){
+	for(int i=0;i<loop_num;i++){
+	    ASSERT( loops[i] );
+	    delete loops[i];
+	}
+    }
+    
+    EOC_loop* get_loop(int l){
+	if( !(l<loop_num && l>=0) ){
+	    PDEBUG(0,"error loop number = %d",l);
+	    return NULL;
+	}
+	return loops[l];
+    }
+	inline void link_up(){
+		for(int i=0;i<MAX_LOOPS;i++)
+			if(loops[i])
+				loops[i]->link_up();
+	}
+	inline void link_down(){
+		for(int i=0;i<MAX_LOOPS;i++)
+			if(loops[i])
+				loops[i]->link_down();
+	}
+    
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_db.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_db.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_db.h	(revision 50)
@@ -0,0 +1,66 @@
+/*
+ * EOC_db.h:
+ *	EOC channel configuration & status storage
+ */
+ 
+#ifndef EOC_DATABASE_H
+#define EOC_DATABASE_H
+
+#include <generic/EOC_generic.h>
+#include <generic/EOC_responses.h>
+#include <generic/EOC_msg.h>
+#include <engine/EOC_scheduler.h>
+#include <db/EOC_unit.h>
+#include <app-if/app_frame.h>
+
+class EOC_db{
+    // Poller REsponse handler prototype
+    typedef int (*response_handler_t)(EOC_db *d,EOC_msg *m,int check);
+    typedef int (*app_handler_t)(EOC_db *db,app_frame *fr);
+
+    EOC_unit *units[MAX_UNITS];
+    u8 units_discov[MAX_UNITS];
+    response_handler_t handlers[RESPONSE_QUAN];
+    app_handler_t app_handlers[app_ids_num];
+    EOC_scheduler *sch;
+    u8 loop_num;
+
+    static int _resp_discovery(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_inventory(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_configure(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_test(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_status(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_nside_perf(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_cside_perf(EOC_db *db,EOC_msg *m,int check);
+    static int _resp_sensor_state(EOC_db *db,EOC_msg *m,int check);
+
+    static int _appreq_inventory(EOC_db *db,app_frame *fr);
+    static int _appreq_endpcur(EOC_db *db,app_frame *fr);
+    static int _appreq_endp15min(EOC_db *db,app_frame *fr);
+    static int _appreq_endp1day(EOC_db *db,app_frame *fr);
+    static int _appreq_endpmaint(EOC_db *db,app_frame *fr);
+    static int _appreq_unitmaint(EOC_db *db,app_frame *fr);
+
+    inline int register_handlers();
+
+public:
+    EOC_db(EOC_scheduler *s,int lnum);
+    int response_chk(EOC_msg *m){ return 0; }
+    int response(EOC_msg *m,int check = 0);
+
+    // TODO: 
+    // what to do if inventory information of unit differs
+//    int add_unit(unit u, resp_inventory *resp);
+    int clear();
+    int app_request(app_frame *fr);
+    int unit_quan();
+    int reg_quan();
+    int link_established();
+
+    int check_exist(unit u);
+    EOC_side *check_exist(unit u,side s);
+    EOC_loop *check_exist(unit u,side s,int loop);
+    void link_down();
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/alarm_profile.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/alarm_profile.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/alarm_profile.h	(revision 50)
@@ -0,0 +1,14 @@
+#ifndef SIGRAND_ALARM_PROFILE_H
+#define SIGRAND_ALARM_PROFILE_H
+
+#include "eoc_primitives.h"
+#include
+
+typedef struct {
+    char name[ADMIN_STR_LEN];
+    char tresh_loop_att;
+    char tresh_snr_marg;
+    perf_stat_t tresh;
+} alarm_prof_t;
+
+#endif
\ No newline at end of file
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_loop.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_loop.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_loop.h	(revision 50)
@@ -0,0 +1,161 @@
+#ifndef EOC_LOOP_H
+#define EOC_LOOP_H
+
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <generic/EOC_types.h>
+#include <generic/EOC_requests.h>
+#include <generic/EOC_responses.h>
+#include <utils/EOC_ring_container.h>
+#include <eoc_debug.h>
+
+class counters_elem{
+ public:
+    time_t tstamp;
+    counters_t cntrs;
+
+    counters_elem(){
+		memset(&cntrs,0,sizeof(cntrs));
+		tstamp = 0;
+    }
+    int addit(counters_t cnt){
+		//	printf("addit: %d to es\n",cnt.es);
+		cntrs.es += cnt.es;
+		cntrs.ses += cnt.ses;
+		cntrs.crc += cnt.crc;
+		cntrs.losws += cnt.losws;
+		cntrs.uas += cnt.uas;
+    }
+    
+};
+
+typedef struct {
+    time_t tstamp;
+    s32 loop_attn;
+    s32 snr_marg;
+    shdsl_status_t stat;
+    counters_elem elem;
+} shdsl_current;
+
+
+#define EOC_15MIN_INT_LEN 15
+#define EOC_15MIN_INTS 96
+#define EOC_1DAY_INTS 30
+
+class EOC_loop{
+ public:
+ protected:
+    // current situation
+    shdsl_current state;
+    EOC_ring_container<counters_elem> _15min_ints;
+    EOC_ring_container<counters_elem> _1day_ints;
+    side_perf last_msg;
+	char lstate;
+	time_t down_ts,up_ts;
+    
+    // TODO: check how hardware maintain moulo counters: i.e. if counter overflow - would it count zero as addit count?
+    inline u8 modulo_diff(u8 val,u8 nval,u8 modulo,char *type){
+		u32 ret = ((nval-val>=0) ? nval-val : nval + (modulo-val)+1);
+		//	printf("modulo_diff8(%s): val(%u) nval(%u) modulo(%u) ret(%u)\n",type,val,nval,modulo,ret);
+		return ret;	
+    }
+
+    inline u16 modulo_diff(u16 val,u16 nval,u16 modulo,char *type){
+		u32 ret = ((nval-val>=0) ? nval-val : nval + (modulo-val)+1);
+		//	printf("modulo_diff16(%s): val(%u) nval(%u) modulo(%u) ret(%u)\n",type,val,nval,modulo,ret);
+		return ret;	
+    }
+
+    void status_diff(side_perf *info,counters_t &cntrs);
+    int setup_cur_status(side_perf *info);
+    inline int get_localtime(time_t *t,struct tm &ret);
+    void shift_rings();
+ public:
+    EOC_loop();
+	// TODO: write    ~EOC_loop();
+    int short_status(s8 snr_margin);
+    int full_status(side_perf *info);
+
+    // output interface
+    s32 cur_snr(){ return state.snr_marg; }
+    s32 cur_attn(){ return state.loop_attn; }
+    counters_t cur_counters(){ return state.elem.cntrs; }
+    shdsl_status_t cur_status(){ return state.stat; }
+    int m15_counters(int index,counters_elem &cntrs){
+		if( !(index < EOC_15MIN_INTS && index>=0) )
+			return -1;
+		if( !_15min_ints[index] )
+			return -1;
+		cntrs = *_15min_ints[index];
+		return 0;
+    }
+
+    int m15_nx_counters(int &index,counters_elem &cntrs){
+		if( !(index < EOC_15MIN_INTS && index>=0) )
+			return -1;
+		int i = index;
+		while( !_15min_ints[i] && i<EOC_15MIN_INTS )
+			i++;
+		if( !_15min_ints[i] )
+			return -1;
+		cntrs = *_15min_ints[i];
+		index = i;
+		return 0;
+    }
+    
+    int d1_counters(int index,counters_elem &cntrs){
+		if( !(index < EOC_1DAY_INTS && index>=0) )
+			return -1;
+		if( !_1day_ints[index] )
+			return -1;
+		cntrs = *_1day_ints[index];
+		return 0;
+    }
+
+    int d1_nx_counters(int &index,counters_elem &cntrs){
+		if( !(index < EOC_1DAY_INTS && index>=0) )
+			return -1;
+		int i = index;
+		while( !_1day_ints[i] && i<EOC_1DAY_INTS )
+			i++;
+		if( !_1day_ints[i] )
+			return -1;
+		cntrs = *_1day_ints[i];
+		index = i;
+		return 0;
+    }
+
+	// Link status change handling
+	inline void link_up(){
+		if( lstate )
+			return;
+		time(&up_ts);
+		lstate = 1;
+	}
+	inline void link_down(){
+		if( !lstate )
+			return;
+		time(&down_ts);
+		_1day_ints[0]->cntrs.mon_sec += down_ts-up_ts;
+		lstate  = 0;
+	}
+
+    // TODO: removethis DEBUG
+    void print_15m(){
+		printf("Dump 15min stat:\n");
+		for(int i=0;i<EOC_15MIN_INTS;i++){
+			if( _15min_ints[i] ){
+				char *c = ctime(&_15min_ints[i]->tstamp);
+				int len = strlen(c);
+				c[len-1] = '\0';
+				printf("%s: es(%u) ses(%u) crc(%u) losws(%u) uas(%u)\n",
+					   c,_15min_ints[i]->cntrs.es,
+					   _15min_ints[i]->cntrs.ses,_15min_ints[i]->cntrs.crc,
+					   _15min_ints[i]->cntrs.losws,_15min_ints[i]->cntrs.uas);
+			}
+		}
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/eoc_primitives.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/eoc_primitives.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/eoc_primitives.h	(revision 50)
@@ -0,0 +1,67 @@
+#ifndef SIGRAND_EOC_PRIMS_H
+#define SIGRAND_EOC_PRIMS_H
+
+// Define types
+typedef unsigned int u32;
+typedef int s32;
+typedef unsigned short u16;
+typedef short s16;
+typedef unsigned char u8;
+typedef char s8;
+
+//-----------------------------------------------------------------------
+
+#define ADMIN_STR_LEN 32
+
+typedef enum { region1=0,region2=1} transm_mode_t;
+typedef enum { xtuC=1,xtuR,xru1,xru2,xru3,xru4,xru5,xru6,xru7,xru8 } unit_id_t;
+typedef enum { pair1=1,pair2,pair3,pair4 } pair_num_t;
+typedef enum { network=1,customer } side_t;
+typedef enum { normal=1,resrved} tip_ring_rev_t;
+typedef enum { preActivation=1, activation, data} act_state_t;
+typedef enum { noLoopback = 1, normalLoopback, specialLoopback } loopback_cfg_t;
+typedef enum { def = 1,ench } power_backoff_t;
+typedef enum { ready = 1,restart } soft_restart_t;
+typedef enum { local = 1, span } pwr_src_t;
+typedef enum { twoWire = 1,fourWire,sixWire,eightWire } wire_if_t;
+typedef enum { symmetric = 1, asymmetric } PSD_t;
+typedef enum { localClk = 1, networkClk, dataOrNetworkClk, dataClk } clock_ref_t;
+typedef enum { noPower = 1, powerFeed, wettingCurrent } remote_conf_t;
+typedef enum { disabled = 1, enabled } pwr_feeding_t;
+typedef enum { disable = 1, enable } line_probe_t;
+typedef enum { active = 1, notInService, notReady, createAndGo, createAndWait, destroy } row_statuis_t;
+
+
+typedef struct {
+	u16 noDefect :1;
+	u16 powerBackoff :1;
+	u16 deviceFault :1;
+	u16 dcContinuityFault :1;
+	u16 snrMarginAlarm :1;
+	u16 loopAttenuationAlarm :1;
+	u16 loswFailureAlarm :1;
+	u16 configInitFailure :1;
+	u16 protocolInitFailure:1;
+	u16 noNeighborPresent :1;
+	u16 loopbackActive :1;
+} status_bits_t;
+
+typedef struct {
+	u8 currCondDown :1;
+	u8 worstCaseDown :1;
+	u8 currCondUp :1;
+	u8 worstCaseUp :1;	
+} targ_marg_t;
+
+// Perfomance & status characteristics
+typedef struct{
+    u32 es;
+    u32 ses;
+    u32 crc_anom;
+    u32 losws;
+    u32 uas;
+} perf_stat_t;
+		    
+
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_unit.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_unit.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/EOC_unit.h	(revision 50)
@@ -0,0 +1,88 @@
+/*
+ * EOC_db.h:
+ *	EOC channel configuration & status storage
+ */
+ 
+#ifndef EOC_UNIT_H
+#define EOC_UNIT_H
+
+#include <generic/EOC_generic.h>
+#include <generic/EOC_responses.h>
+#include <db/EOC_side.h>
+#define EOC_SIDES_NUM 2
+
+class EOC_unit{
+ public:
+    typedef enum { span = 0, local } power_t;
+ protected:
+    unit u;
+    u8 eoc_softw_v;
+    resp_inventory inv_info;
+    u8 inv_info_setted;
+    resp_sensor_state sensors_cur;
+    u8 sens1,sens2,sens3;
+    
+    power_t power;
+    EOC_side *side[EOC_SIDES_NUM];
+ public:
+    EOC_unit(unit u_in,resp_discovery *resp,int loops){
+		inv_info_setted = 0;
+		eoc_softw_v = resp->eoc_softw_ver;
+		for( int i=0; i<EOC_SIDES_NUM;i++)
+			side[i] = NULL;
+		u = u_in;
+		memset(&sensors_cur,0,sizeof(sensors_cur));
+		sens1 = 0;
+		sens2 = 0;	
+		sens3 = 0;
+		switch( u ){
+		case stu_c:
+			side[cust_side] = new EOC_side(loops); 
+			break;
+		case stu_r:
+			side[net_side] = new EOC_side(loops);
+			break;
+		default:
+			side[cust_side] = new EOC_side(loops); 
+			side[net_side] = new EOC_side(loops);
+			break;
+		}
+    }
+    int set_inv_info(resp_inventory *resp){
+		inv_info = *resp;
+		inv_info_setted = 1;
+    }
+    u8 eoc_softw_ver(){ return eoc_softw_v; }
+    
+    EOC_side *nside(){ return side[net_side]; }
+    EOC_side *cside(){ return side[cust_side]; }
+
+    int integrity(resp_inventory *resp){
+		if( !inv_info_setted )
+			return 0;
+		if( memcmp(resp,&inv_info,sizeof(inv_info) ) )
+			return -1;
+		return 0;
+    }
+    resp_inventory inventory_info(){ return inv_info; }
+    void sensor_resp(resp_sensor_state *resp){
+		//	PDEBUG(DINFO,"SAVE SENSOR STATE: s1(%d), s2(%d), s3(%d)",resp->sensor1,resp->sensor2,resp->sensor3);
+		sensors_cur = *resp;
+		sens1 += resp->sensor1;
+		sens2 += resp->sensor2;
+		sens3 += resp->sensor3;
+    }
+	inline void link_up(){
+		for(int i=0;i<EOC_SIDES_NUM;i++)
+			if(side[i])
+				side[i]->link_up();
+	}
+	inline void link_down(){
+		for(int i=0;i<EOC_SIDES_NUM;i++)
+			if(side[i])
+				side[i]->link_down();
+	}
+};
+
+#endif
+ 
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/conf_profile.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/conf_profile.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/db/conf_profile.h	(revision 50)
@@ -0,0 +1,26 @@
+#ifndef SIGRAND_CONF_PROFILE_H
+#define SIGRAND_CONF_PROFILE_H
+
+#include "eoc_primitives.h"
+
+typedef struct {
+    char name[ADMIN_STR_LEN];
+    int hash;
+    wire_if_t wire_if;
+    unsigned int min_lrate;
+    unsigned int max_lrate;
+    PSD_t psd;
+    transm_mode_t transm_mode;
+    remote_conf_t rconf;
+    pwr_feeding_t pwd_feed;
+    char cur_marg_down;
+    char worst_marg_down;
+    char cur_marg_up;
+    char worst_marg_up;
+    targ_marg_t tmarg;
+    clock_ref_t clk_ref;
+    line_probe_t lprobe;
+} conf_prof_t;
+
+
+#endif
\ No newline at end of file
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_queue.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_queue.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_queue.h	(revision 50)
@@ -0,0 +1,140 @@
+#ifndef SCHED_QUEUE_H
+#define SCHED_QUEUE_H
+
+#include <generic/EOC_generic.h>
+#include <engine/sched_elem.h>
+#include <list>
+
+using namespace std;
+
+class sched_queue{
+public:
+protected:
+    list<sched_elem> q;
+    u32 err_no_answer;
+public:
+    sched_queue(){
+	err_no_answer = 0;
+	q.clear();
+    }
+    ~sched_queue(){
+	q.clear();
+    }
+    
+    void clear(){
+	q.clear();
+    }
+    
+    int add(unit src,unit dst,unsigned char type,__timestamp ts){
+	list<sched_elem>::iterator p = q.begin();
+	list<sched_elem>::iterator p1 = q.end();
+	for(;p != q.end();p++ ){
+	    if( src == p->src && dst == p->dst && type == p->type )
+		return -1;
+	    if( p->tstamp == ts )
+		p1 = p;
+	}
+	if( p1 != q.end() )
+	    p1++;
+	sched_elem *n = new sched_elem;
+	n->src = src;
+	n->dst = dst;
+	n->type = type;
+	n->tstamp = ts;
+	q.insert(p1,*n);
+	delete n;
+	return 0;
+    }
+
+    inline int add(sched_elem &el){
+	return add(el.src,el.dst,el.type,el.tstamp);
+    }
+    
+    int get_old(__timestamp cur,u32 wait_to,sched_elem &el)
+    {
+	if( !q.size() )
+	    return -1;
+
+	q.sort();
+	list<sched_elem>::iterator p = q.begin();
+
+	if( cur - p->tstamp > wait_to ){
+	    el = *p;
+//	    printf("FIND_DEL: clear src(%d) dst(%d) type(%d) tstamp(%d)\n",p->src,p->dst,p->type,p->tstamp.get_val());
+	    q.pop_front();
+	    return 0;
+	}
+	return -1;
+    }	
+    
+    int schedule(sched_elem &el,__timestamp cur){
+	q.sort();
+	unit swap;
+	list<sched_elem>::iterator p = q.begin();
+	for(;p != q.end();p++ ){
+	    if( p->tstamp <= cur ){
+		el = *p;
+		q.erase(p);
+		return 0;
+	    }else
+		return -1;
+	}
+	return -1;
+    }
+
+    int find_del(unit src,unit dst,unsigned char type,__timestamp cur){
+	q.sort();
+	list<sched_elem>::iterator p = q.begin();
+	for(;p != q.end();p++ ){
+	    // search needed element
+	    unit s1 = p->src;
+	    unit d1 = p->dst;
+	    char t1 = p->type;
+	    if( ((src == p->src)||(p->src == BCAST)) && (dst == p->dst) && (type == p->type) ){
+		q.erase(p);
+		return 0;
+	    }
+	}	
+	return -1;
+    }
+    
+    void print(){
+	q.sort();
+	list<sched_elem>::iterator p = q.begin();
+	int i=0;
+	for(;p != q.end();p++ ){
+	    unsigned char a = p->type;
+	    printf("%d: src(%d),dst(%d),type(%u),tick(%d)\n",i,p->src,p->dst,(unsigned char)(a&0xff),p->tstamp.get_val());
+	    i++;
+	}	
+    }	
+
+};
+
+/*
+int main()
+{
+    __timestamp t(200);
+    __timestamp t1(t);
+    __timestamp t2(t,5);
+    __timestamp t3(195);
+    sched_queue q,q1;
+    
+    unit s,d;
+    unsigned char tp;
+    sched_elem el;
+    int k=q.schedule(el,t2,q1);
+    q.add(stu_c,stu_r,1,t);
+    q.add(stu_c,sru1,1,t2+10);
+    q.add(stu_c,sru2,2,t2);
+    t++;
+    k=q.find_del(stu_c,sru3,1);
+    k=q.schedule(el,t2,q1);
+    k=q1.find_del(stu_c,sru2,2);
+    k=q.find_del(stu_c,sru1,1);
+    k=q.find_del(stu_c,stu_r,1);
+    k=q.find_del(stu_c,stu_r,1);
+
+}
+*/
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine.h	(revision 50)
@@ -0,0 +1,32 @@
+#ifndef EOC_ENGINE_H
+#define EOC_ENGINE_H
+
+#include <devs/EOC_dev.h>
+#include <devs/EOC_dev_terminal.h>
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <engine/EOC_router.h>
+#include <engine/EOC_responder.h>
+
+#define RECV_ONCE 10
+
+class EOC_engine{
+protected:
+    dev_type type;
+    EOC_router *rtr;
+    EOC_responder *resp;
+    u16 recv_max;
+public:
+    EOC_engine(EOC_dev_terminal *d1,dev_type t = slave,u16 rmax = RECV_ONCE);
+    EOC_engine(EOC_dev *d1,EOC_dev *d2, u16 rmax = RECV_ONCE);
+    inline ~EOC_engine(){
+	if( rtr ) delete rtr;
+	if( resp ) delete resp;
+    }
+    int setup_state();
+    virtual int schedule();
+    dev_type get_type(){ return type; }
+    virtual int configure(char *ch_name); // Slave configuration, Repeater need no configuration
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_act.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_act.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_act.h	(revision 50)
@@ -0,0 +1,38 @@
+#ifndef EOC_ENGINE_ACT_H
+#define EOC_ENGINE_ACT_H
+
+#include <devs/EOC_dev.h>
+#include <devs/EOC_dev_terminal.h>
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+
+#include <utils/hash_table.h>
+
+#include <config/EOC_config.h>
+
+#include <engine/EOC_poller.h>
+#include <engine/EOC_engine.h>
+
+
+
+class EOC_engine_act : public EOC_engine {
+protected:
+    EOC_poller *poll;
+    EOC_config *cfg;
+public:
+    EOC_engine_act(EOC_dev_terminal *d1,EOC_config *cfg,u16 ticks_p_min=0,u16 rmax = 10);
+    inline ~EOC_engine_act(){
+	if( rtr ) delete rtr;
+	if( resp ) delete resp;
+	if( poll ) delete poll;
+    }
+
+    int setup_state_act();
+    int schedule();
+    int register_handlers();
+    int app_request(app_frame *fr);
+    int configure(char *ch_name); // Master configuration
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_poller.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_poller.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_poller.h	(revision 50)
@@ -0,0 +1,54 @@
+/*
+ * EOC_poller.h:
+ * 	master EOC polling class
+ */
+#ifndef EOC_POLLER_H
+#define EOC_POLLER_H
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_types.h>
+#include <devs/EOC_dev.h>
+#include <engine/EOC_scheduler.h>
+#include <engine/EOC_handlers.h>
+#include <config/EOC_config.h>
+#include <db/EOC_db.h>
+
+class EOC_poller{
+private:
+    EOC_db *db;
+    EOC_scheduler *sch;
+    EOC_config *cfg;
+    request_handler_t req_hndl[REQUEST_QUAN];
+
+public:
+    EOC_poller(EOC_config *c,int ticks_per_minute,int loops){
+	int i;
+	sch = new EOC_scheduler(ticks_per_minute);
+	db = new EOC_db(sch,loops);
+	cfg = c;
+	for(i=0;i<REQUEST_QUAN;i++)
+	    req_hndl[i] = NULL;
+    }
+    ~EOC_poller(){
+	delete db;
+	delete sch;
+	delete cfg;
+    }
+    void link_state(EOC_dev::Linkstate link);
+    inline EOC_dev::Linkstate link_state(){ 
+	return ((sch->state()==EOC_scheduler::Offline) ? EOC_dev::OFFLINE : EOC_dev::ONLINE);
+    }
+
+    int register_request(u8 type,request_handler_t h);
+    int unregister_request(u8 type);
+    EOC_msg *gen_request();
+    int process_msg(EOC_msg *m);
+    int app_request(app_frame *fr);
+    inline int unit_quan(){ db->unit_quan(); }
+    inline int link_established(){ db->link_established(); }
+      
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_scheduler.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_scheduler.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_scheduler.h	(revision 50)
@@ -0,0 +1,100 @@
+/*
+ * EOC_scheduler.h:
+ * 	EOC channel units polling schedule objecht
+ * 	provides schedule for request generating and sending
+ */
+
+#ifndef EOC_SCHEDULER_H
+#define EOC_SCHEDULER_H
+
+#include <devs/EOC_dev.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_requests.h>
+#include <generic/EOC_responses.h>
+#include <engine/sched_queue.h>
+
+
+class EOC_scheduler{
+public:
+    enum unit_state{ NotPresent,Discovered, Inventored, Configured };
+    enum sched_state{ Offline,Setup,Normal };    
+protected:
+    struct state_machine{
+	// TODO: Maybe linked list ??
+	unit_state ustates[MAX_UNITS];
+	sched_state state;
+    } *statem;
+    __timestamp ts;
+    int ts_offs;
+    // Task queues
+    sched_queue *send_q,*wait_q;
+    u32 wait_to;
+    // State change functions
+    void jump_Offline();
+    int jump_Setup();
+    int jump_Normal();
+    int poll_unit(int ind);
+public:
+    EOC_scheduler(u32 tick_per_minute){
+    	send_q = new sched_queue();
+	wait_q = new sched_queue();
+	statem = new state_machine;
+	wait_to = tick_per_minute;
+	ts_offs = tick_per_minute*2;
+	jump_Offline();
+    }
+    //
+    inline void link_state(EOC_dev::Linkstate st){
+	switch(st){
+	case EOC_dev::OFFLINE:
+	    jump_Offline();
+	case EOC_dev::ONLINE:
+	    if( jump_Setup() )
+		jump_Offline();
+	}
+    }
+    
+    sched_state state(){ return statem->state; }
+    inline void tick(){ ts++; }
+    
+    // Schedule request & check response to me scheduled
+    int request(sched_elem &el);
+    int response(EOC_msg *m);
+    int resched();
+    // debug
+    void print(){
+    	printf("______________________________________\n");   
+	printf("send_q:\n");
+	send_q->print();
+	printf("______________________________________\n");
+	printf("wait_q:\n");
+	wait_q->print();
+    }
+};
+
+/*
+Очередь запросов, на которые не поступило ответов. Описывается:
+1. Тип ожидаемого ответа
+2. Время отсылки запроса
+3. Источник ответа (фиксированный или широковещательный)
+4. Перевод в новое состояние ???? Кого? 
+    (Discovery -ответ переводитконкретный элемент в состояние Inventory)
+    4 состояния - 1. Discovery, 2. Inventory, 3. Configure 4. Online
+5. 
+
+Машина состояний для канала:
+1. Offline - нет связи
+2. Discovery:
+    1.1 Отослать запрос
+    1.2 Собирать ответы пока не придет ответ от слейва, каждый новый эл-т канала
+        добавляется в БД и переходит в состояние Inventory
+3. Online - если каждый из юнитов успешно прошел все стадии 
+	( 1. Discovery, 2. Inventory, 3. Configure )
+
+Для юнита:
+1. Discovered - элемент создан
+2. Inventored - пришел Inventory response
+3. Configured - пришел Configure response
+    
+*/
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_handlers.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_handlers.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_handlers.h	(revision 50)
@@ -0,0 +1,24 @@
+/*
+ * EOC_responses.h:
+ *	Contains structures of SHDSL EOC responses
+ */
+
+#ifndef EOC_HANDSLERSS_H
+#define EOC_HANDLERS_H
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_requests.h>
+#include <db/EOC_db.h>
+#include <config/EOC_config.h>
+#include <engine/EOC_scheduler.h>
+#include <engine/EOC_responder.h>
+
+
+typedef EOC_scheduler::sched_state sched_state;
+
+// Poller Request handler prototype
+typedef EOC_msg *(*request_handler_t)(sched_state stat,sched_elem el,EOC_config *cfg);
+ 
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_router.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_router.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_router.h	(revision 50)
@@ -0,0 +1,80 @@
+/*
+ *    EOC_router:
+ *	Provide message receiving/sending/routing based on their
+ *	address fields in EOC message as described in G.shdsl standard
+ */
+
+#ifndef SIGRAND_EOC_ROUTER_H
+#define SIGRAND_EOC_ROUTER_H
+
+#include <generic/EOC_msg.h>
+#include <generic/EOC_generic.h>
+#include <devs/EOC_dev.h>
+
+
+class EOC_router{
+public:
+    struct interface{
+	EOC_dev *sdev;
+	unit sunit;
+	EOC_msg::Direction in_dir,out_dir;
+	shdsl_state state;
+    };
+    enum {SHDSL_MAX_IF=2};
+protected:
+    dev_type type;
+    struct interface ifs[SHDSL_MAX_IF];
+    unsigned char if_cnt,if_poll;
+    int max_recv_msg;
+    
+    inline void zero_init();
+    inline EOC_dev *get_route_dev(int if_ind);
+    inline int out_direction(EOC_msg::Direction *dir);
+    inline EOC_msg *process_discovery(int if_ind,EOC_msg *m);
+
+
+    // ------------ loopback ------------------//
+    #define LOOPB_BUF_SZ 16
+    int loop_head,loop_tail;
+    EOC_msg *loopb[LOOPB_BUF_SZ];
+    inline int inc(int ind,int max_ind){ return (ind+1<max_ind) ? ind+1 : 0; }
+    inline int add_loop(EOC_msg *m){
+	if( loop_head == inc(loop_tail,LOOPB_BUF_SZ) ) 
+	    return -1;
+	loopb[loop_tail] = m;
+	loop_tail = inc(loop_tail,LOOPB_BUF_SZ);
+	return 0;
+    }
+
+    inline EOC_msg *get_loop(){
+	EOC_msg *m;
+	if( loop_head == loop_tail ) 
+	    return NULL;
+	m = loopb[loop_head];
+	loop_head = inc(loop_head,LOOPB_BUF_SZ);
+	return m;
+    }
+    // ------------ loopback ------------------//
+
+public:
+    EOC_router(dev_type r,EOC_dev *side);
+    EOC_router(dev_type r,EOC_dev *nside,EOC_dev *cside);
+    ~EOC_router();
+
+    EOC_msg *receive();
+    int send(EOC_msg *m);
+
+    unit csunit();
+    unit nsunit();    
+    EOC_dev *csdev();
+    EOC_dev *nsdev();    
+
+    int csunit(unit u);
+    int nsunit(unit u);
+    int term_unit(unit u);
+    void update_state();    
+    int loops();
+	
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_Cwrap.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_Cwrap.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_engine_Cwrap.h	(revision 50)
@@ -0,0 +1,13 @@
+#ifndef EOC_ENGINE_WRAPPER_H
+#define EOC_ENGINE_WRAPPER_H
+
+struct EOC_engine;
+struct EOC_dev;
+
+// Initialise engine
+EOC_engine *
+init_repeater(EOC_dev *d1,EOC_dev *d2,int packets);
+int engine_sched(EOC_engine *eng);
+void release_repeater(EOC_engine *eng);
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_responder.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_responder.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/EOC_responder.h	(revision 50)
@@ -0,0 +1,67 @@
+/*
+ * EOC_responder.h:
+ *	Defines universal EOC code part which runs on ewery unit in
+ *	SHDSL span.
+ *	It provides request processing.
+*/
+
+
+#ifndef SIGRAND_EOC_RESPONDER_H
+#define SIGRAND_EOC_RESPONDER_H
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_msg.h>
+#include <generic/EOC_requests.h>
+#include <generic/EOC_responses.h>
+#include <engine/EOC_router.h>
+#include <eoc_debug.h>
+
+class EOC_responder{
+public:
+typedef int (*responder_handler_t)(EOC_responder *in,EOC_msg *m,EOC_msg **&ret,int &cnt);
+protected:
+    responder_handler_t handlers[REQUEST_QUAN];
+    EOC_router *r;
+public:
+    EOC_responder(EOC_router *r_in){
+	r = r_in;
+	for(int i=0;i<REQUEST_QUAN;i++)
+	    handlers[i] = NULL;
+
+	handlers[REQ_INVENTORY] = _inventory;
+	handlers[REQ_CONFIGURE] = _configure;
+	handlers[REQ_STATUS] =_status;
+	handlers[15] = _test;
+    }
+
+    ~EOC_responder(){}
+
+    int register_hndl(u8 type,responder_handler_t h){
+	if( !(type < REQUEST_QUAN) || handlers[type])
+	    return -1;
+	handlers[type] = h;
+	return 0;
+    }
+
+    int unregister_hndl(u8 type,responder_handler_t h){
+	if( !(type < REQUEST_QUAN) || !handlers[type])
+	    return -1;
+	handlers[type] = NULL;
+	return 0;
+    }
+
+    int request(EOC_msg *m,EOC_msg **&ret,int &cnt){
+	if( !m->is_request() || !handlers[m->type()])
+	    return -1;
+	return handlers[m->type()](this,m,ret,cnt);
+    }
+    
+    // Handlers
+    static int _inventory(EOC_responder *in,EOC_msg *m,EOC_msg **&ret,int &cnt);
+    static int _configure(EOC_responder *in,EOC_msg *m,EOC_msg **&ret,int &cnt);
+    static int _status(EOC_responder *in,EOC_msg *m,EOC_msg **&ret,int &cnt);
+    static int _test(EOC_responder *in,EOC_msg *m,EOC_msg **&ret,int &cnt);
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_elem.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_elem.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/engine/sched_elem.h	(revision 50)
@@ -0,0 +1,82 @@
+#ifndef SCHED_ELEM_H
+#define SCHED_ELEM_H
+
+#include <generic/EOC_generic.h>
+#include <list>
+
+using namespace std;
+
+class __timestamp{
+protected:
+    unsigned long ticks;
+public:
+    __timestamp(){ ticks = 0; }
+    __timestamp(unsigned int t){ ticks = t; }
+    __timestamp(const __timestamp &t){ ticks = t.ticks; }
+    __timestamp(__timestamp t,unsigned int offs){ ticks = t.ticks + offs; }
+
+    inline __timestamp & operator =(__timestamp &right){
+	ticks = right.ticks;
+	return *this;
+    }
+
+    inline bool operator ==(__timestamp &right){
+	if( ticks == right.ticks )
+	    return 1;
+	return 0;
+    }
+    inline bool operator < (__timestamp &right){
+	if( ticks < right.ticks )
+	    return 1;
+	return 0;
+    }
+    inline bool operator <= (__timestamp &right){
+	if( ticks <= right.ticks )
+	    return 1;
+	return 0;
+    }
+    inline __timestamp & operator ++ (int k){
+	ticks++;
+	return *this;
+    }
+    inline __timestamp &operator+(__timestamp &right){
+	__timestamp *n = new __timestamp(*this);
+	n->ticks += right.ticks;
+	return *n;
+    }
+
+    inline __timestamp operator+(int &offs){
+	__timestamp n = *this;
+	n.ticks += offs;
+	return n;
+    }
+
+    inline int operator-(__timestamp &right){
+	return (this->ticks - right.ticks);
+    }
+
+    int get_val(){ return ticks; }
+
+};
+
+class sched_elem{
+public:
+    unit src,dst;
+    unsigned char type;
+    __timestamp tstamp;
+public:
+    inline bool operator < (sched_elem &right){
+	if( tstamp < right.tstamp )
+	    return 1;
+	return 0;
+    }
+    inline sched_elem &operator = (sched_elem &right){
+	src = right.src;
+	dst = right.dst;
+	type = right.type;
+	tstamp = right.tstamp;
+	return *this;
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/conf_profile.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/conf_profile.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/conf_profile.h	(revision 50)
@@ -0,0 +1,25 @@
+#ifndef SPAN_PROFILE_H
+#define SPAN_PROFILE_H
+
+#include <generic/EOC_types.h>
+#include <utils/hash_table.h>
+#include <generic/span_conf_type.h>
+
+class conf_profile : public hash_elem{
+public:
+    span_conf_profile_t conf;
+
+    conf_profile() : hash_elem()
+    {
+	memset(&conf,0,sizeof(conf));
+	conf.annex = annex_a;
+	conf.wires = twoWire;
+	conf.power = noPower;
+	conf.psd = symmetric;
+	conf.clk = localClk;
+	conf.line_probe = disable;
+	conf.remote_cfg = disabled;
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h	(revision 50)
@@ -0,0 +1,63 @@
+#ifndef APP_FRAME_H
+#define APP_FRAME_H
+
+#include <stdio.h>
+#include <generic/EOC_types.h>
+#include <eoc_debug.h>
+#include <string.h>
+#include <time.h>
+
+#include <app-if/app_messages.h>
+
+#define APP_FRAME_DEBUG 0
+
+class app_frame{
+public:
+    typedef enum { REQUEST,RESPONSE } roles;
+protected:
+    typedef struct {
+	u32 len;
+	u32 psize;
+	u16 csize;
+	u8 id;
+	u8 type:2;
+	u8 role:1;
+	u8 error;
+	char dname[SPAN_NAME_LEN];
+	time_t tstamp;
+	u8 act_sec;
+    }app_frame_hdr;
+    
+    app_frame_hdr *hdr;
+    enum {FRAME_HEADER_SZ = sizeof(app_frame_hdr) };
+    char *buf;
+    u32 buf_size;
+    int size_by_id(app_ids id,app_types type,u32 &psize,u32 &csize);
+    
+public:
+    app_frame(app_ids id,app_types type,roles role,u8 act_sec,char *dname = "\0");
+    app_frame(char *b,int size);
+    ~app_frame();
+    const char *chan_name();
+    void chan_name(char *name);
+    char *payload_ptr();
+    char *changelist_ptr();
+    char *frame_ptr(){ return buf; }
+    int frame_size(){ return buf_size; }
+    app_ids id(){ return (app_ids)hdr->id; }
+    app_types type(){ return (app_types)hdr->type; }
+    roles role(){ return (roles)hdr->role; }
+    void negative(){ hdr->error = 1; }
+    int is_negative(){ return hdr->error; }
+    void response(){ hdr->role = RESPONSE; }
+    int info_uptodate(){
+	time_t cur;
+	if(time(&cur) < 0){
+	    PDEBUG(DERR,"Error getting current time");
+	}
+	return ((cur-hdr->tstamp)<hdr->act_sec) ? 1 : 0;
+    }
+	
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h	(revision 50)
@@ -0,0 +1,63 @@
+#ifndef EOCD_APP_COMMUNICATOR_H
+#define EOCD_APP_COMMUNICATOR_H
+
+#include <sys/types.h>
+#include <string.h>
+#include <malloc.h>
+#include <stdio.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+class app_comm{
+protected:
+    enum { MAX_SOCK_NAME = 256 };
+    enum { BLOCK_SIZE = 1024 };
+    
+    int error_init;
+
+    char *sname;
+    int sfd;
+    fd_set socks;
+    int hisock;    
+    
+    int init_success(){ return !error_init; }
+    int set_nonblock(int sock);
+    virtual int build_select_list();
+    virtual int complete_wait() = 0;
+
+    // data transparency && message end/begin flags
+    char *transp(char *buf,size_t size,size_t &nsize){
+	nsize = size;
+	return buf;
+    }
+    char *untransp(char *frame,size_t frame_len){
+	return frame;
+    }
+public:
+    app_comm(char *sock_name){
+	sname = strndup(sock_name,MAX_SOCK_NAME);
+	error_init = 0;
+    }
+    app_comm(char *sock_path,char *sock_name){
+	int len = strnlen(sock_path,MAX_SOCK_NAME) + strnlen(sock_name,MAX_SOCK_NAME) + 2;
+	sname = (char*)malloc(sizeof(char) * len);
+	snprintf(sname,len,"%s/%s",sock_path,sock_name);
+	error_init = 0;
+    }
+    ~app_comm(){
+//	printf("Call destructor\n");
+	free(sname);
+    }
+    int wait(int sec = 4);
+    int _send(int fd,char *buf,size_t size);
+    ssize_t _recv(int fd,char *&buf);
+    int init_ok(){ return (!error_init); }
+};
+
+#endif
+
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h	(revision 50)
@@ -0,0 +1,18 @@
+#ifndef EOCD_APP_COMM_CLI_H
+#define EOCD_APP_COMM_CLI_H
+
+#include <app-if/app_comm.h>
+
+class app_comm_cli : public app_comm {
+protected:
+    int complete_wait();
+public:
+    app_comm_cli(char *sock_name);
+    ~app_comm_cli();
+    int send(char *buf,size_t size);
+    ssize_t recv(char *&buf);
+};
+
+#endif
+
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h	(revision 50)
@@ -0,0 +1,24 @@
+#ifndef EOC_APP_COMM_SRV_H
+#define EOC_APP_COMM_SRV_H
+
+#include <app-if/app_comm.h>
+
+class app_comm_srv : public app_comm {
+protected:
+    #define MAX_CONNECTIONS 5
+    int conn_fd[MAX_CONNECTIONS];
+    unsigned char conn_act[MAX_CONNECTIONS];
+    int conn_num;
+
+    // functions
+    int complete_wait();
+    int new_connection();
+    int build_select_list();
+    int next_fd();
+public:
+    app_comm_srv(char *sock_path,char *sock_name);
+    int send(int conn_num,char *buf,size_t size);
+    ssize_t recv(int &conn_idx,char *&buf);
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h	(revision 50)
@@ -0,0 +1,195 @@
+#ifndef APP_MESSAGES_H
+#define APP_MESSAGES_H
+
+#include <snmp/snmp-generic.h>
+#include <generic/span_conf_type.h>
+#include <generic/EOC_responses.h>
+#include <generic/EOC_types.h>
+
+
+typedef enum { APP_SPAN_NAME=0,APP_SPAN_PARAMS,APP_SPAN_CONF,APP_SPAN_STATUS,
+	    APP_INVENTORY,APP_ENDP_CONF,APP_ENDP_CUR,APP_ENDP_15MIN,
+	    APP_ENDP_1DAY,APP_ENDP_MAINT,APP_UNIT_MAINT,APP_SPAN_CPROF,
+	    APP_ENDP_APROF } app_ids;
+#define app_ids_num 13
+
+typedef enum { APP_SET,APP_GET,APP_GET_NEXT } app_types;
+
+/*
+1. список обслуживаемых каналов
+2. Для конкретного канала: число элементов в канале, число пар проводов
+*/
+
+#define SPAN_NAMES_NUM 4
+#define SPAN_NAME_LEN 32
+typedef struct{
+    u8 filled:7;
+    u8 last_msg:1; 
+    char name[SPAN_NAMES_NUM][SPAN_NAME_LEN];
+} span_name_payload;
+#define SPAN_NAME_PAY_SZ sizeof(span_name_payload)
+#define SPAN_NAME_CH_SZ 0
+
+typedef struct{
+    u8 units;
+    u8 link_establ:1;
+    u8 loops:7;
+} span_params_payload;
+#define SPAN_PARAMS_PAY_SZ sizeof(span_params_payload)
+#define SPAN_PARAMS_CH_SZ 0
+
+typedef struct{
+    s16 nreps;
+    char conf_prof[SNMP_ADMIN_LEN+1];
+    char alarm_prof[SNMP_ADMIN_LEN+1];
+} span_conf_payload;
+#define SPAN_CONF_PAY_SZ sizeof(span_conf_payload)
+#define SPAN_CONF_CH_SZ 0
+
+typedef struct{
+    s8 nreps;
+    u32 max_lrate;
+    u32 act_lrate;
+    u8 region0 : 1;
+    u8 region1 : 1;
+    u8 : 6;
+    u32 max_prate;
+    u32 act_prate;
+} span_status_payload;
+#define SPAN_STATUS_PAY_SZ sizeof(span_status_payload)
+#define SPAN_STATUS_CH_SZ 0
+
+typedef struct{
+    u8 unit;
+    u8 eoc_softw_ver;
+    resp_inventory inv;
+    u8 region0 :1;
+    u8 region1 :1;
+} inventory_payload;
+#define INVENTORY_PAY_SZ sizeof(inventory_payload)
+#define INVENTORY_CH_SZ 0
+
+typedef struct{
+    u8 unit;
+    u8 side;
+    u8 loop;
+    char alarm_prof[SNMP_ADMIN_LEN+1];
+} endp_conf_payload;
+#define ENDP_CONF_PAY_SZ sizeof(endp_conf_payload)
+// TODO: may be set request!
+#define ENDP_CONF_CH_SZ 0
+
+typedef struct {
+    u8 unit;
+    u8 side;
+    u8 loop;
+    s32 cur_attn;
+    s32 cur_snr;
+    shdsl_status_t cur_status;
+    counters_t total;
+    u32 cur_15m_elaps;
+    counters_t cur15min;
+    u32 cur_1d_elaps;    
+    counters_t cur1day;
+    s32 CurrTipRingReversal;
+    s32 CurrActivationState;
+} endp_cur_payload;
+#define ENDP_CUR_PAY_SZ sizeof(endp_cur_payload)
+#define ENDP_CUR_CH_SZ sizeof(endp_cur_payload)
+
+typedef struct {
+    u8 unit;
+    u8 side;
+    u8 loop;
+    u32 int_num;
+    counters_t cntrs;
+} endp_int_payload;
+
+#define endp_15min_payload endp_int_payload
+#define ENDP_15MIN_PAY_SZ sizeof(endp_15min_payload)
+#define ENDP_15MIN_CH_SZ 0
+
+#define endp_1day_payload endp_int_payload
+#define ENDP_1DAY_PAY_SZ sizeof(endp_15min_payload)
+#define ENDP_1DAY_CH_SZ 0
+
+
+typedef struct{
+    u8 unit;
+    u8 side;
+    s32 LoopbackConfig;
+    s32 TipRingReversal;
+    s32 PowerBackOff;
+    s32 SoftRestart;
+} endp_maint_payload;
+#define ENDP_MAINT_PAY_SZ sizeof(endp_maint_payload)
+
+typedef struct{
+    u8 LoopbackConfig:1;
+    u8 PowerBackOff:1;
+    u8 SoftRestart:1;
+} endp_maint_changes;
+#define ENDP_MAINT_CH_SZ sizeof(endp_maint_changes)
+
+typedef struct{
+    s32 LoopbackTimeout;
+    s32 PowerSource;
+} unit_maint_payload;
+#define UNIT_MAINT_PAY_SZ sizeof(unit_maint_changes)
+
+typedef struct{
+    u8 LoopbackTimeout:1;
+} unit_maint_changes;
+#define UNIT_MAINT_CH_SZ sizeof(unit_maint_changes)
+
+typedef struct{
+    char ProfileName[SNMP_ADMIN_LEN+1];
+    span_conf_profile_t conf;
+} span_conf_prof_payload;
+#define SPAN_CONF_PROF_PAY_SZ sizeof(span_conf_prof_payload)
+
+typedef struct{
+    u8 annex :1;
+    u8 wires :1;      
+    u8 power :1;
+    u8 psd :1;
+    u8 clk:1;
+    u8 line_probe:1;
+    u8 remote_cfg:1;
+    u8 currCondDown :1;                                                   
+    u8 worstCaseDown :1;                                                  
+    u8 currCondUp :1;                                                     
+    u8 worstCaseUp :1;
+    u8 min_rate:1;
+    u8 max_rate:1;
+    s8 cur_marg_down:1;
+    s8 worst_marg_down:1;
+    s8 cur_marg_up:1;
+    s8 worst_marg_up:1;
+} span_conf_prof_changes;
+#define SPAN_CONF_PROF_CH_SZ sizeof(span_conf_prof_changes)
+
+typedef struct{
+    char ProfileName[SNMP_ADMIN_LEN];
+    s32 ThreshLoopAttenuation;
+    s32 ThreshSNRMargin;
+    u32 ThreshES;
+    u32 ThreshSES;
+    u32 ThreshCRCanomalies;
+    u32 ThreshLOSWS;
+    u32 hdsl2ShdslEndpointThreshUAS;
+} endp_alarm_prof_payload;
+#define ENDP_ALARM_PROF_PAY_SZ sizeof(endp_alarm_prof_payload)
+
+typedef struct{
+    u8 ThreshLoopAttenuation:1;
+    u8 ThreshSNRMargin:1;
+    u8 ThreshES:1;
+    u8 ThreshSES:1;
+    u8 ThreshCRCanomalies:1;
+    u8 ThreshLOSWS:1;
+    u8 hdsl2ShdslEndpointThreshUAS:1;
+} endp_alarm_prof_changes;
+#define ENDP_ALARM_PROF_CH_SZ sizeof(endp_alarm_prof_changes)
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h	(revision 50)
@@ -0,0 +1,36 @@
+#ifndef EOC_TYPES_H
+#define EOC_TYPES_H
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+typedef struct{
+    u16 noDefect:1;
+    u16 powerBackoff:1;
+    u16 deviceFault:1;
+    u16 dcContFault:1;
+    u16 snrMargAlarm:1;
+    u16 loopAttnAlarm:1;
+    u16 loswFailAlarm:1;
+    u16 configInitFailure:1;
+    u16 protoInitFailure:1;
+    u16 noNeighborPresent:1;
+    u16 loopbackActive:1;
+} shdsl_status_t;
+ 
+
+typedef struct{
+	u32 mon_sec;
+    u32 es;
+    u32 ses;
+    u32 crc;
+    u32 losws;
+    u32 uas;
+} counters_t;
+
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h	(revision 50)
@@ -0,0 +1,51 @@
+#ifndef EOC_MSG_H
+#define EOC_MSG_H
+
+#include <stdio.h>
+#include <string.h>
+
+#include <generic/EOC_generic.h>
+
+class EOC_msg{
+public:
+    enum Direction { NOSTREAM,DOWNSTREAM, UPSTREAM };
+    enum EOC_CONSTS {EOC_HEADER=2};
+protected:
+    char *buf;
+    int size,bsize;
+    enum Direction dir;
+public:
+    EOC_msg();
+    EOC_msg(int size);    
+    EOC_msg(EOC_msg *ex);
+    EOC_msg(EOC_msg *ex,int new_size);    
+    ~EOC_msg();
+    void direction(enum Direction d);
+    Direction direction();
+    unsigned char type();
+    int type(unsigned char);
+    unit dst();
+    int dst(unit dst);
+    unit src();
+    int src(unit src);
+    int setup(char *ptr,int size);
+    void clean();
+    
+    inline char *mptr(){ return buf; }
+    inline int msize(){	return size; }
+    inline char *payload(){ return &buf[2]; }
+    inline int payload_sz(){ return size-2; }    
+    int response(int);
+    int resize(int sz);
+    
+    // class of message
+    inline int is_request(){
+	if( type() < 127 )
+	    return 1;
+	return 0;
+    }
+    inline int is_response(){ return !is_request(); }
+	
+};
+#endif
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h	(revision 50)
@@ -0,0 +1,54 @@
+/*
+ * EOC_requests.h:
+ *	Contains structures of SHDSL EOC requests
+ */
+#ifndef EOC_REQUESTS_H
+#define EOC_REQUESTS_H
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+
+#define REQ_DISCOVERY 1
+typedef struct{
+    u8 hop;
+} req_discovery; 
+#define REQ_DISCOVERY_SZ sizeof(req_discovery)
+
+#define REQ_INVENTORY 2
+typedef struct{
+}req_inventory; 
+#define REQ_INVENTORY_SZ sizeof(req_inventory)
+
+#define REQ_CONFIGURE 3
+typedef struct{
+    u8 loop_attn:7;
+    u8 conf_type:1;
+    u8 :4;
+    u8 snr_marg:7;
+} req_configure;
+#define REQ_CONFIGURE_SZ sizeof(req_configure)
+
+#define REQ_STATUS 11
+typedef struct{
+} req_status;
+#define REQ_STATUS_SZ sizeof(req_status)
+
+#define REQ_FULL_STATUS 12
+typedef struct{
+} req_full_status;
+#define REQ_FULL_STATUS_SZ sizeof(req_full_status)
+
+
+#define REQ_SRST_BCKOFF 15
+typedef struct{
+    u8 ns_srst :1;
+    u8 ns_bckoff :1;
+    u8 :6;
+    u8 cs_srst :1;
+    u8 cs_bckoff :1;
+    u8 :6; 
+    
+} req_srst_bckoff;
+#define REQ_SRST_BCKOFF_SZ sizeof(req_srst_bckoff)
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h	(revision 50)
@@ -0,0 +1,30 @@
+#ifndef SIGRAND_EOC_GENERIC_H
+#define SIGRAND_EOC_GENERIC_H
+
+#include <generic/EOC_types.h>
+
+typedef enum { master,slave,repeater } dev_type;
+typedef enum { eoc_Offline, eoc_Discovery, eoc_Online } shdsl_state;
+typedef enum {err =-1,unknown=0 ,stu_c,stu_r,sru1,sru2,sru3,sru4,sru5,sru6,
+			sru7,sru8,sru9,sru10,BCAST=0xf} unit;
+typedef enum { net_side=0,cust_side } side;
+
+// SHDSL standard related
+#define MAX_LOOPS 4
+#define MAX_UNITS 10
+#define MAX_REPEATERS (MAX_UNITS-2)
+
+
+
+// EOC messages
+#define REQUEST_QUAN 128
+#define RESPONSE_QUAN 128
+#define RESP_OFFSET 128
+
+// OS related
+#define FNAME_SIZE 32
+#define PATH_SIZE 256
+#define FILE_PATH_SIZE PATH_SIZE+FNAME_SIZE
+
+#endif
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h	(revision 50)
@@ -0,0 +1,112 @@
+/*
+ * EOC_responses.h:
+ *	Contains structures of SHDSL EOC responses
+ */
+
+#ifndef EOC_RESPONSES_H
+#define EOC_RESPONSES_H
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_requests.h>
+
+#define REQ2RESP(x) (x + RESP_OFFSET)
+#define RESP2REQ(x) (x - RESP_OFFSET)
+#define RESP_IND(x) (x - RESP_OFFSET-1)
+
+// DISCOVERY response
+typedef struct{
+    u8 hop;
+    u8 res1;
+    u8 vendor_id[8];
+    u8 eoc_softw_ver;
+    u8 shdsl_ver;
+    u8 fwd_loss:1;
+    u8 :7;
+} resp_discovery;
+#define RESP_DISCOVERY REQ2RESP(REQ_DISCOVERY)
+#define RESP_DISCOVERY_SZ sizeof(resp_discovery)
+
+// IVENTORY response
+typedef struct{
+    u8 shdsl_ver;
+    u8 ven_lst[4];
+    u8 ven_issue[3];
+    u8 softw_ver[7];
+    u8 unit_id_code[11];
+    u8 res1;
+    u8 ven_id[9];
+    u8 ven_model[14];
+    u8 ven_serial[14];
+    u8 other[14];
+} resp_inventory;
+#define RESP_INVENTORY REQ2RESP(REQ_INVENTORY)
+#define RESP_INVENTORY_SZ sizeof(resp_inventory)
+
+
+// CONFIGURE response
+typedef struct{
+    u8 utc:1;
+    u8 :7;
+    u8 loop_attn;
+    u8 :4;
+    u8 snr_marg :7;
+} resp_configure;
+#define RESP_CONFIGURE REQ2RESP(REQ_CONFIGURE)
+#define RESP_CONFIGURE_SZ sizeof(resp_configure)
+
+// STATUS response
+typedef struct{
+    s8 ns_snr_marg;
+    s8 cs_snr_marg;
+    u8 loop_id;
+} resp_status;
+#define RESP_STATUS REQ2RESP(REQ_STATUS)
+#define RESP_STATUS_SZ sizeof(resp_status)
+
+// SIDE PERF STATUS response
+typedef struct{
+    u8 :1;
+    u8 losws_alarm :1;
+    u8 loop_attn_alarm:1;
+    u8 snr_marg_alarm :1;
+    u8 dc_cont_flt:1;
+    u8 dev_flt:1;
+    u8 pwr_bckoff_st:1;
+    u8 :1;
+    s8 snr_marg;
+    s8 loop_attn;
+    u8 es;
+    u8 ses;
+    u16 crc;
+    u8 losws;
+    u8 uas;
+    u8 pwr_bckoff_base_val:4;
+    u8 cntr_rst_stur:1;
+    u8 cntr_ovfl_stur:1;
+    u8 cntr_rst_stuc:1;
+    u8 cntr_ovfl_stuc:1;
+    u8 loop_id:3;
+    u8 :4;
+    u8 pwr_bkf_ext:1;
+}side_perf;
+#define SIDE_PERF_SZ sizeof(side_perf)
+typedef side_perf resp_cside_perf;
+typedef side_perf resp_nside_perf;
+#define RESP_NSIDE_PERF 140
+#define RESP_NSIDE_PERF_SZ sizeof(resp_cside_perf)
+#define RESP_CSIDE_PERF 141
+#define RESP_CSIDE_PERF_SZ sizeof(resp_cside_perf)
+
+#define RESP_MAINT_STAT 137
+/*TODO : Add structure */
+
+#define RESP_SENSOR_STATE 192
+typedef struct{
+    u8 sensor1 :1;
+    u8 sensor2 :1;
+    u8 sensor3 :1;
+    u8 :5; 
+} resp_sensor_state;
+#define RESP_SENSOR_STATE_SZ sizeof(resp_sensor_state)
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h	(revision 50)
@@ -0,0 +1,37 @@
+#ifndef SPAN_CONF_TYPE_H
+#define SPAN_CONF_TYPE_H
+
+#include <generic/EOC_types.h>
+
+typedef enum { annex_a=1,annex_b } annex_t;
+typedef enum { twoWire = 1,fourWire,sixWire,eightWire } wires_t;      
+typedef enum { noPower = 1, powerFeed, wettingCurrent } power_t;
+typedef enum { symmetric = 1, asymmetric } psd_t;
+typedef enum { localClk = 1, networkClk, dataOrNetworkClk, dataClk } clk_t;
+typedef enum { disable = 1, enable } line_probe_t;
+typedef enum { disabled = 1, enabled } remote_cfg_t; 
+
+
+typedef struct{
+    annex_t annex;
+    wires_t wires;      
+    power_t power;
+    psd_t psd;    
+    clk_t clk;    
+    line_probe_t line_probe;
+    remote_cfg_t remote_cfg; 
+    
+    u8 use_cur_down :1;                                                   
+    u8 use_worst_down :1;                                                  
+    u8 use_cur_up :1;                                                     
+    u8 use_worst_up :1;
+
+    u32 min_rate;
+    u32 max_rate;
+    s32 cur_marg_down;
+    s32 worst_marg_down;
+    s32 cur_marg_up;
+    s32 worst_marg_up;
+} span_conf_profile_t;
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/shdsl/config.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/shdsl/config.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/shdsl/config.h	(revision 50)
@@ -0,0 +1,14 @@
+#ifndef EOC_SHDSL_CONFIG_H
+#define EOC_SHDSL_CONFIG_H
+
+#include <generic/EOC_types.h>
+
+class shdsl_config {
+public:
+    u32 max_rate : 20;
+    u32 min_rate : 20;
+    u32 master : 1;
+    u32 annex  :4;
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h	(revision 50)
@@ -0,0 +1,6 @@
+#ifndef EOC_SNMP_H
+#define EOC_SNMP_H
+
+#define SNMP_ADMIN_LEN 32
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/channel.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/channel.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/include/channel.h	(revision 50)
@@ -0,0 +1,30 @@
+#ifndef EOC_CHANNEL_H
+#define EOC_CHANNEL_H
+
+#include <generic/EOC_types.h>
+
+#include <utils/hash_table.h>
+
+#include <snmp/snmp-generic.h>
+
+#include <devs/EOC_dev.h>
+#include <devs/EOC_dev_terminal.h>
+
+#include <engine/EOC_engine.h>
+#include <engine/EOC_engine_act.h>
+
+class channel_elem : public hash_elem{
+public:
+    EOC_engine *eng;
+    channel_elem(EOC_dev_terminal *dev){
+	eng = new EOC_engine(dev);
+    }
+    channel_elem(EOC_dev_terminal *dev,EOC_config *c,u32 tick_per_min){
+	eng = new EOC_engine_act(dev,c,tick_per_min);
+    }
+    ~channel_elem(){
+	delete eng;
+    }
+};
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.h	(revision 50)
@@ -0,0 +1,229 @@
+/*
+ *  hdsl2,shdsl MIB (rfc- interfaces.h
+ */
+
+#ifndef _MIBGROUP_HDSL2SHDSL_H
+#define _MIBGROUP_HDSL2SHDSL_H
+
+//---- header functions ----//
+static int header_dslIfIndex(struct variable*, oid *,size_t *,
+							 int,size_t*,WriteMethod**,int *);
+
+/*---- callbacks ----*/
+extern FindVarMethod var_SpanConfEntry;
+extern FindVarMethod var_SpanStatusEntry;
+extern FindVarMethod var_InventoryEntry;
+/*
+  extern FindVarMethod var_EndpointConfEntry;
+*/
+
+extern FindVarMethod var_EndpointCurrEntry;
+
+extern FindVarMethod var_15MinIntervalEntry;
+extern FindVarMethod var_1DayIntervalEntry;
+/*
+  extern FindVarMethod var_EndpointMaintEntry;
+  extern FindVarMethod var_UnitMaintEntry;
+  // profiles
+  */
+extern FindVarMethod var_SpanConfProfEntry;
+
+/*
+  extern FindVarMethod var_EndpointAlermEntry;
+  extern FindVarMethod var_NotificationEntry;
+*/
+
+/*---- Magic values ----*/
+/*
+ * var_SpanConfEntry Magic numbers 
+ * Represents hdsl2ShdslSpanConfTable:
+ * - table indexed by {ifIndex}
+ * - each entry represents the complete span in single SHDSL line
+ * - information is persistant
+ */
+#define CONF_NREPS	0	
+#define CONF_PRFL	1	
+#define CONF_ALARMPRFL	2
+
+/*
+ * var_SpanStatusEntry Magic numbers 
+ * Represents hdsl2ShdslSpanStatusTable:
+ * - table indexed by {ifIndex},
+ * - each entry represents the complete span in single SHDSL line
+ * - information is NOT persistent
+ */
+#define STATUS_NAVAILREPS	0
+#define STATUS_MAXATTLRATE	1
+#define STATUS_ACTLRATE		2
+#define STATUS_TRNSMSNMODCUR	3
+#define STATUS_MAXATTPRATE	4
+#define STATUS_ACTPRATE		5
+
+/*
+ * var_InventoryEntry Magic numbers 
+ * Represents hdsl2ShdslInventoryTable:
+ * - table indexed by {ifIndex,hdsl2ShdslInvIndex}
+ * - info retreive via EOC from units in SHDSL line
+ * - each entry represents inventory information for a single unit in 
+ SHDSL line
+ * - information is NOT persistent
+ */
+#define INV_INDEX	0
+#define INV_VID		1
+#define INV_VMODELNUM	2
+#define INV_VSERNUM	3
+#define INV_VEOCSV	4
+#define INV_STANDARDV	5
+#define INV_VLISTNUM	6
+#define INV_VISSUENUM	7
+#define INV_VSOFTWV	8
+#define INV_EQCODE	9
+#define INV_VOTHER	10
+#define INV_TRNSMODECPB	11
+
+
+/*
+ * var_EndpointConfEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointConfTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair}
+ * - Configuration of alarm profile is setted by user
+ * - represents a single segment endpoint in an HDSL2/SHDSL line
+ * - information is persistent
+ */
+#define ENDP_SIDE	1
+#define ENDP_PAIR	2
+#define ENDP_CONF_PROF	3
+
+
+/*
+ * var_EndpointCurrEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointCurrTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair}
+ * - contains current status and performance information
+ for segment endpoints in HDSL2/SHDSL lines
+ * - information is persistent
+ */
+ 
+#define ENDP_STAT_CUR_ATN	3
+#define ENDP_STAT_CUR_SNRMGN	4
+#define ENDP_STAT_CUR_STATUS	5
+#define ENDP_STAT_CUR_ES	6
+#define ENDP_STAT_CUR_SES	7
+#define ENDP_STAT_CUR_CRC	8
+#define ENDP_STAT_CUR_LOSWS	9
+#define ENDP_STAT_CUR_UAS	10
+#define ENDP_STAT_CUR_15MEL	11
+#define ENDP_STAT_CUR_15M_ES	12
+#define ENDP_STAT_CUR_15M_SES	13
+#define ENDP_STAT_CUR_15M_CRC	14
+#define ENDP_STAT_CUR_15M_LOSWS	15
+#define ENDP_STAT_CUR_15M_UAS	16
+#define ENDP_STAT_CUR_1DEL	17
+#define ENDP_STAT_CUR_1D_ES	18
+#define ENDP_STAT_CUR_1D_SES	19
+#define ENDP_STAT_CUR_1D_CRC	20
+#define ENDP_STAT_CUR_1D_LOSWS	21
+#define ENDP_STAT_CUR_1D_UAS	22
+
+
+/*
+ * var_Endpoint15minEntry Magic numbers 
+ * Represents hdsl2Shdsl15MinIntervalTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair,hdsl2Shdsl15MinIntervalNumber}
+ * - contains history of performance information for segment endpoints in 
+ HDSL2/SHDSL lines
+ * - information is NOT persistent
+ */
+
+
+#define ENDP_15M_INT 1
+#define ENDP_15M_ES 2
+#define ENDP_15M_SES	3
+#define ENDP_15M_CRC	4
+#define ENDP_15M_LOSWS	5
+#define ENDP_15M_UAS	6
+
+
+/*
+ * var_Endpoint1dayEntry Magic numbers 
+ * Represents hdsl2Shdsl1DayIntervalTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair,hdsl2Shdsl1DayIntervalNumber}
+ * - contains current status and performance information
+ for segment endpoints in HDSL2/SHDSL lines
+ * - information is persistent
+ */
+
+#define ENDP_1D_INT	1
+#define ENDP_1D_MONSECS 2
+#define ENDP_1D_ES	3
+#define ENDP_1D_SES	4
+#define ENDP_1D_CRC	5
+#define ENDP_1D_LOSWS	6
+#define ENDP_1D_UAS	7
+
+
+
+/*
+ * var_EndpointMaintEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointMaintTable:
+ * - table indexed by 
+ *	{ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide}
+ * - supports maintenance operations (e.g., loopbacks)
+ *   to be performed on HDSL2/SHDSL segment endpoints
+ * - information is persistent
+ */
+ 
+#define ENDP_MAINT_LOOPBACK 	1
+#define ENDP_MAINT_TIPRINGREV	2
+#define ENDP_MAINT_PWRBACKOFF	3
+#define ENDP_MAINT_SOFTRESTART	4
+
+/*
+ * var_UnitMaintEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointMaintTable:
+ * - table indexed by 
+ *	{ ifIndex,hdsl2ShdslInvIndex }
+ * - supports maintenance operations (e.g., loopbacks)
+ *   to be performed on HDSL2/SHDSL segment unit
+ * - information is persistent
+ */
+ 
+#define UNIT_MAINT_LPB_TO 	1
+#define UNIT_MAINT_PWR_SRC	2
+
+
+/*
+ * var_SpanConfProfEntry Magic numbers 
+ * Represents hdsl2ShdslSpanConfProfileTable
+ * - table indexed by 
+ *	{ hdsl2ShdslSpanConfProfileName }
+ * - SHDSL Line configuration profile table to be 
+ *   performed on HDSL2/SHDSL segment unit
+ * - information is persistent
+ */
+
+#define CONF_WIRE_IFACE 	1
+#define CONF_MIN_LRATE	 	2
+#define CONF_MAX_LRATE	 	3
+#define CONF_PSD	 	4
+#define CONF_TRNSM_MODE 	5
+#define CONF_REM_ENABLE 	6
+#define CONF_PWR_FEED	 	7
+#define CONF_CURR_DOWN	 	8
+#define CONF_WORST_DOWN 	9
+#define CONF_CURR_UP	 	10
+#define CONF_WORST_UP	 	11
+#define CONF_USED_MARG	 	12
+#define CONF_REF_CLK	 	13
+#define CONF_LPROBE	 	14
+#define CONF_ROW_ST	 	15
+
+#endif                          /* _MIBGROUP_HDSL2SHDSL_H */
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.h	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.h	(revision 50)
@@ -0,0 +1,18 @@
+#ifndef SHDSL_COMM_H
+#define SHDSL_COMM_H
+
+#include <generic/EOC_types.h>
+#include <app-if/app_messages.h>
+
+struct app_comm;
+struct app_frame;
+
+struct app_comm *init_comm();
+char *comm_alloc_request(app_ids id,app_types type,char *chname,struct app_frame **fr);
+struct app_frame *comm_request(struct app_comm *comm,struct app_frame *fr);
+char *comm_frame_payload(struct app_frame *fr);
+void set_chan_name(struct app_frame *fr,char *name);
+void comm_frame_free(struct app_frame *fr);
+void comm_free(struct app_comm *cli);
+
+#endif
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/TODO.txt
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/TODO.txt	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/TODO.txt	(revision 50)
@@ -0,0 +1 @@
+(+)1. Broken pipe problem
\ No newline at end of file
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp	(revision 50)
@@ -0,0 +1,92 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm_cli.h>
+#include <eoc_debug.h>
+
+app_comm_cli::
+app_comm_cli(char *sock_name):app_comm(sock_name)
+{
+    struct sockaddr_un saun;
+    struct stat sbuf;    
+    int s;
+    int ret=0,len;
+
+    // Check path exist
+    if( (ret = stat(sname,&sbuf)) ){
+        PERROR("Problem with socket (%s)",sname);
+        error_init = 1;
+        return;
+    }  
+    if( !S_ISSOCK(sbuf.st_mode) ){
+	PDEBUG(DERR,"Not a socket (%s)",sname);
+        error_init = 1;	
+	return;
+    }
+
+    // Create socket
+    if ( (s = socket(AF_UNIX, SOCK_STREAM, 0) ) < 0) {
+    	PERROR("Cannot create socket (%s)",sname);
+        error_init = 1;
+	return;    
+    }
+
+    saun.sun_family = AF_UNIX;
+    strcpy(saun.sun_path,sname);
+	
+    len = sizeof(saun.sun_family) + strlen(saun.sun_path);
+    if (connect(s,(struct sockaddr*)&saun, len) < 0) {
+	PERROR("Cannot connect to (%s)",sname);
+        error_init = 1;
+	sfd = -1;
+	return;
+    }
+    sfd = s;
+}
+
+app_comm_cli::
+~app_comm_cli()
+{
+    close(sfd);
+}
+
+int app_comm_cli::
+complete_wait()
+{
+    if( sfd < 0 ){
+	PDEBUG(DERR,"Error wile initialisation\n");
+	return -1;
+    }
+
+    if (FD_ISSET(sfd,&socks))
+	return 1;
+    return 0;
+}
+
+int app_comm_cli::
+send(char *buf,size_t size)
+{
+    if( sfd < 0 ){
+	PDEBUG(DERR,"Error wile initialisation\n");
+	return -1;
+    }
+    return _send(sfd,buf,size);
+
+}
+
+ssize_t app_comm_cli::
+recv(char *&buf)
+{
+    if( sfd < 0 ){
+	PDEBUG(DERR,"Error wile initialisation\n");
+	return -1;
+    }
+
+    return _recv(sfd,buf);
+}
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp	(revision 50)
@@ -0,0 +1,185 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm_srv.h>
+#include <eoc_debug.h>
+
+app_comm_srv::
+app_comm_srv(char *sock_path,char *sock_name) : app_comm(sock_path,sock_name)
+{
+    struct sockaddr_un saun;
+    struct stat sbuf;
+    int s;
+    int ret=0,len;
+    
+    // Check path exist
+    if( (ret = stat(sock_path,&sbuf)) ){
+	if( errno != ENOENT ){
+	    PERROR("Error getting info about %s",sock_path);
+	    return;
+	}
+	if( mkdir(sock_path,(S_IRWXU | S_IRGRP | S_IXGRP)) ){
+	    PERROR("Cannot create dir %s",sock_path);
+	    return;
+	}
+	if( stat(sock_path,&sbuf) ){
+	    PERROR("Error creating dir %s",sock_path);
+	    return;
+	}
+    }  
+    if( !S_ISDIR(sbuf.st_mode) ){
+	PDEBUG(DERR,"Error: %s is not directory",sock_path);
+	return;
+    }
+
+    // Create socket
+    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+    	PERROR("Cannot create socket");
+	return;    
+    }
+			    
+    if( unlink(sname) ){
+	if( errno != ENOENT ){
+	    PERROR("Cannot unlink (%s)",sname);
+	    return;
+	}
+    }
+    
+    saun.sun_family = AF_UNIX;
+    strcpy(saun.sun_path,sname);
+    len = sizeof(saun.sun_family) + strlen(saun.sun_path);
+    if(bind(s, (const sockaddr*)&saun, len) < 0) {
+    	PERROR("Cannot bind server with socket (%s)",sname);
+	return;
+    }
+    // open socket for listening
+    if(listen(s,MAX_CONNECTIONS) < 0) {
+    	PERROR("Error trying listen socket (%s)",sname);
+	return;
+    }
+    
+    // setup non blocking
+    if( set_nonblock(s) )
+	return; /* ?? */
+
+    // setup descriptor
+    sfd = s;
+    conn_num = 0;
+
+    return;			
+}
+
+
+int app_comm_srv::
+build_select_list()
+{
+    int i;
+    if( sfd < 0 )
+	return -1; 
+    // blank fd set
+    FD_ZERO(&socks);
+    // fill fd set
+    FD_SET(sfd,&socks);
+    hisock = sfd;
+    for(i=0; i < conn_num; i++) {
+        FD_SET(conn_fd[i],&socks);
+	if ( conn_fd[i] > hisock)
+	    hisock = conn_fd[i];
+    }
+    return 0;
+}
+
+int app_comm_srv::
+new_connection()
+{
+	int i,ret=0;
+	int nsock; /* Socket file descriptor for incoming connections */
+
+	nsock = accept(sfd, NULL, NULL);
+	if( nsock < 0) {
+		PERROR("Error: while accept incoming connection of (%s)",sname);
+		return -errno;
+	}
+	if( (ret = set_nonblock(nsock)) ){
+		close(nsock);
+		return ret;
+	}
+
+	if( conn_num == MAX_CONNECTIONS ){
+		close(nsock);
+		PDEBUG(DINFO,"Close new connection - no room left");
+		return -ENOMEM;
+	}
+	// add to socket list
+	conn_fd[conn_num++] = nsock;
+	return 0;
+}
+
+int app_comm_srv::
+complete_wait()
+{
+    int i,j;
+    int num_act=0;
+    char tmp;
+	
+    memset(conn_act,0,sizeof(conn_act));	
+    for (i=0; i<conn_num; i++) {
+	if (FD_ISSET(conn_fd[i],&socks)){
+	    if( ::recv(conn_fd[i],&tmp,1,MSG_PEEK|MSG_DONTWAIT) < 1 ){
+		PDEBUG(DINFO,"Connection closed");
+		close(conn_fd[i]);
+		// shift descriptors
+		for(j=i;j<conn_num;j++)
+		    conn_fd[j]=conn_fd[j+1];
+		conn_num--;
+		i--;
+	    }else{
+		conn_act[i] = 1;
+		num_act++;
+	    }
+	}
+    }
+    if (FD_ISSET(sfd,&socks))
+	new_connection();
+    return num_act;
+}
+
+
+int app_comm_srv::
+next_fd(){
+    int i;
+    for(i=0;i<conn_num;i++){
+	if( conn_act[i] ){
+	    conn_act[i] = 0;
+	    return i;
+	}
+    }
+    return -1;
+}
+
+int app_comm_srv::
+send(int c_num,char *buf,size_t size)
+{
+    if( !c_num ){
+	return _send(sfd,buf,size);
+    }else{
+	if( c_num > conn_num )
+	    return -1;
+	return _send(conn_fd[c_num-1],buf,size);
+    }
+}
+
+ssize_t app_comm_srv::
+recv(int &c_idx,char *&buf)
+{
+    if( (c_idx = next_fd()) <0 ) 
+	return 0;
+    c_idx++;
+    return _recv(conn_fd[c_idx-1],buf);
+}
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp	(revision 50)
@@ -0,0 +1,151 @@
+#include <app-if/app_frame.h>
+
+app_frame::    
+app_frame(app_ids id,app_types type,roles role,u8 act_seconds,char *dname){
+	u32 psize,csize;
+	int offs;
+	if( (offs = size_by_id(id,type,psize,csize) ) <0 ){
+	    buf = NULL;
+	    buf_size = 0;
+	    return;
+	}
+
+	buf_size = offs;
+	if( !(buf = new char[buf_size]) ){
+	    buf_size = 0;
+	    PDEBUG(DERR,"Not enought memory");
+	    return;
+	}
+	memset(buf,0,buf_size);
+	hdr = (app_frame_hdr *)buf;
+	hdr->len = buf_size;
+	hdr->psize = psize;
+	hdr->csize = csize;
+	hdr->id = (u8)id;
+	hdr->type = (u8)type;
+	hdr->role = (u8)role;
+	if( time(&hdr->tstamp) < 0)
+	    PDEBUG(DERR,"Error getting current time");
+	hdr->act_sec = act_seconds;
+	memcpy(hdr->dname,dname,strnlen(dname,SPAN_NAME_LEN));
+}
+
+app_frame::
+app_frame(char *b,int size){
+    u32 psize,csize;
+    int offs;
+    buf = b;
+    buf_size = size;
+    hdr = (app_frame_hdr *)buf;
+    // GET correct parameters of frame
+    if( (offs = size_by_id((app_ids)hdr->id,(app_types)hdr->type,psize,csize) ) <0 ){
+        buf = NULL;
+        buf_size = 0;
+        PDEBUG(DERR,"Cannot get info about frame id = %d",hdr->id);
+        return;
+    }
+    if( (hdr->psize != psize) || (hdr->csize != csize) ||
+	    (!csize && hdr->type == APP_SET) ){
+        PDEBUG(DERR,"Error in app_frame header");
+        buf = NULL;
+        buf_size = 0;
+    }
+}
+
+app_frame::
+~app_frame(){
+    if(buf)
+        delete[] buf;
+}
+
+
+int app_frame::
+size_by_id(app_ids id,app_types type,u32 &psize,u32 &csize)
+{
+    int size = FRAME_HEADER_SZ;
+
+    switch(id){
+    case APP_SPAN_NAME:
+        psize = SPAN_NAME_PAY_SZ;
+        csize = SPAN_NAME_CH_SZ;
+        break;
+    case APP_SPAN_PARAMS:
+        psize = SPAN_PARAMS_PAY_SZ;
+        csize = SPAN_PARAMS_CH_SZ;
+        break;
+    case APP_SPAN_CONF:
+        psize = SPAN_CONF_PAY_SZ;
+        csize = SPAN_CONF_CH_SZ;
+        break;
+    case APP_SPAN_STATUS:
+        psize = SPAN_STATUS_PAY_SZ;
+        csize = SPAN_STATUS_CH_SZ;
+        break;
+    case APP_INVENTORY:
+        psize = INVENTORY_PAY_SZ;
+        csize = INVENTORY_CH_SZ;
+        break;
+    case APP_ENDP_CONF:
+        psize = ENDP_CONF_PAY_SZ;
+        csize = ENDP_CONF_CH_SZ;
+        break;
+    case APP_ENDP_CUR:
+        psize = ENDP_CUR_PAY_SZ;
+        csize = ENDP_CUR_CH_SZ;
+        break;
+    case APP_ENDP_15MIN:
+        psize = ENDP_15MIN_PAY_SZ;
+        csize = ENDP_15MIN_CH_SZ;
+        break;
+    case APP_ENDP_1DAY:
+        psize = ENDP_1DAY_PAY_SZ;
+        csize = ENDP_1DAY_CH_SZ;
+        break;
+    case APP_ENDP_MAINT:
+        psize = ENDP_MAINT_PAY_SZ;
+        csize = ENDP_MAINT_CH_SZ;
+        break;
+    case APP_SPAN_CPROF:
+	psize = SPAN_CONF_PROF_PAY_SZ;
+	csize = SPAN_CONF_PROF_CH_SZ;
+	break;
+    default:
+        return -1;
+    }
+
+    size += psize;
+    if( type == APP_SET ){
+        size += csize;
+    }else{
+        csize = 0;
+    }
+    return size;    
+}
+    
+const char *app_frame::
+chan_name(){
+	return hdr->dname;
+}
+
+void app_frame::
+chan_name(char *name)
+{
+    strncpy(hdr->dname,name,SPAN_NAME_LEN);
+}
+
+char *app_frame::
+payload_ptr(){
+    ASSERT( buf );
+    if( buf )
+	return &buf[FRAME_HEADER_SZ];
+    return NULL;
+}
+
+char * app_frame::
+changelist_ptr(){
+    ASSERT(buf && hdr->csize);
+    if( buf && hdr->csize )
+        return &buf[FRAME_HEADER_SZ + hdr->psize];
+    return NULL;
+}
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp	(revision 50)
@@ -0,0 +1,93 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm.h>
+#include <eoc_debug.h>
+
+int app_comm::
+set_nonblock(int sock)
+{
+    int opts;
+
+    opts = fcntl(sock,F_GETFL);
+    if (opts < 0) {
+    	PERROR("fcntl(F_GETFL)");
+    	return -errno;
+    }
+    opts = (opts | O_NONBLOCK);
+    if (fcntl(sock,F_SETFL,opts) < 0) {
+    	PERROR("fcntl(F_SETFL)");
+    	return -errno;
+    }
+    return 0;
+}
+
+int app_comm::
+build_select_list()
+{
+    if( sfd < 0 )
+	return -1;
+    // blank fd set
+    FD_ZERO(&socks);
+    // fill fd set
+    FD_SET(sfd,&socks);
+    hisock = sfd;
+    return 0;
+}
+
+int app_comm::
+wait(int sec)
+{
+    int count=0;
+    struct timeval timeout;  /* Timeout for select */	
+
+    timeout.tv_sec = sec;
+    timeout.tv_usec = 0;
+    if( build_select_list() )
+	return -1;
+
+    count = select(hisock+1,&socks,(fd_set *)0,(fd_set *)0, &timeout);
+    if( count < 0) {
+        PERROR("Select");
+        return -errno;
+    }
+    if( count ){
+    	return complete_wait();
+    }
+    return count;
+}
+
+int app_comm::
+_send(int fd,char *buf,size_t size)
+{
+    size_t nsize;
+    if( (nsize=::send(fd,buf,size,0)) != size ){
+        PDEBUG(DERR,"error: %d",nsize); 
+        return -EAGAIN;
+    }
+
+    return 0;
+}	
+
+ssize_t app_comm::
+_recv(int fd,char *&buf)
+{
+    char *frame = new char[BLOCK_SIZE];
+    int frame_len;
+    int ret;
+    
+    
+    if( (frame_len = ::recv(fd,frame,BLOCK_SIZE,MSG_PEEK|MSG_DONTWAIT) ) <= 0 )
+	return -EAGAIN;
+    ret = ::recv(fd,(char*)frame,frame_len,MSG_DONTWAIT);
+    if( frame_len != ret )
+	return -EAGAIN;
+    buf = frame;
+    return frame_len;
+}
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.cpp
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.cpp	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/comm.cpp	(revision 50)
@@ -0,0 +1,83 @@
+#include <app-if/app_frame.h>
+#include <app-if/app_comm_cli.h>
+
+
+extern "C" {
+
+app_comm_cli *
+init_comm()
+{
+    app_comm_cli *cli = new app_comm_cli("/var/eocd/eocd-socket");
+    if( !cli->init_ok() ){
+	delete cli;
+	return NULL;
+    }
+    return cli;
+}
+
+char *
+comm_alloc_request(app_ids id,app_types type,char *chname,app_frame **fr)
+{
+    *fr = new app_frame(id,type,app_frame::REQUEST,1,chname);
+    if( !(*fr)->frame_ptr() ){
+	return NULL;
+    }
+    return (*fr)->payload_ptr();
+}
+
+app_frame *
+comm_request(app_comm_cli *comm,app_frame *fr)
+{
+    char *b;
+    app_frame *fr1 = NULL;
+    int i = 0;
+    
+    while(i<3){
+	comm->send(fr->frame_ptr(),fr->frame_size());
+	comm->wait();
+	int size = comm->recv(b);
+	if( size <=0 ){
+	    i++;
+	    continue;
+	}
+	    
+	fr1 = new app_frame(b,size);
+	if( !fr1->frame_ptr() ){
+	    delete fr1;
+	    fr1 = NULL;
+	    i++;
+	    continue;
+        }
+	if( fr1->is_negative() ){
+	    delete fr1;
+	    return NULL;
+	}
+	break;
+    }
+    return fr1;
+}
+
+char *
+comm_frame_payload(app_frame *fr)
+{
+    if( !fr->frame_ptr() )
+	return NULL;
+    return fr->payload_ptr();
+}
+
+void 
+set_chan_name(app_frame *fr,char *name)
+{
+    fr->chan_name(name);
+}
+
+void comm_frame_free(app_frame *fr){
+    delete fr;
+}
+
+void comm_free(app_comm_cli *cli){
+    delete cli;
+}
+
+}
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/Makefile
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/Makefile	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/app-if/Makefile	(revision 50)
@@ -0,0 +1,27 @@
+ifeq ($(TOPDIR),)
+    TOPDIR=$(PWD)/../
+#    RANLIB=ranlib
+endif
+
+.PHONY: install lib objects apps
+
+all: lib install
+
+objects: app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o comm.o
+
+install: app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o
+	cp $^ $(TOPDIR)/build
+
+all: install apps
+#	g++ $(CPPFLAGS) -o result main.cpp
+
+apps: install
+	make -C applications
+
+lib: objects
+	$(AR) rc libcomm.a app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o comm.o
+	$(RANLIB) libcomm.a
+
+clean:
+	rm -f *.o *.lo
+	rm -f result libcomm.* ext cli srv
Index: net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.c
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.c	(revision 0)
+++ net-snmp-5.1.2/agent/mibgroup/mibII/shdsl/shdsl.c	(revision 50)
@@ -0,0 +1,2056 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <net-snmp/net-snmp-config.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/auto_nlist.h>
+
+#include <stdio.h>
+#include <time.h>
+
+#include "shdsl.h"
+#include "struct.h"
+#include "util_funcs.h"
+#include "../sysORTable.h"
+#include "../interfaces.h"
+
+#include <app-if/app_messages.h>
+
+//------- Global definitions -------------//
+#define CACHE_INT 0
+#define SHDSL_MAX_CHANNELS 30
+typedef struct{
+    struct timeval tv;
+    char name[SPAN_NAME_LEN];
+    int index;
+    int units;
+    int wires;
+} shdsl_channel_elem;
+
+typedef struct{
+    struct timeval tv;
+    span_conf_payload p;
+} shdsl_spanconf_elem;
+
+typedef struct{
+    struct timeval tv;
+    span_status_payload p;
+} shdsl_spanstatus_elem;
+
+/* typedef struct{ */
+/*     struct timeval tv; */
+/*     span_status_payload p; */
+/* } shdsl_spanstatus_elem; */
+
+
+
+// -------- Served channel names cache -------------//
+shdsl_channel_elem tbl[SHDSL_MAX_CHANNELS];
+int tbl_size;
+struct timeval tbl_tv = {0,0};
+int min_i = 0;
+
+// -------- Served channels span info -------------//
+shdsl_spanconf_elem *spanconf_tbl[SHDSL_MAX_CHANNELS];
+int spanconf_tbl_size;
+shdsl_spanstatus_elem *spanstatus_tbl[SHDSL_MAX_CHANNELS];
+int spanstatus_tbl_size;
+
+
+/*---- global vars ----*/
+struct app_comm *comm;
+char driver_dir_path[]="/root/snmp/";
+
+
+char interface_ind;
+int unit_index = 0;
+int endp_index = 0;
+int wire_index = 0;
+counters_t perf_int;
+
+//------- DEBUG ------------//
+void
+dbg_oid(char *comment,char *name, int length)
+{
+    DEBUGMSGTL(("mibII/shdsl", comment));
+    DEBUGMSGOID(("mibII/shdsl", name, length));
+    DEBUGMSG(("mibII/shdsl", "\n"));    
+}
+
+
+/*------------------------------ mib registration data -----------------------------------*/
+
+oid hdsl2Shdsl_variables_oid[] = { SNMP_OID_MIB2, 10, 48, 1 };
+struct variable3 shdsl_spanconf[] = {
+{ CONF_NREPS, ASN_GAUGE,RWRITE, var_SpanConfEntry, 3, {1,1,1} },
+{ CONF_PRFL, ASN_OCTET_STR, RWRITE, var_SpanConfEntry, 3, {1,1,2} },    
+{ CONF_ALARMPRFL, ASN_OCTET_STR, RWRITE, var_SpanConfEntry, 3, {1,1,3} },    
+};
+
+struct variable3 shdsl_spanstat[] = {
+{ STATUS_NAVAILREPS, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,1} },
+{ STATUS_MAXATTLRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,2} },    
+{ STATUS_ACTLRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,3} },    
+{ STATUS_TRNSMSNMODCUR, ASN_BIT_STR, RONLY, var_SpanStatusEntry, 3, {2,1,4} },
+{ STATUS_MAXATTPRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,5} },    
+{ STATUS_ACTPRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,6} },        
+};
+
+struct variable3 shdsl_inventory[] = {
+{INV_INDEX, ASN_INTEGER, NOACCESS, var_InventoryEntry, 3, {3,1,1}},
+{INV_VID, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,2}},    
+{INV_VMODELNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,3}},    
+{INV_VSERNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,4}},
+{INV_VEOCSV, ASN_INTEGER, RONLY, var_InventoryEntry, 3, {3,1,5}},    
+{INV_STANDARDV, ASN_INTEGER, RONLY, var_InventoryEntry, 3, {3,1,6}},    
+{INV_VLISTNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,7}},        
+{INV_VISSUENUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,8}},    
+{INV_VSOFTWV,ASN_OCTET_STR , RONLY, var_InventoryEntry, 3, {3,1,9}},
+{INV_EQCODE, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,10}},    
+{INV_VOTHER, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,11}},
+{INV_TRNSMODECPB, ASN_BIT_STR, RONLY, var_InventoryEntry, 3, {3,1,12}}    
+};
+
+/*
+  struct variable3 shdsl_endp_conf[] = {
+  {ENDP_CONF_PROF, ASN_OCTET_STR, RONLY, var_EndpointConfEntry, 3, {4,1,3}},    
+  };
+*/
+
+struct variable3 shdsl_endp_currstat[] = {
+{ ENDP_STAT_CUR_ATN, ASN_INTEGER, RONLY, var_EndpointCurrEntry, 3, {5,1,1} },
+{ ENDP_STAT_CUR_SNRMGN, ASN_INTEGER, RONLY, var_EndpointCurrEntry, 3, {5,1,2} },
+{ ENDP_STAT_CUR_STATUS,ASN_BIT_STR,RONLY, var_EndpointCurrEntry, 3, {5,1,3} },
+{ ENDP_STAT_CUR_ES,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,4} },
+{ ENDP_STAT_CUR_SES,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,5} },
+{ ENDP_STAT_CUR_CRC,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,6} },
+{ ENDP_STAT_CUR_LOSWS,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,7} },
+{ ENDP_STAT_CUR_UAS,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,8} },
+{ ENDP_STAT_CUR_15MEL,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,9} },
+{ ENDP_STAT_CUR_15M_ES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,10} },
+{ ENDP_STAT_CUR_15M_SES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,11} },
+{ ENDP_STAT_CUR_15M_CRC,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,12} },
+{ ENDP_STAT_CUR_15M_LOSWS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,13} },
+{ ENDP_STAT_CUR_15M_UAS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,14} },
+{ ENDP_STAT_CUR_1DEL,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,15} },
+{ ENDP_STAT_CUR_1D_ES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,16} },
+{ ENDP_STAT_CUR_1D_SES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,17} },
+{ ENDP_STAT_CUR_1D_CRC,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,18} },
+{ ENDP_STAT_CUR_1D_LOSWS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,19} },
+{ ENDP_STAT_CUR_1D_UAS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,20} },
+};
+
+struct variable3 shdsl_endp_15minstat[] = {
+{ ENDP_15M_INT,ASN_UNSIGNED,NOACCESS,var_15MinIntervalEntry,3,{6,1,1} },
+{ ENDP_15M_ES,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,2} },
+{ ENDP_15M_SES,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,3} },
+{ ENDP_15M_CRC,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,4} },
+{ ENDP_15M_LOSWS,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,5} },
+{ ENDP_15M_UAS,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,6} },
+};
+
+struct variable3 shdsl_endp_1daystat[] = {
+{ ENDP_1D_INT,ASN_UNSIGNED,NOACCESS,var_1DayIntervalEntry,3,{7,1,1} },
+{ ENDP_1D_MONSECS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,2} },
+{ ENDP_1D_ES,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,3} },
+{ ENDP_1D_SES,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,4} },
+{ ENDP_1D_CRC,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,5} },
+{ ENDP_1D_LOSWS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,6} },
+{ ENDP_1D_UAS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,7} },
+};
+
+/*
+  struct variable3 shdsl_endp_maint[] = {
+  { ENDP_MAINT_LOOPBACK, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,1} },
+  { ENDP_MAINT_TIPRINGREV, ASN_INTEGER, RONLY, var_EndpointMaintEntry, 3, {8,1,2} },
+  { ENDP_MAINT_PWRBACKOFF, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,3} },
+  { ENDP_MAINT_SOFTRESTART, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,4} },
+  };
+
+  struct variable3 shdsl_unit_maint[] = {
+  {UNIT_MAINT_LPB_TO, ASN_INTEGER, RWRITE, var_UnitMaintEntry, 3, {9,1,1}},
+  {UNIT_MAINT_PWR_SRC, ASN_INTEGER, RONLY, var_UnitMaintEntry, 3, {9,1,2}},
+  };
+*/
+
+struct variable3 shdsl_conf_prof[] = {
+{CONF_WIRE_IFACE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,2}},
+{CONF_MIN_LRATE, ASN_UNSIGNED, RWRITE, var_SpanConfProfEntry, 3, {10,1,3}},
+{CONF_MAX_LRATE, ASN_UNSIGNED, RWRITE, var_SpanConfProfEntry, 3, {10,1,4}},
+{CONF_PSD, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,5}},
+{CONF_TRNSM_MODE, ASN_BIT_STR, RWRITE, var_SpanConfProfEntry, 3, {10,1,6}},
+{CONF_REM_ENABLE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,7}},
+{CONF_PWR_FEED, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,8}},
+{CONF_CURR_DOWN, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,9}},
+{CONF_WORST_DOWN, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,10}},
+{CONF_CURR_UP, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,11}},
+{CONF_WORST_UP, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,12}},
+{CONF_USED_MARG, ASN_BIT_STR, RWRITE, var_SpanConfProfEntry, 3, {10,1,13}},
+{CONF_REF_CLK, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,14}},
+{CONF_LPROBE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,15}},
+{CONF_ROW_ST, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,16}},
+};
+
+
+
+
+void
+init_shdsl(void)
+{
+
+    comm = NULL;
+    memset(&perf_int,0,sizeof(perf_int));
+    memset(spanconf_tbl,0,sizeof(spanconf_tbl));
+    spanconf_tbl_size = 0;
+    memset(spanstatus_tbl,0,sizeof(spanstatus_tbl));
+    spanstatus_tbl_size = 0;
+    memset(tbl,0,sizeof(tbl));
+
+    /*
+     * register ourselves with the agent to handle our mib tree 
+     */
+    printf("Register Span Conf\n");
+    REGISTER_MIB("mibII/hdsl2ShdslSpanConf", shdsl_spanconf, variable3,
+                 hdsl2Shdsl_variables_oid);
+
+    printf("Register Span Status\n");
+    REGISTER_MIB("mibII/hdsl2shdslSpanStatus", shdsl_spanstat, variable3,
+                 hdsl2Shdsl_variables_oid);
+
+    printf("Register Inventory\n");
+    REGISTER_MIB("mibII/hdsl2shdslInventory", shdsl_inventory, variable3,
+                 hdsl2Shdsl_variables_oid);
+
+	/*
+	  REGISTER_MIB("mibII/hdsl2shdslEndpointConf", shdsl_endp_conf, variable3,
+	  hdsl2Shdsl_variables_oid);
+	*/
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpointCurr",shdsl_endp_currstat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpoint15min",shdsl_endp_15minstat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpoint1day",shdsl_endp_1daystat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+	/*
+	  REGISTER_MIB("mibII/hdsl2shdslEndpointMaint", shdsl_endp_maint, variable3,
+	  hdsl2Shdsl_variables_oid);
+
+	  REGISTER_MIB("mibII/hdsl2shdslUnitMaint", shdsl_unit_maint, variable3,
+	  hdsl2Shdsl_variables_oid);
+	*/
+		
+	REGISTER_MIB("mibII/hdsl2shdslSpanConfProfile", shdsl_conf_prof, variable3,
+				 hdsl2Shdsl_variables_oid);
+	  
+    DEBUGMSGTL(("mibII/hdsl2Shdsl","register variables"));
+    printf("Register finished\n");
+
+}
+
+/*
+ * header_dslIfIndex(...
+ * Arguments:
+ * vp     IN      - pointer to variable entry that points here
+ * name    IN/OUT  - IN/name requested, OUT/name found
+ * length  IN/OUT  - length of IN/OUT oid's 
+ * exact   IN      - TRUE if an exact match was requested
+ * var_len OUT     - length of variable or 0 if function returned
+ * write_method
+ */
+
+int
+ifname_to_index(char *Name, int Len)
+{
+    short ifIndex = 0;
+    char ifName[20];
+    char found = 0;
+    Interface_Scan_Init();
+    while ( Interface_Scan_Next(&ifIndex, ifName, NULL, NULL) ){
+		if( !strcmp(Name, ifName)){
+			found = 1;
+			break;
+		}
+    }
+    if( found )
+		return ifIndex;
+    return -1;
+}
+
+int
+chann_names()
+{
+    struct app_frame *fr1,*fr2;
+    span_name_payload *p;
+    int i;
+    char ifname[SPAN_NAME_LEN];
+    int index,len;
+    // caching
+    struct timeval tvcur;
+    char tverr = 0;
+
+    if( gettimeofday(&tvcur,NULL) )
+		tverr = 1;
+	
+    if( ((tvcur.tv_sec - tbl_tv.tv_sec) > CACHE_INT) || tverr ){
+
+        ifname[0] = 0;
+		tbl_size = 0;
+		p = (span_name_payload*)
+			comm_alloc_request(APP_SPAN_NAME,APP_GET,ifname,&fr1);
+
+		if( !p ){
+    	    DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+    	    return -1;
+		}
+    
+        do{
+			set_chan_name(fr1,ifname);
+			fr2 = comm_request(comm,fr1);
+			if( !fr2 ){
+				printf("mibII/hdsl2Shdsl Reqest failed\n");
+				comm_frame_free(fr1);
+				return -1;
+			}
+			p = (span_name_payload*)comm_frame_payload(fr2);
+			for(i=0;i<p->filled;i++){
+				len = strnlen(p->name[i],SPAN_NAME_LEN);
+				if( (index = ifname_to_index(p->name[i],len)) < 0 )
+					continue;
+				strncpy(tbl[tbl_size].name,p->name[i],len);
+				tbl[tbl_size].index = index;
+				if( (tbl_size==0) || tbl[min_i].index > tbl[tbl_size].index  ){
+					min_i = tbl_size;
+				}
+				tbl[tbl_size].units = -1;
+				tbl[tbl_size].wires = -1;
+				tbl[tbl_size].tv.tv_sec = 0;
+				tbl_size++;
+			}
+			if( !p->last_msg && p->filled){
+				strncpy(ifname,p->name[p->filled-1],SPAN_NAME_LEN);
+			}
+			comm_frame_free(fr2);
+		}while( tbl_size<SHDSL_MAX_CHANNELS && !p->last_msg );
+		comm_frame_free(fr1);
+		tbl_tv = tvcur;
+    }
+    return min_i;
+}
+
+
+static int
+header_ifIndex(struct variable *vp,
+               oid * name, size_t * length, int exact,
+			   size_t * var_len, WriteMethod ** write_method)
+{
+    oid newname[MAX_OID_LEN];
+    int base_compare;
+    int oid_min = (vp->namelen > *length) ? *length : vp->namelen;
+    int min_ind = -1, min_i = 0;
+    int i;
+
+    if( (min_i = chann_names()) < 0 ){
+		printf("ifIndex: Cannot get table of controlling interfaces\n");
+		return MATCH_FAILED;
+    }
+
+    if( !tbl_size ){
+		printf("ifIndex: MATCH FAILED: tbl_size is zero\n");
+		return MATCH_FAILED;
+    }
+
+    memcpy((char *) newname, (char *) vp->name,
+           (int) vp->namelen * sizeof(oid));
+
+    if( (base_compare = snmp_oid_compare(name,oid_min,newname,oid_min)) > 0){
+		return MATCH_FAILED;
+    }
+    
+    if( exact ){
+		if( base_compare || (*length < vp->namelen+1) ){
+			return MATCH_FAILED;
+		}
+		// check that name[vp->namelen] is DSL index
+		for(i=0;i<tbl_size;i++){
+			if( name[vp->namelen] == tbl[i].index ){
+				interface_ind = i;
+				break;
+			}
+		}
+		if( i == tbl_size )
+			return MATCH_FAILED;
+    } else {
+		// 1. OID for GETNEXT > vp base OID
+		// 2. Index of GETNEXT > max index
+		if( base_compare < 0 || ( !base_compare && *length<=vp->namelen) ){
+			memcpy((char*)name,(char*)newname,((int)vp->namelen+1)*sizeof(oid));
+			*length = vp->namelen + 1;
+			name[vp->namelen] = tbl[min_i].index;
+			interface_ind  = min_i;
+		}else if( !base_compare ){
+			min_i = 0;
+			min_ind = -1;
+			for( i=0;i<tbl_size;i++){
+				if( tbl[i].index > name[vp->namelen] ){
+					if( (min_ind < 0) || (min_ind > tbl[i].index) ){
+						min_i = i;
+						min_ind = tbl[i].index;
+					}
+				}
+			}
+			if( min_ind>0 ){
+				interface_ind = min_i;
+				name[vp->namelen] = tbl[min_i].index;
+			}else{
+				return MATCH_FAILED;
+			}
+		} else
+			return MATCH_FAILED;
+    }
+    *write_method = 0;
+    *var_len = sizeof(long); 
+    dbg_oid("Result_oid ",name,*length);
+    return name[vp->namelen];
+}
+
+
+/*
+ * Span Configuration Group 
+ */
+
+u_char *
+var_SpanConfEntry(struct variable * vp,
+				  oid * name,
+				  size_t * length,
+				  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_conf_payload *p;
+    static char ConfProfile[SNMP_ADMIN_LEN];
+    char *return_ptr = NULL;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+
+    DEBUGMSGTL(("mibII/shdsl", "var_SpanConfEntry: *lenght=%d namelen=%d \n",*length,vp->namelen));
+    DEBUGMSGOID(("mibII/shdsl", name, *length));
+    DEBUGMSG(("mibII/shdsl", "\nexact= %d\n", exact));
+
+    comm = init_comm();
+    if(!comm){
+        DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+        return NULL;
+    }
+
+    if ( ( iface=header_ifIndex(vp, name, length, exact, var_len,write_method) )
+         == MATCH_FAILED || (*length != vp->namelen+1)){
+		//	DEBUGMSG(("mibII/shdsl", "SpanConf: MATCH_FAILED\n"));	
+		//	printf("mibII/shdsl SpanConf: MATCH_FAILED\n");	
+		goto exit;
+    }
+
+    if( gettimeofday(&tvcur,NULL) ){
+		printf("%s: tverr occured\n",__FUNCTION__);
+		tverr = 1;
+    }
+
+
+    if( !spanconf_tbl[interface_ind] || tverr ||
+		(tvcur.tv_sec - spanconf_tbl[interface_ind]->tv.tv_sec > CACHE_INT) ){
+
+        p = (span_conf_payload*)comm_alloc_request(APP_SPAN_CONF,APP_GET,tbl[interface_ind].name,&fr1);
+		if( !p ){
+			//DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			printf("mibII/shdsl Cannot allocate application frame");
+    	    goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+        if( !fr2 ){
+			printf("Error requesting\n");
+    	    goto exit;
+		}
+		p = (span_conf_payload*)comm_frame_payload(fr2);
+
+        // Cache data
+		if( !spanconf_tbl[interface_ind] )
+			spanconf_tbl[interface_ind] = malloc(sizeof(shdsl_spanconf));
+		spanconf_tbl[interface_ind]->p = *p;
+		spanconf_tbl[interface_ind]->tv = tvcur;
+    }else{
+		p = &spanconf_tbl[interface_ind]->p;
+    }
+
+    switch (vp->magic) {
+    case CONF_NREPS:
+		*var_len=sizeof(int);
+		long_return=p->nreps;
+		//	long_return= 2;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case CONF_PRFL:
+		strncpy(ConfProfile,p->conf_prof,SNMP_ADMIN_LEN);
+		//	strncpy(ConfProfile,"profile",SNMP_ADMIN_LEN);
+		*var_len=strnlen(ConfProfile,SNMP_ADMIN_LEN);
+		return_ptr = (u_char *)ConfProfile;	
+		break;
+    case CONF_ALARMPRFL:
+		goto exit;
+		//!!	*var_len=strlen(ConfAlarmProfile);
+		//!!	return (u_char *)ConfAlarmProfile;	
+    default:
+        DEBUGMSGTL(("snmpd", "unknown sub-id %d in var_interfaces\n",
+                    vp->magic));
+		break;
+    }
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+    return return_ptr;
+}
+
+
+/*
+ * Span Status Group 
+ */
+
+u_char *
+var_SpanStatusEntry(struct variable * vp,
+					oid * name,
+					size_t * length,
+					int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+
+    span_status_payload *p;
+    char *return_ptr = NULL;
+    // Cacheing 
+    int tverr = 0;
+    struct timeval tvcur;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( ( iface=header_ifIndex(vp, name, length, exact, var_len,write_method) )
+	     == MATCH_FAILED || (*length != vp->namelen+1)){
+		//	printf("mibII/shdsl SpanConf: MATCH_FAILED\n");	
+        goto exit;
+    }
+
+    if( gettimeofday(&tvcur,NULL) ){
+		printf("%s: tverr occured\n",__FUNCTION__);
+		tverr = 1;
+    }
+
+    if( !spanstatus_tbl[interface_ind] || tverr ||
+	    ((tvcur.tv_sec - spanstatus_tbl[interface_ind]->tv.tv_sec)>CACHE_INT) ){
+        p = (span_status_payload*)comm_alloc_request(APP_SPAN_STATUS,APP_GET,tbl[interface_ind].name,&fr1);
+		if( !p ){
+			//DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			printf("mibII/shdsl Cannot allocate application frame");
+			goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+		if( !fr2 ){
+			printf("Error requesting\n");
+			goto exit;
+		}
+		p = (span_status_payload*)comm_frame_payload(fr2);
+        // Cache data
+		if( !spanstatus_tbl[interface_ind] )
+			spanstatus_tbl[interface_ind] = malloc(sizeof(shdsl_spanstatus_elem));
+	
+		spanstatus_tbl[interface_ind]->p = *p;
+        spanstatus_tbl[interface_ind]->tv = tvcur;
+    }else{
+		p = &spanstatus_tbl[interface_ind]->p;
+    }
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case STATUS_NAVAILREPS:
+		long_return= p->nreps;    
+		if( p->nreps <0 )
+			long_return = 0;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_MAXATTLRATE:
+		long_return = p->max_lrate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_ACTLRATE:
+		long_return = p->act_lrate;
+		return_ptr = (u_char *) & long_return;
+		break;
+		/*    case STATUS_TRNSMSNMODCUR:
+		//	long_return = *((unsigned char*)&cfg.annex);
+		*var_len = sizeof(char);
+		return (u_char *)&long_return;
+		*/    case STATUS_MAXATTPRATE:
+		long_return = p->max_prate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_ACTPRATE:
+		long_return = p->act_prate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    default:
+		break;
+    }
+    
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+    return return_ptr;
+
+}
+
+/*
+ * Unit Inventory Group
+ */
+
+static int
+header_unitIndex(struct variable *vp,
+				 oid * name,
+				 size_t * length,
+				 int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface = 0;
+    int length_bkp = *length;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_params_payload *p;
+    int ret_val = MATCH_FAILED;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+    
+	// If OID is belong to Inventory Table
+    if( (iface = header_ifIndex(vp, name, length,1/*exact = 1*/, var_len,write_method)) 
+	    != MATCH_FAILED ){ 	// OID belongs to Invetory table and ifIdex is valid
+		//	printf("unitIndex: OID belong to Inv Table, if = %s\n",tbl[iface].name);
+        
+		if( gettimeofday(&tvcur,NULL) ){
+			printf("%s: tverr occured\n",__FUNCTION__);
+			tverr = 1;
+		}
+
+		if( ((tvcur.tv_sec - tbl[interface_ind].tv.tv_sec) > CACHE_INT) || tverr || 
+			tbl[interface_ind].units < 0 ){
+			p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+														 APP_GET,tbl[interface_ind].name,&fr1);
+			if( !p ){
+				//		printf("unitIndex: Cannot allocate application frame\n");
+				goto exit;
+			}
+			fr2 = comm_request(comm,fr1);
+			if( !fr2 ){
+				printf("unitIndex: Error requesting\n");
+				goto exit;
+			}
+			p = (span_params_payload*)comm_frame_payload(fr2);
+			// Cache data
+			tbl[interface_ind].tv = tvcur;
+			tbl[interface_ind].units = p->units;
+			tbl[interface_ind].wires = p->loops;
+		}
+
+
+		//	printf("unitIndex: Get params info for %s: units(%d) loops(%d)\n",tbl[iface].name,p->units,p->loops);
+
+		if( exact ){ // Need exact MATCH
+			//	    printf("unitIndex: Exact match\n");
+			if( (*length >= vp->namelen+2) && 
+				(name[vp->namelen+1] > 0) && 
+				(name[vp->namelen+1]<= tbl[interface_ind].units) ){
+				//		    printf("unitIndex: Exact match - OK\n");
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			} else {
+				//		printf("unitIndex: Exact match - FAIL\n");
+				goto exit;
+			}
+		} else { // Need next regenerator index
+			if( *length >= vp->namelen+2 &&
+				(name[vp->namelen+1]+1 > 0) &&
+				(name[vp->namelen+1]+1 <= tbl[interface_ind].units) ){
+				//		printf("unitIndex: Next unit after %d\n",name[vp->namelen+1]);
+				name[vp->namelen+1]++;
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			}else if( *length == vp->namelen + 1 ){
+				name[vp->namelen+1] = stu_c;
+				//		printf("unitIndex:  First unit \n");
+				*length = vp->namelen+2;
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			}
+		}
+    }
+    
+    if( exact ){
+		//	printf("unitIndex: Exact match - seems failed\n");
+		goto exit;
+    }
+    
+    if( (iface=header_ifIndex(vp, name, length, exact, var_len,write_method)) 
+		== MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		//	printf("unitIndex: Search for next iface failed\n");
+		goto exit;
+    }
+    
+    if( fr2 ){
+		comm_frame_free(fr2);
+		fr2 = NULL;
+    }
+
+    if( ((tvcur.tv_sec - tbl[interface_ind].tv.tv_sec) > CACHE_INT) || tverr || 
+		tbl[interface_ind].units < 0 ){
+	
+		if( !fr1 ){	
+			p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+														 APP_GET,tbl[interface_ind].name,&fr1);
+		}else{
+			p = (span_params_payload*)comm_frame_payload(fr1);
+		}
+		    
+		if( !p ){
+			//    	    printf("unitIndex: Cannot allocate application frame\n");
+    	    goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+		if( !fr2 ){
+			//    	    printf("unitIndex: Error requesting\n");
+    	    goto exit;
+		}
+		p = (span_params_payload*)comm_frame_payload(fr2);
+		//    printf("unitIndex: Get params info for %s: units(%d) loops(%d)\n",tbl[iface].name,p->units,p->loops);    
+		tbl[interface_ind].units = p->units;
+		tbl[interface_ind].wires = p->loops;
+		tbl[interface_ind].tv = tvcur;
+    }
+	
+    name[vp->namelen+1] = stu_c;
+    *length = vp->namelen + 2;
+	//    printf("unitIndex: Result: unit #%d\n",name[vp->namelen+1]);
+    ret_val = name[vp->namelen+1];
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    return ret_val;
+}
+
+
+u_char *
+var_InventoryEntry(struct variable * vp,
+				   oid * name,
+				   size_t * length,
+				   int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int unit;
+    size_t length1;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    inventory_payload *p;
+    resp_inventory *resp;
+    char *return_ptr = NULL;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( ( unit = header_unitIndex(vp,name,length,exact,var_len,write_method) )
+		 == MATCH_FAILED ){
+		printf("var_InventoryEntry: Cannot find unit\n");
+		goto exit;
+    }
+
+	// ------------- Need cacheing ------------------//
+	p = (inventory_payload*)comm_alloc_request(APP_INVENTORY,APP_GET,
+											   tbl[interface_ind].name,&fr1);
+	if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		printf("var_InventoryEntry: Cannot allocate application frame\n");
+		goto exit;
+	}
+
+	p->unit = unit;
+	fr2 = comm_request(comm,fr1);
+	if( !fr2 && exact ){
+		printf("var_InventoryEntry: Error requesting\n");
+		goto exit;
+	}
+    
+	while( !fr2 ){
+		
+		if ( ( unit = header_unitIndex(vp,name,length,exact,var_len,write_method) )
+			 == MATCH_FAILED ){
+			printf("var_InventoryEntry: Cannot find unit\n");
+			goto exit;
+		}
+
+		p = (inventory_payload*)comm_alloc_request(APP_INVENTORY,APP_GET,
+												   tbl[interface_ind].name,&fr1);
+		if( !p ){
+			DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			printf("var_InventoryEntry: Cannot allocate application frame\n");
+			goto exit;
+		}
+		p->unit = unit;
+		if( fr2 )
+			comm_frame_free(fr2);
+		fr2 = comm_request(comm,fr1);
+	}
+    
+	if( !fr2 ){
+		printf("var_InventoryEntry: Error requesting\n");
+		goto exit;
+	}
+	p = (inventory_payload*)comm_frame_payload(fr2);
+	//~~~~~~~~~~~~~~~~~~ Need cacheing ~~~~~~~~~~~~~~~~~~~~~~~~`//
+
+	resp = &p->inv;
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case INV_VID:
+		*var_len = sizeof(resp->ven_id);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_id,*var_len);    
+		/* 		strncpy(return_buf,"111",10); */
+		/* 		*var_len = strlen(return_buf); */
+		return_ptr = (u_char *)return_buf;
+		break;
+    case INV_VMODELNUM:
+		*var_len = sizeof(resp->ven_model);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_model,*var_len);    
+		/* 		strncpy(return_buf,"222",10); */
+		/* 		*var_len = strlen(return_buf); */
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VSERNUM:
+		*var_len = sizeof(resp->ven_serial);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_serial,*var_len);    
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VEOCSV:
+		long_return=p->eoc_softw_ver;
+		return_ptr = (u_char *)&long_return;
+		break;
+	case INV_STANDARDV:
+		long_return = resp->shdsl_ver;
+		return_ptr = (u_char *)&long_return;
+		break;
+	case INV_VLISTNUM:
+		*var_len = strlen(resp->ven_lst);
+		strncpy(return_buf,resp->ven_lst,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VISSUENUM:
+		*var_len = strlen(resp->ven_issue);
+		strncpy(return_buf,resp->ven_issue,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VSOFTWV:
+		*var_len = strlen(resp->softw_ver);
+		strncpy(return_buf,resp->softw_ver,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_EQCODE:
+		*var_len = strlen(resp->unit_id_code);
+		strncpy(return_buf,resp->unit_id_code,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VOTHER:
+		*var_len = strlen(resp->other);
+		strncpy(return_buf,resp->other,*var_len);    
+		return_ptr = (u_char *)return_buf;
+		break;
+		/*    case INV_TRNSMODECPB:
+		 *var_len = sizeof(info->TransModeCpb);
+		 long_return=info->TransModeCpb;
+		 return (u_char *)&long_return;
+		*/
+	}
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+    return return_ptr;
+}
+
+/*
+ * ------------ Segment Endpoint Group --------------------
+ */
+ 
+ 
+/*
+ * header_endpIndex:
+ * 	Defines propriate endpoint index for incoming OID
+ */
+
+static int 
+header_endpIndex(struct variable *vp,
+				 oid * name,
+				 size_t * length,
+				 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int unit = 0;
+    int length_bkp = *length;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+
+    if ( ( unit = header_unitIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+		//	printf("endpIndex: uinit matched: %d\n",unit);
+		unit_index = unit;
+
+		if( exact ){ // Need exact MATCH
+			if( (*length >= vp->namelen+3) ){
+				switch( unit ){
+				case stu_c:
+					if( name[vp->namelen+2] != (cust_side+1) )
+						return MATCH_FAILED;
+					else
+						return name[vp->namelen+2];
+					break;
+				case stu_r:
+					if( name[vp->namelen+2] != (net_side+1) )		
+						return MATCH_FAILED;
+					else
+						return name[vp->namelen+2];
+					break;
+				case sru1:
+				case sru2:
+				case sru3:
+				case sru4:
+				case sru5:
+				case sru6:
+				case sru7:
+				case sru8:
+					if( name[vp->namelen+2] == (cust_side+1) || 
+						name[vp->namelen+2] == (net_side+1) )
+						return name[vp->namelen+2];
+					else
+						return MATCH_FAILED;
+				default:
+					return MATCH_FAILED;
+				}
+			} else
+				return MATCH_FAILED;
+		} else { // Nonexact match
+			//	    printf("endpIndex: nonexact match: unit(%d) side(%d)\n",unit,name[vp->namelen+2]);
+			if( unit >= sru1 && unit <=sru8 ){
+				if( *length >= vp->namelen+3 ){
+					if( name[vp->namelen+2] == (net_side+1) ){
+						name[vp->namelen+2] = (cust_side+1);
+						return name[vp->namelen+2];
+					}
+				}else if( *length == vp->namelen+2 ){
+					name[vp->namelen+2] == (net_side+1);
+					*length = vp->namelen+3;
+					return name[vp->namelen+2];	
+				}
+			}
+		}
+    }
+	
+    // OID does not belong to Inventory Table OR NO next regenerator 
+    if( exact ){
+		return MATCH_FAILED;
+    }
+	//    printf("endpIndex: SWITCH to next unit\n");
+    if( (unit=header_unitIndex(vp, name, length, exact, var_len,write_method)) 
+	    == MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		return MATCH_FAILED;
+    }
+    unit_index = unit;
+	//    printf("endpIndex: next unit = %d\n",unit);
+    switch( unit ){
+    case stu_c:
+		name[vp->namelen+2] = (cust_side+1);
+		break;
+    case stu_r:
+		name[vp->namelen+2] = (net_side+1);    
+		break;
+    case sru1:
+    case sru2:
+    case sru3:
+    case sru4:
+    case sru5:
+    case sru6:
+    case sru7:
+    case sru8:
+		name[vp->namelen+2] = (net_side+1);
+		break;
+    default:
+		return MATCH_FAILED;
+    }
+    *length = vp->namelen + 3;
+    return name[vp->namelen+2];
+}
+
+
+/*
+ * header_wirePairIndex:
+ * 	Defines propriate Wire pair index for incoming OID
+ *	(by now only 1 pair supported)
+ */
+
+static int 
+header_wirePairIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int endp = 0;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_params_payload *p;
+    int ret_val = MATCH_FAILED;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+
+    if ( ( endp = header_endpIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+    
+		printf("wirePair: interface_ind = %d,exact endpoint = %d\n",interface_ind,endp);
+		printf("wirePair: Get params info for %s\n",tbl[interface_ind].name);
+
+		endp_index = endp;
+		tverr = gettimeofday(&tvcur,NULL);
+		printf("%s: before if 1\n",__FUNCTION__);
+		int k = tbl[interface_ind].wires;
+		printf("%s: before if 2\n",__FUNCTION__);
+		int k1 = tvcur.tv_sec - tbl[interface_ind].tv.tv_sec;
+		printf("%s: before if 3\n",__FUNCTION__);
+		if( tverr || tbl[interface_ind].wires < 0 ||
+			(tvcur.tv_sec - tbl[interface_ind].tv.tv_sec > CACHE_INT ) ){ 
+			printf("%s: 1\n",__FUNCTION__);
+			p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+														 APP_GET,tbl[interface_ind].name,&fr1);
+			printf("%s: 2\n",__FUNCTION__);
+			if( !p ){
+				DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+				printf("wirePair: Cannot allocate application frame\n");
+				goto exit;
+			}
+			printf("%s: 3\n",__FUNCTION__);	    
+			fr2 = comm_request(comm,fr1);
+			printf("%s: 4\n",__FUNCTION__);
+			if( !fr2 ){
+				printf("wirePair: Error requesting\n");
+				goto exit;
+			}
+			printf("%s: 5\n",__FUNCTION__);	    
+			p = (span_params_payload*)comm_frame_payload(fr2);
+			tbl[interface_ind].units = p->units;
+			tbl[interface_ind].wires = p->loops;
+			tbl[interface_ind].tv = tvcur;
+		}
+		printf("%s: after if\n",__FUNCTION__);
+		printf("wirePair: Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);
+
+		if( exact ){ // Need exact MATCH
+			printf("wirePair: Exact Match\n");
+			if( (*length >= vp->namelen+4) && 
+				(name[vp->namelen+3] > 0) && (name[vp->namelen+3] <= tbl[interface_ind].wires) ){
+				ret_val =  name[vp->namelen+3];
+				goto exit;
+			} else {
+				goto exit;
+			}
+		} else { // Nonexact match
+			// Because we have only one wire pair - we change it only 
+			// if field is empty
+			if( *length == vp->namelen+3 ){
+				name[vp->namelen+3] = 1; // first pair
+				*length = vp->namelen+4;
+				ret_val = name[vp->namelen+3];
+				goto exit;
+			}else{
+				if( name[vp->namelen+3] <= 0 )
+					goto exit;
+				if( name[vp->namelen+3]+1 <= tbl[interface_ind].wires ){
+					*length = vp->namelen+4;
+					ret_val = (++name[vp->namelen+3]);
+					goto exit;
+				}
+			}
+		}
+    }
+	
+    printf("%s: Exact match failed\n",__FUNCTION__);
+    if( exact ){
+		goto exit;
+    }
+    
+    if( (endp = header_endpIndex(vp, name, length, exact, var_len,write_method)) 
+	    == MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		goto exit;
+    }
+
+    printf("wirePair: nonexact endpoint = %d\n",endp);
+    endp_index = endp;
+
+    if( tverr || tbl[interface_ind].wires < 0 ||
+        (tvcur.tv_sec - tbl[interface_ind].tv.tv_sec > CACHE_INT ) ){ 
+        p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+													 APP_GET,tbl[interface_ind].name,&fr1);
+        if( !p ){
+    	    DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			printf("wirePair: Cannot allocate application frame\n");
+			goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+		if( !fr2 ){
+			printf("wirePair: Error requesting\n");
+			goto exit;
+		}
+		p = (span_params_payload*)comm_frame_payload(fr2);
+		tbl[interface_ind].units = p->units;
+		tbl[interface_ind].wires = p->loops;
+		tbl[interface_ind].tv = tvcur;
+    }
+
+    name[ vp->namelen+3] = 1; // First pair
+    *length = vp->namelen + 4;
+    ret_val = name[vp->namelen+3];
+ exit:
+    printf("%s: exit\n",__FUNCTION__);
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    printf("%s: returning\n",__FUNCTION__);
+    return ret_val;
+}
+
+
+/*
+ * Segment Endpoint Current Status/Performance Group
+ */
+
+u_char *
+var_EndpointCurrEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    endp_cur_payload *p;
+    char *return_ptr = NULL;
+    int pair,endp;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    printf("EndpointCurStatEntry: start\n");
+
+	// ------------------------------ Obtain requested information ------------------------------- //
+
+    if ( ( pair = header_wirePairIndex(vp,name,length,exact,var_len,write_method) )
+		 == MATCH_FAILED )
+        goto exit;
+       
+    printf("Result : if(%s) unit(%d) side(%d) pair(%d)\n",tbl[interface_ind].name,unit_index,endp_index,pair);
+
+    p = (endp_cur_payload*)comm_alloc_request(APP_ENDP_CUR,APP_GET,
+											  tbl[interface_ind].name,&fr1);
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		printf("var_InventoryEntry: Cannot allocate application frame\n");
+		goto exit;
+    }
+    p->unit = unit_index;
+    p->side = endp_index-1;
+    p->loop = pair-1;
+    fr2 = comm_request(comm,fr1);
+    printf("Request if(%s) unit(%d) side(%d) loop(%d)\n",
+		   tbl[interface_ind].name,p->unit,p->side,p->loop);
+
+    
+    if( !fr2 && exact ){
+		printf("var_InventoryEntry: error requesting\n");
+		goto exit;
+    }
+    
+    while( !fr2 ){
+		if ( ( pair = header_wirePairIndex(vp,name,length,exact,var_len,write_method) )
+			 == MATCH_FAILED )
+    	    goto exit;
+    
+		printf("Result (rep): if(%s) unit(%d) side(%d) pair(%d)\n",tbl[interface_ind].name,unit_index,endp_index,pair);
+		p->unit = unit_index;
+		p->side = endp_index-1;
+		p->loop = pair-1;
+		fr2 = comm_request(comm,fr1);
+
+		printf("Request (rep): if(%s) unit(%d) side(%d) loop(%d)\n",
+			   tbl[interface_ind].name,p->unit,p->side,p->loop);
+
+    }
+
+    if( !fr2 ){
+		printf("var_InventoryEntry: error requesting\n");
+		goto exit;
+    }
+    
+    p = (endp_cur_payload*)comm_frame_payload(fr2);
+    
+	// ------------------------------ Return requested information ------------------------------- //
+	
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_STAT_CUR_ATN:
+		long_return = p->cur_attn;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_SNRMGN:
+		long_return = p->cur_snr;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_STATUS:
+		break;
+    case ENDP_STAT_CUR_ES:
+		long_return = (u_long)p->total.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_SES:
+		long_return = (u_long)p->total.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_CRC:
+		long_return = (u_long)p->total.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_LOSWS:
+		long_return = (u_long)p->total.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_UAS:
+		long_return = (u_long)p->total.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15MEL:
+		long_return = p->cur_15m_elaps;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_ES:
+		long_return = p->cur15min.es;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_SES:
+		long_return = p->cur15min.ses;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_CRC:
+		long_return = p->cur15min.crc;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_LOSWS:
+		long_return = p->cur15min.losws;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_UAS:
+		long_return = p->cur15min.uas;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1DEL:
+		long_return = p->cur_1d_elaps;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_ES:
+		long_return = p->cur1day.es;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_SES:
+		long_return = p->cur1day.ses;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_CRC:
+		long_return = p->cur1day.crc;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_LOSWS:
+		long_return = p->cur1day.losws;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_UAS:
+		long_return = p->cur1day.uas;
+		return_ptr = (char*)&long_return;
+		break;
+    default:
+		break;
+    }
+
+
+ exit:
+    printf("%s: exit\n",__FUNCTION__);
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+    printf("%s: returning %p\n",__FUNCTION__,return_ptr);
+    return return_ptr;
+}
+
+// ----------------- Perfomance/Status intervals ------------------//
+
+static int 
+header_intervalIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method,app_ids msg_id)
+{
+    int wire = 0;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    endp_int_payload *p;
+    int int_num,ret_val = MATCH_FAILED;
+    
+    
+    printf("%s(Input): if(%d) unit(%d) side(%d) pair(%d) int(%d) id(%d)\n",
+		   __FUNCTION__,name[vp->namelen],name[vp->namelen+1],name[vp->namelen+2],
+		   name[vp->namelen+3],name[vp->namelen+4],msg_id);
+
+
+	// printf("----------- WirePair: start ------------\n");
+    //-------------- Try requested wire_pair ----------------//
+    if ( ( wire = header_wirePairIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+    
+		wire_index = wire;
+		if( exact ){
+			if( *length != vp->namelen+5 )
+				goto exit;
+			int_num = name[vp->namelen+4];
+		} else {
+			if( *length < vp->namelen+4 ){
+				return MATCH_FAILED;
+			} else if( *length == vp->namelen+3 ){
+				int_num = 1;
+			}else{
+				int_num = name[vp->namelen+4]+1;
+			}
+		}
+
+		if( exact ){
+			p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET,
+													  tbl[interface_ind].name,&fr1);
+		}else{
+			p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET_NEXT,
+													  tbl[interface_ind].name,&fr1);
+		}	
+		if( !p ){
+			DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Cannot allocate application frame"));
+			printf("interval15Index: Cannot allocate application frame\n");
+			return MATCH_FAILED;
+		}
+	    
+		p->unit = unit_index;
+		p->side = endp_index-1;
+		p->loop = wire_index-1;
+		p->int_num = int_num;
+
+		printf("Output: unit(%d) side(%d) pair(%d) int(%d)\n",
+			   p->unit,p->side,p->loop,p->int_num);
+	
+		fr2 = comm_request(comm,fr1);
+		if( fr2 ){
+			p = (endp_int_payload*)comm_frame_payload(fr2);
+			//	printf("wirePair: Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);
+			perf_int = p->cntrs;
+			name[vp->namelen+4] = p->int_num;
+			*length = vp->namelen+5;
+			ret_val = name[vp->namelen+4];
+			goto exit;
+		}
+    }
+    
+    if( exact ){
+		goto exit;
+    }
+    
+    //-------------- Switch to next wire_pair ----------------//
+    if ( ( wire = header_wirePairIndex(vp,name,length, exact,var_len,write_method) )
+		 == MATCH_FAILED ){
+		goto exit;
+    }
+    wire_index = wire;
+    if( !fr1 ){
+		p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET_NEXT,
+												  tbl[interface_ind].name,&fr1);
+    }else{
+		p = (endp_int_payload*)comm_frame_payload(fr1);
+    }
+    
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Cannot allocate application frame"));
+		printf("interval15Index: Cannot allocate application frame\n");
+		goto exit;
+    }
+
+    p->unit = unit_index;
+    p->side = endp_index-1;
+    p->loop = wire_index-1;
+    p->int_num = 1;
+
+    printf("Output: unit(%d) side(%d) pair(%d) int(%d)\n",
+		   p->unit,p->side,p->loop,p->int_num);
+
+	if( fr2 )
+		comm_frame_free(fr2);
+    fr2 = comm_request(comm,fr1);
+    if( !fr2 ){
+    	DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Error requesting\n"));
+    	printf("interval15Index: Error requesting\n");
+		goto exit;
+    }
+
+    printf("Request successfull, p =%p\n",p);
+    p = (endp_int_payload*)comm_frame_payload(fr2);
+    if( !p ){
+		goto exit;
+    }
+    //	printf("wirePair: Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);
+    perf_int = p->cntrs;
+    name[vp->namelen+4] = p->int_num;
+    ret_val = name[vp->namelen+4];
+    *length = vp->namelen+5;
+    printf("%s: exit\n",__FUNCTION__);
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    printf("%s: returning\n",__FUNCTION__);
+    return ret_val;
+}
+
+
+
+/*
+ * Segment Endpoint 15-Minute Interval Status/Performance Group 
+ */
+u_char *
+var_15MinIntervalEntry(struct variable * vp,
+					   oid * name,
+					   size_t * length,
+					   int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    endp_int_payload *p15,*p1d;
+    char *return_ptr = NULL;
+    int int_num;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( (int_num = header_intervalIndex(vp,name,length,exact,var_len,write_method,APP_ENDP_15MIN) )
+		 == MATCH_FAILED )
+        goto exit;
+    
+	//    printf("Result : if(%s) unit(%d) side(%d) pair(%d) int(%d)\n",tbl[interface_ind].name,unit_index,endp_index,wire_index,int_num);
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_15M_ES:
+		long_return = (u_long)perf_int.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_SES:
+		long_return = (u_long)perf_int.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_CRC:
+		long_return = (u_long)perf_int.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_LOSWS:
+		long_return = (u_long)perf_int.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_UAS:
+		long_return = (u_long)perf_int.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    default:
+		break;
+    }
+
+
+ exit:
+    printf("%s: exit\n",__FUNCTION__);
+    comm_free(comm);
+    comm = NULL;
+    printf("%s: returning, %p\n",__FUNCTION__,return_ptr);
+    return return_ptr;
+}
+
+
+/*
+ * Segment Endpoint 1-Day Interval Status/Performance Group
+ */
+u_char *
+var_1DayIntervalEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    endp_int_payload *p1d;
+    char *return_ptr = NULL;
+    int int_num;
+
+	printf("%s: start\n",__FUNCTION__);
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( (int_num = header_intervalIndex(vp,name,length,exact,var_len,write_method,APP_ENDP_1DAY) )
+		 == MATCH_FAILED )
+        goto exit;
+    
+    printf("(Result) : if(%s) unit(%d) side(%d) pair(%d) int(%d)\n",tbl[interface_ind].name,unit_index,endp_index,wire_index,int_num);
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_1D_MONSECS:
+		long_return = (u_long)perf_int.mon_sec;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_ES:
+		long_return = (u_long)perf_int.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_SES:
+		long_return = (u_long)perf_int.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_CRC:
+		long_return = (u_long)perf_int.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_LOSWS:
+		long_return = (u_long)perf_int.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_UAS:
+		long_return = (u_long)perf_int.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    default:
+		break;
+    }
+ exit:
+    comm_free(comm);
+    comm = NULL;
+    return return_ptr;
+}
+
+
+
+/*
+ * Segment Endpoint Configuration Group
+ *//*
+	 u_char *
+	 var_EndpointConfEntry(struct variable * vp,
+	 oid * name,
+	 size_t * length,
+	 int exact, size_t * var_len, WriteMethod ** write_method)
+	 {
+	 shdsl_unit_t Info, *info = &Info;
+	 int pair;
+
+	 //    DEBUGMSGTL(("mibII/shdsl", "\n-----------------------START----------------------------\n"
+	 //			"var_EndpointConfEntry. exact= %d\n",exact));
+	 //    DEBUGMSGOID(("mibII/shdsl", name, *length));
+	 //    DEBUGMSG(("mibII/shdsl", "\n"));    
+    
+	 if ( ( pair = header_wirePairIndex(vp,name,length,exact,var_len,write_method) )
+	 == MATCH_FAILED )
+	 return NULL;
+
+
+
+
+
+
+	 struct app_frame *fr1,*fr2;
+	 char *b;
+	 endp_int_payload *p;
+    
+
+	 p = (endp_int_payload*)comm_alloc_request(APP_ENDP_15MIN,APP_GET,"dsl0",&fr1);
+	 if( !p ){
+	 DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+	 return;
+	 }
+	 p->unit = stu_c;
+	 p->side = net_side;
+	 p->loop = 0;
+	 p->int_num = 73;
+
+	 fr2 = comm_request(c,fr1);
+	 if( !fr2 ){
+	 printf("Error requesting\n");
+	 return -1;
+	 }
+	 p = (endp_int_payload*)comm_frame_payload(fr2);
+	 print_int_payload(p,"1day");    
+
+
+
+
+
+
+
+
+    
+	 //    DEBUGMSGTL(("mibII/shdsl", "Result pair = %d\n-------------------END------------------------\n",pair));
+	 //---- ack ----//
+	 switch (vp->magic) {
+	 case ENDP_CONF_PROF:
+	 strcpy(return_buf,"DEFAULT");    
+	 *var_len = strlen(return_buf);
+	 return (u_char *)return_buf;
+	 }    
+	 return NULL;
+	 }
+
+
+	 /*
+	 *
+	 * ---------------------- Maintenance Group  ------------------------
+	 *
+	 *//*
+
+u_char *
+var_EndpointMaintEntry(struct variable * vp,
+oid * name,
+size_t * length,
+int exact, size_t * var_len, WriteMethod ** write_method)
+{
+shdsl_endp_maint_t Info, *info = &Info;
+int pair;
+/*
+DEBUGMSGTL(("mibII/shdsl", "\n-----------------------START----------------------------\n"
+"var_EndpointConfEntry. exact= %d\n",exact));
+DEBUGMSGOID(("mibII/shdsl", name, *length));
+DEBUGMSG(("mibII/shdsl", "\n"));    
+	   *//*    
+			   if ( ( pair = header_endpIndex(vp,name,length,exact,var_len,write_method) )
+			   == MATCH_FAILED )
+			   return NULL;
+
+
+
+			   struct app_frame *fr1,*fr2;
+			   char *b;
+			   endp_int_payload *p;
+    
+
+			   p = (endp_int_payload*)comm_alloc_request(APP_ENDP_15MIN,APP_GET,"dsl0",&fr1);
+			   if( !p ){
+			   DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			   return;
+			   }
+			   p->unit = stu_c;
+			   p->side = net_side;
+			   p->loop = 0;
+			   p->int_num = 73;
+
+			   fr2 = comm_request(c,fr1);
+			   if( !fr2 ){
+			   printf("Error requesting\n");
+			   return -1;
+			   }
+			   p = (endp_int_payload*)comm_frame_payload(fr2);
+			   print_int_payload(p,"1day");    
+
+
+
+
+
+
+
+    
+			   eocd_endp_maint(interface_ind,unit_index,&eocd,info);    
+    
+			   //    DEBUGMSGTL(("mibII/shdsl", "Result pair = %d\n-------------------END------------------------\n",pair));
+			   //---- ack ----//
+			   switch (vp->magic) {
+			   case ENDP_MAINT_LOOPBACK:
+			   long_return= info->lpb_cfg;
+			   return (u_char *) & long_return;
+			   case ENDP_MAINT_TIPRINGREV:
+			   long_return= info->ring_rev;
+			   return (u_char *) & long_return;
+			   case ENDP_MAINT_PWRBACKOFF:
+			   long_return= info->pwr_backoff;
+			   return (u_char *) & long_return;
+			   case ENDP_MAINT_SOFTRESTART:
+			   long_return= info->soft_rst;
+			   return (u_char *) & long_return;
+			   }
+			   return NULL;
+			   }
+
+			   u_char *
+			   var_UnitMaintEntry(struct variable * vp,
+               oid * name,
+               size_t * length,
+               int exact, size_t * var_len, WriteMethod ** write_method)
+			   {
+			   shdsl_unit_maint_t Info, *info = &Info;
+			   int unit;
+
+			   //    DEBUGMSGTL(("mibII/shdsl", "\n-----------------------START----------------------------\n"
+			   //			"var_UnitMaintEntry. exact= %d\n",exact));
+			   //    DEBUGMSGOID(("mibII/shdsl", name, *length));
+			   //    DEBUGMSG(("mibII/shdsl", "\n"));    
+    
+			   if ( ( unit = header_unitIndex(vp,name,length,exact,var_len,write_method) )
+			   == MATCH_FAILED )
+			   return NULL;
+
+
+
+			   struct app_frame *fr1,*fr2;
+			   char *b;
+			   endp_int_payload *p;
+    
+
+			   p = (endp_int_payload*)comm_alloc_request(APP_ENDP_15MIN,APP_GET,"dsl0",&fr1);
+			   if( !p ){
+			   DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			   return;
+			   }
+			   p->unit = stu_c;
+			   p->side = net_side;
+			   p->loop = 0;
+			   p->int_num = 73;
+
+			   fr2 = comm_request(c,fr1);
+			   if( !fr2 ){
+			   printf("Error requesting\n");
+			   return -1;
+			   }
+			   p = (endp_int_payload*)comm_frame_payload(fr2);
+			   print_int_payload(p,"1day");    
+
+
+
+
+
+    
+			   eocd_unit_maint(interface_ind,unit_index,&eocd,info);    
+    
+			   //    DEBUGMSGTL(("mibII/shdsl", "Result unit = %d\n-------------------END------------------------\n",unit));
+			   //---- ack ----//
+			   switch (vp->magic) {
+			   case ENDP_MAINT_LOOPBACK:
+			   long_return= info->lpb_to;
+			   return (u_char *) & long_return;
+			   case ENDP_MAINT_TIPRINGREV:
+			   long_return= info->pwr_src;
+			   return (u_char *) & long_return;
+			   }
+			   return NULL;
+			   }
+
+
+			   /*
+			   *
+			   * ---------------------- PROFILES ------------------- 
+			   *
+			   */
+
+
+/*
+ * header_wirePairIndex:
+ * 	Defines propriate Wire pair index for incoming OID
+ *	(by now only 1 pair supported)
+ */
+
+span_conf_prof_payload _cprof;
+
+static int 
+header_confProfIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int base_compare;
+    int oid_min = (vp->namelen > *length) ? *length : vp->namelen;
+    char profname[MAX_OID_LEN];
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1 = NULL,*fr2 = NULL;
+    char *b;
+    span_conf_prof_payload *p;
+    int i,l;
+
+	/*
+	  printf("%s: Start\n",__FUNCTION__);
+
+	  printf("%s: name:\n",__FUNCTION__);
+	  for(i=0;i<*length;i++){
+	  if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' )
+	  printf("%c.",name[i]);
+	  else
+	  printf("%d.",name[i]);
+	  }
+	  printf("\n");
+
+	*/
+
+    if( (base_compare = snmp_oid_compare(name,oid_min,vp->name,oid_min)) > 0){
+		// OID is grater than supported
+		return MATCH_FAILED;
+    }
+    
+    if( exact ){
+		int len;
+		if( base_compare || (*length < vp->namelen) ){
+			// Already incorrect
+			return MATCH_FAILED;
+		}
+        len = *length - vp->namelen;
+        len = (len>SNMP_ADMIN_LEN) ? SNMP_ADMIN_LEN : len;
+        memcpy(profname,name+vp->namelen,len);
+		profname[len+1] = 0;	
+		p = (span_conf_prof_payload*)
+			comm_alloc_request(APP_SPAN_CPROF,APP_GET,"",&fr1);
+    }else{
+		if( (base_compare < 0) || (!base_compare && *length<=vp->namelen) ){
+			memcpy((char*)name,vp->name,((int)vp->namelen)*sizeof(oid));
+			*length = vp->namelen;
+			profname[0] = 0;
+			//printf("%s: nonexact, first request\n",__FUNCTION__);
+		}else{
+			int len = *length - vp->namelen;
+			len = (len>SNMP_ADMIN_LEN) ? SNMP_ADMIN_LEN : len;
+			for(i=0;i<len;i++){
+				profname[i] = name[vp->namelen+i];
+			}
+			profname[len] = 0;
+			*length = vp->namelen;	    
+			//printf("%s: nonexact, profname=%s\n",__FUNCTION__,profname);
+		}
+		p = (span_conf_prof_payload*)
+			comm_alloc_request(APP_SPAN_CPROF,APP_GET_NEXT,"",&fr1);
+    }	
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		if( fr1 )
+			comm_frame_free(fr1);
+		return MATCH_FAILED;
+    }
+
+    strncpy(p->ProfileName,profname,SNMP_ADMIN_LEN+1);
+	//    printf("%s: Request profile:\n",__FUNCTION__);//,p->ProfileName);
+    fr2 = comm_request(comm,fr1);
+	//    printf("%s, request successfull\n",__FUNCTION__);
+    if( !fr2 ){
+		printf("%s: Error requesting\n",__FUNCTION__);
+		if( fr1 )
+			comm_frame_free(fr1);
+		return MATCH_FAILED;
+    }
+    
+    p = (span_conf_prof_payload*)comm_frame_payload(fr2);
+    
+    _cprof = *p;
+
+	/*
+	  printf("%s: name:\n",__FUNCTION__);
+	  for(i=0;i<*length;i++){
+	  if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' )
+	  printf("%c.",name[i]);
+	  else 
+	  printf("%d.",name[i]);
+	  }
+	  printf("\n");
+
+	*/    
+	//    printf("%s: get profile - %s,len=%d,vp->namelen=%d\n",__FUNCTION__,p->ProfileName,strnlen(p->ProfileName,SNMP_ADMIN_LEN+1),vp->namelen);
+    l = strnlen(p->ProfileName,SNMP_ADMIN_LEN+1);
+    for(i=0;i<l;i++){
+		name[vp->namelen+i] = p->ProfileName[i];
+    }
+    *length += strnlen(p->ProfileName,SNMP_ADMIN_LEN+1);
+	/*
+	  printf("%s: name:\n",__FUNCTION__);
+	  for(i=0;i<*length;i++){
+	  if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' )
+	  printf("%c.",name[i]);
+	  else 
+	  printf("%d.",name[i]);
+	  }
+	  printf("\n");
+
+	*/
+    if( fr1 )
+        comm_frame_free(fr1);
+    if( fr2 )
+        comm_frame_free(fr2);
+    return !(MATCH_FAILED);
+}
+
+u_char *
+var_SpanConfProfEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    char *return_ptr = NULL;
+    int i;
+
+    comm = init_comm();
+    if(!comm){
+        DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+        return NULL;
+    }
+    
+    if ( header_confProfIndex(vp,name,length,exact,var_len,write_method)
+		 == MATCH_FAILED ){
+		printf("%s: returning NULL\n",__FUNCTION__);
+        goto exit;
+    }
+	/*
+	  printf("%s: name:\n",__FUNCTION__);
+	  for(i=0;i<*length;i++){
+	  if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' ){
+	  printf("%c.",name[i]);
+	  }else {
+	  printf("%d.",name[i]);
+	  }
+	  }
+	  printf("\n");
+	*/
+
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case CONF_WIRE_IFACE:
+		long_return= _cprof.conf.wires;
+		return_ptr = (u_char *)&long_return;
+		printf("WIRE_IFACE: ret=%d", _cprof.conf.wires);
+		break;
+    case CONF_MIN_LRATE:
+		long_return = _cprof.conf.min_rate;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_MAX_LRATE:
+		long_return = _cprof.conf.max_rate;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_PSD:
+		long_return= _cprof.conf.psd;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*	
+			case CONF_TRNSM_MODE:
+			*var_len = sizeof(char);
+			long_return = *((unsigned char*)&info->transm_mode);
+			return_ptr = (u_char *)&long_return;
+			break; */
+    case CONF_REM_ENABLE:
+		long_return = _cprof.conf.remote_cfg;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_PWR_FEED:
+		long_return = _cprof.conf.power;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_CURR_DOWN:
+		long_return = _cprof.conf.cur_marg_down;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_WORST_DOWN:
+		long_return = _cprof.conf.worst_marg_down;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_CURR_UP:
+		long_return = _cprof.conf.cur_marg_up;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_WORST_UP:
+		long_return = _cprof.conf.worst_marg_up;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*    case CONF_USED_MARG:
+		 *var_len = sizeof(char);
+		 long_return = *((unsigned char*)&info->used_margins);
+		 return_ptr = (u_char *)&long_return; */
+    case CONF_REF_CLK:
+		long_return = _cprof.conf.clk;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_LPROBE:
+		long_return = _cprof.conf.line_probe;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*    case CONF_ROW_ST:
+			  long_return = info->status;
+			  return_ptr = (u_char *)&long_return;
+		*/
+    }
+    
+ exit:
+    comm_free(comm);
+    comm = NULL;    
+    return return_ptr;
+}
+
+
Index: net-snmp-5.1.2/agent/mibgroup/mibII.h
===================================================================
--- net-snmp-5.1.2/agent/mibgroup/mibII.h	(revision 42)
+++ net-snmp-5.1.2/agent/mibgroup/mibII.h	(revision 50)
@@ -13,3 +13,4 @@
 config_require(mibII/udp)
 config_require(mibII/vacm_vars)
 config_require(mibII/setSerialNo)
+config_require(mibII/shdsl/shdsl)
Index: net-snmp-5.1.2/Makefile.top
===================================================================
--- net-snmp-5.1.2/Makefile.top	(revision 42)
+++ net-snmp-5.1.2/Makefile.top	(revision 50)
@@ -52,6 +52,11 @@
 
 # Misc Compiling Stuff
 CC	        = @CC@
+CXX	        = @CXX@
+AR	        = @AR@
+RANLIB		= @RANLIB@
+export CXX AR RANLIB
+
 # version number is prefixed by a 0 for a better shared library version number
 #
 # ok, use libtool proper versioning:
@@ -73,6 +78,9 @@
 RANLIB		= :
 
 # libtool definitions
-.SUFFIXES: .c .o .lo
+.SUFFIXES: .c .o .lo .cpp
 .c.lo:
 	$(LIBTOOL) --mode=compile $(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
+
+.cpp.lo:
+	$(LIBTOOL) --mode=compile $(CXX) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
